<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>TargetTransformInfo.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// This pass exposes codegen information to IR-level passes. Every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// transformation that uses codegen information is broken into three parts:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// 1. The IR-level analysis pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">/// 2. The IR-level transformation interface which provides the needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">///    information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">/// 3. Codegen-level implementation which uses target-specific hooks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">/// This file defines #2, which is the interface that IR-level transformations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">/// use for querying the codegen.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#ifndef LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#define LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/ADT/SmallBitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/IR/FMF.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/IR/InstrTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/IR/PassManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/Support/AtomicOrdering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/Support/BranchProbability.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/Support/InstructionCost.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include <functional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">namespace Intrinsic {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">typedef unsigned ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">class AllocaInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">class AssumptionCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">class BlockFrequencyInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">class DominatorTree;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">class BranchInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">class CallBase;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">class Function;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">class GlobalValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">class InstCombiner;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">class OptimizationRemarkEmitter;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">class InterleavedAccessInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">class IntrinsicInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">class LoadInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">class Loop;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">class LoopInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">class LoopVectorizationLegality;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">class ProfileSummaryInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">class RecurrenceDescriptor;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">class SCEV;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">class ScalarEvolution;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">class StoreInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">class SwitchInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">class TargetLibraryInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">class Type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">class User;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">class Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">class VPIntrinsic;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">struct KnownBits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">/// Information about a load/store intrinsic defined by the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">struct MemIntrinsicInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">  /// This is the pointer that the intrinsic is loading from or storing to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">  /// If this is non-null, then analysis/optimization passes can assume that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">  /// this intrinsic is functionally equivalent to a load/store from this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">  /// pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">  Value *PtrVal = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  // Ordering for atomic operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  // Same Id is set by the target for corresponding load/store intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">  unsigned short MatchingId = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">  bool ReadMem = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">  bool WriteMem = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  bool IsVolatile = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  bool isUnordered() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">    return (Ordering == AtomicOrdering::NotAtomic ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">            Ordering == AtomicOrdering::Unordered) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">           !IsVolatile;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">/// Attributes of a target dependent hardware loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">struct HardwareLoopInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  HardwareLoopInfo() = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  HardwareLoopInfo(Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  Loop *L = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  BasicBlock *ExitBlock = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  BranchInst *ExitBranch = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  const SCEV *ExitCount = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  IntegerType *CountType = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  Value *LoopDecrement = nullptr; // Decrement the loop counter by this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">                                  // value in every iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">  bool IsNestingLegal = false;    // Can a hardware loop be a parent to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">                                  // another hardware loop?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  bool CounterInReg = false;      // Should loop counter be updated in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">                                  // the loop via a phi?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">  bool PerformEntryTest = false;  // Generate the intrinsic which also performs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">                                  // icmp ne zero on the loop counter value and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">                                  // produces an i1 to guard the loop entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  bool isHardwareLoopCandidate(ScalarEvolution &SE, LoopInfo &LI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">                               DominatorTree &DT, bool ForceNestedLoop = false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">                               bool ForceHardwareLoopPHI = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  bool canAnalyze(LoopInfo &LI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">class IntrinsicCostAttributes {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  const IntrinsicInst *II = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">  Type *RetTy = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  Intrinsic::ID IID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">  SmallVector<Type *, 4> ParamTys;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">  SmallVector<const Value *, 4> Arguments;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">  FastMathFlags FMF;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  // If ScalarizationCost is UINT_MAX, the cost of scalarizing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">  // arguments and the return value will be computed based on types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">  InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">  IntrinsicCostAttributes(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">      Intrinsic::ID Id, const CallBase &CI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">      InstructionCost ScalarCost = InstructionCost::getInvalid(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">      bool TypeBasedOnly = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">  IntrinsicCostAttributes(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">      Intrinsic::ID Id, Type *RTy, ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">      FastMathFlags Flags = FastMathFlags(), const IntrinsicInst *I = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">  IntrinsicCostAttributes(Intrinsic::ID Id, Type *RTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">                          ArrayRef<const Value *> Args);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">  IntrinsicCostAttributes(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">      Intrinsic::ID Id, Type *RTy, ArrayRef<const Value *> Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">      ArrayRef<Type *> Tys, FastMathFlags Flags = FastMathFlags(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">      const IntrinsicInst *I = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="uncoveredLine">  Intrinsic::ID getID() const { return IID; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="uncoveredLine">  const IntrinsicInst *getInst() const { return II; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="uncoveredLine">  Type *getReturnType() const { return RetTy; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="uncoveredLine">  FastMathFlags getFlags() const { return FMF; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="uncoveredLine">  InstructionCost getScalarizationCost() const { return ScalarizationCost; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="uncoveredLine">  const SmallVectorImpl<const Value *> &getArgs() const { return Arguments; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="uncoveredLine">  const SmallVectorImpl<Type *> &getArgTypes() const { return ParamTys; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">  bool isTypeBasedOnly() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="uncoveredLine">    return Arguments.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">  bool skipScalarizationCost() const { return ScalarizationCost.isValid(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">enum class TailFoldingStyle {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  /// Don't use tail folding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">  None,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  /// Use predicate only to mask operations on data in the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">  /// When the VL is not known to be a power-of-2, this method requires a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  /// runtime overflow check for the i + VL in the loop because it compares the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  /// scalar induction variable against the tripcount rounded up by VL which may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">  /// overflow. When the VL is a power-of-2, both the increment and uprounded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  /// tripcount will overflow to 0, which does not require a runtime check</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  /// since the loop is exited when the loop induction variable equals the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">  /// uprounded trip-count, which are both 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">  Data,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  /// Same as Data, but avoids using the get.active.lane.mask intrinsic to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  /// calculate the mask and instead implements this with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">  /// splat/stepvector/cmp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">  /// active.lane.mask intrinsic when it is not natively supported?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  DataWithoutLaneMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  /// Use predicate to control both data and control flow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  /// This method always requires a runtime overflow check for the i + VL</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">  /// increment inside the loop, because it uses the result direclty in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">  /// active.lane.mask to calculate the mask for the next iteration. If the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">  /// increment overflows, the mask is no longer correct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  DataAndControlFlow,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  /// Use predicate to control both data and control flow, but modify</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">  /// the trip count so that a runtime overflow check can be avoided</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">  /// and such that the scalar epilogue loop can always be removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  DataAndControlFlowWithoutRuntimeCheck</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">struct TailFoldingInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  TargetLibraryInfo *TLI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">  LoopVectorizationLegality *LVL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">  InterleavedAccessInfo *IAI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">  TailFoldingInfo(TargetLibraryInfo *TLI, LoopVectorizationLegality *LVL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">                  InterleavedAccessInfo *IAI)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">      : TLI(TLI), LVL(LVL), IAI(IAI) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">class TargetTransformInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">typedef TargetTransformInfo TTI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">/// This pass provides access to the codegen interfaces that are needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">/// for IR-level transformations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">class TargetTransformInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">  /// Construct a TTI object using a type implementing the \c Concept</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  /// API below.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">  /// This is used by targets to construct a TTI wrapping their target-specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  /// implementation that encodes appropriate costs for their target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">  template <typename T> TargetTransformInfo(T Impl);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  /// Construct a baseline TTI object using a minimal implementation of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">  /// the \c Concept API below.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">  /// The TTI implementation will reflect the information in the DataLayout</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  /// provided if non-null.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  explicit TargetTransformInfo(const DataLayout &DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  // Provide move semantics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">  TargetTransformInfo(TargetTransformInfo &&Arg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">  TargetTransformInfo &operator=(TargetTransformInfo &&RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  // We need to define the destructor out-of-line to define our sub-classes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  // out-of-line.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">  ~TargetTransformInfo();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">  /// Handle the invalidation of this information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">  /// When used as a result of \c TargetIRAnalysis this method will be called</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">  /// when the function this was computed for changes. When it returns false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  /// the information is preserved across those changes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  bool invalidate(Function &, const PreservedAnalyses &,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">                  FunctionAnalysisManager::Invalidator &) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">    // FIXME: We should probably in some way ensure that the subtarget</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">    // information for a function hasn't changed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">    return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">  /// \name Generic Target Information</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">  /// The kind of cost model.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">  /// There are several different cost models that can be customized by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  /// target. The normalization of each cost model may be target specific.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">  /// e.g. TCK_SizeAndLatency should be comparable to target thresholds such as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  /// those derived from MCSchedModel::LoopMicroOpBufferSize etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  enum TargetCostKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">    TCK_RecipThroughput, ///< Reciprocal throughput.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">    TCK_Latency,         ///< The latency of instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">    TCK_CodeSize,        ///< Instruction code size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">    TCK_SizeAndLatency   ///< The weighted sum of size and latency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  /// Underlying constants for 'cost' values in this interface.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  /// Many APIs in this interface return a cost. This enum defines the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  /// fundamental values that should be used to interpret (and produce) those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  /// costs. The costs are returned as an int rather than a member of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  /// enumeration because it is expected that the cost of one IR instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  /// may have a multiplicative factor to it or otherwise won't fit directly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  /// into the enum. Moreover, it is common to sum or average costs which works</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  /// better as simple integral values. Thus this enum only provides constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  /// Also note that the returned costs are signed integers to make it natural</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  /// to add, subtract, and test with zero (a common boundary condition). It is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  /// not expected that 2^32 is a realistic cost to be modeling at any point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  /// Note that these costs should usually reflect the intersection of code-size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">  /// cost and execution cost. A free instruction is typically one that folds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">  /// into another instruction. For example, reg-to-reg moves can often be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">  /// skipped by renaming the registers in the CPU, but they still are encoded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">  /// and thus wouldn't be considered 'free' here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  enum TargetCostConstants {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">    TCC_Free = 0,     ///< Expected to fold away in lowering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">    TCC_Basic = 1,    ///< The cost of a typical 'add' instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">    TCC_Expensive = 4 ///< The cost of a 'div' instruction on x86.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  /// Estimate the cost of a GEP operation when lowered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  /// \p PointeeType is the source element type of the GEP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">  /// \p Ptr is the base pointer operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  /// \p Operands is the list of indices following the base pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  /// \p AccessType is a hint as to what type of memory might be accessed by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  /// users of the GEP. getGEPCost will use it to determine if the GEP can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  /// folded into the addressing mode of a load/store. If AccessType is null,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  /// then the resulting target type based off of PointeeType will be used as an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">  /// approximation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">             ArrayRef<const Value *> Operands, Type *AccessType = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">             TargetCostKind CostKind = TCK_SizeAndLatency) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  /// Describe known properties for a set of pointers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">  struct PointersChainInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">    /// All the GEPs in a set have same base address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">    unsigned IsSameBaseAddress : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">    /// These properties only valid if SameBaseAddress is set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">    /// True if all pointers are separated by a unit stride.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">    unsigned IsUnitStride : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">    /// True if distance between any two neigbouring pointers is a known value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">    unsigned IsKnownStride : 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">    unsigned Reserved : 29;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">    bool isSameBase() const { return IsSameBaseAddress; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">    bool isUnitStride() const { return IsSameBaseAddress && IsUnitStride; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">    bool isKnownStride() const { return IsSameBaseAddress && IsKnownStride; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">    static PointersChainInfo getUnitStride() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">              /*IsKnownStride=*/1, 0};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">    static PointersChainInfo getKnownStride() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">              /*IsKnownStride=*/1, 0};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">    static PointersChainInfo getUnknownStride() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">              /*IsKnownStride=*/0, 0};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  static_assert(sizeof(PointersChainInfo) == 4, "Was size increase justified?");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">  /// Estimate the cost of a chain of pointers (typically pointer operands of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">  /// chain of loads or stores within same block) operations set when lowered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">  /// \p AccessTy is the type of the loads/stores that will ultimately use the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  /// \p Ptrs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">                       const PointersChainInfo &Info, Type *AccessTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">                       TargetCostKind CostKind = TTI::TCK_RecipThroughput</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">  ) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  /// \returns A value by which our inlining threshold should be multiplied.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">  /// This is primarily used to bump up the inlining threshold wholesale on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">  /// targets where calls are unusually expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">  /// TODO: This is a rather blunt instrument.  Perhaps altering the costs of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">  /// individual classes of instructions would be better.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  unsigned getInliningThresholdMultiplier() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">  /// \returns A value to be added to the inlining threshold.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">  unsigned adjustInliningThreshold(const CallBase *CB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  /// \returns The cost of having an Alloca in the caller if not inlined, to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">  /// added to the threshold</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">  /// \returns Vector bonus in percent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">  /// Vector bonuses: We want to more aggressively inline vector-dense kernels</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">  /// and apply this bonus based on the percentage of vector instructions. A</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">  /// bonus is applied if the vector instructions exceed 50% and half that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  /// amount is applied if it exceeds 10%. Note that these bonuses are some what</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">  /// arbitrary and evolved over time by accident as much as because they are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">  /// principled bonuses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">  /// FIXME: It would be nice to base the bonus values on something more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">  /// scientific. A target may has no bonus on vector instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  int getInlinerVectorBonusPercent() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">  /// \return the expected cost of a memcpy, which could e.g. depend on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">  /// source/destination type and alignment and the number of bytes copied.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">  InstructionCost getMemcpyCost(const Instruction *I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">  /// Returns the maximum memset / memcpy size in bytes that still makes it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">  /// profitable to inline the call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">  /// \return The estimated number of case clusters when lowering \p 'SI'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">  /// \p JTSize Set a jump table size only when \p SI is suitable for a jump</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">  /// table.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">                                            unsigned &JTSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">                                            ProfileSummaryInfo *PSI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">                                            BlockFrequencyInfo *BFI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">  /// Estimate the cost of a given IR user when lowered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">  /// This can estimate the cost of either a ConstantExpr or Instruction when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">  /// lowered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">  /// \p Operands is a list of operands which can be a result of transformations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">  /// of the current operands. The number of the operands on the list must equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  /// to the number of the current operands the IR user has. Their order on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  /// list must be the same as the order of the current operands the IR user</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">  /// has.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">  /// The returned cost is defined in terms of \c TargetCostConstants, see its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">  /// comments for a detailed explanation of the cost values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">  InstructionCost getInstructionCost(const User *U,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">                                     ArrayRef<const Value *> Operands,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">                                     TargetCostKind CostKind) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  /// This is a helper function which calls the three-argument</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  /// getInstructionCost with \p Operands which are the current operands U has.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">  InstructionCost getInstructionCost(const User *U,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">                                     TargetCostKind CostKind) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">    SmallVector<const Value *, 4> Operands(U->operand_values());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">    return getInstructionCost(U, Operands, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  /// If a branch or a select condition is skewed in one direction by more than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  /// this factor, it is very likely to be predicted correctly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">  BranchProbability getPredictableBranchThreshold() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">  /// Return true if branch divergence exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">  /// Branch divergence has a significantly negative impact on GPU performance</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  /// when threads in the same wavefront take different paths due to conditional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">  /// branches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  /// If \p F is passed, provides a context function. If \p F is known to only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  /// execute in a single threaded environment, the target may choose to skip</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">  /// uniformity analysis and assume all values are uniform.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  bool hasBranchDivergence(const Function *F = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  /// Returns whether V is a source of divergence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  /// This function provides the target-dependent information for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">  /// the target-independent UniformityAnalysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  bool isSourceOfDivergence(const Value *V) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  // Returns true for the target specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  // set of operations which produce uniform result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">  // even taking non-uniform arguments</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  bool isAlwaysUniform(const Value *V) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">  /// Query the target whether the specified address space cast from FromAS to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">  /// ToAS is valid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">  /// Return false if a \p AS0 address cannot possibly alias a \p AS1 address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">  /// Returns the address space ID for a target's 'flat' address space. Note</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">  /// this is not necessarily the same as addrspace(0), which LLVM sometimes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">  /// refers to as the generic address space. The flat address space is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">  /// generic address space that can be used access multiple segments of memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  /// with different address spaces. Access of a memory location through a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">  /// pointer with this address space is expected to be legal but slower</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">  /// compared to the same memory location accessed through a pointer with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">  /// different address space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  /// This is for targets with different pointer representations which can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">  /// be converted with the addrspacecast instruction. If a pointer is converted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">  /// to this address space, optimizations should attempt to replace the access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">  /// with the source address space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">  /// \returns ~0u if the target does not have such a flat address space to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">  /// optimize away.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">  unsigned getFlatAddressSpace() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">  /// Return any intrinsic address operand indexes which may be rewritten if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">  /// they use a flat address space pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  /// \returns true if the intrinsic was handled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">                                  Intrinsic::ID IID) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">  /// Return true if globals in this address space can have initializers other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  /// than `undef`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  bool canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  unsigned getAssumedAddrSpace(const Value *V) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  bool isSingleThreaded() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  std::pair<const Value *, unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">  getPredicatedAddrSpace(const Value *V) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">  /// Rewrite intrinsic call \p II such that \p OldV will be replaced with \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">  /// NewV, which has a different address space. This should happen for every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  /// operand index that collectFlatAddressOperands returned for the intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">  /// \returns nullptr if the intrinsic was not handled. Otherwise, returns the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">  /// new value (which may be the original \p II with modified operands).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">                                          Value *NewV) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">  /// Test whether calls to a function lower to actual program function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  /// calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  /// The idea is to test whether the program is likely to require a 'call'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">  /// instruction or equivalent in order to call the given function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">  /// FIXME: It's not clear that this is a good or useful query API. Client's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">  /// should probably move to simpler cost metrics using the above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">  /// Alternatively, we could split the cost interface into distinct code-size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">  /// and execution-speed costs. This would allow modelling the core of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">  /// query more accurately as a call is a single small instruction, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">  /// incurs significant execution cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">  bool isLoweredToCall(const Function *F) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">  struct LSRCost {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">    /// TODO: Some of these could be merged. Also, a lexical ordering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">    /// isn't always optimal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">    unsigned Insns;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">    unsigned NumRegs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">    unsigned AddRecCost;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">    unsigned NumIVMuls;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">    unsigned NumBaseAdds;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">    unsigned ImmCost;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">    unsigned SetupCost;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">    unsigned ScaleCost;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">  /// Parameters that control the generic loop unrolling transformation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">  struct UnrollingPreferences {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">    /// The cost threshold for the unrolled loop. Should be relative to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">    /// getInstructionCost values returned by this API, and the expectation is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">    /// that the unrolled loop's instructions when run through that interface</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">    /// should not exceed this cost. However, this is only an estimate. Also,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">    /// specific loops may be unrolled even with a cost above this threshold if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">    /// deemed profitable. Set this to UINT_MAX to disable the loop body cost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">    /// restriction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">    unsigned Threshold;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">    /// If complete unrolling will reduce the cost of the loop, we will boost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">    /// the Threshold by a certain percent to allow more aggressive complete</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">    /// unrolling. This value provides the maximum boost percentage that we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">    /// can apply to Threshold (The value should be no less than 100).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">    /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">    ///                                    MaxPercentThresholdBoost / 100)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">    /// E.g. if complete unrolling reduces the loop execution time by 50%</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">    /// then we boost the threshold by the factor of 2x. If unrolling is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">    /// expected to reduce the running time, then we do not increase the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">    /// threshold.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">    unsigned MaxPercentThresholdBoost;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">    /// The cost threshold for the unrolled loop when optimizing for size (set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">    /// to UINT_MAX to disable).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">    unsigned OptSizeThreshold;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">    /// The cost threshold for the unrolled loop, like Threshold, but used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">    /// for partial/runtime unrolling (set to UINT_MAX to disable).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">    unsigned PartialThreshold;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">    /// The cost threshold for the unrolled loop when optimizing for size, like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">    /// OptSizeThreshold, but used for partial/runtime unrolling (set to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">    /// UINT_MAX to disable).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">    unsigned PartialOptSizeThreshold;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">    /// A forced unrolling factor (the number of concatenated bodies of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">    /// original loop in the unrolled loop body). When set to 0, the unrolling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">    /// transformation will select an unrolling factor based on the current cost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">    /// threshold and other factors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">    unsigned Count;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">    /// Default unroll count for loops with run-time trip count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">    unsigned DefaultUnrollRuntimeCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">    // Set the maximum unrolling factor. The unrolling factor may be selected</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">    // using the appropriate cost threshold, but may not exceed this number</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">    // (set to UINT_MAX to disable). This does not apply in cases where the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">    // loop is being fully unrolled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">    unsigned MaxCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">    /// Set the maximum unrolling factor for full unrolling. Like MaxCount, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">    /// applies even if full unrolling is selected. This allows a target to fall</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">    /// back to Partial unrolling if full unrolling is above FullUnrollMaxCount.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">    unsigned FullUnrollMaxCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">    // Represents number of instructions optimized when "back edge"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">    // becomes "fall through" in unrolled loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">    // For now we count a conditional branch on a backedge and a comparison</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">    // feeding it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">    unsigned BEInsns;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">    /// Allow partial unrolling (unrolling of loops to expand the size of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">    /// loop body, not only to eliminate small constant-trip-count loops).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">    bool Partial;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">    /// Allow runtime unrolling (unrolling of loops to expand the size of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">    /// loop body even when the number of loop iterations is not known at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">    /// compile time).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">    bool Runtime;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">    /// Allow generation of a loop remainder (extra iterations after unroll).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">    bool AllowRemainder;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">    /// Allow emitting expensive instructions (such as divisions) when computing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">    /// the trip count of a loop for runtime unrolling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">    bool AllowExpensiveTripCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">    /// Apply loop unroll on any kind of loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">    /// (mainly to loops that fail runtime unrolling).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">    bool Force;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">    /// Allow using trip count upper bound to unroll loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">    bool UpperBound;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">    /// Allow unrolling of all the iterations of the runtime loop remainder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">    bool UnrollRemainder;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">    /// Allow unroll and jam. Used to enable unroll and jam for the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">    bool UnrollAndJam;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">    /// Threshold for unroll and jam, for inner loop size. The 'Threshold'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">    /// value above is used during unroll and jam for the outer loop size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">    /// This value is used in the same manner to limit the size of the inner</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">    /// loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">    unsigned UnrollAndJamInnerLoopThreshold;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">    /// Don't allow loop unrolling to simulate more than this number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">    /// iterations when checking full unroll profitability</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">    unsigned MaxIterationsCountToAnalyze;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">    /// Don't disable runtime unroll for the loops which were vectorized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">    bool UnrollVectorizedLoop = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  /// Get target-customized preferences for the generic loop unrolling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  /// transformation. The caller will initialize UP with the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  /// target-independent defaults.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">  void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">                               UnrollingPreferences &UP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">                               OptimizationRemarkEmitter *ORE) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">  /// Query the target whether it would be profitable to convert the given loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">  /// into a hardware loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">                                HardwareLoopInfo &HWLoopInfo) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">  /// Query the target whether it would be prefered to create a predicated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">  /// vector loop, which can avoid the need to emit a scalar epilogue loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">  /// Query the target what the preferred style of tail folding is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">  /// \param IVUpdateMayOverflow Tells whether it is known if the IV update</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">  /// may (or will never) overflow for the suggested VF/UF in the given loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">  /// Targets can use this information to select a more optimal tail folding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  /// style. The value conservatively defaults to true, such that no assumptions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">  /// are made on overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">  TailFoldingStyle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">  // Parameters that control the loop peeling transformation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">  struct PeelingPreferences {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">    /// A forced peeling factor (the number of bodied of the original loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">    /// that should be peeled off before the loop body). When set to 0, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">    /// a peeling factor based on profile information and other factors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">    unsigned PeelCount;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">    /// Allow peeling off loop iterations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">    bool AllowPeeling;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">    /// Allow peeling off loop iterations for loop nests.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">    bool AllowLoopNestsPeeling;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">    /// Allow peeling basing on profile. Uses to enable peeling off all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">    /// iterations basing on provided profile.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">    /// If the value is true the peeling cost model can decide to peel only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">    /// some iterations and in this case it will set this to false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">    bool PeelProfiledIterations;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">  /// Get target-customized preferences for the generic loop peeling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  /// transformation. The caller will initialize \p PP with the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  /// target-independent defaults with information from \p L and \p SE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">                             PeelingPreferences &PP) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  /// Targets can implement their own combinations for target-specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  /// intrinsics. This function will be called from the InstCombine pass every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">  /// time a target-specific intrinsic is encountered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  /// \returns std::nullopt to not do anything target specific or a value that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  /// will be returned from the InstCombiner. It is possible to return null and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">  /// stop further processing of the intrinsic by returning nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner & IC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">                                                    IntrinsicInst & II) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  /// Can be used to implement target-specific instruction combining.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">  /// \see instCombineIntrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">  std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">      KnownBits & Known, bool &KnownBitsComputed) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">  /// Can be used to implement target-specific instruction combining.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  /// \see instCombineIntrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">      APInt & UndefElts, APInt & UndefElts2, APInt & UndefElts3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">          SimplifyAndSetOp) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  /// \name Scalar Target Information</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  /// Flags indicating the kind of support for population count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  /// Compared to the SW implementation, HW support is supposed to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  /// significantly boost the performance when the population is dense, and it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  /// may or may not degrade performance if the population is sparse. A HW</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  /// support is considered as "Fast" if it can outperform, or is on a par</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">  /// with, SW implementation when the population is sparse; otherwise, it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">  /// considered as "Slow".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">  enum PopcntSupportKind { PSK_Software, PSK_SlowHardware, PSK_FastHardware };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">  /// Return true if the specified immediate is legal add immediate, that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  /// is the target has add instructions which can add a register with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">  /// immediate without having to materialize the immediate into a register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">  bool isLegalAddImmediate(int64_t Imm) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">  /// Return true if the specified immediate is legal icmp immediate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  /// that is the target has icmp instructions which can compare a register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">  /// against the immediate without having to materialize the immediate into a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  /// register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">  bool isLegalICmpImmediate(int64_t Imm) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  /// Return true if the addressing mode represented by AM is legal for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  /// this target, for a load/store of the specified type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  /// The type may be VoidTy, in which case only return true if the addressing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">  /// mode is legal for a load/store of any legal type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">  /// If target returns true in LSRWithInstrQueries(), I may be valid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">  /// TODO: Handle pre/postinc as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">                             bool HasBaseReg, int64_t Scale,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">                             unsigned AddrSpace = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">                             Instruction *I = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">  /// Return true if LSR cost of C1 is lower than C2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">                     const TargetTransformInfo::LSRCost &C2) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">  /// Return true if LSR major cost is number of registers. Targets which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  /// implement their own isLSRCostLess and unset number of registers as major</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">  /// cost should return false, otherwise return true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">  bool isNumRegsMajorCostOfLSR() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">  /// \returns true if LSR should not optimize a chain that includes \p I.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">  bool isProfitableLSRChainElement(Instruction *I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  /// Return true if the target can fuse a compare and branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">  /// Loop-strength-reduction (LSR) uses that knowledge to adjust its cost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">  /// calculation for the instructions in a loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">  bool canMacroFuseCmp() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">  /// Return true if the target can save a compare for loop count, for example</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">  /// hardware loop saves a compare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">                  DominatorTree *DT, AssumptionCache *AC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">                  TargetLibraryInfo *LibInfo) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">  enum AddressingModeKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">    AMK_PreIndexed,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    AMK_PostIndexed,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">    AMK_None</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">  /// Return the preferred addressing mode LSR should make efforts to generate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">  AddressingModeKind getPreferredAddressingMode(const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">                                                ScalarEvolution *SE) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">  /// Return true if the target supports masked store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">  bool isLegalMaskedStore(Type *DataType, Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  /// Return true if the target supports masked load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">  /// Return true if the target supports nontemporal store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  bool isLegalNTStore(Type *DataType, Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">  /// Return true if the target supports nontemporal load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">  bool isLegalNTLoad(Type *DataType, Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">  /// \Returns true if the target supports broadcasting a load to a vector of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">  /// type <NumElements x ElementTy>.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">  bool isLegalBroadcastLoad(Type *ElementTy, ElementCount NumElements) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">  /// Return true if the target supports masked scatter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">  /// Return true if the target supports masked gather.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">  bool isLegalMaskedGather(Type *DataType, Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">  /// Return true if the target forces scalarizing of llvm.masked.gather</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">  /// intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">  bool forceScalarizeMaskedGather(VectorType *Type, Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">  /// Return true if the target forces scalarizing of llvm.masked.scatter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">  /// intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">  bool forceScalarizeMaskedScatter(VectorType *Type, Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">  /// Return true if the target supports masked compress store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">  bool isLegalMaskedCompressStore(Type *DataType) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">  /// Return true if the target supports masked expand load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">  bool isLegalMaskedExpandLoad(Type *DataType) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">  /// Return true if this is an alternating opcode pattern that can be lowered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">  /// to a single instruction on the target. In X86 this is for the addsub</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">  /// instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">  /// This function expectes two opcodes: \p Opcode1 and \p Opcode2 being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">  /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">  /// when \p Opcode0 is selected and `1` when Opcode1 is selected.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">  /// \p VecTy is the vector type of the instruction to be generated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">                       const SmallBitVector &OpcodeMask) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  /// Return true if we should be enabling ordered reductions for the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">  bool enableOrderedReductions() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">  /// Return true if the target has a unified operation to calculate division</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">  /// and remainder. If so, the additional implicit multiplication and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">  /// subtraction required to calculate a remainder from division are free. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">  /// can enable more aggressive transformations for division and remainder than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">  /// would typically be allowed using throughput or size cost models.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">  bool hasDivRemOp(Type *DataType, bool IsSigned) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">  /// Return true if the given instruction (assumed to be a memory access</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">  /// instruction) has a volatile variant. If that's the case then we can avoid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">  /// addrspacecast to generic AS for volatile loads/stores. Default</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">  /// implementation returns false, which prevents address space inference for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">  /// volatile loads/stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">  /// Return true if target doesn't mind addresses in vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">  bool prefersVectorizedAddressing() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">  /// Return the cost of the scaling factor used in the addressing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">  /// mode represented by AM for this target, for a load/store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">  /// of the specified type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">  /// If the AM is supported, the return value must be >= 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">  /// If the AM is not supported, it returns a negative value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">  /// TODO: Handle pre/postinc as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">                                       int64_t Scale,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">                                       unsigned AddrSpace = 0) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">  /// Return true if the loop strength reduce pass should make</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">  /// Instruction* based TTI queries to isLegalAddressingMode(). This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">  /// needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">  /// immediate offset and no index register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  bool LSRWithInstrQueries() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  /// Return true if it's free to truncate a value of type Ty1 to type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">  /// Ty2. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">  /// by referencing its sub-register AX.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">  bool isTruncateFree(Type *Ty1, Type *Ty2) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">  /// Return true if it is profitable to hoist instruction in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">  /// then/else to before if.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">  bool isProfitableToHoist(Instruction *I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  bool useAA() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">  /// Return true if this type is legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">  bool isTypeLegal(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">  /// Returns the estimated number of registers required to represent \p Ty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">  unsigned getRegUsageForType(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">  /// Return true if switches should be turned into lookup tables for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">  /// target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">  bool shouldBuildLookupTables() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">  /// Return true if switches should be turned into lookup tables</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">  /// containing this constant value for the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">  bool shouldBuildLookupTablesForConstant(Constant *C) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  /// Return true if lookup tables should be turned into relative lookup tables.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">  bool shouldBuildRelLookupTables() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  /// Return true if the input function which is cold at all call sites,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">  ///  should use coldcc calling convention.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">  bool useColdCCForColdCall(Function &F) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  /// are set if the demanded result elements need to be inserted and/or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  /// extracted from vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">                                           const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">                                           bool Insert, bool Extract,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">                                           TTI::TargetCostKind CostKind) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">  /// Estimate the overhead of scalarizing an instructions unique</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  /// non-constant operands. The (potentially vector) types to use for each of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  /// argument are passes via Tys.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">                                   ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">                                   TTI::TargetCostKind CostKind) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">  /// If target has efficient vector element load/store instructions, it can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">  /// return true here so that insertion/extraction costs are not added to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">  /// the scalarization cost of a load/store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  bool supportsEfficientVectorElementLoadStore() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">  /// If the target supports tail calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  bool supportsTailCalls() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  /// If target supports tail call on \p CB</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  bool supportsTailCallFor(const CallBase *CB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">  /// Don't restrict interleaved unrolling to small loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">  bool enableAggressiveInterleaving(bool LoopHasReductions) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">  /// Returns options for expansion of memcmp. IsZeroCmp is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">  // true if this is the expansion of memcmp(p1, p2, s) == 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  struct MemCmpExpansionOptions {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">    // Return true if memcmp expansion is enabled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">    operator bool() const { return MaxNumLoads > 0; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">    // Maximum number of load operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">    unsigned MaxNumLoads = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">    // The list of available load sizes (in bytes), sorted in decreasing order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">    SmallVector<unsigned, 8> LoadSizes;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">    // For memcmp expansion when the memcmp result is only compared equal or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">    // not-equal to 0, allow up to this number of load pairs per block. As an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">    // example, this may allow 'memcmp(a, b, 3) == 0' in a single block:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">    //   a0 = load2bytes &a[0]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">    //   b0 = load2bytes &b[0]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">    //   a2 = load1byte  &a[2]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">    //   b2 = load1byte  &b[2]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">    //   r  = cmp eq (a0 ^ b0 | a2 ^ b2), 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">    unsigned NumLoadsPerBlock = 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">    // Set to true to allow overlapping loads. For example, 7-byte compares can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">    // be done with two 4-byte compares instead of 4+2+1-byte compares. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">    // requires all loads in LoadSizes to be doable in an unaligned way.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">    bool AllowOverlappingLoads = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">                                               bool IsZeroCmp) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">  /// Should the Select Optimization pass be enabled and ran.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">  bool enableSelectOptimize() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">  /// Enable matching of interleaved access groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">  bool enableInterleavedAccessVectorization() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">  /// Enable matching of interleaved access groups that contain predicated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">  /// accesses or gaps and therefore vectorized using masked</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="">  /// vector loads/stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="">  bool enableMaskedInterleavedAccessVectorization() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  /// Indicate that it is potentially unsafe to automatically vectorize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="">  /// floating-point operations because the semantics of vector and scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">  /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">  /// does not support IEEE-754 denormal numbers, while depending on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">  /// platform, scalar floating-point math does.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">  /// This applies to floating-point math operations and calls, not memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">  /// operations, shuffles, or casts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">  bool isFPVectorizationPotentiallyUnsafe() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">  /// Determine if the target supports unaligned memory accesses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">                                      unsigned AddressSpace = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">                                      Align Alignment = Align(1),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">                                      unsigned *Fast = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  /// Return hardware support for population count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">  /// Return true if the hardware has a fast square-root instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">  bool haveFastSqrt(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">  /// Return true if the cost of the instruction is too high to speculatively</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  /// execute and should be kept behind a branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">  /// This normally just wraps around a getInstructionCost() call, but some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">  /// targets might report a low TCK_SizeAndLatency value that is incompatible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">  /// with the fixed TCC_Expensive value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">  /// NOTE: This assumes the instruction passes isSafeToSpeculativelyExecute().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">  bool isExpensiveToSpeculativelyExecute(const Instruction *I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">  /// Return true if it is faster to check if a floating-point value is NaN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">  /// (or not-NaN) versus a comparison against a constant FP zero value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">  /// Targets should override this if materializing a 0.0 for comparison is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">  /// generally as cheap as checking for ordered/unordered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">  /// Return the expected cost of supporting the floating point operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">  /// of the specified type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">  InstructionCost getFPOpCost(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">  /// Return the expected cost of materializing for the given integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">  /// immediate of the specified type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">                                TargetCostKind CostKind) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  /// Return the expected cost of materialization for the given integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  /// immediate of the specified type for a given instruction. The cost can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  /// zero if the immediate can be folded into the specified instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">                                    const APInt &Imm, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">                                    TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">                                    Instruction *Inst = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">                                      const APInt &Imm, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">                                      TargetCostKind CostKind) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">  /// Return the expected cost for the given integer when optimising</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">  /// for size. This is different than the other integer immediate cost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">  /// functions in that it is subtarget agnostic. This is useful when you e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">  /// target one ISA such as Aarch32 but smaller encodings could be possible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  /// with another such as Thumb. This return value is used as a penalty when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">  /// the total costs for a constant is calculated (the bigger the cost, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">  /// more beneficial constant hoisting is).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">                                        const APInt &Imm, Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">  /// \name Vector Target Information</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">  /// The various kinds of shuffle patterns for vector queries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">  enum ShuffleKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">    SK_Broadcast,        ///< Broadcast element 0 to all other elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">    SK_Reverse,          ///< Reverse the order of the vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">    SK_Select,           ///< Selects elements from the corresponding lane of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">                         ///< either source operand. This is equivalent to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">                         ///< vector select with a constant condition operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">    SK_Transpose,        ///< Transpose two vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">    SK_InsertSubvector,  ///< InsertSubvector. Index indicates start offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">    SK_ExtractSubvector, ///< ExtractSubvector Index indicates start offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">    SK_PermuteTwoSrc,    ///< Merge elements from two source vectors into one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">                         ///< with any shuffle mask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">    SK_PermuteSingleSrc, ///< Shuffle elements of single source vector with any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">                         ///< shuffle mask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">    SK_Splice            ///< Concatenates elements from the first input vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">                         ///< with elements of the second input vector. Returning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">                         ///< a vector of the same type as the input vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">                         ///< Index indicates start offset in first input vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">  /// Additional information about an operand's possible values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">  enum OperandValueKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">    OK_AnyValue,               // Operand can have any value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">    OK_UniformValue,           // Operand is uniform (splat of a value).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">    OK_UniformConstantValue,   // Operand is uniform constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">    OK_NonUniformConstantValue // Operand is a non uniform constant value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">  /// Additional properties of an operand's values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">  enum OperandValueProperties {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">    OP_None = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">    OP_PowerOf2 = 1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">    OP_NegatedPowerOf2 = 2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">  // Describe the values an operand can take.  We're in the process</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  // of migrating uses of OperandValueKind and OperandValueProperties</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  // to use this class, and then will change the internal representation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">  struct OperandValueInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">    OperandValueKind Kind = OK_AnyValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">    OperandValueProperties Properties = OP_None;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="uncoveredLine">    bool isConstant() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">      return Kind == OK_UniformConstantValue || Kind == OK_NonUniformConstantValue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">    bool isUniform() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">      return Kind == OK_UniformConstantValue || Kind == OK_UniformValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">    bool isPowerOf2() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">      return Properties == OP_PowerOf2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">    bool isNegatedPowerOf2() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">      return Properties == OP_NegatedPowerOf2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">    OperandValueInfo getNoProps() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">      return {Kind, OP_None};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">  /// \return the number of registers in the target-provided register class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  unsigned getNumberOfRegisters(unsigned ClassID) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">  /// \return the target-provided register class ID for the provided type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  /// accounting for type promotion and other type-legalization techniques that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">  /// the target might apply. However, it specifically does not account for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">  /// scalarization or splitting of vector types. Should a vector type require</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">  /// scalarization or splitting into multiple underlying vector registers, that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  /// type should be mapped to a register class containing no registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  /// Specifically, this is designed to provide a simple, high-level view of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  /// register allocation later performed by the backend. These register classes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">  /// don't necessarily map onto the register classes used by the backend.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">  /// FIXME: It's not currently possible to determine how many registers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">  /// are used by the provided type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">  unsigned getRegisterClassForType(bool Vector, Type *Ty = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">  /// \return the target-provided register class name</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">  const char *getRegisterClassName(unsigned ClassID) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">  enum RegisterKind { RGK_Scalar, RGK_FixedWidthVector, RGK_ScalableVector };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">  /// \return The width of the largest scalar or vector register type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">  TypeSize getRegisterBitWidth(RegisterKind K) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">  /// \return The width of the smallest vector register type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">  unsigned getMinVectorRegisterBitWidth() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">  /// \return The maximum value of vscale if the target specifies an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">  ///  architectural maximum vector length, and std::nullopt otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">  std::optional<unsigned> getMaxVScale() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">  /// \return the value of vscale to tune the cost model for.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">  std::optional<unsigned> getVScaleForTuning() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">  /// \return true if vscale is known to be a power of 2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">  bool isVScaleKnownToBeAPowerOfTwo() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">  /// \return True if the vectorization factor should be chosen to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">  /// make the vector of the smallest element type match the size of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">  /// vector register. For wider element types, this could result in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">  /// creating vectors that span multiple vector registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">  /// If false, the vectorization factor will be chosen based on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">  /// size of the widest element type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">  /// \p K Register Kind for vectorization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">  bool shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">  /// \return The minimum vectorization factor for types of given element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">  /// bit width, or 0 if there is no minimum VF. The returned value only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">  /// applies when shouldMaximizeVectorBandwidth returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">  /// If IsScalable is true, the returned ElementCount must be a scalable VF.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">  ElementCount getMinimumVF(unsigned ElemWidth, bool IsScalable) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">  /// \return The maximum vectorization factor for types of given element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">  /// bit width and opcode, or 0 if there is no maximum VF.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  /// Currently only used by the SLP vectorizer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">  /// \return The minimum vectorization factor for the store instruction. Given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">  /// the initial estimation of the minimum vector factor and store value type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">  /// it tries to find possible lowest VF, which still might be profitable for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">  /// the vectorization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">  /// \param VF Initial estimation of the minimum vector factor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  /// \param ScalarMemTy Scalar memory type of the store operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">  /// \param ScalarValTy Scalar type of the stored value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">  /// Currently only used by the SLP vectorizer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">                             Type *ScalarValTy) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">  /// \return True if it should be considered for address type promotion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">  /// \p AllowPromotionWithoutCommonHeader Set true if promoting \p I is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">  /// profitable without finding other extensions fed by the same input.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">  bool shouldConsiderAddressTypePromotion(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">  /// \return The size of a cache line in bytes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  unsigned getCacheLineSize() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">  /// The possible cache levels</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="">  enum class CacheLevel {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">    L1D, // The L1 data cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">    L2D, // The L2 data cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">    // We currently do not model L3 caches, as their sizes differ widely between</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">    // microarchitectures. Also, we currently do not have a use for L3 cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">    // size modeling yet.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">  /// \return The size of the cache level in bytes, if available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">  std::optional<unsigned> getCacheSize(CacheLevel Level) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">  /// \return The associativity of the cache level, if available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">  std::optional<unsigned> getCacheAssociativity(CacheLevel Level) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">  /// \return How much before a load we should place the prefetch</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">  /// instruction.  This is currently measured in number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">  /// instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">  unsigned getPrefetchDistance() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">  /// Some HW prefetchers can handle accesses up to a certain constant stride.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">  /// Sometimes prefetching is beneficial even below the HW prefetcher limit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="">  /// and the arguments provided are meant to serve as a basis for deciding this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">  /// for a particular loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">  /// \param NumMemAccesses        Number of memory accesses in the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">  /// \param NumStridedMemAccesses Number of the memory accesses that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">  ///                              ScalarEvolution could find a known stride</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">  ///                              for.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">  /// \param NumPrefetches         Number of software prefetches that will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="">  ///                              emitted as determined by the addresses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">  ///                              involved and the cache line size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">  /// \param HasCall               True if the loop contains a call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">  /// \return This is the minimum stride in bytes where it makes sense to start</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">  ///         adding SW prefetches. The default is 1, i.e. prefetch with any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  ///         stride.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">                                unsigned NumStridedMemAccesses,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">                                unsigned NumPrefetches, bool HasCall) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">  /// the required number of iterations is more than this number, no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">  /// prefetching is performed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">  unsigned getMaxPrefetchIterationsAhead() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">  /// \return True if prefetching should also be done for writes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">  bool enableWritePrefetching() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">  bool shouldPrefetchAddressSpace(unsigned AS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="">  /// \return The maximum interleave factor that any transform should try to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">  /// perform for this target. This number depends on the level of parallelism</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">  /// and the number of execution units in the CPU.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">  unsigned getMaxInterleaveFactor(ElementCount VF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">  /// Collect properties of V used in cost analysis, e.g. OP_PowerOf2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  static OperandValueInfo getOperandInfo(const Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  /// This is an approximation of reciprocal throughput of a math/logic op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">  /// A higher cost indicates less expected throughput.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  /// From Agner Fog's guides, reciprocal throughput is "the average number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">  /// clock cycles per instruction when the instructions are not part of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="">  /// limiting dependency chain."</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">  /// Therefore, costs should be scaled to account for multiple execution units</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">  /// on the target that can process this type of instruction. For example, if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="">  /// there are 5 scalar integer units and 2 vector integer units that can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">  /// calculate an 'add' in a single cycle, this model should indicate that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">  /// cost of the vector add instruction is 2.5 times the cost of the scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">  /// add instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">  /// \p Args is an optional argument which holds the instruction operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">  /// values so the TTI can analyze those values searching for special</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">  /// cases or optimizations based on those values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">  /// \p CxtI is the optional original context instruction, if one exists, to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">  /// provide even more information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">  InstructionCost getArithmeticInstrCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="">      unsigned Opcode, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">      const Instruction *CxtI = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">  /// \return The cost of a shuffle instruction of kind Kind and of type Tp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  /// The exact mask may be passed as Mask, or else the array will be empty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">  /// The index and subtype parameters are used by the subvector insertion and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">  /// extraction shuffle kinds to show the insert/extract point and the type of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">  /// the subvector being inserted/extracted. The operands of the shuffle can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  /// passed through \p Args, which helps improve the cost estimation in some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="">  /// cases, like in broadcast loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">  /// NOTE: For subvector extractions Tp represents the source type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">  getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">                 ArrayRef<int> Mask = std::nullopt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">                 TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">                 int Index = 0, VectorType *SubTp = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">                 ArrayRef<const Value *> Args = std::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">  /// Represents a hint about the context in which a cast is used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  /// For zext/sext, the context of the cast is the operand, which must be a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">  /// load of some kind. For trunc, the context is of the cast is the single</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">  /// user of the instruction, which must be a store of some kind.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">  /// This enum allows the vectorizer to give getCastInstrCost an idea of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  /// type of cast it's dealing with, as not every cast is equal. For instance,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">  /// the zext of a load may be free, but the zext of an interleaving load can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  //// be (very) expensive!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">  /// See \c getCastContextHint to compute a CastContextHint from a cast</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">  /// Instruction*. Callers can use it if they don't need to override the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">  /// context and just want it to be calculated from the instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">  /// FIXME: This handles the types of load/store that the vectorizer can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">  /// produce, which are the cases where the context instruction is most</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">  /// likely to be incorrect. There are other situations where that can happen</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">  /// too, which might be handled here but in the long run a more general</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">  /// solution of costing multiple instructions at the same times may be better.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">  enum class CastContextHint : uint8_t {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">    None,          ///< The cast is not used with a load/store of any kind.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">    Normal,        ///< The cast is used with a normal load/store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">    Masked,        ///< The cast is used with a masked load/store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">    GatherScatter, ///< The cast is used with a gather/scatter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">    Interleave,    ///< The cast is used with an interleaved load/store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">    Reversed,      ///< The cast is used with a reversed load/store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">  /// Calculates a CastContextHint from \p I.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  /// This should be used by callers of getCastInstrCost if they wish to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">  /// determine the context from some instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">  /// \returns the CastContextHint for ZExt/SExt/Trunc, None if \p I is nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">  /// or if it's another type of cast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">  static CastContextHint getCastContextHint(const Instruction *I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">  /// \return The expected cost of cast instructions, such as bitcast, trunc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">  /// zext, etc. If there is an existing instruction that holds Opcode, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">  /// may be passed in the 'I' parameter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">  getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">                   TTI::CastContextHint CCH,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">                   TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">                   const Instruction *I = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">  /// \return The expected cost of a sign- or zero-extended vector extract. Use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  /// Index = -1 to indicate that there is no information about the index value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">                                           VectorType *VecTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">                                           unsigned Index) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">  /// \return The expected cost of control-flow related instructions such as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  /// Phi, Ret, Br, Switch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">  getCFInstrCost(unsigned Opcode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">                 const Instruction *I = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  /// \returns The expected cost of compare and select instructions. If there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">  /// is an existing instruction that holds Opcode, it may be passed in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">  /// 'I' parameter. The \p VecPred parameter can be used to indicate the select</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">  /// is using a compare with the specified predicate as condition. When vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  /// types are passed, \p VecPred must be used for all lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">  getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">                     CmpInst::Predicate VecPred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">                     TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">                     const Instruction *I = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">  /// \return The expected cost of vector Insert and Extract.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">  /// Use -1 to indicate that there is no information on the index value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">  /// This is used when the instruction is not available; a typical use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">  /// case is to provision the cost of vectorization/scalarization in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">  /// vectorizer passes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">                                     TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">                                     unsigned Index = -1, Value *Op0 = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">                                     Value *Op1 = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">  /// \return The expected cost of vector Insert and Extract.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">  /// This is used when instruction is available, and implementation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">  /// asserts 'I' is not nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">  /// A typical suitable use case is cost estimation when vector instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">  /// exists (e.g., from basic blocks during transformation).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">                                     TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">                                     unsigned Index = -1) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">  /// \return The cost of replication shuffle of \p VF elements typed \p EltTy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">  /// \p ReplicationFactor times.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">  /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">  ///   <0,0,0,1,1,1,2,2,2,3,3,3></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">                                            int VF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">                                            const APInt &DemandedDstElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">                                            TTI::TargetCostKind CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">  /// \return The cost of Load and Store instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">                  unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">                  TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">                  OperandValueInfo OpdInfo = {OK_AnyValue, OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">                  const Instruction *I = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">  /// \return The cost of VP Load and Store instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">  getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">                    unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">                    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">                    const Instruction *I = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">  /// \return The cost of masked Load and Store instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="">  InstructionCost getMaskedMemoryOpCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">      unsigned Opcode, Type *Src, Align Alignment, unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">  /// \return The cost of Gather or Scatter operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">  /// \p Opcode - is a type of memory access Load or Store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="">  /// \p DataTy - a vector type of the data to be loaded or stored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="">  /// \p Ptr - pointer [or vector of pointers] - address[es] in memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">  /// \p VariableMask - true when the memory access is predicated with a mask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">  ///                   that is not a compile-time constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">  /// \p Alignment - alignment of single element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">  /// \p I - the optional original context instruction, if one exists, e.g. the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">  ///        load/store to transform or the call to the gather/scatter intrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">  InstructionCost getGatherScatterOpCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">      unsigned Opcode, Type *DataTy, const Value *Ptr, bool VariableMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">      Align Alignment, TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">      const Instruction *I = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">  /// \return The cost of the interleaved memory operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">  /// \p Opcode is the memory operation code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">  /// \p VecTy is the vector type of the interleaved access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">  /// \p Factor is the interleave factor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">  /// \p Indices is the indices for interleaved load members (as interleaved</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">  ///    load allows gaps)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">  /// \p Alignment is the alignment of the memory operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">  /// \p AddressSpace is address space of the pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">  /// \p UseMaskForCond indicates if the memory access is predicated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">  /// \p UseMaskForGaps indicates if gaps should be masked.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">      Align Alignment, unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">      bool UseMaskForCond = false, bool UseMaskForGaps = false) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">  /// A helper function to determine the type of reduction algorithm used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">  /// for a given \p Opcode and set of FastMathFlags \p FMF.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="uncoveredLine">  static bool requiresOrderedReduction(std::optional<FastMathFlags> FMF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">    return FMF && !(*FMF).allowReassoc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">  /// Calculate the cost of vector reduction intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">  /// This is the cost of reducing the vector value of type \p Ty to a scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">  /// value using the operation denoted by \p Opcode. The FastMathFlags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">  /// parameter \p FMF indicates what type of reduction we are performing:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">  ///   1. Tree-wise. This is the typical 'fast' reduction performed that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">  ///   involves successively splitting a vector into half and doing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">  ///   operation on the pair of halves until you have a scalar value. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">  ///   example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">  ///     (v0, v1, v2, v3)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">  ///     ((v0+v2), (v1+v3), undef, undef)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">  ///     ((v0+v2+v1+v3), undef, undef, undef)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">  ///   This is the default behaviour for integer operations, whereas for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">  ///   floating point we only do this if \p FMF indicates that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">  ///   reassociation is allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">  ///   2. Ordered. For a vector with N elements this involves performing N</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">  ///   operations in lane order, starting with an initial scalar value, i.e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">  ///     result = InitVal + v0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">  ///     result = result + v1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">  ///     result = result + v2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">  ///     result = result + v3</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="">  ///   This is only the case for FP operations and when reassociation is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">  ///   allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">  InstructionCost getArithmeticReductionCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">      unsigned Opcode, VectorType *Ty, std::optional<FastMathFlags> FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">  InstructionCost getMinMaxReductionCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">      Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF = FastMathFlags(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">  /// Calculate the cost of an extended reduction pattern, similar to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">  /// getArithmeticReductionCost of an Add reduction with multiply and optional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">  /// extensions. This is the cost of as:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">  /// ResTy vecreduce.add(mul (A, B)).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">  /// ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">  InstructionCost getMulAccReductionCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">  /// Calculate the cost of an extended reduction pattern, similar to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">  /// getArithmeticReductionCost of a reduction with an extension.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">  /// This is the cost of as:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">  /// ResTy vecreduce.opcode(ext(Ty A)).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  InstructionCost getExtendedReductionCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">      FastMathFlags FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">  /// \returns The cost of Intrinsic instructions. Analyses the real arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">  /// Three cases are handled: 1. scalar instruction 2. vector instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">  /// 3. scalar instruction which is to be vectorized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">                                        TTI::TargetCostKind CostKind) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">  /// \returns The cost of Call instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">  InstructionCost getCallInstrCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">      Function *F, Type *RetTy, ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">  /// \returns The number of pieces into which the provided type must be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">  /// split during legalization. Zero is returned when the answer is unknown.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">  unsigned getNumberOfParts(Type *Tp) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">  /// \returns The cost of the address computation. For most targets this can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">  /// merged into the instruction indexing mode. Some targets might want to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">  /// distinguish between address computation for memory operations on vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">  /// types and scalar types. Such targets should override this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">  /// The 'SE' parameter holds pointer for the scalar evolution object which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">  /// is used in order to get the Ptr step value in case of constant stride.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">  /// The 'Ptr' parameter holds SCEV of the access pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">  InstructionCost getAddressComputationCost(Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="">                                            ScalarEvolution *SE = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">                                            const SCEV *Ptr = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">  /// \returns The cost, if any, of keeping values of the given types alive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="">  /// over a callsite.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">  /// Some types may require the use of register classes that do not have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">  /// any callee-saved registers, so would require a spill and fill.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">  /// \returns True if the intrinsic is a supported memory intrinsic.  Info</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">  /// will contain additional information - whether the intrinsic may write</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">  /// or read to memory, volatility and the pointer.  Info is undefined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">  /// if false is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">  bool getTgtMemIntrinsic(IntrinsicInst *Inst, MemIntrinsicInfo &Info) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">  /// \returns The maximum element size, in bytes, for an element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="">  /// unordered-atomic memory intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">  unsigned getAtomicMemIntrinsicMaxElementSize() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">  /// \returns A value which is the result of the given memory intrinsic.  New</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">  /// instructions may be created to extract the result from the given intrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">  /// memory operation.  Returns nullptr if the target cannot create a result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">  /// from the given intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="">                                           Type *ExpectedType) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">  /// \returns The type to use in a loop expansion of a memcpy call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">  Type *getMemcpyLoopLoweringType(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">      std::optional<uint32_t> AtomicElementSize = std::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">  /// \param[out] OpsOut The operand types to copy RemainingBytes of memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">  /// \param RemainingBytes The number of bytes to copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">  /// Calculates the operand types to use when copying \p RemainingBytes of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  /// memory, where source and destination alignments are \p SrcAlign and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="">  /// \p DestAlign respectively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">  void getMemcpyLoopResidualLoweringType(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">      std::optional<uint32_t> AtomicCpySize = std::nullopt) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">  /// \returns True if the two functions have compatible attributes for inlining</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">  /// purposes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="">  bool areInlineCompatible(const Function *Caller,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">                           const Function *Callee) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  /// \returns True if the caller and callee agree on how \p Types will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  /// passed to or returned from the callee.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">  /// to the callee.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">  /// \param Types List of types to check.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">                             const ArrayRef<Type *> &Types) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">  /// The type of load/store indexing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">  enum MemIndexedMode {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">    MIM_Unindexed, ///< No indexing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">    MIM_PreInc,    ///< Pre-incrementing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">    MIM_PreDec,    ///< Pre-decrementing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">    MIM_PostInc,   ///< Post-incrementing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">    MIM_PostDec    ///< Post-decrementing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">  /// \returns True if the specified indexed load for the given type is legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="">  bool isIndexedLoadLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">  /// \returns True if the specified indexed store for the given type is legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">  bool isIndexedStoreLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">  /// \returns The bitwidth of the largest vector type that should be used to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">  /// load/store in the given address space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">  /// \returns True if the load instruction is legal to vectorize.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">  bool isLegalToVectorizeLoad(LoadInst *LI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">  /// \returns True if the store instruction is legal to vectorize.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">  bool isLegalToVectorizeStore(StoreInst *SI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">  /// \returns True if it is legal to vectorize the given load chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="">                                   unsigned AddrSpace) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="">  /// \returns True if it is legal to vectorize the given store chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="">                                    unsigned AddrSpace) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="">  /// \returns True if it is legal to vectorize the given reduction kind.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="">                                   ElementCount VF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">  /// \returns True if the given type is supported for scalable vectors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">  bool isElementTypeLegalForScalableVector(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">  /// \returns The new vector factor value if the target doesn't support \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">  /// SizeInBytes loads or has a better vector factor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">                               unsigned ChainSizeInBytes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">                               VectorType *VecTy) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="">  /// \returns The new vector factor value if the target doesn't support \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">  /// SizeInBytes stores or has a better vector factor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="">                                unsigned ChainSizeInBytes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">                                VectorType *VecTy) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="">  /// Flags describing the kind of vector reduction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">  struct ReductionFlags {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">    ReductionFlags() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="">    bool IsMaxOp =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="">        false; ///< If the op a min/max kind, true if it's a max operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">    bool IsSigned = false; ///< Whether the operation is a signed int reduction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="">    bool NoNaN =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">        false; ///< If op is an fp min/max, whether NaNs may be present.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="">  /// \returns True if the target prefers reductions in loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">                             ReductionFlags Flags) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">  /// \returns True if the target prefers reductions select kept in the loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">  /// when tail folding. i.e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">  /// loop:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">  ///   p = phi (0, s)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">  ///   a = add (p, x)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">  ///   s = select (mask, a, p)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="">  /// vecreduce.add(s)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="">  /// As opposed to the normal scheme of p = phi (0, a) which allows the select</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">  /// to be pulled out of the loop. If the select(.., add, ..) can be predicated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="">  /// by the target, this can lead to cleaner code generation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">                                       ReductionFlags Flags) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="">  /// Return true if the loop vectorizer should consider vectorizing an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="">  /// otherwise scalar epilogue loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">  bool preferEpilogueVectorization() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">  /// \returns True if the target wants to expand the given reduction intrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="">  /// into a shuffle sequence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">  bool shouldExpandReduction(const IntrinsicInst *II) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">  /// \returns the size cost of rematerializing a GlobalValue address relative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">  /// to a stack reload.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">  unsigned getGISelRematGlobalCost() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">  /// \returns the lower bound of a trip count to decide on vectorization</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="">  /// while tail-folding.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">  unsigned getMinTripCountTailFoldingThreshold() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">  /// \returns True if the target supports scalable vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="">  bool supportsScalableVectors() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">  /// \return true when scalable vectorization is preferred.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="">  bool enableScalableVectorization() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="">  /// \name Vector Predication Information</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">  /// Whether the target supports the %evl parameter of VP intrinsic efficiently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="">  /// in hardware, for the given opcode and type/alignment. (see LLVM Language</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="">  /// Reference - "Vector Predication Intrinsics").</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">  /// Use of %evl is discouraged when that is not the case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">                             Align Alignment) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">  struct VPLegalization {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="">    enum VPTransform {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="">      // keep the predicating parameter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">      Legal = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="">      // where legal, discard the predicate parameter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="">      Discard = 1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">      // transform into something else that is also predicating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="">      Convert = 2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="">    // How to transform the EVL parameter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="">    // Legal:   keep the EVL parameter as it is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">    // Discard: Ignore the EVL parameter where it is safe to do so.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="">    // Convert: Fold the EVL into the mask parameter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">    VPTransform EVLParamStrategy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="">    // How to transform the operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">    // Legal:   The target supports this operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">    // Convert: Convert this to a non-VP operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="">    // The 'Discard' strategy is invalid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="">    VPTransform OpStrategy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="">    bool shouldDoNothing() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">      return (EVLParamStrategy == Legal) && (OpStrategy == Legal);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="uncoveredLine">    VPLegalization(VPTransform EVLParamStrategy, VPTransform OpStrategy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">        : EVLParamStrategy(EVLParamStrategy), OpStrategy(OpStrategy) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="">  /// \returns How the target needs this vector-predicated operation to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="">  /// transformed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="">  VPLegalization getVPLegalizationStrategy(const VPIntrinsic &PI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">  /// \returns Whether a 32-bit branch instruction is available in Arm or Thumb</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">  /// state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="">  /// Used by the LowerTypeTests pass, which constructs an IR inline assembler</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">  /// node containing a jump table in a format suitable for the target, so it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="">  /// needs to know what format of jump table it can legally use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">  /// For non-Arm targets, this function isn't used. It defaults to returning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="">  /// false, but it shouldn't matter what it returns anyway.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">  bool hasArmWideBranch(bool Thumb) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="">  /// \return The maximum number of function arguments the target supports.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">  unsigned getMaxNumArgs() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="">  /// The abstract base class used to type erase specific TTI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="">  /// implementations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">  class Concept;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="">  /// The template model for the base class which wraps a concrete</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="">  /// implementation in a type erased interface.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">  template <typename T> class Model;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">  std::unique_ptr<Concept> TTIImpl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="">class TargetTransformInfo::Concept {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="">  virtual ~Concept() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="">  virtual const DataLayout &getDataLayout() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">  virtual InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">                                     ArrayRef<const Value *> Operands,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">                                     Type *AccessType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="">                                     TTI::TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="">                       const TTI::PointersChainInfo &Info, Type *AccessTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">                       TTI::TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="">  virtual unsigned getInliningThresholdMultiplier() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">  virtual unsigned adjustInliningThreshold(const CallBase *CB) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="">  virtual int getInlinerVectorBonusPercent() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="">  virtual unsigned getCallerAllocaCost(const CallBase *CB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">                                       const AllocaInst *AI) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">  virtual InstructionCost getMemcpyCost(const Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">  virtual uint64_t getMaxMemIntrinsicInlineSizeThreshold() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="">  virtual unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="">  getEstimatedNumberOfCaseClusters(const SwitchInst &SI, unsigned &JTSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="">                                   ProfileSummaryInfo *PSI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="">                                   BlockFrequencyInfo *BFI) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">  virtual InstructionCost getInstructionCost(const User *U,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">                                             ArrayRef<const Value *> Operands,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="">                                             TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">  virtual BranchProbability getPredictableBranchThreshold() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="">  virtual bool hasBranchDivergence(const Function *F = nullptr) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">  virtual bool isSourceOfDivergence(const Value *V) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">  virtual bool isAlwaysUniform(const Value *V) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">  virtual bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">  virtual bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">  virtual unsigned getFlatAddressSpace() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">  virtual bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">                                          Intrinsic::ID IID) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="">  virtual bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">  virtual unsigned getAssumedAddrSpace(const Value *V) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">  virtual bool isSingleThreaded() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">  virtual std::pair<const Value *, unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="">  getPredicatedAddrSpace(const Value *V) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">  virtual Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="">                                                  Value *OldV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="">                                                  Value *NewV) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="">  virtual bool isLoweredToCall(const Function *F) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">  virtual void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">                                       UnrollingPreferences &UP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">                                       OptimizationRemarkEmitter *ORE) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">  virtual void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">                                     PeelingPreferences &PP) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">  virtual bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="">                                        AssumptionCache &AC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">                                        TargetLibraryInfo *LibInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="">                                        HardwareLoopInfo &HWLoopInfo) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">  virtual bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">  virtual TailFoldingStyle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="">  virtual std::optional<Instruction *> instCombineIntrinsic(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="">      InstCombiner &IC, IntrinsicInst &II) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">  virtual std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">      KnownBits & Known, bool &KnownBitsComputed) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="">  virtual std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="">      APInt &UndefElts, APInt &UndefElts2, APInt &UndefElts3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="">          SimplifyAndSetOp) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">  virtual bool isLegalAddImmediate(int64_t Imm) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">  virtual bool isLegalICmpImmediate(int64_t Imm) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="">  virtual bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">                                     int64_t BaseOffset, bool HasBaseReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">                                     int64_t Scale, unsigned AddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">                                     Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">  virtual bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">                             const TargetTransformInfo::LSRCost &C2) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">  virtual bool isNumRegsMajorCostOfLSR() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">  virtual bool isProfitableLSRChainElement(Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">  virtual bool canMacroFuseCmp() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">  virtual bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">                          LoopInfo *LI, DominatorTree *DT, AssumptionCache *AC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">                          TargetLibraryInfo *LibInfo) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">  virtual AddressingModeKind</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">    getPreferredAddressingMode(const Loop *L, ScalarEvolution *SE) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="">  virtual bool isLegalMaskedStore(Type *DataType, Align Alignment) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="">  virtual bool isLegalMaskedLoad(Type *DataType, Align Alignment) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="">  virtual bool isLegalNTStore(Type *DataType, Align Alignment) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="">  virtual bool isLegalNTLoad(Type *DataType, Align Alignment) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">  virtual bool isLegalBroadcastLoad(Type *ElementTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">                                    ElementCount NumElements) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="">  virtual bool isLegalMaskedScatter(Type *DataType, Align Alignment) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">  virtual bool isLegalMaskedGather(Type *DataType, Align Alignment) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="">  virtual bool forceScalarizeMaskedGather(VectorType *DataType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">                                          Align Alignment) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">  virtual bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="">                                           Align Alignment) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">  virtual bool isLegalMaskedCompressStore(Type *DataType) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">  virtual bool isLegalMaskedExpandLoad(Type *DataType) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">  virtual bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">                               unsigned Opcode1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="">                               const SmallBitVector &OpcodeMask) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">  virtual bool enableOrderedReductions() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">  virtual bool hasDivRemOp(Type *DataType, bool IsSigned) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">  virtual bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">  virtual bool prefersVectorizedAddressing() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">  virtual InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">                                               int64_t BaseOffset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="">                                               bool HasBaseReg, int64_t Scale,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">                                               unsigned AddrSpace) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="">  virtual bool LSRWithInstrQueries() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">  virtual bool isTruncateFree(Type *Ty1, Type *Ty2) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="">  virtual bool isProfitableToHoist(Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="">  virtual bool useAA() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="">  virtual bool isTypeLegal(Type *Ty) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">  virtual unsigned getRegUsageForType(Type *Ty) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="">  virtual bool shouldBuildLookupTables() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="">  virtual bool shouldBuildLookupTablesForConstant(Constant *C) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="">  virtual bool shouldBuildRelLookupTables() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">  virtual bool useColdCCForColdCall(Function &F) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">  virtual InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="">                                                   const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">                                                   bool Insert, bool Extract,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">                                                   TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">                                   ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">                                   TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">  virtual bool supportsEfficientVectorElementLoadStore() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">  virtual bool supportsTailCalls() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">  virtual bool supportsTailCallFor(const CallBase *CB) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">  virtual bool enableAggressiveInterleaving(bool LoopHasReductions) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">  virtual MemCmpExpansionOptions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">  enableMemCmpExpansion(bool OptSize, bool IsZeroCmp) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="">  virtual bool enableSelectOptimize() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="">  virtual bool enableInterleavedAccessVectorization() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">  virtual bool enableMaskedInterleavedAccessVectorization() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="">  virtual bool isFPVectorizationPotentiallyUnsafe() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="">  virtual bool allowsMisalignedMemoryAccesses(LLVMContext &Context,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">                                              unsigned BitWidth,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="">                                              unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="">                                              Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="">                                              unsigned *Fast) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">  virtual PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="">  virtual bool haveFastSqrt(Type *Ty) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="">  virtual bool isExpensiveToSpeculativelyExecute(const Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">  virtual bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="">  virtual InstructionCost getFPOpCost(Type *Ty) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">  virtual InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">                                                const APInt &Imm, Type *Ty) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">  virtual InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">                                        TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="">  virtual InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">                                            const APInt &Imm, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">                                            TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">                                            Instruction *Inst = nullptr) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">  virtual InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">                                              const APInt &Imm, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="">                                              TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">  virtual unsigned getNumberOfRegisters(unsigned ClassID) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">  virtual unsigned getRegisterClassForType(bool Vector,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">                                           Type *Ty = nullptr) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="">  virtual const char *getRegisterClassName(unsigned ClassID) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">  virtual TypeSize getRegisterBitWidth(RegisterKind K) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">  virtual unsigned getMinVectorRegisterBitWidth() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">  virtual std::optional<unsigned> getMaxVScale() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="">  virtual std::optional<unsigned> getVScaleForTuning() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="">  virtual bool isVScaleKnownToBeAPowerOfTwo() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">  shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">  virtual ElementCount getMinimumVF(unsigned ElemWidth,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">                                    bool IsScalable) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">  virtual unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="">  virtual unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">                                     Type *ScalarValTy) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">  virtual bool shouldConsiderAddressTypePromotion(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">  virtual unsigned getCacheLineSize() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="">  virtual std::optional<unsigned> getCacheSize(CacheLevel Level) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="">  virtual std::optional<unsigned> getCacheAssociativity(CacheLevel Level)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="">      const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">  /// \return How much before a load we should place the prefetch</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">  /// instruction.  This is currently measured in number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">  /// instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="">  virtual unsigned getPrefetchDistance() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="">  /// \return Some HW prefetchers can handle accesses up to a certain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="">  /// constant stride.  This is the minimum stride in bytes where it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="">  /// makes sense to start adding SW prefetches.  The default is 1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="">  /// i.e. prefetch with any stride.  Sometimes prefetching is beneficial</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="">  /// even below the HW prefetcher limit, and the arguments provided are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  /// meant to serve as a basis for deciding this for a particular loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="">                                        unsigned NumStridedMemAccesses,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">                                        unsigned NumPrefetches,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">                                        bool HasCall) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="">  /// the required number of iterations is more than this number, no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="">  /// prefetching is performed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="">  virtual unsigned getMaxPrefetchIterationsAhead() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="">  /// \return True if prefetching should also be done for writes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">  virtual bool enableWritePrefetching() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">  virtual unsigned getMaxInterleaveFactor(ElementCount VF) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  virtual InstructionCost getArithmeticInstrCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">      ArrayRef<const Value *> Args, const Instruction *CxtI = nullptr) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">  virtual InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">                                         ArrayRef<int> Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="">                                         TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">                                         int Index, VectorType *SubTp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">                                         ArrayRef<const Value *> Args) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">  virtual InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">                                           Type *Src, CastContextHint CCH,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">                                           TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">                                           const Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="">  virtual InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="">                                                   VectorType *VecTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">                                                   unsigned Index) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="">  virtual InstructionCost getCFInstrCost(unsigned Opcode,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="">                                         TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="">                                         const Instruction *I = nullptr) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">  virtual InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="">                                             Type *CondTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="">                                             CmpInst::Predicate VecPred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="">                                             TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">                                             const Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="">  virtual InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="">                                             TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="">                                             unsigned Index, Value *Op0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="">                                             Value *Op1) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="">  virtual InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="">                                             TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="">                                             unsigned Index) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">                            const APInt &DemandedDstElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">                            TTI::TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">                  OperandValueInfo OpInfo, const Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="">  virtual InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">                                            Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="">                                            unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">                                            TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">                                            const Instruction *I) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="">  getMaskedMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">                        unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">                        TTI::TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">                         bool VariableMask, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">                         TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="">                         const Instruction *I = nullptr) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">  virtual InstructionCost getInterleavedMemoryOpCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">      bool UseMaskForCond = false, bool UseMaskForGaps = false) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">                             std::optional<FastMathFlags> FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">                             TTI::TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="">                         TTI::TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">  virtual InstructionCost getExtendedReductionCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">      FastMathFlags FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="">  virtual InstructionCost getMulAccReductionCost(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="">  getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">                        TTI::TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="">  virtual InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="">                                           ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">                                           TTI::TargetCostKind CostKind) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">  virtual unsigned getNumberOfParts(Type *Tp) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">  getAddressComputationCost(Type *Ty, ScalarEvolution *SE, const SCEV *Ptr) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="">  virtual InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="">  getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">  virtual bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="">                                  MemIntrinsicInfo &Info) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">  virtual unsigned getAtomicMemIntrinsicMaxElementSize() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="">  virtual Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">                                                   Type *ExpectedType) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">  virtual Type *getMemcpyLoopLoweringType(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="">      std::optional<uint32_t> AtomicElementSize) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="">  virtual void getMemcpyLoopResidualLoweringType(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">      std::optional<uint32_t> AtomicCpySize) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">  virtual bool areInlineCompatible(const Function *Caller,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">                                   const Function *Callee) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">  virtual bool areTypesABICompatible(const Function *Caller,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">                                     const Function *Callee,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">                                     const ArrayRef<Type *> &Types) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="">  virtual bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">  virtual bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">  virtual unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">  virtual bool isLegalToVectorizeLoad(LoadInst *LI) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">  virtual bool isLegalToVectorizeStore(StoreInst *SI) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">  virtual bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">                                           Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">                                           unsigned AddrSpace) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">  virtual bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">                                            Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="">                                            unsigned AddrSpace) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="">  virtual bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">                                           ElementCount VF) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">  virtual bool isElementTypeLegalForScalableVector(Type *Ty) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">  virtual unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="">                                       unsigned ChainSizeInBytes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="">                                       VectorType *VecTy) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="">  virtual unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="">                                        unsigned ChainSizeInBytes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="">                                        VectorType *VecTy) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">  virtual bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">                                     ReductionFlags) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">  virtual bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="">                                               ReductionFlags) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">  virtual bool preferEpilogueVectorization() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">  virtual bool shouldExpandReduction(const IntrinsicInst *II) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">  virtual unsigned getGISelRematGlobalCost() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">  virtual unsigned getMinTripCountTailFoldingThreshold() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="">  virtual bool enableScalableVectorization() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">  virtual bool supportsScalableVectors() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="">  virtual bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="">                                     Align Alignment) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">  virtual VPLegalization</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">  getVPLegalizationStrategy(const VPIntrinsic &PI) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">  virtual bool hasArmWideBranch(bool Thumb) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">  virtual unsigned getMaxNumArgs() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">class TargetTransformInfo::Model final : public TargetTransformInfo::Concept {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="">  T Impl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="coveredLine">  Model(T Impl) : Impl(std::move(Impl)) {}</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="coveredLine">  ~Model() override = default;</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">  const DataLayout &getDataLayout() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="uncoveredLine">    return Impl.getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="uncoveredLine">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">             ArrayRef<const Value *> Operands, Type *AccessType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">             TargetTransformInfo::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">    return Impl.getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">  InstructionCost getPointersChainCost(ArrayRef<const Value *> Ptrs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="">                                       const Value *Base,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="">                                       const PointersChainInfo &Info,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">                                       Type *AccessTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="">                                       TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">    return Impl.getPointersChainCost(Ptrs, Base, Info, AccessTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">  unsigned getInliningThresholdMultiplier() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">    return Impl.getInliningThresholdMultiplier();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="uncoveredLine">  unsigned adjustInliningThreshold(const CallBase *CB) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="uncoveredLine">    return Impl.adjustInliningThreshold(CB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="uncoveredLine">  int getInlinerVectorBonusPercent() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">    return Impl.getInlinerVectorBonusPercent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="uncoveredLine">  unsigned getCallerAllocaCost(const CallBase *CB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="">                               const AllocaInst *AI) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">    return Impl.getCallerAllocaCost(CB, AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="uncoveredLine">  InstructionCost getMemcpyCost(const Instruction *I) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">    return Impl.getMemcpyCost(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="uncoveredLine">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">    return Impl.getMaxMemIntrinsicInlineSizeThreshold();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="uncoveredLine">  InstructionCost getInstructionCost(const User *U,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="">                                     ArrayRef<const Value *> Operands,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="">                                     TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="uncoveredLine">    return Impl.getInstructionCost(U, Operands, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">  BranchProbability getPredictableBranchThreshold() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">    return Impl.getPredictableBranchThreshold();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="coveredLine">  bool hasBranchDivergence(const Function *F = nullptr) override {</td>
    <td>42</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="coveredLine">    return Impl.hasBranchDivergence(F);</td>
    <td>42</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">  bool isSourceOfDivergence(const Value *V) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">    return Impl.isSourceOfDivergence(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">  bool isAlwaysUniform(const Value *V) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="uncoveredLine">    return Impl.isAlwaysUniform(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">    return Impl.isValidAddrSpaceCast(FromAS, ToAS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">    return Impl.addrspacesMayAlias(AS0, AS1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="uncoveredLine">  unsigned getFlatAddressSpace() override { return Impl.getFlatAddressSpace(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">                                  Intrinsic::ID IID) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="uncoveredLine">    return Impl.collectFlatAddressOperands(OpIndexes, IID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="uncoveredLine">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="uncoveredLine">    return Impl.isNoopAddrSpaceCast(FromAS, ToAS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">  bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="uncoveredLine">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="uncoveredLine">    return Impl.canHaveNonUndefGlobalInitializerInAddressSpace(AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="uncoveredLine">  unsigned getAssumedAddrSpace(const Value *V) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="uncoveredLine">    return Impl.getAssumedAddrSpace(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="uncoveredLine">  bool isSingleThreaded() const override { return Impl.isSingleThreaded(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">  std::pair<const Value *, unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="uncoveredLine">  getPredicatedAddrSpace(const Value *V) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="uncoveredLine">    return Impl.getPredicatedAddrSpace(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="uncoveredLine">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">                                          Value *NewV) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="uncoveredLine">    return Impl.rewriteIntrinsicWithAddressSpace(II, OldV, NewV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="uncoveredLine">  bool isLoweredToCall(const Function *F) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="uncoveredLine">    return Impl.isLoweredToCall(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="uncoveredLine">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">                               UnrollingPreferences &UP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="">                               OptimizationRemarkEmitter *ORE) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="uncoveredLine">    return Impl.getUnrollingPreferences(L, SE, UP, ORE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="uncoveredLine">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="">                             PeelingPreferences &PP) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="uncoveredLine">    return Impl.getPeelingPreferences(L, SE, PP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="uncoveredLine">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="">                                HardwareLoopInfo &HWLoopInfo) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="uncoveredLine">    return Impl.isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="uncoveredLine">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">    return Impl.preferPredicateOverEpilogue(TFI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">  TailFoldingStyle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="uncoveredLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="uncoveredLine">    return Impl.getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="">  std::optional<Instruction *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="uncoveredLine">  instCombineIntrinsic(InstCombiner &IC, IntrinsicInst &II) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">    return Impl.instCombineIntrinsic(IC, II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">  std::optional<Value *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="uncoveredLine">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="">                                   APInt DemandedMask, KnownBits &Known,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">                                   bool &KnownBitsComputed) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">    return Impl.simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">                                                 KnownBitsComputed);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">      APInt &UndefElts2, APInt &UndefElts3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="">          SimplifyAndSetOp) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">    return Impl.simplifyDemandedVectorEltsIntrinsic(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="uncoveredLine">        SimplifyAndSetOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="uncoveredLine">  bool isLegalAddImmediate(int64_t Imm) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="uncoveredLine">    return Impl.isLegalAddImmediate(Imm);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">  bool isLegalICmpImmediate(int64_t Imm) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">    return Impl.isLegalICmpImmediate(Imm);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="uncoveredLine">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="">                             bool HasBaseReg, int64_t Scale, unsigned AddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="">                             Instruction *I) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="uncoveredLine">    return Impl.isLegalAddressingMode(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="uncoveredLine">                                      AddrSpace, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="">                     const TargetTransformInfo::LSRCost &C2) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">    return Impl.isLSRCostLess(C1, C2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="uncoveredLine">  bool isNumRegsMajorCostOfLSR() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="uncoveredLine">    return Impl.isNumRegsMajorCostOfLSR();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="uncoveredLine">  bool isProfitableLSRChainElement(Instruction *I) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">    return Impl.isProfitableLSRChainElement(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="uncoveredLine">  bool canMacroFuseCmp() override { return Impl.canMacroFuseCmp(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="">                  DominatorTree *DT, AssumptionCache *AC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="">                  TargetLibraryInfo *LibInfo) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="uncoveredLine">    return Impl.canSaveCmp(L, BI, SE, LI, DT, AC, LibInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="">  AddressingModeKind</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="uncoveredLine">    getPreferredAddressingMode(const Loop *L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">                               ScalarEvolution *SE) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="uncoveredLine">    return Impl.getPreferredAddressingMode(L, SE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="uncoveredLine">  bool isLegalMaskedStore(Type *DataType, Align Alignment) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="uncoveredLine">    return Impl.isLegalMaskedStore(DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="uncoveredLine">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="uncoveredLine">    return Impl.isLegalMaskedLoad(DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="uncoveredLine">  bool isLegalNTStore(Type *DataType, Align Alignment) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">    return Impl.isLegalNTStore(DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">  bool isLegalNTLoad(Type *DataType, Align Alignment) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="uncoveredLine">    return Impl.isLegalNTLoad(DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="uncoveredLine">  bool isLegalBroadcastLoad(Type *ElementTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">                            ElementCount NumElements) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">    return Impl.isLegalBroadcastLoad(ElementTy, NumElements);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="uncoveredLine">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="uncoveredLine">    return Impl.isLegalMaskedScatter(DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="uncoveredLine">  bool isLegalMaskedGather(Type *DataType, Align Alignment) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="uncoveredLine">    return Impl.isLegalMaskedGather(DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="uncoveredLine">  bool forceScalarizeMaskedGather(VectorType *DataType,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="">                                  Align Alignment) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">    return Impl.forceScalarizeMaskedGather(DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="uncoveredLine">  bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">                                   Align Alignment) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="uncoveredLine">    return Impl.forceScalarizeMaskedScatter(DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="uncoveredLine">  bool isLegalMaskedCompressStore(Type *DataType) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="uncoveredLine">    return Impl.isLegalMaskedCompressStore(DataType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="uncoveredLine">  bool isLegalMaskedExpandLoad(Type *DataType) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="uncoveredLine">    return Impl.isLegalMaskedExpandLoad(DataType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="uncoveredLine">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">                       const SmallBitVector &OpcodeMask) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="uncoveredLine">    return Impl.isLegalAltInstr(VecTy, Opcode0, Opcode1, OpcodeMask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="uncoveredLine">  bool enableOrderedReductions() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="uncoveredLine">    return Impl.enableOrderedReductions();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="uncoveredLine">  bool hasDivRemOp(Type *DataType, bool IsSigned) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="uncoveredLine">    return Impl.hasDivRemOp(DataType, IsSigned);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">    return Impl.hasVolatileVariant(I, AddrSpace);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="uncoveredLine">  bool prefersVectorizedAddressing() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="uncoveredLine">    return Impl.prefersVectorizedAddressing();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="uncoveredLine">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">                                       int64_t Scale,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="">                                       unsigned AddrSpace) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="uncoveredLine">    return Impl.getScalingFactorCost(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="uncoveredLine">                                     AddrSpace);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="uncoveredLine">  bool LSRWithInstrQueries() override { return Impl.LSRWithInstrQueries(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">  bool isTruncateFree(Type *Ty1, Type *Ty2) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="uncoveredLine">    return Impl.isTruncateFree(Ty1, Ty2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">  bool isProfitableToHoist(Instruction *I) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="uncoveredLine">    return Impl.isProfitableToHoist(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="uncoveredLine">  bool useAA() override { return Impl.useAA(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="uncoveredLine">  bool isTypeLegal(Type *Ty) override { return Impl.isTypeLegal(Ty); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="uncoveredLine">  unsigned getRegUsageForType(Type *Ty) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="uncoveredLine">    return Impl.getRegUsageForType(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="uncoveredLine">  bool shouldBuildLookupTables() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="uncoveredLine">    return Impl.shouldBuildLookupTables();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="uncoveredLine">  bool shouldBuildLookupTablesForConstant(Constant *C) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="uncoveredLine">    return Impl.shouldBuildLookupTablesForConstant(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="uncoveredLine">  bool shouldBuildRelLookupTables() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">    return Impl.shouldBuildRelLookupTables();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="uncoveredLine">  bool useColdCCForColdCall(Function &F) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="uncoveredLine">    return Impl.useColdCCForColdCall(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="uncoveredLine">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="">                                           const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="">                                           bool Insert, bool Extract,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="">                                           TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="uncoveredLine">    return Impl.getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="uncoveredLine">                                         CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="">                                   ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">                                   TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="uncoveredLine">    return Impl.getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="uncoveredLine">  bool supportsEfficientVectorElementLoadStore() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="uncoveredLine">    return Impl.supportsEfficientVectorElementLoadStore();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="uncoveredLine">  bool supportsTailCalls() override { return Impl.supportsTailCalls(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="uncoveredLine">  bool supportsTailCallFor(const CallBase *CB) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="uncoveredLine">    return Impl.supportsTailCallFor(CB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="uncoveredLine">  bool enableAggressiveInterleaving(bool LoopHasReductions) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="uncoveredLine">    return Impl.enableAggressiveInterleaving(LoopHasReductions);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="uncoveredLine">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">                                               bool IsZeroCmp) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="uncoveredLine">    return Impl.enableMemCmpExpansion(OptSize, IsZeroCmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="uncoveredLine">  bool enableInterleavedAccessVectorization() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="uncoveredLine">    return Impl.enableInterleavedAccessVectorization();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="uncoveredLine">  bool enableSelectOptimize() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="uncoveredLine">    return Impl.enableSelectOptimize();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="uncoveredLine">  bool enableMaskedInterleavedAccessVectorization() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="uncoveredLine">    return Impl.enableMaskedInterleavedAccessVectorization();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">  bool isFPVectorizationPotentiallyUnsafe() override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="uncoveredLine">    return Impl.isFPVectorizationPotentiallyUnsafe();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="uncoveredLine">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="">                                      unsigned AddressSpace, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="">                                      unsigned *Fast) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="uncoveredLine">    return Impl.allowsMisalignedMemoryAccesses(Context, BitWidth, AddressSpace,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="uncoveredLine">                                               Alignment, Fast);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="uncoveredLine">    return Impl.getPopcntSupport(IntTyWidthInBit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="uncoveredLine">  bool haveFastSqrt(Type *Ty) override { return Impl.haveFastSqrt(Ty); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="uncoveredLine">  bool isExpensiveToSpeculativelyExecute(const Instruction* I) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="uncoveredLine">    return Impl.isExpensiveToSpeculativelyExecute(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="uncoveredLine">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="uncoveredLine">    return Impl.isFCmpOrdCheaperThanFCmpZero(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="uncoveredLine">  InstructionCost getFPOpCost(Type *Ty) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">    return Impl.getFPOpCost(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="">                                        const APInt &Imm, Type *Ty) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">    return Impl.getIntImmCodeSizeCost(Opc, Idx, Imm, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="">                                TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">    return Impl.getIntImmCost(Imm, Ty, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="uncoveredLine">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="">                                    const APInt &Imm, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="">                                    TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">                                    Instruction *Inst = nullptr) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">    return Impl.getIntImmCostInst(Opc, Idx, Imm, Ty, CostKind, Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="uncoveredLine">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">                                      const APInt &Imm, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">                                      TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="uncoveredLine">    return Impl.getIntImmCostIntrin(IID, Idx, Imm, Ty, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="uncoveredLine">  unsigned getNumberOfRegisters(unsigned ClassID) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="uncoveredLine">    return Impl.getNumberOfRegisters(ClassID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">  unsigned getRegisterClassForType(bool Vector,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="">                                   Type *Ty = nullptr) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">    return Impl.getRegisterClassForType(Vector, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="uncoveredLine">  const char *getRegisterClassName(unsigned ClassID) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="uncoveredLine">    return Impl.getRegisterClassName(ClassID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="uncoveredLine">  TypeSize getRegisterBitWidth(RegisterKind K) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="uncoveredLine">    return Impl.getRegisterBitWidth(K);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="uncoveredLine">  unsigned getMinVectorRegisterBitWidth() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="uncoveredLine">    return Impl.getMinVectorRegisterBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="uncoveredLine">  std::optional<unsigned> getMaxVScale() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">    return Impl.getMaxVScale();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="uncoveredLine">  std::optional<unsigned> getVScaleForTuning() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="uncoveredLine">    return Impl.getVScaleForTuning();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">  bool isVScaleKnownToBeAPowerOfTwo() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="uncoveredLine">    return Impl.isVScaleKnownToBeAPowerOfTwo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="uncoveredLine">  bool shouldMaximizeVectorBandwidth(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="">      TargetTransformInfo::RegisterKind K) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="uncoveredLine">    return Impl.shouldMaximizeVectorBandwidth(K);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="uncoveredLine">  ElementCount getMinimumVF(unsigned ElemWidth,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="">                            bool IsScalable) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="uncoveredLine">    return Impl.getMinimumVF(ElemWidth, IsScalable);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="uncoveredLine">    return Impl.getMaximumVF(ElemWidth, Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="uncoveredLine">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="">                             Type *ScalarValTy) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="uncoveredLine">    return Impl.getStoreMinimumVF(VF, ScalarMemTy, ScalarValTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="uncoveredLine">  bool shouldConsiderAddressTypePromotion(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="uncoveredLine">    return Impl.shouldConsiderAddressTypePromotion(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="uncoveredLine">        I, AllowPromotionWithoutCommonHeader);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="uncoveredLine">  unsigned getCacheLineSize() const override { return Impl.getCacheLineSize(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="uncoveredLine">  std::optional<unsigned> getCacheSize(CacheLevel Level) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="uncoveredLine">    return Impl.getCacheSize(Level);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="">  std::optional<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="uncoveredLine">  getCacheAssociativity(CacheLevel Level) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="uncoveredLine">    return Impl.getCacheAssociativity(Level);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="">  /// Return the preferred prefetch distance in terms of instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="uncoveredLine">  unsigned getPrefetchDistance() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="uncoveredLine">    return Impl.getPrefetchDistance();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="">  /// Return the minimum stride necessary to trigger software</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">  /// prefetching.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="uncoveredLine">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">                                unsigned NumStridedMemAccesses,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="">                                unsigned NumPrefetches,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="">                                bool HasCall) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="uncoveredLine">    return Impl.getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="uncoveredLine">                                     NumPrefetches, HasCall);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">  /// Return the maximum prefetch distance in terms of loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="">  /// iterations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="uncoveredLine">  unsigned getMaxPrefetchIterationsAhead() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">    return Impl.getMaxPrefetchIterationsAhead();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="">  /// \return True if prefetching should also be done for writes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="uncoveredLine">  bool enableWritePrefetching() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="uncoveredLine">    return Impl.enableWritePrefetching();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="uncoveredLine">  bool shouldPrefetchAddressSpace(unsigned AS) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="uncoveredLine">    return Impl.shouldPrefetchAddressSpace(AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="uncoveredLine">  unsigned getMaxInterleaveFactor(ElementCount VF) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="uncoveredLine">    return Impl.getMaxInterleaveFactor(VF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="uncoveredLine">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="">                                            unsigned &JTSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="">                                            ProfileSummaryInfo *PSI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="">                                            BlockFrequencyInfo *BFI) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="uncoveredLine">    return Impl.getEstimatedNumberOfCaseClusters(SI, JTSize, PSI, BFI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="uncoveredLine">  InstructionCost getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="">      ArrayRef<const Value *> Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="">      const Instruction *CxtI = nullptr) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="uncoveredLine">    return Impl.getArithmeticInstrCost(Opcode, Ty, CostKind, Opd1Info, Opd2Info,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="uncoveredLine">                                       Args, CxtI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="uncoveredLine">  InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="">                                 ArrayRef<int> Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="">                                 TTI::TargetCostKind CostKind, int Index,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="">                                 VectorType *SubTp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="">                                 ArrayRef<const Value *> Args) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="uncoveredLine">    return Impl.getShuffleCost(Kind, Tp, Mask, CostKind, Index, SubTp, Args);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="uncoveredLine">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">                                   CastContextHint CCH,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="">                                   TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="">                                   const Instruction *I) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="uncoveredLine">    return Impl.getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="uncoveredLine">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="">                                           VectorType *VecTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="">                                           unsigned Index) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="uncoveredLine">    return Impl.getExtractWithExtendCost(Opcode, Dst, VecTy, Index);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="uncoveredLine">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="">                                 const Instruction *I = nullptr) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="uncoveredLine">    return Impl.getCFInstrCost(Opcode, CostKind, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="uncoveredLine">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="">                                     CmpInst::Predicate VecPred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="">                                     TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="">                                     const Instruction *I) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="uncoveredLine">    return Impl.getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="uncoveredLine">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="">                                     TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="">                                     unsigned Index, Value *Op0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="">                                     Value *Op1) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">    return Impl.getVectorInstrCost(Opcode, Val, CostKind, Index, Op0, Op1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="uncoveredLine">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="">                                     TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="">                                     unsigned Index) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="uncoveredLine">    return Impl.getVectorInstrCost(I, Val, CostKind, Index);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="uncoveredLine">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="">                            const APInt &DemandedDstElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="">                            TTI::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="uncoveredLine">    return Impl.getReplicationShuffleCost(EltTy, ReplicationFactor, VF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="uncoveredLine">                                          DemandedDstElts, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="uncoveredLine">  InstructionCost getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="">                                  unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="">                                  TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="">                                  OperandValueInfo OpInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="">                                  const Instruction *I) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="uncoveredLine">    return Impl.getMemoryOpCost(Opcode, Src, Alignment, AddressSpace, CostKind,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="uncoveredLine">                                OpInfo, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="uncoveredLine">  InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="">                                    unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="">                                    TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="">                                    const Instruction *I) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="uncoveredLine">    return Impl.getVPMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="uncoveredLine">                                  CostKind, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="uncoveredLine">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *Src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="">                                        Align Alignment, unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="">                                        TTI::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="uncoveredLine">    return Impl.getMaskedMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="uncoveredLine">                                      CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="">                         bool VariableMask, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="">                         TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="">                         const Instruction *I = nullptr) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="uncoveredLine">    return Impl.getGatherScatterOpCost(Opcode, DataTy, Ptr, VariableMask,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="uncoveredLine">                                       Alignment, CostKind, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="uncoveredLine">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="">      bool UseMaskForCond, bool UseMaskForGaps) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="uncoveredLine">    return Impl.getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="">                                           Alignment, AddressSpace, CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="uncoveredLine">                                           UseMaskForCond, UseMaskForGaps);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="uncoveredLine">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="">                             std::optional<FastMathFlags> FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="">                             TTI::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="uncoveredLine">    return Impl.getArithmeticReductionCost(Opcode, Ty, FMF, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="uncoveredLine">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="">                         TTI::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="uncoveredLine">    return Impl.getMinMaxReductionCost(IID, Ty, FMF, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="uncoveredLine">  getExtendedReductionCost(unsigned Opcode, bool IsUnsigned, Type *ResTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="">                           VectorType *Ty, FastMathFlags FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="">                           TTI::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="uncoveredLine">    return Impl.getExtendedReductionCost(Opcode, IsUnsigned, ResTy, Ty, FMF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="uncoveredLine">                                         CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="uncoveredLine">  getMulAccReductionCost(bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="">                         TTI::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="uncoveredLine">    return Impl.getMulAccReductionCost(IsUnsigned, ResTy, Ty, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="uncoveredLine">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="">                                        TTI::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="uncoveredLine">    return Impl.getIntrinsicInstrCost(ICA, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="uncoveredLine">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="">                                   ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="">                                   TTI::TargetCostKind CostKind) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="uncoveredLine">    return Impl.getCallInstrCost(F, RetTy, Tys, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="uncoveredLine">  unsigned getNumberOfParts(Type *Tp) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="uncoveredLine">    return Impl.getNumberOfParts(Tp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="uncoveredLine">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *SE,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="">                                            const SCEV *Ptr) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="uncoveredLine">    return Impl.getAddressComputationCost(Ty, SE, Ptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="uncoveredLine">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="uncoveredLine">    return Impl.getCostOfKeepingLiveOverCall(Tys);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="uncoveredLine">  bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="">                          MemIntrinsicInfo &Info) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="uncoveredLine">    return Impl.getTgtMemIntrinsic(Inst, Info);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="uncoveredLine">  unsigned getAtomicMemIntrinsicMaxElementSize() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="uncoveredLine">    return Impl.getAtomicMemIntrinsicMaxElementSize();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="uncoveredLine">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="">                                           Type *ExpectedType) override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="uncoveredLine">    return Impl.getOrCreateResultFromMemIntrinsic(Inst, ExpectedType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="uncoveredLine">  Type *getMemcpyLoopLoweringType(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="">      std::optional<uint32_t> AtomicElementSize) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="uncoveredLine">    return Impl.getMemcpyLoopLoweringType(Context, Length, SrcAddrSpace,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="">                                          DestAddrSpace, SrcAlign, DestAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="uncoveredLine">                                          AtomicElementSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="uncoveredLine">  void getMemcpyLoopResidualLoweringType(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="">      std::optional<uint32_t> AtomicCpySize) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="uncoveredLine">    Impl.getMemcpyLoopResidualLoweringType(OpsOut, Context, RemainingBytes,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="">                                           SrcAddrSpace, DestAddrSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="">                                           SrcAlign, DestAlign, AtomicCpySize);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="uncoveredLine">  bool areInlineCompatible(const Function *Caller,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="">                           const Function *Callee) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="uncoveredLine">    return Impl.areInlineCompatible(Caller, Callee);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="uncoveredLine">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="">                             const ArrayRef<Type *> &Types) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="uncoveredLine">    return Impl.areTypesABICompatible(Caller, Callee, Types);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="uncoveredLine">  bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="uncoveredLine">    return Impl.isIndexedLoadLegal(Mode, Ty, getDataLayout());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="uncoveredLine">  bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="uncoveredLine">    return Impl.isIndexedStoreLegal(Mode, Ty, getDataLayout());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="uncoveredLine">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="uncoveredLine">    return Impl.getLoadStoreVecRegBitWidth(AddrSpace);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="uncoveredLine">  bool isLegalToVectorizeLoad(LoadInst *LI) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="uncoveredLine">    return Impl.isLegalToVectorizeLoad(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="uncoveredLine">  bool isLegalToVectorizeStore(StoreInst *SI) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="uncoveredLine">    return Impl.isLegalToVectorizeStore(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="uncoveredLine">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="">                                   unsigned AddrSpace) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="uncoveredLine">    return Impl.isLegalToVectorizeLoadChain(ChainSizeInBytes, Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="uncoveredLine">                                            AddrSpace);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="uncoveredLine">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="">                                    unsigned AddrSpace) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="uncoveredLine">    return Impl.isLegalToVectorizeStoreChain(ChainSizeInBytes, Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="uncoveredLine">                                             AddrSpace);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="uncoveredLine">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="">                                   ElementCount VF) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="uncoveredLine">    return Impl.isLegalToVectorizeReduction(RdxDesc, VF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="uncoveredLine">  bool isElementTypeLegalForScalableVector(Type *Ty) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="uncoveredLine">    return Impl.isElementTypeLegalForScalableVector(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="uncoveredLine">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="">                               unsigned ChainSizeInBytes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="">                               VectorType *VecTy) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="uncoveredLine">    return Impl.getLoadVectorFactor(VF, LoadSize, ChainSizeInBytes, VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="uncoveredLine">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="">                                unsigned ChainSizeInBytes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="">                                VectorType *VecTy) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="uncoveredLine">    return Impl.getStoreVectorFactor(VF, StoreSize, ChainSizeInBytes, VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="uncoveredLine">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="">                             ReductionFlags Flags) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="uncoveredLine">    return Impl.preferInLoopReduction(Opcode, Ty, Flags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="uncoveredLine">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="">                                       ReductionFlags Flags) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="uncoveredLine">    return Impl.preferPredicatedReductionSelect(Opcode, Ty, Flags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="uncoveredLine">  bool preferEpilogueVectorization() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="uncoveredLine">    return Impl.preferEpilogueVectorization();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="uncoveredLine">  bool shouldExpandReduction(const IntrinsicInst *II) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="uncoveredLine">    return Impl.shouldExpandReduction(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="uncoveredLine">  unsigned getGISelRematGlobalCost() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="uncoveredLine">    return Impl.getGISelRematGlobalCost();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="uncoveredLine">  unsigned getMinTripCountTailFoldingThreshold() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="uncoveredLine">    return Impl.getMinTripCountTailFoldingThreshold();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="uncoveredLine">  bool supportsScalableVectors() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="uncoveredLine">    return Impl.supportsScalableVectors();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="uncoveredLine">  bool enableScalableVectorization() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="uncoveredLine">    return Impl.enableScalableVectorization();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="uncoveredLine">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="">                             Align Alignment) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="uncoveredLine">    return Impl.hasActiveVectorLength(Opcode, DataType, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="">  VPLegalization</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="uncoveredLine">  getVPLegalizationStrategy(const VPIntrinsic &PI) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="uncoveredLine">    return Impl.getVPLegalizationStrategy(PI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="uncoveredLine">  bool hasArmWideBranch(bool Thumb) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="uncoveredLine">    return Impl.hasArmWideBranch(Thumb);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="uncoveredLine">  unsigned getMaxNumArgs() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="uncoveredLine">    return Impl.getMaxNumArgs();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="coveredLine">TargetTransformInfo::TargetTransformInfo(T Impl)</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="coveredLine">    : TTIImpl(new Model<T>(Impl)) {}</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="">/// Analysis pass providing the \c TargetTransformInfo.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="">/// The core idea of the TargetIRAnalysis is to expose an interface through</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="">/// which LLVM targets can analyze and provide information about the middle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="">/// end's target-independent IR. This supports use cases such as target-aware</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="">/// cost modeling of IR constructs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="">/// This is a function analysis because much of the cost modeling for targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="">/// is done in a subtarget specific way and LLVM supports compiling different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="">/// functions targeting different subtargets in order to support runtime</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="">/// dispatch according to the observed subtarget.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="">class TargetIRAnalysis : public AnalysisInfoMixin<TargetIRAnalysis> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="">  typedef TargetTransformInfo Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="">  /// Default construct a target IR analysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="">  /// This will use the module's datalayout to construct a baseline</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="">  /// conservative TTI result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="">  TargetIRAnalysis();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="">  /// Construct an IR analysis pass around a target-provide callback.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="">  /// The callback will be called with a particular function for which the TTI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="">  /// is needed and must return a TTI object for that function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="">  TargetIRAnalysis(std::function<Result(const Function &)> TTICallback);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="">  // Value semantics. We spell out the constructors for MSVC.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="">  TargetIRAnalysis(const TargetIRAnalysis &Arg)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="">      : TTICallback(Arg.TTICallback) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="coveredLine">  TargetIRAnalysis(TargetIRAnalysis &&Arg)</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="coveredLine">      : TTICallback(std::move(Arg.TTICallback)) {}</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="">  TargetIRAnalysis &operator=(const TargetIRAnalysis &RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="">    TTICallback = RHS.TTICallback;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="">    return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="">  TargetIRAnalysis &operator=(TargetIRAnalysis &&RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="">    TTICallback = std::move(RHS.TTICallback);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="">    return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="">  Result run(const Function &F, FunctionAnalysisManager &);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="">  friend AnalysisInfoMixin<TargetIRAnalysis>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="">  static AnalysisKey Key;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="">  /// The callback used to produce a result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="">  /// We use a completely opaque callback so that targets can provide whatever</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="">  /// mechanism they desire for constructing the TTI for a given function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="">  /// FIXME: Should we really use std::function? It's relatively inefficient.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="">  /// It might be possible to arrange for even stateful callbacks to outlive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="">  /// the analysis and thus use a function_ref which would be lighter weight.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="">  /// This may also be less error prone as the callback is likely to reference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="">  /// the external TargetMachine, and that reference needs to never dangle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="">  std::function<Result(const Function &)> TTICallback;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="">  /// Helper function used as the callback in the default constructor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="">  static Result getDefaultTTI(const Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="">/// Wrapper pass for TargetTransformInfo.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="">/// This pass can be constructed from a TTI object which it stores internally</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="">/// and is queried by passes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="">class TargetTransformInfoWrapperPass : public ImmutablePass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="">  TargetIRAnalysis TIRA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="">  std::optional<TargetTransformInfo> TTI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="">  virtual void anchor();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="">  /// We must provide a default constructor for the pass but it should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="">  /// never be used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="">  /// Use the constructor below or call one of the creation routines.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="">  TargetTransformInfoWrapperPass();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="">  explicit TargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="">  TargetTransformInfo &getTTI(const Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="">/// Create an analysis pass wrapper around a TTI object.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="">/// This analysis pass just holds the TTI instance and makes it available to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="">/// clients.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="">ImmutablePass *createTargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="">} // namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes5getIDEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes7getInstEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes13getReturnTypeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes8getFlagsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes20getScalarizationCostEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes7getArgsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes11getArgTypesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes15isTypeBasedOnlyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23IntrinsicCostAttributes21skipScalarizationCostEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo17PointersChainInfo10isSameBaseEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo16OperandValueInfo10isConstantEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo24requiresOrderedReductionESt8optionalINS_13FastMathFlagsEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo14VPLegalizationC2ENS1_11VPTransformES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEEC2ES2_</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEED2Ev</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEED0Ev</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE13getDataLayoutEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE10getGEPCostEPNS_4TypeEPKNS_5ValueENS_8ArrayRefIS8_EES5_NS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20getPointersChainCostENS_8ArrayRefIPKNS_5ValueEEES7_RKNS0_17PointersChainInfoEPNS_4TypeENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE30getInliningThresholdMultiplierEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23adjustInliningThresholdEPKNS_8CallBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE28getInlinerVectorBonusPercentEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19getCallerAllocaCostEPKNS_8CallBaseEPKNS_10AllocaInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE13getMemcpyCostEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE37getMaxMemIntrinsicInlineSizeThresholdEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18getInstructionCostEPKNS_4UserENS_8ArrayRefIPKNS_5ValueEEENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE29getPredictableBranchThresholdEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19hasBranchDivergenceEPKNS_8FunctionE</td>
    <td class="numberOfCalls">42</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20isSourceOfDivergenceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE15isAlwaysUniformEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20isValidAddrSpaceCastEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18addrspacesMayAliasEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19getFlatAddressSpaceEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26collectFlatAddressOperandsERNS_15SmallVectorImplIiEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19isNoopAddrSpaceCastEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE46canHaveNonUndefGlobalInitializerInAddressSpaceEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19getAssumedAddrSpaceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE16isSingleThreadedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE22getPredicatedAddrSpaceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE32rewriteIntrinsicWithAddressSpaceEPNS_13IntrinsicInstEPNS_5ValueES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE15isLoweredToCallEPKNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23getUnrollingPreferencesEPNS_4LoopERNS_15ScalarEvolutionERNS0_20UnrollingPreferencesEPNS_25OptimizationRemarkEmitterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21getPeelingPreferencesEPNS_4LoopERNS_15ScalarEvolutionERNS0_18PeelingPreferencesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE24isHardwareLoopProfitableEPNS_4LoopERNS_15ScalarEvolutionERNS_15AssumptionCacheEPNS_17TargetLibraryInfoERNS_16HardwareLoopInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE27preferPredicateOverEpilogueEPNS_15TailFoldingInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE28getPreferredTailFoldingStyleEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20instCombineIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE32simplifyDemandedUseBitsIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstENS_5APIntERNS_9KnownBitsERb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE35simplifyDemandedVectorEltsIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstENS_5APIntERS8_S9_S9_St8functionIFvPNS_11InstructionEjS8_S9_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19isLegalAddImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20isLegalICmpImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21isLegalAddressingModeEPNS_4TypeEPNS_11GlobalValueElbljPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE13isLSRCostLessERKNS0_7LSRCostES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23isNumRegsMajorCostOfLSREv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE27isProfitableLSRChainElementEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE15canMacroFuseCmpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE10canSaveCmpEPNS_4LoopEPPNS_10BranchInstEPNS_15ScalarEvolutionEPNS_8LoopInfoEPNS_13DominatorTreeEPNS_15AssumptionCacheEPNS_17TargetLibraryInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26getPreferredAddressingModeEPKNS_4LoopEPNS_15ScalarEvolutionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18isLegalMaskedStoreEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE17isLegalMaskedLoadEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE14isLegalNTStoreEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE13isLegalNTLoadEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20isLegalBroadcastLoadEPNS_4TypeENS_12ElementCountE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20isLegalMaskedScatterEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19isLegalMaskedGatherEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26forceScalarizeMaskedGatherEPNS_10VectorTypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE27forceScalarizeMaskedScatterEPNS_10VectorTypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26isLegalMaskedCompressStoreEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23isLegalMaskedExpandLoadEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE15isLegalAltInstrEPNS_10VectorTypeEjjRKNS_14SmallBitVectorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23enableOrderedReductionsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE11hasDivRemOpEPNS_4TypeEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18hasVolatileVariantEPNS_11InstructionEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE27prefersVectorizedAddressingEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20getScalingFactorCostEPNS_4TypeEPNS_11GlobalValueElblj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19LSRWithInstrQueriesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE14isTruncateFreeEPNS_4TypeES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19isProfitableToHoistEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE5useAAEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE11isTypeLegalEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18getRegUsageForTypeEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23shouldBuildLookupTablesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE34shouldBuildLookupTablesForConstantEPNS_8ConstantE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26shouldBuildRelLookupTablesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20useColdCCForColdCallERNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE24getScalarizationOverheadEPNS_10VectorTypeERKNS_5APIntEbbNS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE32getOperandsScalarizationOverheadENS_8ArrayRefIPKNS_5ValueEEENS4_IPNS_4TypeEEENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE39supportsEfficientVectorElementLoadStoreEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE17supportsTailCallsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19supportsTailCallForEPKNS_8CallBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE28enableAggressiveInterleavingEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21enableMemCmpExpansionEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE36enableInterleavedAccessVectorizationEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20enableSelectOptimizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE42enableMaskedInterleavedAccessVectorizationEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE34isFPVectorizationPotentiallyUnsafeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE30allowsMisalignedMemoryAccessesERNS_11LLVMContextEjjNS_5AlignEPj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE16getPopcntSupportEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE12haveFastSqrtEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE33isExpensiveToSpeculativelyExecuteEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE28isFCmpOrdCheaperThanFCmpZeroEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE11getFPOpCostEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21getIntImmCodeSizeCostEjjRKNS_5APIntEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE13getIntImmCostERKNS_5APIntEPNS_4TypeENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE17getIntImmCostInstEjjRKNS_5APIntEPNS_4TypeENS0_14TargetCostKindEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19getIntImmCostIntrinEjjRKNS_5APIntEPNS_4TypeENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20getNumberOfRegistersEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23getRegisterClassForTypeEbPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20getRegisterClassNameEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19getRegisterBitWidthENS0_12RegisterKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE28getMinVectorRegisterBitWidthEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE12getMaxVScaleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18getVScaleForTuningEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE28isVScaleKnownToBeAPowerOfTwoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE29shouldMaximizeVectorBandwidthENS0_12RegisterKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE12getMinimumVFEjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE12getMaximumVFEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE17getStoreMinimumVFEjPNS_4TypeES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE34shouldConsiderAddressTypePromotionERKNS_11InstructionERb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE16getCacheLineSizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE12getCacheSizeENS0_10CacheLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21getCacheAssociativityENS0_10CacheLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19getPrefetchDistanceEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20getMinPrefetchStrideEjjjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE29getMaxPrefetchIterationsAheadEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE22enableWritePrefetchingEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26shouldPrefetchAddressSpaceEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE22getMaxInterleaveFactorENS_12ElementCountE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE32getEstimatedNumberOfCaseClustersERKNS_10SwitchInstERjPNS_18ProfileSummaryInfoEPNS_18BlockFrequencyInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE22getArithmeticInstrCostEjPNS_4TypeENS0_14TargetCostKindENS0_16OperandValueInfoES7_NS_8ArrayRefIPKNS_5ValueEEEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE14getShuffleCostENS0_11ShuffleKindEPNS_10VectorTypeENS_8ArrayRefIiEENS0_14TargetCostKindEiS6_NS7_IPKNS_5ValueEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE16getCastInstrCostEjPNS_4TypeES5_NS0_15CastContextHintENS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE24getExtractWithExtendCostEjPNS_4TypeEPNS_10VectorTypeEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE14getCFInstrCostEjNS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18getCmpSelInstrCostEjPNS_4TypeES5_NS_7CmpInst9PredicateENS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18getVectorInstrCostEjPNS_4TypeENS0_14TargetCostKindEjPNS_5ValueES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18getVectorInstrCostERKNS_11InstructionEPNS_4TypeENS0_14TargetCostKindEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE25getReplicationShuffleCostEPNS_4TypeEiiRKNS_5APIntENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE15getMemoryOpCostEjPNS_4TypeENS_5AlignEjNS0_14TargetCostKindENS0_16OperandValueInfoEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE17getVPMemoryOpCostEjPNS_4TypeENS_5AlignEjNS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21getMaskedMemoryOpCostEjPNS_4TypeENS_5AlignEjNS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE22getGatherScatterOpCostEjPNS_4TypeEPKNS_5ValueEbNS_5AlignENS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26getInterleavedMemoryOpCostEjPNS_4TypeEjNS_8ArrayRefIjEENS_5AlignEjNS0_14TargetCostKindEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26getArithmeticReductionCostEjPNS_10VectorTypeESt8optionalINS_13FastMathFlagsEENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE22getMinMaxReductionCostEjPNS_10VectorTypeENS_13FastMathFlagsENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE24getExtendedReductionCostEjbPNS_4TypeEPNS_10VectorTypeENS_13FastMathFlagsENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE22getMulAccReductionCostEbPNS_4TypeEPNS_10VectorTypeENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21getIntrinsicInstrCostERKNS_23IntrinsicCostAttributesENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE16getCallInstrCostEPNS_8FunctionEPNS_4TypeENS_8ArrayRefIS7_EENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE16getNumberOfPartsEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE25getAddressComputationCostEPNS_4TypeEPNS_15ScalarEvolutionEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE28getCostOfKeepingLiveOverCallENS_8ArrayRefIPNS_4TypeEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18getTgtMemIntrinsicEPNS_13IntrinsicInstERNS_16MemIntrinsicInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE35getAtomicMemIntrinsicMaxElementSizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE33getOrCreateResultFromMemIntrinsicEPNS_13IntrinsicInstEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE25getMemcpyLoopLoweringTypeERNS_11LLVMContextEPNS_5ValueEjjjjSt8optionalIjE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE33getMemcpyLoopResidualLoweringTypeERNS_15SmallVectorImplIPNS_4TypeEEERNS_11LLVMContextEjjjjjSt8optionalIjE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19areInlineCompatibleEPKNS_8FunctionES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21areTypesABICompatibleEPKNS_8FunctionES6_RKNS_8ArrayRefIPNS_4TypeEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE18isIndexedLoadLegalENS0_14MemIndexedModeEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19isIndexedStoreLegalENS0_14MemIndexedModeEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE26getLoadStoreVecRegBitWidthEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE22isLegalToVectorizeLoadEPNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23isLegalToVectorizeStoreEPNS_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE27isLegalToVectorizeLoadChainEjNS_5AlignEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE28isLegalToVectorizeStoreChainEjNS_5AlignEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE27isLegalToVectorizeReductionERKNS_20RecurrenceDescriptorENS_12ElementCountE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE35isElementTypeLegalForScalableVectorEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE19getLoadVectorFactorEjjjPNS_10VectorTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE20getStoreVectorFactorEjjjPNS_10VectorTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21preferInLoopReductionEjPNS_4TypeENS0_14ReductionFlagsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE31preferPredicatedReductionSelectEjPNS_4TypeENS0_14ReductionFlagsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE27preferEpilogueVectorizationEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21shouldExpandReductionEPKNS_13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23getGISelRematGlobalCostEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE35getMinTripCountTailFoldingThresholdEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE23supportsScalableVectorsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE27enableScalableVectorizationEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE21hasActiveVectorLengthEjPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE25getVPLegalizationStrategyERKNS_11VPIntrinsicE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE16hasArmWideBranchEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelINS_11MipsTTIImplEE13getMaxNumArgsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfoC2INS_11MipsTTIImplEEET_</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEEC2ES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEED2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEED0Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE13getDataLayoutEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE10getGEPCostEPNS_4TypeEPKNS_5ValueENS_8ArrayRefIS9_EES6_NS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20getPointersChainCostENS_8ArrayRefIPKNS_5ValueEEES8_RKNS0_17PointersChainInfoEPNS_4TypeENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE30getInliningThresholdMultiplierEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23adjustInliningThresholdEPKNS_8CallBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE28getInlinerVectorBonusPercentEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19getCallerAllocaCostEPKNS_8CallBaseEPKNS_10AllocaInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE13getMemcpyCostEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE37getMaxMemIntrinsicInlineSizeThresholdEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18getInstructionCostEPKNS_4UserENS_8ArrayRefIPKNS_5ValueEEENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE29getPredictableBranchThresholdEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19hasBranchDivergenceEPKNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20isSourceOfDivergenceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE15isAlwaysUniformEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20isValidAddrSpaceCastEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18addrspacesMayAliasEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19getFlatAddressSpaceEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26collectFlatAddressOperandsERNS_15SmallVectorImplIiEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19isNoopAddrSpaceCastEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE46canHaveNonUndefGlobalInitializerInAddressSpaceEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19getAssumedAddrSpaceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE16isSingleThreadedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE22getPredicatedAddrSpaceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE32rewriteIntrinsicWithAddressSpaceEPNS_13IntrinsicInstEPNS_5ValueES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE15isLoweredToCallEPKNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23getUnrollingPreferencesEPNS_4LoopERNS_15ScalarEvolutionERNS0_20UnrollingPreferencesEPNS_25OptimizationRemarkEmitterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21getPeelingPreferencesEPNS_4LoopERNS_15ScalarEvolutionERNS0_18PeelingPreferencesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE24isHardwareLoopProfitableEPNS_4LoopERNS_15ScalarEvolutionERNS_15AssumptionCacheEPNS_17TargetLibraryInfoERNS_16HardwareLoopInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE27preferPredicateOverEpilogueEPNS_15TailFoldingInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE28getPreferredTailFoldingStyleEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20instCombineIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE32simplifyDemandedUseBitsIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstENS_5APIntERNS_9KnownBitsERb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE35simplifyDemandedVectorEltsIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstENS_5APIntERS9_SA_SA_St8functionIFvPNS_11InstructionEjS9_SA_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19isLegalAddImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20isLegalICmpImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21isLegalAddressingModeEPNS_4TypeEPNS_11GlobalValueElbljPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE13isLSRCostLessERKNS0_7LSRCostES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23isNumRegsMajorCostOfLSREv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE27isProfitableLSRChainElementEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE15canMacroFuseCmpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE10canSaveCmpEPNS_4LoopEPPNS_10BranchInstEPNS_15ScalarEvolutionEPNS_8LoopInfoEPNS_13DominatorTreeEPNS_15AssumptionCacheEPNS_17TargetLibraryInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26getPreferredAddressingModeEPKNS_4LoopEPNS_15ScalarEvolutionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18isLegalMaskedStoreEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE17isLegalMaskedLoadEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE14isLegalNTStoreEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE13isLegalNTLoadEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20isLegalBroadcastLoadEPNS_4TypeENS_12ElementCountE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20isLegalMaskedScatterEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19isLegalMaskedGatherEPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26forceScalarizeMaskedGatherEPNS_10VectorTypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE27forceScalarizeMaskedScatterEPNS_10VectorTypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26isLegalMaskedCompressStoreEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23isLegalMaskedExpandLoadEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE15isLegalAltInstrEPNS_10VectorTypeEjjRKNS_14SmallBitVectorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23enableOrderedReductionsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE11hasDivRemOpEPNS_4TypeEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18hasVolatileVariantEPNS_11InstructionEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE27prefersVectorizedAddressingEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20getScalingFactorCostEPNS_4TypeEPNS_11GlobalValueElblj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19LSRWithInstrQueriesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE14isTruncateFreeEPNS_4TypeES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19isProfitableToHoistEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE5useAAEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE11isTypeLegalEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18getRegUsageForTypeEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23shouldBuildLookupTablesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE34shouldBuildLookupTablesForConstantEPNS_8ConstantE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26shouldBuildRelLookupTablesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20useColdCCForColdCallERNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE24getScalarizationOverheadEPNS_10VectorTypeERKNS_5APIntEbbNS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE32getOperandsScalarizationOverheadENS_8ArrayRefIPKNS_5ValueEEENS5_IPNS_4TypeEEENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE39supportsEfficientVectorElementLoadStoreEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE17supportsTailCallsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19supportsTailCallForEPKNS_8CallBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE28enableAggressiveInterleavingEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21enableMemCmpExpansionEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE36enableInterleavedAccessVectorizationEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20enableSelectOptimizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE42enableMaskedInterleavedAccessVectorizationEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE34isFPVectorizationPotentiallyUnsafeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE30allowsMisalignedMemoryAccessesERNS_11LLVMContextEjjNS_5AlignEPj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE16getPopcntSupportEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE12haveFastSqrtEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE33isExpensiveToSpeculativelyExecuteEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE28isFCmpOrdCheaperThanFCmpZeroEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE11getFPOpCostEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21getIntImmCodeSizeCostEjjRKNS_5APIntEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE13getIntImmCostERKNS_5APIntEPNS_4TypeENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE17getIntImmCostInstEjjRKNS_5APIntEPNS_4TypeENS0_14TargetCostKindEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19getIntImmCostIntrinEjjRKNS_5APIntEPNS_4TypeENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20getNumberOfRegistersEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23getRegisterClassForTypeEbPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20getRegisterClassNameEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19getRegisterBitWidthENS0_12RegisterKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE28getMinVectorRegisterBitWidthEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE12getMaxVScaleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18getVScaleForTuningEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE28isVScaleKnownToBeAPowerOfTwoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE29shouldMaximizeVectorBandwidthENS0_12RegisterKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE12getMinimumVFEjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE12getMaximumVFEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE17getStoreMinimumVFEjPNS_4TypeES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE34shouldConsiderAddressTypePromotionERKNS_11InstructionERb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE16getCacheLineSizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE12getCacheSizeENS0_10CacheLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21getCacheAssociativityENS0_10CacheLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19getPrefetchDistanceEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20getMinPrefetchStrideEjjjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE29getMaxPrefetchIterationsAheadEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE22enableWritePrefetchingEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26shouldPrefetchAddressSpaceEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE22getMaxInterleaveFactorENS_12ElementCountE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE32getEstimatedNumberOfCaseClustersERKNS_10SwitchInstERjPNS_18ProfileSummaryInfoEPNS_18BlockFrequencyInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE22getArithmeticInstrCostEjPNS_4TypeENS0_14TargetCostKindENS0_16OperandValueInfoES8_NS_8ArrayRefIPKNS_5ValueEEEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE14getShuffleCostENS0_11ShuffleKindEPNS_10VectorTypeENS_8ArrayRefIiEENS0_14TargetCostKindEiS7_NS8_IPKNS_5ValueEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE16getCastInstrCostEjPNS_4TypeES6_NS0_15CastContextHintENS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE24getExtractWithExtendCostEjPNS_4TypeEPNS_10VectorTypeEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE14getCFInstrCostEjNS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18getCmpSelInstrCostEjPNS_4TypeES6_NS_7CmpInst9PredicateENS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18getVectorInstrCostEjPNS_4TypeENS0_14TargetCostKindEjPNS_5ValueES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18getVectorInstrCostERKNS_11InstructionEPNS_4TypeENS0_14TargetCostKindEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE25getReplicationShuffleCostEPNS_4TypeEiiRKNS_5APIntENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE15getMemoryOpCostEjPNS_4TypeENS_5AlignEjNS0_14TargetCostKindENS0_16OperandValueInfoEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE17getVPMemoryOpCostEjPNS_4TypeENS_5AlignEjNS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21getMaskedMemoryOpCostEjPNS_4TypeENS_5AlignEjNS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE22getGatherScatterOpCostEjPNS_4TypeEPKNS_5ValueEbNS_5AlignENS0_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26getInterleavedMemoryOpCostEjPNS_4TypeEjNS_8ArrayRefIjEENS_5AlignEjNS0_14TargetCostKindEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26getArithmeticReductionCostEjPNS_10VectorTypeESt8optionalINS_13FastMathFlagsEENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE22getMinMaxReductionCostEjPNS_10VectorTypeENS_13FastMathFlagsENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE24getExtendedReductionCostEjbPNS_4TypeEPNS_10VectorTypeENS_13FastMathFlagsENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE22getMulAccReductionCostEbPNS_4TypeEPNS_10VectorTypeENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21getIntrinsicInstrCostERKNS_23IntrinsicCostAttributesENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE16getCallInstrCostEPNS_8FunctionEPNS_4TypeENS_8ArrayRefIS8_EENS0_14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE16getNumberOfPartsEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE25getAddressComputationCostEPNS_4TypeEPNS_15ScalarEvolutionEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE28getCostOfKeepingLiveOverCallENS_8ArrayRefIPNS_4TypeEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18getTgtMemIntrinsicEPNS_13IntrinsicInstERNS_16MemIntrinsicInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE35getAtomicMemIntrinsicMaxElementSizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE33getOrCreateResultFromMemIntrinsicEPNS_13IntrinsicInstEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE25getMemcpyLoopLoweringTypeERNS_11LLVMContextEPNS_5ValueEjjjjSt8optionalIjE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE33getMemcpyLoopResidualLoweringTypeERNS_15SmallVectorImplIPNS_4TypeEEERNS_11LLVMContextEjjjjjSt8optionalIjE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19areInlineCompatibleEPKNS_8FunctionES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21areTypesABICompatibleEPKNS_8FunctionES7_RKNS_8ArrayRefIPNS_4TypeEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE18isIndexedLoadLegalENS0_14MemIndexedModeEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19isIndexedStoreLegalENS0_14MemIndexedModeEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE26getLoadStoreVecRegBitWidthEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE22isLegalToVectorizeLoadEPNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23isLegalToVectorizeStoreEPNS_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE27isLegalToVectorizeLoadChainEjNS_5AlignEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE28isLegalToVectorizeStoreChainEjNS_5AlignEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE27isLegalToVectorizeReductionERKNS_20RecurrenceDescriptorENS_12ElementCountE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE35isElementTypeLegalForScalableVectorEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE19getLoadVectorFactorEjjjPNS_10VectorTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE20getStoreVectorFactorEjjjPNS_10VectorTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21preferInLoopReductionEjPNS_4TypeENS0_14ReductionFlagsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE31preferPredicatedReductionSelectEjPNS_4TypeENS0_14ReductionFlagsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE27preferEpilogueVectorizationEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21shouldExpandReductionEPKNS_13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23getGISelRematGlobalCostEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE35getMinTripCountTailFoldingThresholdEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE23supportsScalableVectorsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE27enableScalableVectorizationEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE21hasActiveVectorLengthEjPNS_4TypeENS_5AlignE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE25getVPLegalizationStrategyERKNS_11VPIntrinsicE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE16hasArmWideBranchEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm19TargetTransformInfo5ModelIN12_GLOBAL__N_19NoTTIImplEE13getMaxNumArgsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16TargetIRAnalysisC2EOS0_</td>
    <td class="numberOfCalls">4</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// This pass exposes codegen information to IR-level passes. Every</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// This pass exposes codegen information to IR-level passes. Every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// transformation that uses codegen information is broken into three parts:</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// transformation that uses codegen information is broken into three parts:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// 1. The IR-level analysis pass.</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// 1. The IR-level analysis pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">/// 2. The IR-level transformation interface which provides the needed</td>
    <td class="lineNumber">12</td>
    <td class="codeline">/// 2. The IR-level transformation interface which provides the needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">///    information.</td>
    <td class="lineNumber">13</td>
    <td class="codeline">///    information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">/// 3. Codegen-level implementation which uses target-specific hooks.</td>
    <td class="lineNumber">14</td>
    <td class="codeline">/// 3. Codegen-level implementation which uses target-specific hooks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">///</td>
    <td class="lineNumber">15</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">/// This file defines #2, which is the interface that IR-level transformations</td>
    <td class="lineNumber">16</td>
    <td class="codeline">/// This file defines #2, which is the interface that IR-level transformations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">/// use for querying the codegen.</td>
    <td class="lineNumber">17</td>
    <td class="codeline">/// use for querying the codegen.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">///</td>
    <td class="lineNumber">18</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">19</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline"></td>
    <td class="lineNumber">20</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#ifndef LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#ifndef LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#define LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#define LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline"></td>
    <td class="lineNumber">23</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/SmallBitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/IR/FMF.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/IR/FMF.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/Support/AtomicOrdering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/Support/BranchProbability.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Support/InstructionCost.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Support/InstructionCost.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include <functional></td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include <functional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline"></td>
    <td class="lineNumber">35</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">36</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline"></td>
    <td class="lineNumber">37</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">namespace Intrinsic {</td>
    <td class="lineNumber">38</td>
    <td class="codeline">namespace Intrinsic {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">typedef unsigned ID;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">typedef unsigned ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">}</td>
    <td class="lineNumber">40</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">class AllocaInst;</td>
    <td class="lineNumber">42</td>
    <td class="codeline">class AllocaInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">class AssumptionCache;</td>
    <td class="lineNumber">43</td>
    <td class="codeline">class AssumptionCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">class BlockFrequencyInfo;</td>
    <td class="lineNumber">44</td>
    <td class="codeline">class BlockFrequencyInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">class DominatorTree;</td>
    <td class="lineNumber">45</td>
    <td class="codeline">class DominatorTree;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">class BranchInst;</td>
    <td class="lineNumber">46</td>
    <td class="codeline">class BranchInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">class CallBase;</td>
    <td class="lineNumber">47</td>
    <td class="codeline">class CallBase;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">class Function;</td>
    <td class="lineNumber">48</td>
    <td class="codeline">class Function;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">class GlobalValue;</td>
    <td class="lineNumber">49</td>
    <td class="codeline">class GlobalValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">class InstCombiner;</td>
    <td class="lineNumber">50</td>
    <td class="codeline">class InstCombiner;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">class OptimizationRemarkEmitter;</td>
    <td class="lineNumber">51</td>
    <td class="codeline">class OptimizationRemarkEmitter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">class InterleavedAccessInfo;</td>
    <td class="lineNumber">52</td>
    <td class="codeline">class InterleavedAccessInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">class IntrinsicInst;</td>
    <td class="lineNumber">53</td>
    <td class="codeline">class IntrinsicInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">class LoadInst;</td>
    <td class="lineNumber">54</td>
    <td class="codeline">class LoadInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">class Loop;</td>
    <td class="lineNumber">55</td>
    <td class="codeline">class Loop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">class LoopInfo;</td>
    <td class="lineNumber">56</td>
    <td class="codeline">class LoopInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">class LoopVectorizationLegality;</td>
    <td class="lineNumber">57</td>
    <td class="codeline">class LoopVectorizationLegality;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">class ProfileSummaryInfo;</td>
    <td class="lineNumber">58</td>
    <td class="codeline">class ProfileSummaryInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">class RecurrenceDescriptor;</td>
    <td class="lineNumber">59</td>
    <td class="codeline">class RecurrenceDescriptor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">class SCEV;</td>
    <td class="lineNumber">60</td>
    <td class="codeline">class SCEV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">class ScalarEvolution;</td>
    <td class="lineNumber">61</td>
    <td class="codeline">class ScalarEvolution;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">class StoreInst;</td>
    <td class="lineNumber">62</td>
    <td class="codeline">class StoreInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">class SwitchInst;</td>
    <td class="lineNumber">63</td>
    <td class="codeline">class SwitchInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">class TargetLibraryInfo;</td>
    <td class="lineNumber">64</td>
    <td class="codeline">class TargetLibraryInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">class Type;</td>
    <td class="lineNumber">65</td>
    <td class="codeline">class Type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">class User;</td>
    <td class="lineNumber">66</td>
    <td class="codeline">class User;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">class Value;</td>
    <td class="lineNumber">67</td>
    <td class="codeline">class Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">class VPIntrinsic;</td>
    <td class="lineNumber">68</td>
    <td class="codeline">class VPIntrinsic;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">struct KnownBits;</td>
    <td class="lineNumber">69</td>
    <td class="codeline">struct KnownBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline"></td>
    <td class="lineNumber">70</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">/// Information about a load/store intrinsic defined by the target.</td>
    <td class="lineNumber">71</td>
    <td class="codeline">/// Information about a load/store intrinsic defined by the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">struct MemIntrinsicInfo {</td>
    <td class="lineNumber">72</td>
    <td class="codeline">struct MemIntrinsicInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">  /// This is the pointer that the intrinsic is loading from or storing to.</td>
    <td class="lineNumber">73</td>
    <td class="codeline">  /// This is the pointer that the intrinsic is loading from or storing to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">  /// If this is non-null, then analysis/optimization passes can assume that</td>
    <td class="lineNumber">74</td>
    <td class="codeline">  /// If this is non-null, then analysis/optimization passes can assume that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">  /// this intrinsic is functionally equivalent to a load/store from this</td>
    <td class="lineNumber">75</td>
    <td class="codeline">  /// this intrinsic is functionally equivalent to a load/store from this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">  /// pointer.</td>
    <td class="lineNumber">76</td>
    <td class="codeline">  /// pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">  Value *PtrVal = nullptr;</td>
    <td class="lineNumber">77</td>
    <td class="codeline">  Value *PtrVal = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline"></td>
    <td class="lineNumber">78</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  // Ordering for atomic operations.</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  // Ordering for atomic operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  // Same Id is set by the target for corresponding load/store intrinsics.</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  // Same Id is set by the target for corresponding load/store intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  unsigned short MatchingId = 0;</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  unsigned short MatchingId = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline"></td>
    <td class="lineNumber">84</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  bool ReadMem = false;</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  bool ReadMem = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  bool WriteMem = false;</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  bool WriteMem = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  bool IsVolatile = false;</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  bool IsVolatile = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  bool isUnordered() const {</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  bool isUnordered() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">    return (Ordering == AtomicOrdering::NotAtomic ||</td>
    <td class="lineNumber">90</td>
    <td class="codeline">    return (Ordering == AtomicOrdering::NotAtomic ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">            Ordering == AtomicOrdering::Unordered) &&</td>
    <td class="lineNumber">91</td>
    <td class="codeline">            Ordering == AtomicOrdering::Unordered) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">           !IsVolatile;</td>
    <td class="lineNumber">92</td>
    <td class="codeline">           !IsVolatile;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">};</td>
    <td class="lineNumber">94</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline"></td>
    <td class="lineNumber">95</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">/// Attributes of a target dependent hardware loop.</td>
    <td class="lineNumber">96</td>
    <td class="codeline">/// Attributes of a target dependent hardware loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">struct HardwareLoopInfo {</td>
    <td class="lineNumber">97</td>
    <td class="codeline">struct HardwareLoopInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  HardwareLoopInfo() = delete;</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  HardwareLoopInfo() = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  HardwareLoopInfo(Loop *L);</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  HardwareLoopInfo(Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  Loop *L = nullptr;</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  Loop *L = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  BasicBlock *ExitBlock = nullptr;</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  BasicBlock *ExitBlock = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  BranchInst *ExitBranch = nullptr;</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  BranchInst *ExitBranch = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  const SCEV *ExitCount = nullptr;</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  const SCEV *ExitCount = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  IntegerType *CountType = nullptr;</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  IntegerType *CountType = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  Value *LoopDecrement = nullptr; // Decrement the loop counter by this</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  Value *LoopDecrement = nullptr; // Decrement the loop counter by this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">                                  // value in every iteration.</td>
    <td class="lineNumber">106</td>
    <td class="codeline">                                  // value in every iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  bool IsNestingLegal = false;    // Can a hardware loop be a parent to</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  bool IsNestingLegal = false;    // Can a hardware loop be a parent to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">                                  // another hardware loop?</td>
    <td class="lineNumber">108</td>
    <td class="codeline">                                  // another hardware loop?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  bool CounterInReg = false;      // Should loop counter be updated in</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  bool CounterInReg = false;      // Should loop counter be updated in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">                                  // the loop via a phi?</td>
    <td class="lineNumber">110</td>
    <td class="codeline">                                  // the loop via a phi?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  bool PerformEntryTest = false;  // Generate the intrinsic which also performs</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  bool PerformEntryTest = false;  // Generate the intrinsic which also performs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">                                  // icmp ne zero on the loop counter value and</td>
    <td class="lineNumber">112</td>
    <td class="codeline">                                  // icmp ne zero on the loop counter value and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">                                  // produces an i1 to guard the loop entry.</td>
    <td class="lineNumber">113</td>
    <td class="codeline">                                  // produces an i1 to guard the loop entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  bool isHardwareLoopCandidate(ScalarEvolution &SE, LoopInfo &LI,</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  bool isHardwareLoopCandidate(ScalarEvolution &SE, LoopInfo &LI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">                               DominatorTree &DT, bool ForceNestedLoop = false,</td>
    <td class="lineNumber">115</td>
    <td class="codeline">                               DominatorTree &DT, bool ForceNestedLoop = false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">                               bool ForceHardwareLoopPHI = false);</td>
    <td class="lineNumber">116</td>
    <td class="codeline">                               bool ForceHardwareLoopPHI = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  bool canAnalyze(LoopInfo &LI);</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  bool canAnalyze(LoopInfo &LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">};</td>
    <td class="lineNumber">118</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">class IntrinsicCostAttributes {</td>
    <td class="lineNumber">120</td>
    <td class="codeline">class IntrinsicCostAttributes {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  const IntrinsicInst *II = nullptr;</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  const IntrinsicInst *II = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  Type *RetTy = nullptr;</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  Type *RetTy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  Intrinsic::ID IID;</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  Intrinsic::ID IID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  SmallVector<Type *, 4> ParamTys;</td>
    <td class="lineNumber">124</td>
    <td class="codeline">  SmallVector<Type *, 4> ParamTys;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  SmallVector<const Value *, 4> Arguments;</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  SmallVector<const Value *, 4> Arguments;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  FastMathFlags FMF;</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  FastMathFlags FMF;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  // If ScalarizationCost is UINT_MAX, the cost of scalarizing the</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  // If ScalarizationCost is UINT_MAX, the cost of scalarizing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  // arguments and the return value will be computed based on types.</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  // arguments and the return value will be computed based on types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">131</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  IntrinsicCostAttributes(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">      Intrinsic::ID Id, const CallBase &CI,</td>
    <td class="lineNumber">133</td>
    <td class="codeline">      Intrinsic::ID Id, const CallBase &CI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">      InstructionCost ScalarCost = InstructionCost::getInvalid(),</td>
    <td class="lineNumber">134</td>
    <td class="codeline">      InstructionCost ScalarCost = InstructionCost::getInvalid(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">      bool TypeBasedOnly = false);</td>
    <td class="lineNumber">135</td>
    <td class="codeline">      bool TypeBasedOnly = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">137</td>
    <td class="codeline">  IntrinsicCostAttributes(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">      Intrinsic::ID Id, Type *RTy, ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">138</td>
    <td class="codeline">      Intrinsic::ID Id, Type *RTy, ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">      FastMathFlags Flags = FastMathFlags(), const IntrinsicInst *I = nullptr,</td>
    <td class="lineNumber">139</td>
    <td class="codeline">      FastMathFlags Flags = FastMathFlags(), const IntrinsicInst *I = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
    <td class="lineNumber">140</td>
    <td class="codeline">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline"></td>
    <td class="lineNumber">141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  IntrinsicCostAttributes(Intrinsic::ID Id, Type *RTy,</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  IntrinsicCostAttributes(Intrinsic::ID Id, Type *RTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">                          ArrayRef<const Value *> Args);</td>
    <td class="lineNumber">143</td>
    <td class="codeline">                          ArrayRef<const Value *> Args);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  IntrinsicCostAttributes(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">      Intrinsic::ID Id, Type *RTy, ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">146</td>
    <td class="codeline">      Intrinsic::ID Id, Type *RTy, ArrayRef<const Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">      ArrayRef<Type *> Tys, FastMathFlags Flags = FastMathFlags(),</td>
    <td class="lineNumber">147</td>
    <td class="codeline">      ArrayRef<Type *> Tys, FastMathFlags Flags = FastMathFlags(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">      const IntrinsicInst *I = nullptr,</td>
    <td class="lineNumber">148</td>
    <td class="codeline">      const IntrinsicInst *I = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
    <td class="lineNumber">149</td>
    <td class="codeline">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
    <td class="lineNumber">150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">  Intrinsic::ID getID() const { return IID; }</td>
    <td class="lineNumber">151</td>
    <td class="codeline">  Intrinsic::ID getID() const { return IID; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  const IntrinsicInst *getInst() const { return II; }</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  const IntrinsicInst *getInst() const { return II; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  Type *getReturnType() const { return RetTy; }</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  Type *getReturnType() const { return RetTy; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  FastMathFlags getFlags() const { return FMF; }</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  FastMathFlags getFlags() const { return FMF; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  InstructionCost getScalarizationCost() const { return ScalarizationCost; }</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  InstructionCost getScalarizationCost() const { return ScalarizationCost; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  const SmallVectorImpl<const Value *> &getArgs() const { return Arguments; }</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  const SmallVectorImpl<const Value *> &getArgs() const { return Arguments; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  const SmallVectorImpl<Type *> &getArgTypes() const { return ParamTys; }</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  const SmallVectorImpl<Type *> &getArgTypes() const { return ParamTys; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  bool isTypeBasedOnly() const {</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  bool isTypeBasedOnly() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">    return Arguments.empty();</td>
    <td class="lineNumber">160</td>
    <td class="codeline">    return Arguments.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  bool skipScalarizationCost() const { return ScalarizationCost.isValid(); }</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  bool skipScalarizationCost() const { return ScalarizationCost.isValid(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">};</td>
    <td class="lineNumber">164</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">enum class TailFoldingStyle {</td>
    <td class="lineNumber">166</td>
    <td class="codeline">enum class TailFoldingStyle {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  /// Don't use tail folding</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  /// Don't use tail folding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  None,</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  None,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  /// Use predicate only to mask operations on data in the loop.</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  /// Use predicate only to mask operations on data in the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  /// When the VL is not known to be a power-of-2, this method requires a</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  /// When the VL is not known to be a power-of-2, this method requires a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  /// runtime overflow check for the i + VL in the loop because it compares the</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  /// runtime overflow check for the i + VL in the loop because it compares the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  /// scalar induction variable against the tripcount rounded up by VL which may</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  /// scalar induction variable against the tripcount rounded up by VL which may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  /// overflow. When the VL is a power-of-2, both the increment and uprounded</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  /// overflow. When the VL is a power-of-2, both the increment and uprounded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  /// tripcount will overflow to 0, which does not require a runtime check</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  /// tripcount will overflow to 0, which does not require a runtime check</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  /// since the loop is exited when the loop induction variable equals the</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  /// since the loop is exited when the loop induction variable equals the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  /// uprounded trip-count, which are both 0.</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  /// uprounded trip-count, which are both 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  Data,</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  Data,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  /// Same as Data, but avoids using the get.active.lane.mask intrinsic to</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  /// Same as Data, but avoids using the get.active.lane.mask intrinsic to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  /// calculate the mask and instead implements this with a</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  /// calculate the mask and instead implements this with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  /// splat/stepvector/cmp.</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  /// splat/stepvector/cmp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  /// active.lane.mask intrinsic when it is not natively supported?</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  /// active.lane.mask intrinsic when it is not natively supported?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  DataWithoutLaneMask,</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  DataWithoutLaneMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  /// Use predicate to control both data and control flow.</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  /// Use predicate to control both data and control flow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  /// This method always requires a runtime overflow check for the i + VL</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  /// This method always requires a runtime overflow check for the i + VL</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  /// increment inside the loop, because it uses the result direclty in the</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  /// increment inside the loop, because it uses the result direclty in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  /// active.lane.mask to calculate the mask for the next iteration. If the</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  /// active.lane.mask to calculate the mask for the next iteration. If the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">  /// increment overflows, the mask is no longer correct.</td>
    <td class="lineNumber">188</td>
    <td class="codeline">  /// increment overflows, the mask is no longer correct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  DataAndControlFlow,</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  DataAndControlFlow,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  /// Use predicate to control both data and control flow, but modify</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  /// Use predicate to control both data and control flow, but modify</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  /// the trip count so that a runtime overflow check can be avoided</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  /// the trip count so that a runtime overflow check can be avoided</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  /// and such that the scalar epilogue loop can always be removed.</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  /// and such that the scalar epilogue loop can always be removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  DataAndControlFlowWithoutRuntimeCheck</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  DataAndControlFlowWithoutRuntimeCheck</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">};</td>
    <td class="lineNumber">194</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">struct TailFoldingInfo {</td>
    <td class="lineNumber">196</td>
    <td class="codeline">struct TailFoldingInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  TargetLibraryInfo *TLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  LoopVectorizationLegality *LVL;</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  LoopVectorizationLegality *LVL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  InterleavedAccessInfo *IAI;</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  InterleavedAccessInfo *IAI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">  TailFoldingInfo(TargetLibraryInfo *TLI, LoopVectorizationLegality *LVL,</td>
    <td class="lineNumber">200</td>
    <td class="codeline">  TailFoldingInfo(TargetLibraryInfo *TLI, LoopVectorizationLegality *LVL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">                  InterleavedAccessInfo *IAI)</td>
    <td class="lineNumber">201</td>
    <td class="codeline">                  InterleavedAccessInfo *IAI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">      : TLI(TLI), LVL(LVL), IAI(IAI) {}</td>
    <td class="lineNumber">202</td>
    <td class="codeline">      : TLI(TLI), LVL(LVL), IAI(IAI) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">};</td>
    <td class="lineNumber">203</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">class TargetTransformInfo;</td>
    <td class="lineNumber">205</td>
    <td class="codeline">class TargetTransformInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">typedef TargetTransformInfo TTI;</td>
    <td class="lineNumber">206</td>
    <td class="codeline">typedef TargetTransformInfo TTI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">/// This pass provides access to the codegen interfaces that are needed</td>
    <td class="lineNumber">208</td>
    <td class="codeline">/// This pass provides access to the codegen interfaces that are needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">/// for IR-level transformations.</td>
    <td class="lineNumber">209</td>
    <td class="codeline">/// for IR-level transformations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">class TargetTransformInfo {</td>
    <td class="lineNumber">210</td>
    <td class="codeline">class TargetTransformInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">211</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  /// Construct a TTI object using a type implementing the \c Concept</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  /// Construct a TTI object using a type implementing the \c Concept</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  /// API below.</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  /// API below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  /// This is used by targets to construct a TTI wrapping their target-specific</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  /// This is used by targets to construct a TTI wrapping their target-specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  /// implementation that encodes appropriate costs for their target.</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  /// implementation that encodes appropriate costs for their target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  template <typename T> TargetTransformInfo(T Impl);</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  template <typename T> TargetTransformInfo(T Impl);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  /// Construct a baseline TTI object using a minimal implementation of</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  /// Construct a baseline TTI object using a minimal implementation of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  /// the \c Concept API below.</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  /// the \c Concept API below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  /// The TTI implementation will reflect the information in the DataLayout</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  /// The TTI implementation will reflect the information in the DataLayout</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  /// provided if non-null.</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  /// provided if non-null.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  explicit TargetTransformInfo(const DataLayout &DL);</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  explicit TargetTransformInfo(const DataLayout &DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
    <td class="lineNumber">225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  // Provide move semantics.</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  // Provide move semantics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  TargetTransformInfo(TargetTransformInfo &&Arg);</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  TargetTransformInfo(TargetTransformInfo &&Arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  TargetTransformInfo &operator=(TargetTransformInfo &&RHS);</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  TargetTransformInfo &operator=(TargetTransformInfo &&RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  // We need to define the destructor out-of-line to define our sub-classes</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  // We need to define the destructor out-of-line to define our sub-classes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  // out-of-line.</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  // out-of-line.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  ~TargetTransformInfo();</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  ~TargetTransformInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  /// Handle the invalidation of this information.</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  /// Handle the invalidation of this information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  /// When used as a result of \c TargetIRAnalysis this method will be called</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  /// When used as a result of \c TargetIRAnalysis this method will be called</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  /// when the function this was computed for changes. When it returns false,</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  /// when the function this was computed for changes. When it returns false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  /// the information is preserved across those changes.</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  /// the information is preserved across those changes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  bool invalidate(Function &, const PreservedAnalyses &,</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  bool invalidate(Function &, const PreservedAnalyses &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">                  FunctionAnalysisManager::Invalidator &) {</td>
    <td class="lineNumber">240</td>
    <td class="codeline">                  FunctionAnalysisManager::Invalidator &) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">    // FIXME: We should probably in some way ensure that the subtarget</td>
    <td class="lineNumber">241</td>
    <td class="codeline">    // FIXME: We should probably in some way ensure that the subtarget</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">    // information for a function hasn't changed.</td>
    <td class="lineNumber">242</td>
    <td class="codeline">    // information for a function hasn't changed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  /// \name Generic Target Information</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  /// \name Generic Target Information</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  /// The kind of cost model.</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  /// The kind of cost model.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  /// There are several different cost models that can be customized by the</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  /// There are several different cost models that can be customized by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  /// target. The normalization of each cost model may be target specific.</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  /// target. The normalization of each cost model may be target specific.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  /// e.g. TCK_SizeAndLatency should be comparable to target thresholds such as</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  /// e.g. TCK_SizeAndLatency should be comparable to target thresholds such as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  /// those derived from MCSchedModel::LoopMicroOpBufferSize etc.</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  /// those derived from MCSchedModel::LoopMicroOpBufferSize etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  enum TargetCostKind {</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  enum TargetCostKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    TCK_RecipThroughput, ///< Reciprocal throughput.</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    TCK_RecipThroughput, ///< Reciprocal throughput.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">    TCK_Latency,         ///< The latency of instruction.</td>
    <td class="lineNumber">257</td>
    <td class="codeline">    TCK_Latency,         ///< The latency of instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    TCK_CodeSize,        ///< Instruction code size.</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    TCK_CodeSize,        ///< Instruction code size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">    TCK_SizeAndLatency   ///< The weighted sum of size and latency.</td>
    <td class="lineNumber">259</td>
    <td class="codeline">    TCK_SizeAndLatency   ///< The weighted sum of size and latency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  /// Underlying constants for 'cost' values in this interface.</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  /// Underlying constants for 'cost' values in this interface.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  /// Many APIs in this interface return a cost. This enum defines the</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  /// Many APIs in this interface return a cost. This enum defines the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  /// fundamental values that should be used to interpret (and produce) those</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  /// fundamental values that should be used to interpret (and produce) those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  /// costs. The costs are returned as an int rather than a member of this</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  /// costs. The costs are returned as an int rather than a member of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  /// enumeration because it is expected that the cost of one IR instruction</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  /// enumeration because it is expected that the cost of one IR instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  /// may have a multiplicative factor to it or otherwise won't fit directly</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  /// may have a multiplicative factor to it or otherwise won't fit directly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  /// into the enum. Moreover, it is common to sum or average costs which works</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  /// into the enum. Moreover, it is common to sum or average costs which works</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  /// better as simple integral values. Thus this enum only provides constants.</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  /// better as simple integral values. Thus this enum only provides constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  /// Also note that the returned costs are signed integers to make it natural</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  /// Also note that the returned costs are signed integers to make it natural</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  /// to add, subtract, and test with zero (a common boundary condition). It is</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  /// to add, subtract, and test with zero (a common boundary condition). It is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  /// not expected that 2^32 is a realistic cost to be modeling at any point.</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  /// not expected that 2^32 is a realistic cost to be modeling at any point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  /// Note that these costs should usually reflect the intersection of code-size</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  /// Note that these costs should usually reflect the intersection of code-size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  /// cost and execution cost. A free instruction is typically one that folds</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  /// cost and execution cost. A free instruction is typically one that folds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  /// into another instruction. For example, reg-to-reg moves can often be</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  /// into another instruction. For example, reg-to-reg moves can often be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  /// skipped by renaming the registers in the CPU, but they still are encoded</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  /// skipped by renaming the registers in the CPU, but they still are encoded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  /// and thus wouldn't be considered 'free' here.</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  /// and thus wouldn't be considered 'free' here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  enum TargetCostConstants {</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  enum TargetCostConstants {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">    TCC_Free = 0,     ///< Expected to fold away in lowering.</td>
    <td class="lineNumber">281</td>
    <td class="codeline">    TCC_Free = 0,     ///< Expected to fold away in lowering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">    TCC_Basic = 1,    ///< The cost of a typical 'add' instruction.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">    TCC_Basic = 1,    ///< The cost of a typical 'add' instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    TCC_Expensive = 4 ///< The cost of a 'div' instruction on x86.</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    TCC_Expensive = 4 ///< The cost of a 'div' instruction on x86.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  /// Estimate the cost of a GEP operation when lowered.</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  /// Estimate the cost of a GEP operation when lowered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  /// \p PointeeType is the source element type of the GEP.</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  /// \p PointeeType is the source element type of the GEP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  /// \p Ptr is the base pointer operand.</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  /// \p Ptr is the base pointer operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  /// \p Operands is the list of indices following the base pointer.</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  /// \p Operands is the list of indices following the base pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  /// \p AccessType is a hint as to what type of memory might be accessed by</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  /// \p AccessType is a hint as to what type of memory might be accessed by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  /// users of the GEP. getGEPCost will use it to determine if the GEP can be</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  /// users of the GEP. getGEPCost will use it to determine if the GEP can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  /// folded into the addressing mode of a load/store. If AccessType is null,</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  /// folded into the addressing mode of a load/store. If AccessType is null,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  /// then the resulting target type based off of PointeeType will be used as an</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  /// then the resulting target type based off of PointeeType will be used as an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  /// approximation.</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  /// approximation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">             ArrayRef<const Value *> Operands, Type *AccessType = nullptr,</td>
    <td class="lineNumber">299</td>
    <td class="codeline">             ArrayRef<const Value *> Operands, Type *AccessType = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">             TargetCostKind CostKind = TCK_SizeAndLatency) const;</td>
    <td class="lineNumber">300</td>
    <td class="codeline">             TargetCostKind CostKind = TCK_SizeAndLatency) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  /// Describe known properties for a set of pointers.</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  /// Describe known properties for a set of pointers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  struct PointersChainInfo {</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  struct PointersChainInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    /// All the GEPs in a set have same base address.</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    /// All the GEPs in a set have same base address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    unsigned IsSameBaseAddress : 1;</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    unsigned IsSameBaseAddress : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    /// These properties only valid if SameBaseAddress is set.</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    /// These properties only valid if SameBaseAddress is set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    /// True if all pointers are separated by a unit stride.</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    /// True if all pointers are separated by a unit stride.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    unsigned IsUnitStride : 1;</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    unsigned IsUnitStride : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">    /// True if distance between any two neigbouring pointers is a known value.</td>
    <td class="lineNumber">309</td>
    <td class="codeline">    /// True if distance between any two neigbouring pointers is a known value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    unsigned IsKnownStride : 1;</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    unsigned IsKnownStride : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    unsigned Reserved : 29;</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    unsigned Reserved : 29;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline"></td>
    <td class="lineNumber">312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    bool isSameBase() const { return IsSameBaseAddress; }</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    bool isSameBase() const { return IsSameBaseAddress; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">    bool isUnitStride() const { return IsSameBaseAddress && IsUnitStride; }</td>
    <td class="lineNumber">314</td>
    <td class="codeline">    bool isUnitStride() const { return IsSameBaseAddress && IsUnitStride; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">    bool isKnownStride() const { return IsSameBaseAddress && IsKnownStride; }</td>
    <td class="lineNumber">315</td>
    <td class="codeline">    bool isKnownStride() const { return IsSameBaseAddress && IsKnownStride; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">    static PointersChainInfo getUnitStride() {</td>
    <td class="lineNumber">317</td>
    <td class="codeline">    static PointersChainInfo getUnitStride() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/1,</td>
    <td class="lineNumber">318</td>
    <td class="codeline">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">              /*IsKnownStride=*/1, 0};</td>
    <td class="lineNumber">319</td>
    <td class="codeline">              /*IsKnownStride=*/1, 0};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    static PointersChainInfo getKnownStride() {</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    static PointersChainInfo getKnownStride() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
    <td class="lineNumber">322</td>
    <td class="codeline">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">              /*IsKnownStride=*/1, 0};</td>
    <td class="lineNumber">323</td>
    <td class="codeline">              /*IsKnownStride=*/1, 0};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">324</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">    static PointersChainInfo getUnknownStride() {</td>
    <td class="lineNumber">325</td>
    <td class="codeline">    static PointersChainInfo getUnknownStride() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
    <td class="lineNumber">326</td>
    <td class="codeline">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">              /*IsKnownStride=*/0, 0};</td>
    <td class="lineNumber">327</td>
    <td class="codeline">              /*IsKnownStride=*/0, 0};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">328</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  static_assert(sizeof(PointersChainInfo) == 4, "Was size increase justified?");</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  static_assert(sizeof(PointersChainInfo) == 4, "Was size increase justified?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline"></td>
    <td class="lineNumber">331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  /// Estimate the cost of a chain of pointers (typically pointer operands of a</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  /// Estimate the cost of a chain of pointers (typically pointer operands of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  /// chain of loads or stores within same block) operations set when lowered.</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  /// chain of loads or stores within same block) operations set when lowered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  /// \p AccessTy is the type of the loads/stores that will ultimately use the</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  /// \p AccessTy is the type of the loads/stores that will ultimately use the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  /// \p Ptrs.</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  /// \p Ptrs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">                       const PointersChainInfo &Info, Type *AccessTy,</td>
    <td class="lineNumber">338</td>
    <td class="codeline">                       const PointersChainInfo &Info, Type *AccessTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">                       TargetCostKind CostKind = TTI::TCK_RecipThroughput</td>
    <td class="lineNumber">339</td>
    <td class="codeline">                       TargetCostKind CostKind = TTI::TCK_RecipThroughput</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline"></td>
    <td class="lineNumber">340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">  ) const;</td>
    <td class="lineNumber">341</td>
    <td class="codeline">  ) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  /// \returns A value by which our inlining threshold should be multiplied.</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  /// \returns A value by which our inlining threshold should be multiplied.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  /// This is primarily used to bump up the inlining threshold wholesale on</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  /// This is primarily used to bump up the inlining threshold wholesale on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  /// targets where calls are unusually expensive.</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  /// targets where calls are unusually expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  /// TODO: This is a rather blunt instrument.  Perhaps altering the costs of</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  /// TODO: This is a rather blunt instrument.  Perhaps altering the costs of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  /// individual classes of instructions would be better.</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  /// individual classes of instructions would be better.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  unsigned getInliningThresholdMultiplier() const;</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  unsigned getInliningThresholdMultiplier() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline"></td>
    <td class="lineNumber">350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  /// \returns A value to be added to the inlining threshold.</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  /// \returns A value to be added to the inlining threshold.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  unsigned adjustInliningThreshold(const CallBase *CB) const;</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  unsigned adjustInliningThreshold(const CallBase *CB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline"></td>
    <td class="lineNumber">353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  /// \returns The cost of having an Alloca in the caller if not inlined, to be</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  /// \returns The cost of having an Alloca in the caller if not inlined, to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  /// added to the threshold</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  /// added to the threshold</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const;</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
    <td class="lineNumber">357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  /// \returns Vector bonus in percent.</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  /// \returns Vector bonus in percent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  /// Vector bonuses: We want to more aggressively inline vector-dense kernels</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  /// Vector bonuses: We want to more aggressively inline vector-dense kernels</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">  /// and apply this bonus based on the percentage of vector instructions. A</td>
    <td class="lineNumber">361</td>
    <td class="codeline">  /// and apply this bonus based on the percentage of vector instructions. A</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  /// bonus is applied if the vector instructions exceed 50% and half that</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  /// bonus is applied if the vector instructions exceed 50% and half that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  /// amount is applied if it exceeds 10%. Note that these bonuses are some what</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  /// amount is applied if it exceeds 10%. Note that these bonuses are some what</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  /// arbitrary and evolved over time by accident as much as because they are</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  /// arbitrary and evolved over time by accident as much as because they are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  /// principled bonuses.</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  /// principled bonuses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  /// FIXME: It would be nice to base the bonus values on something more</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  /// FIXME: It would be nice to base the bonus values on something more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  /// scientific. A target may has no bonus on vector instructions.</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  /// scientific. A target may has no bonus on vector instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  int getInlinerVectorBonusPercent() const;</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  int getInlinerVectorBonusPercent() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  /// \return the expected cost of a memcpy, which could e.g. depend on the</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  /// \return the expected cost of a memcpy, which could e.g. depend on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  /// source/destination type and alignment and the number of bytes copied.</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  /// source/destination type and alignment and the number of bytes copied.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  InstructionCost getMemcpyCost(const Instruction *I) const;</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  InstructionCost getMemcpyCost(const Instruction *I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  /// Returns the maximum memset / memcpy size in bytes that still makes it</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  /// Returns the maximum memset / memcpy size in bytes that still makes it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  /// profitable to inline the call.</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  /// profitable to inline the call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const;</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">  /// \return The estimated number of case clusters when lowering \p 'SI'.</td>
    <td class="lineNumber">378</td>
    <td class="codeline">  /// \return The estimated number of case clusters when lowering \p 'SI'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  /// \p JTSize Set a jump table size only when \p SI is suitable for a jump</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  /// \p JTSize Set a jump table size only when \p SI is suitable for a jump</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  /// table.</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  /// table.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">                                            unsigned &JTSize,</td>
    <td class="lineNumber">382</td>
    <td class="codeline">                                            unsigned &JTSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">383</td>
    <td class="codeline">                                            ProfileSummaryInfo *PSI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">                                            BlockFrequencyInfo *BFI) const;</td>
    <td class="lineNumber">384</td>
    <td class="codeline">                                            BlockFrequencyInfo *BFI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  /// Estimate the cost of a given IR user when lowered.</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  /// Estimate the cost of a given IR user when lowered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">  /// This can estimate the cost of either a ConstantExpr or Instruction when</td>
    <td class="lineNumber">388</td>
    <td class="codeline">  /// This can estimate the cost of either a ConstantExpr or Instruction when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  /// lowered.</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  /// lowered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  /// \p Operands is a list of operands which can be a result of transformations</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  /// \p Operands is a list of operands which can be a result of transformations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  /// of the current operands. The number of the operands on the list must equal</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  /// of the current operands. The number of the operands on the list must equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  /// to the number of the current operands the IR user has. Their order on the</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  /// to the number of the current operands the IR user has. Their order on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  /// list must be the same as the order of the current operands the IR user</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  /// list must be the same as the order of the current operands the IR user</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  /// has.</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  /// has.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  /// The returned cost is defined in terms of \c TargetCostConstants, see its</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  /// The returned cost is defined in terms of \c TargetCostConstants, see its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  /// comments for a detailed explanation of the cost values.</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  /// comments for a detailed explanation of the cost values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  InstructionCost getInstructionCost(const User *U,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">400</td>
    <td class="codeline">                                     ArrayRef<const Value *> Operands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">                                     TargetCostKind CostKind) const;</td>
    <td class="lineNumber">401</td>
    <td class="codeline">                                     TargetCostKind CostKind) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
    <td class="lineNumber">402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  /// This is a helper function which calls the three-argument</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  /// This is a helper function which calls the three-argument</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  /// getInstructionCost with \p Operands which are the current operands U has.</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  /// getInstructionCost with \p Operands which are the current operands U has.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  InstructionCost getInstructionCost(const User *U,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">                                     TargetCostKind CostKind) const {</td>
    <td class="lineNumber">406</td>
    <td class="codeline">                                     TargetCostKind CostKind) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">    SmallVector<const Value *, 4> Operands(U->operand_values());</td>
    <td class="lineNumber">407</td>
    <td class="codeline">    SmallVector<const Value *, 4> Operands(U->operand_values());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">    return getInstructionCost(U, Operands, CostKind);</td>
    <td class="lineNumber">408</td>
    <td class="codeline">    return getInstructionCost(U, Operands, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  /// If a branch or a select condition is skewed in one direction by more than</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  /// If a branch or a select condition is skewed in one direction by more than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  /// this factor, it is very likely to be predicted correctly.</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  /// this factor, it is very likely to be predicted correctly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  BranchProbability getPredictableBranchThreshold() const;</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  BranchProbability getPredictableBranchThreshold() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline"></td>
    <td class="lineNumber">414</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  /// Return true if branch divergence exists.</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  /// Return true if branch divergence exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  /// Branch divergence has a significantly negative impact on GPU performance</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  /// Branch divergence has a significantly negative impact on GPU performance</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  /// when threads in the same wavefront take different paths due to conditional</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  /// when threads in the same wavefront take different paths due to conditional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  /// branches.</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  /// branches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">420</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  /// If \p F is passed, provides a context function. If \p F is known to only</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  /// If \p F is passed, provides a context function. If \p F is known to only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  /// execute in a single threaded environment, the target may choose to skip</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  /// execute in a single threaded environment, the target may choose to skip</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  /// uniformity analysis and assume all values are uniform.</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  /// uniformity analysis and assume all values are uniform.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  bool hasBranchDivergence(const Function *F = nullptr) const;</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  bool hasBranchDivergence(const Function *F = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  /// Returns whether V is a source of divergence.</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  /// Returns whether V is a source of divergence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  /// This function provides the target-dependent information for</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  /// This function provides the target-dependent information for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  /// the target-independent UniformityAnalysis.</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  /// the target-independent UniformityAnalysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  bool isSourceOfDivergence(const Value *V) const;</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  bool isSourceOfDivergence(const Value *V) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline"></td>
    <td class="lineNumber">431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  // Returns true for the target specific</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  // Returns true for the target specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  // set of operations which produce uniform result</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  // set of operations which produce uniform result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  // even taking non-uniform arguments</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  // even taking non-uniform arguments</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  bool isAlwaysUniform(const Value *V) const;</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  bool isAlwaysUniform(const Value *V) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  /// Query the target whether the specified address space cast from FromAS to</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  /// Query the target whether the specified address space cast from FromAS to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  /// ToAS is valid.</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  /// ToAS is valid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  /// Return false if a \p AS0 address cannot possibly alias a \p AS1 address.</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  /// Return false if a \p AS0 address cannot possibly alias a \p AS1 address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const;</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  /// Returns the address space ID for a target's 'flat' address space. Note</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  /// Returns the address space ID for a target's 'flat' address space. Note</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  /// this is not necessarily the same as addrspace(0), which LLVM sometimes</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  /// this is not necessarily the same as addrspace(0), which LLVM sometimes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  /// refers to as the generic address space. The flat address space is a</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  /// refers to as the generic address space. The flat address space is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  /// generic address space that can be used access multiple segments of memory</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  /// generic address space that can be used access multiple segments of memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  /// with different address spaces. Access of a memory location through a</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  /// with different address spaces. Access of a memory location through a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  /// pointer with this address space is expected to be legal but slower</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  /// pointer with this address space is expected to be legal but slower</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  /// compared to the same memory location accessed through a pointer with a</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  /// compared to the same memory location accessed through a pointer with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  /// different address space.</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  /// different address space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">452</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  /// This is for targets with different pointer representations which can</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  /// This is for targets with different pointer representations which can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  /// be converted with the addrspacecast instruction. If a pointer is converted</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  /// be converted with the addrspacecast instruction. If a pointer is converted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  /// to this address space, optimizations should attempt to replace the access</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  /// to this address space, optimizations should attempt to replace the access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  /// with the source address space.</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  /// with the source address space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">  /// \returns ~0u if the target does not have such a flat address space to</td>
    <td class="lineNumber">458</td>
    <td class="codeline">  /// \returns ~0u if the target does not have such a flat address space to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  /// optimize away.</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  /// optimize away.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  unsigned getFlatAddressSpace() const;</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  unsigned getFlatAddressSpace() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline"></td>
    <td class="lineNumber">461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  /// Return any intrinsic address operand indexes which may be rewritten if</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  /// Return any intrinsic address operand indexes which may be rewritten if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  /// they use a flat address space pointer.</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  /// they use a flat address space pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  /// \returns true if the intrinsic was handled.</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  /// \returns true if the intrinsic was handled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">                                  Intrinsic::ID IID) const;</td>
    <td class="lineNumber">467</td>
    <td class="codeline">                                  Intrinsic::ID IID) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline"></td>
    <td class="lineNumber">468</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline"></td>
    <td class="lineNumber">470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">  /// Return true if globals in this address space can have initializers other</td>
    <td class="lineNumber">471</td>
    <td class="codeline">  /// Return true if globals in this address space can have initializers other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  /// than `undef`.</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  /// than `undef`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  bool canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const;</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  bool canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline"></td>
    <td class="lineNumber">474</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  unsigned getAssumedAddrSpace(const Value *V) const;</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  unsigned getAssumedAddrSpace(const Value *V) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  bool isSingleThreaded() const;</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  bool isSingleThreaded() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">479</td>
    <td class="codeline">  std::pair<const Value *, unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  getPredicatedAddrSpace(const Value *V) const;</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  getPredicatedAddrSpace(const Value *V) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  /// Rewrite intrinsic call \p II such that \p OldV will be replaced with \p</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  /// Rewrite intrinsic call \p II such that \p OldV will be replaced with \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">  /// NewV, which has a different address space. This should happen for every</td>
    <td class="lineNumber">483</td>
    <td class="codeline">  /// NewV, which has a different address space. This should happen for every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  /// operand index that collectFlatAddressOperands returned for the intrinsic.</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  /// operand index that collectFlatAddressOperands returned for the intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  /// \returns nullptr if the intrinsic was not handled. Otherwise, returns the</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  /// \returns nullptr if the intrinsic was not handled. Otherwise, returns the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  /// new value (which may be the original \p II with modified operands).</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  /// new value (which may be the original \p II with modified operands).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">                                          Value *NewV) const;</td>
    <td class="lineNumber">488</td>
    <td class="codeline">                                          Value *NewV) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  /// Test whether calls to a function lower to actual program function</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  /// Test whether calls to a function lower to actual program function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  /// calls.</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  /// calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  /// The idea is to test whether the program is likely to require a 'call'</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  /// The idea is to test whether the program is likely to require a 'call'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  /// instruction or equivalent in order to call the given function.</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  /// instruction or equivalent in order to call the given function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  /// FIXME: It's not clear that this is a good or useful query API. Client's</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  /// FIXME: It's not clear that this is a good or useful query API. Client's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  /// should probably move to simpler cost metrics using the above.</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  /// should probably move to simpler cost metrics using the above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  /// Alternatively, we could split the cost interface into distinct code-size</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  /// Alternatively, we could split the cost interface into distinct code-size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  /// and execution-speed costs. This would allow modelling the core of this</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  /// and execution-speed costs. This would allow modelling the core of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  /// query more accurately as a call is a single small instruction, but</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  /// query more accurately as a call is a single small instruction, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">  /// incurs significant execution cost.</td>
    <td class="lineNumber">501</td>
    <td class="codeline">  /// incurs significant execution cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  bool isLoweredToCall(const Function *F) const;</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  bool isLoweredToCall(const Function *F) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline"></td>
    <td class="lineNumber">503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  struct LSRCost {</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  struct LSRCost {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">    /// TODO: Some of these could be merged. Also, a lexical ordering</td>
    <td class="lineNumber">505</td>
    <td class="codeline">    /// TODO: Some of these could be merged. Also, a lexical ordering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">    /// isn't always optimal.</td>
    <td class="lineNumber">506</td>
    <td class="codeline">    /// isn't always optimal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    unsigned Insns;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    unsigned Insns;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">    unsigned NumRegs;</td>
    <td class="lineNumber">508</td>
    <td class="codeline">    unsigned NumRegs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">    unsigned AddRecCost;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">    unsigned AddRecCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">    unsigned NumIVMuls;</td>
    <td class="lineNumber">510</td>
    <td class="codeline">    unsigned NumIVMuls;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">    unsigned NumBaseAdds;</td>
    <td class="lineNumber">511</td>
    <td class="codeline">    unsigned NumBaseAdds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">    unsigned ImmCost;</td>
    <td class="lineNumber">512</td>
    <td class="codeline">    unsigned ImmCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">    unsigned SetupCost;</td>
    <td class="lineNumber">513</td>
    <td class="codeline">    unsigned SetupCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">    unsigned ScaleCost;</td>
    <td class="lineNumber">514</td>
    <td class="codeline">    unsigned ScaleCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline"></td>
    <td class="lineNumber">516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  /// Parameters that control the generic loop unrolling transformation.</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  /// Parameters that control the generic loop unrolling transformation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  struct UnrollingPreferences {</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  struct UnrollingPreferences {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">    /// The cost threshold for the unrolled loop. Should be relative to the</td>
    <td class="lineNumber">519</td>
    <td class="codeline">    /// The cost threshold for the unrolled loop. Should be relative to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">    /// getInstructionCost values returned by this API, and the expectation is</td>
    <td class="lineNumber">520</td>
    <td class="codeline">    /// getInstructionCost values returned by this API, and the expectation is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">    /// that the unrolled loop's instructions when run through that interface</td>
    <td class="lineNumber">521</td>
    <td class="codeline">    /// that the unrolled loop's instructions when run through that interface</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">    /// should not exceed this cost. However, this is only an estimate. Also,</td>
    <td class="lineNumber">522</td>
    <td class="codeline">    /// should not exceed this cost. However, this is only an estimate. Also,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">    /// specific loops may be unrolled even with a cost above this threshold if</td>
    <td class="lineNumber">523</td>
    <td class="codeline">    /// specific loops may be unrolled even with a cost above this threshold if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">    /// deemed profitable. Set this to UINT_MAX to disable the loop body cost</td>
    <td class="lineNumber">524</td>
    <td class="codeline">    /// deemed profitable. Set this to UINT_MAX to disable the loop body cost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">    /// restriction.</td>
    <td class="lineNumber">525</td>
    <td class="codeline">    /// restriction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">    unsigned Threshold;</td>
    <td class="lineNumber">526</td>
    <td class="codeline">    unsigned Threshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">    /// If complete unrolling will reduce the cost of the loop, we will boost</td>
    <td class="lineNumber">527</td>
    <td class="codeline">    /// If complete unrolling will reduce the cost of the loop, we will boost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    /// the Threshold by a certain percent to allow more aggressive complete</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    /// the Threshold by a certain percent to allow more aggressive complete</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">    /// unrolling. This value provides the maximum boost percentage that we</td>
    <td class="lineNumber">529</td>
    <td class="codeline">    /// unrolling. This value provides the maximum boost percentage that we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    /// can apply to Threshold (The value should be no less than 100).</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    /// can apply to Threshold (The value should be no less than 100).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">    /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,</td>
    <td class="lineNumber">531</td>
    <td class="codeline">    /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    ///                                    MaxPercentThresholdBoost / 100)</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    ///                                    MaxPercentThresholdBoost / 100)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">    /// E.g. if complete unrolling reduces the loop execution time by 50%</td>
    <td class="lineNumber">533</td>
    <td class="codeline">    /// E.g. if complete unrolling reduces the loop execution time by 50%</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    /// then we boost the threshold by the factor of 2x. If unrolling is not</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    /// then we boost the threshold by the factor of 2x. If unrolling is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">    /// expected to reduce the running time, then we do not increase the</td>
    <td class="lineNumber">535</td>
    <td class="codeline">    /// expected to reduce the running time, then we do not increase the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">    /// threshold.</td>
    <td class="lineNumber">536</td>
    <td class="codeline">    /// threshold.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">    unsigned MaxPercentThresholdBoost;</td>
    <td class="lineNumber">537</td>
    <td class="codeline">    unsigned MaxPercentThresholdBoost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">    /// The cost threshold for the unrolled loop when optimizing for size (set</td>
    <td class="lineNumber">538</td>
    <td class="codeline">    /// The cost threshold for the unrolled loop when optimizing for size (set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    /// to UINT_MAX to disable).</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    /// to UINT_MAX to disable).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">    unsigned OptSizeThreshold;</td>
    <td class="lineNumber">540</td>
    <td class="codeline">    unsigned OptSizeThreshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">    /// The cost threshold for the unrolled loop, like Threshold, but used</td>
    <td class="lineNumber">541</td>
    <td class="codeline">    /// The cost threshold for the unrolled loop, like Threshold, but used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">    /// for partial/runtime unrolling (set to UINT_MAX to disable).</td>
    <td class="lineNumber">542</td>
    <td class="codeline">    /// for partial/runtime unrolling (set to UINT_MAX to disable).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">    unsigned PartialThreshold;</td>
    <td class="lineNumber">543</td>
    <td class="codeline">    unsigned PartialThreshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">    /// The cost threshold for the unrolled loop when optimizing for size, like</td>
    <td class="lineNumber">544</td>
    <td class="codeline">    /// The cost threshold for the unrolled loop when optimizing for size, like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">    /// OptSizeThreshold, but used for partial/runtime unrolling (set to</td>
    <td class="lineNumber">545</td>
    <td class="codeline">    /// OptSizeThreshold, but used for partial/runtime unrolling (set to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">    /// UINT_MAX to disable).</td>
    <td class="lineNumber">546</td>
    <td class="codeline">    /// UINT_MAX to disable).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">    unsigned PartialOptSizeThreshold;</td>
    <td class="lineNumber">547</td>
    <td class="codeline">    unsigned PartialOptSizeThreshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">    /// A forced unrolling factor (the number of concatenated bodies of the</td>
    <td class="lineNumber">548</td>
    <td class="codeline">    /// A forced unrolling factor (the number of concatenated bodies of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">    /// original loop in the unrolled loop body). When set to 0, the unrolling</td>
    <td class="lineNumber">549</td>
    <td class="codeline">    /// original loop in the unrolled loop body). When set to 0, the unrolling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">    /// transformation will select an unrolling factor based on the current cost</td>
    <td class="lineNumber">550</td>
    <td class="codeline">    /// transformation will select an unrolling factor based on the current cost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">    /// threshold and other factors.</td>
    <td class="lineNumber">551</td>
    <td class="codeline">    /// threshold and other factors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">    unsigned Count;</td>
    <td class="lineNumber">552</td>
    <td class="codeline">    unsigned Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">    /// Default unroll count for loops with run-time trip count.</td>
    <td class="lineNumber">553</td>
    <td class="codeline">    /// Default unroll count for loops with run-time trip count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">    unsigned DefaultUnrollRuntimeCount;</td>
    <td class="lineNumber">554</td>
    <td class="codeline">    unsigned DefaultUnrollRuntimeCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">    // Set the maximum unrolling factor. The unrolling factor may be selected</td>
    <td class="lineNumber">555</td>
    <td class="codeline">    // Set the maximum unrolling factor. The unrolling factor may be selected</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">    // using the appropriate cost threshold, but may not exceed this number</td>
    <td class="lineNumber">556</td>
    <td class="codeline">    // using the appropriate cost threshold, but may not exceed this number</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    // (set to UINT_MAX to disable). This does not apply in cases where the</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    // (set to UINT_MAX to disable). This does not apply in cases where the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    // loop is being fully unrolled.</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    // loop is being fully unrolled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">    unsigned MaxCount;</td>
    <td class="lineNumber">559</td>
    <td class="codeline">    unsigned MaxCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    /// Set the maximum unrolling factor for full unrolling. Like MaxCount, but</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    /// Set the maximum unrolling factor for full unrolling. Like MaxCount, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">    /// applies even if full unrolling is selected. This allows a target to fall</td>
    <td class="lineNumber">561</td>
    <td class="codeline">    /// applies even if full unrolling is selected. This allows a target to fall</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">    /// back to Partial unrolling if full unrolling is above FullUnrollMaxCount.</td>
    <td class="lineNumber">562</td>
    <td class="codeline">    /// back to Partial unrolling if full unrolling is above FullUnrollMaxCount.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">    unsigned FullUnrollMaxCount;</td>
    <td class="lineNumber">563</td>
    <td class="codeline">    unsigned FullUnrollMaxCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">    // Represents number of instructions optimized when "back edge"</td>
    <td class="lineNumber">564</td>
    <td class="codeline">    // Represents number of instructions optimized when "back edge"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">    // becomes "fall through" in unrolled loop.</td>
    <td class="lineNumber">565</td>
    <td class="codeline">    // becomes "fall through" in unrolled loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">    // For now we count a conditional branch on a backedge and a comparison</td>
    <td class="lineNumber">566</td>
    <td class="codeline">    // For now we count a conditional branch on a backedge and a comparison</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">    // feeding it.</td>
    <td class="lineNumber">567</td>
    <td class="codeline">    // feeding it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">    unsigned BEInsns;</td>
    <td class="lineNumber">568</td>
    <td class="codeline">    unsigned BEInsns;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">    /// Allow partial unrolling (unrolling of loops to expand the size of the</td>
    <td class="lineNumber">569</td>
    <td class="codeline">    /// Allow partial unrolling (unrolling of loops to expand the size of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">    /// loop body, not only to eliminate small constant-trip-count loops).</td>
    <td class="lineNumber">570</td>
    <td class="codeline">    /// loop body, not only to eliminate small constant-trip-count loops).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    bool Partial;</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    bool Partial;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">    /// Allow runtime unrolling (unrolling of loops to expand the size of the</td>
    <td class="lineNumber">572</td>
    <td class="codeline">    /// Allow runtime unrolling (unrolling of loops to expand the size of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">    /// loop body even when the number of loop iterations is not known at</td>
    <td class="lineNumber">573</td>
    <td class="codeline">    /// loop body even when the number of loop iterations is not known at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">    /// compile time).</td>
    <td class="lineNumber">574</td>
    <td class="codeline">    /// compile time).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">    bool Runtime;</td>
    <td class="lineNumber">575</td>
    <td class="codeline">    bool Runtime;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">    /// Allow generation of a loop remainder (extra iterations after unroll).</td>
    <td class="lineNumber">576</td>
    <td class="codeline">    /// Allow generation of a loop remainder (extra iterations after unroll).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">    bool AllowRemainder;</td>
    <td class="lineNumber">577</td>
    <td class="codeline">    bool AllowRemainder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">    /// Allow emitting expensive instructions (such as divisions) when computing</td>
    <td class="lineNumber">578</td>
    <td class="codeline">    /// Allow emitting expensive instructions (such as divisions) when computing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">    /// the trip count of a loop for runtime unrolling.</td>
    <td class="lineNumber">579</td>
    <td class="codeline">    /// the trip count of a loop for runtime unrolling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">    bool AllowExpensiveTripCount;</td>
    <td class="lineNumber">580</td>
    <td class="codeline">    bool AllowExpensiveTripCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">    /// Apply loop unroll on any kind of loop</td>
    <td class="lineNumber">581</td>
    <td class="codeline">    /// Apply loop unroll on any kind of loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    /// (mainly to loops that fail runtime unrolling).</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    /// (mainly to loops that fail runtime unrolling).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    bool Force;</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    bool Force;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">    /// Allow using trip count upper bound to unroll loops.</td>
    <td class="lineNumber">584</td>
    <td class="codeline">    /// Allow using trip count upper bound to unroll loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">    bool UpperBound;</td>
    <td class="lineNumber">585</td>
    <td class="codeline">    bool UpperBound;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">    /// Allow unrolling of all the iterations of the runtime loop remainder.</td>
    <td class="lineNumber">586</td>
    <td class="codeline">    /// Allow unrolling of all the iterations of the runtime loop remainder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">    bool UnrollRemainder;</td>
    <td class="lineNumber">587</td>
    <td class="codeline">    bool UnrollRemainder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    /// Allow unroll and jam. Used to enable unroll and jam for the target.</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    /// Allow unroll and jam. Used to enable unroll and jam for the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">    bool UnrollAndJam;</td>
    <td class="lineNumber">589</td>
    <td class="codeline">    bool UnrollAndJam;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">    /// Threshold for unroll and jam, for inner loop size. The 'Threshold'</td>
    <td class="lineNumber">590</td>
    <td class="codeline">    /// Threshold for unroll and jam, for inner loop size. The 'Threshold'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    /// value above is used during unroll and jam for the outer loop size.</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    /// value above is used during unroll and jam for the outer loop size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">    /// This value is used in the same manner to limit the size of the inner</td>
    <td class="lineNumber">592</td>
    <td class="codeline">    /// This value is used in the same manner to limit the size of the inner</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    /// loop.</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    /// loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    unsigned UnrollAndJamInnerLoopThreshold;</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    unsigned UnrollAndJamInnerLoopThreshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    /// Don't allow loop unrolling to simulate more than this number of</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    /// Don't allow loop unrolling to simulate more than this number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">    /// iterations when checking full unroll profitability</td>
    <td class="lineNumber">596</td>
    <td class="codeline">    /// iterations when checking full unroll profitability</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    unsigned MaxIterationsCountToAnalyze;</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    unsigned MaxIterationsCountToAnalyze;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">    /// Don't disable runtime unroll for the loops which were vectorized.</td>
    <td class="lineNumber">598</td>
    <td class="codeline">    /// Don't disable runtime unroll for the loops which were vectorized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">    bool UnrollVectorizedLoop = false;</td>
    <td class="lineNumber">599</td>
    <td class="codeline">    bool UnrollVectorizedLoop = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  /// Get target-customized preferences for the generic loop unrolling</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  /// Get target-customized preferences for the generic loop unrolling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  /// transformation. The caller will initialize UP with the current</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  /// transformation. The caller will initialize UP with the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  /// target-independent defaults.</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  /// target-independent defaults.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">                               UnrollingPreferences &UP,</td>
    <td class="lineNumber">606</td>
    <td class="codeline">                               UnrollingPreferences &UP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">                               OptimizationRemarkEmitter *ORE) const;</td>
    <td class="lineNumber">607</td>
    <td class="codeline">                               OptimizationRemarkEmitter *ORE) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline"></td>
    <td class="lineNumber">608</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  /// Query the target whether it would be profitable to convert the given loop</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  /// Query the target whether it would be profitable to convert the given loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  /// into a hardware loop.</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  /// into a hardware loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">612</td>
    <td class="codeline">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">                                HardwareLoopInfo &HWLoopInfo) const;</td>
    <td class="lineNumber">613</td>
    <td class="codeline">                                HardwareLoopInfo &HWLoopInfo) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  /// Query the target whether it would be prefered to create a predicated</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  /// Query the target whether it would be prefered to create a predicated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  /// vector loop, which can avoid the need to emit a scalar epilogue loop.</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  /// vector loop, which can avoid the need to emit a scalar epilogue loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) const;</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  /// Query the target what the preferred style of tail folding is.</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  /// Query the target what the preferred style of tail folding is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">  /// \param IVUpdateMayOverflow Tells whether it is known if the IV update</td>
    <td class="lineNumber">620</td>
    <td class="codeline">  /// \param IVUpdateMayOverflow Tells whether it is known if the IV update</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">  /// may (or will never) overflow for the suggested VF/UF in the given loop.</td>
    <td class="lineNumber">621</td>
    <td class="codeline">  /// may (or will never) overflow for the suggested VF/UF in the given loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">  /// Targets can use this information to select a more optimal tail folding</td>
    <td class="lineNumber">622</td>
    <td class="codeline">  /// Targets can use this information to select a more optimal tail folding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  /// style. The value conservatively defaults to true, such that no assumptions</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  /// style. The value conservatively defaults to true, such that no assumptions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  /// are made on overflow.</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  /// are made on overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  TailFoldingStyle</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  TailFoldingStyle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) const;</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline"></td>
    <td class="lineNumber">627</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  // Parameters that control the loop peeling transformation</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  // Parameters that control the loop peeling transformation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  struct PeelingPreferences {</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  struct PeelingPreferences {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">    /// A forced peeling factor (the number of bodied of the original loop</td>
    <td class="lineNumber">630</td>
    <td class="codeline">    /// A forced peeling factor (the number of bodied of the original loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    /// that should be peeled off before the loop body). When set to 0, the</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    /// that should be peeled off before the loop body). When set to 0, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">    /// a peeling factor based on profile information and other factors.</td>
    <td class="lineNumber">632</td>
    <td class="codeline">    /// a peeling factor based on profile information and other factors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">    unsigned PeelCount;</td>
    <td class="lineNumber">633</td>
    <td class="codeline">    unsigned PeelCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">    /// Allow peeling off loop iterations.</td>
    <td class="lineNumber">634</td>
    <td class="codeline">    /// Allow peeling off loop iterations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">    bool AllowPeeling;</td>
    <td class="lineNumber">635</td>
    <td class="codeline">    bool AllowPeeling;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    /// Allow peeling off loop iterations for loop nests.</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    /// Allow peeling off loop iterations for loop nests.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">    bool AllowLoopNestsPeeling;</td>
    <td class="lineNumber">637</td>
    <td class="codeline">    bool AllowLoopNestsPeeling;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">    /// Allow peeling basing on profile. Uses to enable peeling off all</td>
    <td class="lineNumber">638</td>
    <td class="codeline">    /// Allow peeling basing on profile. Uses to enable peeling off all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">    /// iterations basing on provided profile.</td>
    <td class="lineNumber">639</td>
    <td class="codeline">    /// iterations basing on provided profile.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    /// If the value is true the peeling cost model can decide to peel only</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    /// If the value is true the peeling cost model can decide to peel only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    /// some iterations and in this case it will set this to false.</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    /// some iterations and in this case it will set this to false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">    bool PeelProfiledIterations;</td>
    <td class="lineNumber">642</td>
    <td class="codeline">    bool PeelProfiledIterations;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  /// Get target-customized preferences for the generic loop peeling</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  /// Get target-customized preferences for the generic loop peeling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  /// transformation. The caller will initialize \p PP with the current</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  /// transformation. The caller will initialize \p PP with the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  /// target-independent defaults with information from \p L and \p SE.</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  /// target-independent defaults with information from \p L and \p SE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">                             PeelingPreferences &PP) const;</td>
    <td class="lineNumber">649</td>
    <td class="codeline">                             PeelingPreferences &PP) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline"></td>
    <td class="lineNumber">650</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  /// Targets can implement their own combinations for target-specific</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  /// Targets can implement their own combinations for target-specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  /// intrinsics. This function will be called from the InstCombine pass every</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  /// intrinsics. This function will be called from the InstCombine pass every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  /// time a target-specific intrinsic is encountered.</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  /// time a target-specific intrinsic is encountered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  /// \returns std::nullopt to not do anything target specific or a value that</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  /// \returns std::nullopt to not do anything target specific or a value that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  /// will be returned from the InstCombiner. It is possible to return null and</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  /// will be returned from the InstCombiner. It is possible to return null and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  /// stop further processing of the intrinsic by returning nullptr.</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  /// stop further processing of the intrinsic by returning nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner & IC,</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner & IC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">                                                    IntrinsicInst & II) const;</td>
    <td class="lineNumber">659</td>
    <td class="codeline">                                                    IntrinsicInst & II) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  /// Can be used to implement target-specific instruction combining.</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  /// Can be used to implement target-specific instruction combining.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  /// \see instCombineIntrinsic</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  /// \see instCombineIntrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedMask,</td>
    <td class="lineNumber">663</td>
    <td class="codeline">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">      KnownBits & Known, bool &KnownBitsComputed) const;</td>
    <td class="lineNumber">664</td>
    <td class="codeline">      KnownBits & Known, bool &KnownBitsComputed) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  /// Can be used to implement target-specific instruction combining.</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  /// Can be used to implement target-specific instruction combining.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  /// \see instCombineIntrinsic</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  /// \see instCombineIntrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedElts,</td>
    <td class="lineNumber">668</td>
    <td class="codeline">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">      APInt & UndefElts, APInt & UndefElts2, APInt & UndefElts3,</td>
    <td class="lineNumber">669</td>
    <td class="codeline">      APInt & UndefElts, APInt & UndefElts2, APInt & UndefElts3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">670</td>
    <td class="codeline">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">          SimplifyAndSetOp) const;</td>
    <td class="lineNumber">671</td>
    <td class="codeline">          SimplifyAndSetOp) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline"></td>
    <td class="lineNumber">673</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  /// \name Scalar Target Information</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  /// \name Scalar Target Information</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  /// Flags indicating the kind of support for population count.</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  /// Flags indicating the kind of support for population count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  /// Compared to the SW implementation, HW support is supposed to</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  /// Compared to the SW implementation, HW support is supposed to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  /// significantly boost the performance when the population is dense, and it</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  /// significantly boost the performance when the population is dense, and it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  /// may or may not degrade performance if the population is sparse. A HW</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  /// may or may not degrade performance if the population is sparse. A HW</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  /// support is considered as "Fast" if it can outperform, or is on a par</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  /// support is considered as "Fast" if it can outperform, or is on a par</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  /// with, SW implementation when the population is sparse; otherwise, it is</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  /// with, SW implementation when the population is sparse; otherwise, it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  /// considered as "Slow".</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  /// considered as "Slow".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  enum PopcntSupportKind { PSK_Software, PSK_SlowHardware, PSK_FastHardware };</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  enum PopcntSupportKind { PSK_Software, PSK_SlowHardware, PSK_FastHardware };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline"></td>
    <td class="lineNumber">686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  /// Return true if the specified immediate is legal add immediate, that</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  /// Return true if the specified immediate is legal add immediate, that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  /// is the target has add instructions which can add a register with the</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  /// is the target has add instructions which can add a register with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  /// immediate without having to materialize the immediate into a register.</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  /// immediate without having to materialize the immediate into a register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  bool isLegalAddImmediate(int64_t Imm) const;</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  bool isLegalAddImmediate(int64_t Imm) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  /// Return true if the specified immediate is legal icmp immediate,</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  /// Return true if the specified immediate is legal icmp immediate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  /// that is the target has icmp instructions which can compare a register</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  /// that is the target has icmp instructions which can compare a register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  /// against the immediate without having to materialize the immediate into a</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  /// against the immediate without having to materialize the immediate into a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  /// register.</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  /// register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  bool isLegalICmpImmediate(int64_t Imm) const;</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  bool isLegalICmpImmediate(int64_t Imm) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  /// Return true if the addressing mode represented by AM is legal for</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  /// Return true if the addressing mode represented by AM is legal for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  /// this target, for a load/store of the specified type.</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  /// this target, for a load/store of the specified type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  /// The type may be VoidTy, in which case only return true if the addressing</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  /// The type may be VoidTy, in which case only return true if the addressing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  /// mode is legal for a load/store of any legal type.</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  /// mode is legal for a load/store of any legal type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">  /// If target returns true in LSRWithInstrQueries(), I may be valid.</td>
    <td class="lineNumber">702</td>
    <td class="codeline">  /// If target returns true in LSRWithInstrQueries(), I may be valid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">  /// TODO: Handle pre/postinc as well.</td>
    <td class="lineNumber">703</td>
    <td class="codeline">  /// TODO: Handle pre/postinc as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">                             bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">705</td>
    <td class="codeline">                             bool HasBaseReg, int64_t Scale,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">                             unsigned AddrSpace = 0,</td>
    <td class="lineNumber">706</td>
    <td class="codeline">                             unsigned AddrSpace = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">                             Instruction *I = nullptr) const;</td>
    <td class="lineNumber">707</td>
    <td class="codeline">                             Instruction *I = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  /// Return true if LSR cost of C1 is lower than C2.</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  /// Return true if LSR cost of C1 is lower than C2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">                     const TargetTransformInfo::LSRCost &C2) const;</td>
    <td class="lineNumber">711</td>
    <td class="codeline">                     const TargetTransformInfo::LSRCost &C2) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  /// Return true if LSR major cost is number of registers. Targets which</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  /// Return true if LSR major cost is number of registers. Targets which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  /// implement their own isLSRCostLess and unset number of registers as major</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  /// implement their own isLSRCostLess and unset number of registers as major</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">  /// cost should return false, otherwise return true.</td>
    <td class="lineNumber">715</td>
    <td class="codeline">  /// cost should return false, otherwise return true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  bool isNumRegsMajorCostOfLSR() const;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  bool isNumRegsMajorCostOfLSR() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline"></td>
    <td class="lineNumber">717</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  /// \returns true if LSR should not optimize a chain that includes \p I.</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  /// \returns true if LSR should not optimize a chain that includes \p I.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  bool isProfitableLSRChainElement(Instruction *I) const;</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  bool isProfitableLSRChainElement(Instruction *I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  /// Return true if the target can fuse a compare and branch.</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  /// Return true if the target can fuse a compare and branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  /// Loop-strength-reduction (LSR) uses that knowledge to adjust its cost</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  /// Loop-strength-reduction (LSR) uses that knowledge to adjust its cost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  /// calculation for the instructions in a loop.</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  /// calculation for the instructions in a loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">  bool canMacroFuseCmp() const;</td>
    <td class="lineNumber">724</td>
    <td class="codeline">  bool canMacroFuseCmp() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline"></td>
    <td class="lineNumber">725</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">  /// Return true if the target can save a compare for loop count, for example</td>
    <td class="lineNumber">726</td>
    <td class="codeline">  /// Return true if the target can save a compare for loop count, for example</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">  /// hardware loop saves a compare.</td>
    <td class="lineNumber">727</td>
    <td class="codeline">  /// hardware loop saves a compare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
    <td class="lineNumber">728</td>
    <td class="codeline">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">                  DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">729</td>
    <td class="codeline">                  DominatorTree *DT, AssumptionCache *AC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">                  TargetLibraryInfo *LibInfo) const;</td>
    <td class="lineNumber">730</td>
    <td class="codeline">                  TargetLibraryInfo *LibInfo) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline"></td>
    <td class="lineNumber">731</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  enum AddressingModeKind {</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  enum AddressingModeKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">    AMK_PreIndexed,</td>
    <td class="lineNumber">733</td>
    <td class="codeline">    AMK_PreIndexed,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    AMK_PostIndexed,</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    AMK_PostIndexed,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    AMK_None</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    AMK_None</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  /// Return the preferred addressing mode LSR should make efforts to generate.</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  /// Return the preferred addressing mode LSR should make efforts to generate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  AddressingModeKind getPreferredAddressingMode(const Loop *L,</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  AddressingModeKind getPreferredAddressingMode(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">                                                ScalarEvolution *SE) const;</td>
    <td class="lineNumber">740</td>
    <td class="codeline">                                                ScalarEvolution *SE) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">  /// Return true if the target supports masked store.</td>
    <td class="lineNumber">742</td>
    <td class="codeline">  /// Return true if the target supports masked store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">  bool isLegalMaskedStore(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">743</td>
    <td class="codeline">  bool isLegalMaskedStore(Type *DataType, Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  /// Return true if the target supports masked load.</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  /// Return true if the target supports masked load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  /// Return true if the target supports nontemporal store.</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  /// Return true if the target supports nontemporal store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  bool isLegalNTStore(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  bool isLegalNTStore(Type *DataType, Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  /// Return true if the target supports nontemporal load.</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  /// Return true if the target supports nontemporal load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">  bool isLegalNTLoad(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">750</td>
    <td class="codeline">  bool isLegalNTLoad(Type *DataType, Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">  /// \Returns true if the target supports broadcasting a load to a vector of</td>
    <td class="lineNumber">752</td>
    <td class="codeline">  /// \Returns true if the target supports broadcasting a load to a vector of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  /// type <NumElements x ElementTy>.</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  /// type <NumElements x ElementTy>.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">  bool isLegalBroadcastLoad(Type *ElementTy, ElementCount NumElements) const;</td>
    <td class="lineNumber">754</td>
    <td class="codeline">  bool isLegalBroadcastLoad(Type *ElementTy, ElementCount NumElements) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  /// Return true if the target supports masked scatter.</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  /// Return true if the target supports masked scatter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  /// Return true if the target supports masked gather.</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  /// Return true if the target supports masked gather.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">  bool isLegalMaskedGather(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">759</td>
    <td class="codeline">  bool isLegalMaskedGather(Type *DataType, Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">  /// Return true if the target forces scalarizing of llvm.masked.gather</td>
    <td class="lineNumber">760</td>
    <td class="codeline">  /// Return true if the target forces scalarizing of llvm.masked.gather</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">  /// intrinsics.</td>
    <td class="lineNumber">761</td>
    <td class="codeline">  /// intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">  bool forceScalarizeMaskedGather(VectorType *Type, Align Alignment) const;</td>
    <td class="lineNumber">762</td>
    <td class="codeline">  bool forceScalarizeMaskedGather(VectorType *Type, Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">  /// Return true if the target forces scalarizing of llvm.masked.scatter</td>
    <td class="lineNumber">763</td>
    <td class="codeline">  /// Return true if the target forces scalarizing of llvm.masked.scatter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">  /// intrinsics.</td>
    <td class="lineNumber">764</td>
    <td class="codeline">  /// intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">  bool forceScalarizeMaskedScatter(VectorType *Type, Align Alignment) const;</td>
    <td class="lineNumber">765</td>
    <td class="codeline">  bool forceScalarizeMaskedScatter(VectorType *Type, Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  /// Return true if the target supports masked compress store.</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  /// Return true if the target supports masked compress store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">  bool isLegalMaskedCompressStore(Type *DataType) const;</td>
    <td class="lineNumber">768</td>
    <td class="codeline">  bool isLegalMaskedCompressStore(Type *DataType) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  /// Return true if the target supports masked expand load.</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  /// Return true if the target supports masked expand load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">  bool isLegalMaskedExpandLoad(Type *DataType) const;</td>
    <td class="lineNumber">770</td>
    <td class="codeline">  bool isLegalMaskedExpandLoad(Type *DataType) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  /// Return true if this is an alternating opcode pattern that can be lowered</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  /// Return true if this is an alternating opcode pattern that can be lowered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">  /// to a single instruction on the target. In X86 this is for the addsub</td>
    <td class="lineNumber">773</td>
    <td class="codeline">  /// to a single instruction on the target. In X86 this is for the addsub</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">  /// instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.</td>
    <td class="lineNumber">774</td>
    <td class="codeline">  /// instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">  /// This function expectes two opcodes: \p Opcode1 and \p Opcode2 being</td>
    <td class="lineNumber">775</td>
    <td class="codeline">  /// This function expectes two opcodes: \p Opcode1 and \p Opcode2 being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  /// when \p Opcode0 is selected and `1` when Opcode1 is selected.</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  /// when \p Opcode0 is selected and `1` when Opcode1 is selected.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">  /// \p VecTy is the vector type of the instruction to be generated.</td>
    <td class="lineNumber">778</td>
    <td class="codeline">  /// \p VecTy is the vector type of the instruction to be generated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
    <td class="lineNumber">779</td>
    <td class="codeline">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">                       const SmallBitVector &OpcodeMask) const;</td>
    <td class="lineNumber">780</td>
    <td class="codeline">                       const SmallBitVector &OpcodeMask) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  /// Return true if we should be enabling ordered reductions for the target.</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  /// Return true if we should be enabling ordered reductions for the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  bool enableOrderedReductions() const;</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  bool enableOrderedReductions() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">  /// Return true if the target has a unified operation to calculate division</td>
    <td class="lineNumber">785</td>
    <td class="codeline">  /// Return true if the target has a unified operation to calculate division</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  /// and remainder. If so, the additional implicit multiplication and</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  /// and remainder. If so, the additional implicit multiplication and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  /// subtraction required to calculate a remainder from division are free. This</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  /// subtraction required to calculate a remainder from division are free. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">  /// can enable more aggressive transformations for division and remainder than</td>
    <td class="lineNumber">788</td>
    <td class="codeline">  /// can enable more aggressive transformations for division and remainder than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  /// would typically be allowed using throughput or size cost models.</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  /// would typically be allowed using throughput or size cost models.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  bool hasDivRemOp(Type *DataType, bool IsSigned) const;</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  bool hasDivRemOp(Type *DataType, bool IsSigned) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  /// Return true if the given instruction (assumed to be a memory access</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  /// Return true if the given instruction (assumed to be a memory access</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  /// instruction) has a volatile variant. If that's the case then we can avoid</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  /// instruction) has a volatile variant. If that's the case then we can avoid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  /// addrspacecast to generic AS for volatile loads/stores. Default</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  /// addrspacecast to generic AS for volatile loads/stores. Default</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">  /// implementation returns false, which prevents address space inference for</td>
    <td class="lineNumber">795</td>
    <td class="codeline">  /// implementation returns false, which prevents address space inference for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">  /// volatile loads/stores.</td>
    <td class="lineNumber">796</td>
    <td class="codeline">  /// volatile loads/stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) const;</td>
    <td class="lineNumber">797</td>
    <td class="codeline">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline"></td>
    <td class="lineNumber">798</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">  /// Return true if target doesn't mind addresses in vectors.</td>
    <td class="lineNumber">799</td>
    <td class="codeline">  /// Return true if target doesn't mind addresses in vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">  bool prefersVectorizedAddressing() const;</td>
    <td class="lineNumber">800</td>
    <td class="codeline">  bool prefersVectorizedAddressing() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline"></td>
    <td class="lineNumber">801</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">  /// Return the cost of the scaling factor used in the addressing</td>
    <td class="lineNumber">802</td>
    <td class="codeline">  /// Return the cost of the scaling factor used in the addressing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">  /// mode represented by AM for this target, for a load/store</td>
    <td class="lineNumber">803</td>
    <td class="codeline">  /// mode represented by AM for this target, for a load/store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  /// of the specified type.</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  /// of the specified type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  /// If the AM is supported, the return value must be >= 0.</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  /// If the AM is supported, the return value must be >= 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  /// If the AM is not supported, it returns a negative value.</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  /// If the AM is not supported, it returns a negative value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">  /// TODO: Handle pre/postinc as well.</td>
    <td class="lineNumber">807</td>
    <td class="codeline">  /// TODO: Handle pre/postinc as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">809</td>
    <td class="codeline">                                       int64_t BaseOffset, bool HasBaseReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">                                       int64_t Scale,</td>
    <td class="lineNumber">810</td>
    <td class="codeline">                                       int64_t Scale,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">                                       unsigned AddrSpace = 0) const;</td>
    <td class="lineNumber">811</td>
    <td class="codeline">                                       unsigned AddrSpace = 0) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  /// Return true if the loop strength reduce pass should make</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  /// Return true if the loop strength reduce pass should make</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  /// Instruction* based TTI queries to isLegalAddressingMode(). This is</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  /// Instruction* based TTI queries to isLegalAddressingMode(). This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">  /// needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned</td>
    <td class="lineNumber">815</td>
    <td class="codeline">  /// needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  /// immediate offset and no index register.</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  /// immediate offset and no index register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  bool LSRWithInstrQueries() const;</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  bool LSRWithInstrQueries() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  /// Return true if it's free to truncate a value of type Ty1 to type</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  /// Return true if it's free to truncate a value of type Ty1 to type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  /// Ty2. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  /// Ty2. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  /// by referencing its sub-register AX.</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  /// by referencing its sub-register AX.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">  bool isTruncateFree(Type *Ty1, Type *Ty2) const;</td>
    <td class="lineNumber">822</td>
    <td class="codeline">  bool isTruncateFree(Type *Ty1, Type *Ty2) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  /// Return true if it is profitable to hoist instruction in the</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  /// Return true if it is profitable to hoist instruction in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  /// then/else to before if.</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  /// then/else to before if.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  bool isProfitableToHoist(Instruction *I) const;</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  bool isProfitableToHoist(Instruction *I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  bool useAA() const;</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  bool useAA() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline"></td>
    <td class="lineNumber">829</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  /// Return true if this type is legal.</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  /// Return true if this type is legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  bool isTypeLegal(Type *Ty) const;</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  bool isTypeLegal(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  /// Returns the estimated number of registers required to represent \p Ty.</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  /// Returns the estimated number of registers required to represent \p Ty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  unsigned getRegUsageForType(Type *Ty) const;</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  unsigned getRegUsageForType(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">  /// Return true if switches should be turned into lookup tables for the</td>
    <td class="lineNumber">836</td>
    <td class="codeline">  /// Return true if switches should be turned into lookup tables for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  /// target.</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  /// target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  bool shouldBuildLookupTables() const;</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  bool shouldBuildLookupTables() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline"></td>
    <td class="lineNumber">839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  /// Return true if switches should be turned into lookup tables</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  /// Return true if switches should be turned into lookup tables</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">  /// containing this constant value for the target.</td>
    <td class="lineNumber">841</td>
    <td class="codeline">  /// containing this constant value for the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  bool shouldBuildLookupTablesForConstant(Constant *C) const;</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  bool shouldBuildLookupTablesForConstant(Constant *C) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline"></td>
    <td class="lineNumber">843</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  /// Return true if lookup tables should be turned into relative lookup tables.</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  /// Return true if lookup tables should be turned into relative lookup tables.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  bool shouldBuildRelLookupTables() const;</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  bool shouldBuildRelLookupTables() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline"></td>
    <td class="lineNumber">846</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  /// Return true if the input function which is cold at all call sites,</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  /// Return true if the input function which is cold at all call sites,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  ///  should use coldcc calling convention.</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  ///  should use coldcc calling convention.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  bool useColdCCForColdCall(Function &F) const;</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  bool useColdCCForColdCall(Function &F) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
    <td class="lineNumber">851</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  /// are set if the demanded result elements need to be inserted and/or</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  /// are set if the demanded result elements need to be inserted and/or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  /// extracted from vectors.</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  /// extracted from vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">855</td>
    <td class="codeline">                                           const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">856</td>
    <td class="codeline">                                           bool Insert, bool Extract,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">857</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline"></td>
    <td class="lineNumber">858</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing an instructions unique</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing an instructions unique</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  /// non-constant operands. The (potentially vector) types to use for each of</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  /// non-constant operands. The (potentially vector) types to use for each of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  /// argument are passes via Tys.</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  /// argument are passes via Tys.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">864</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">865</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  /// If target has efficient vector element load/store instructions, it can</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  /// If target has efficient vector element load/store instructions, it can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  /// return true here so that insertion/extraction costs are not added to</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  /// return true here so that insertion/extraction costs are not added to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  /// the scalarization cost of a load/store.</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  /// the scalarization cost of a load/store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  bool supportsEfficientVectorElementLoadStore() const;</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  bool supportsEfficientVectorElementLoadStore() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline"></td>
    <td class="lineNumber">871</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  /// If the target supports tail calls.</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  /// If the target supports tail calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  bool supportsTailCalls() const;</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  bool supportsTailCalls() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  /// If target supports tail call on \p CB</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  /// If target supports tail call on \p CB</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  bool supportsTailCallFor(const CallBase *CB) const;</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  bool supportsTailCallFor(const CallBase *CB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  /// Don't restrict interleaved unrolling to small loops.</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  /// Don't restrict interleaved unrolling to small loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  bool enableAggressiveInterleaving(bool LoopHasReductions) const;</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  bool enableAggressiveInterleaving(bool LoopHasReductions) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline"></td>
    <td class="lineNumber">880</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">  /// Returns options for expansion of memcmp. IsZeroCmp is</td>
    <td class="lineNumber">881</td>
    <td class="codeline">  /// Returns options for expansion of memcmp. IsZeroCmp is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">  // true if this is the expansion of memcmp(p1, p2, s) == 0.</td>
    <td class="lineNumber">882</td>
    <td class="codeline">  // true if this is the expansion of memcmp(p1, p2, s) == 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  struct MemCmpExpansionOptions {</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  struct MemCmpExpansionOptions {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">    // Return true if memcmp expansion is enabled.</td>
    <td class="lineNumber">884</td>
    <td class="codeline">    // Return true if memcmp expansion is enabled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">    operator bool() const { return MaxNumLoads > 0; }</td>
    <td class="lineNumber">885</td>
    <td class="codeline">    operator bool() const { return MaxNumLoads > 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline"></td>
    <td class="lineNumber">886</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">    // Maximum number of load operations.</td>
    <td class="lineNumber">887</td>
    <td class="codeline">    // Maximum number of load operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">    unsigned MaxNumLoads = 0;</td>
    <td class="lineNumber">888</td>
    <td class="codeline">    unsigned MaxNumLoads = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline"></td>
    <td class="lineNumber">889</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">    // The list of available load sizes (in bytes), sorted in decreasing order.</td>
    <td class="lineNumber">890</td>
    <td class="codeline">    // The list of available load sizes (in bytes), sorted in decreasing order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">    SmallVector<unsigned, 8> LoadSizes;</td>
    <td class="lineNumber">891</td>
    <td class="codeline">    SmallVector<unsigned, 8> LoadSizes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline"></td>
    <td class="lineNumber">892</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">    // For memcmp expansion when the memcmp result is only compared equal or</td>
    <td class="lineNumber">893</td>
    <td class="codeline">    // For memcmp expansion when the memcmp result is only compared equal or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">    // not-equal to 0, allow up to this number of load pairs per block. As an</td>
    <td class="lineNumber">894</td>
    <td class="codeline">    // not-equal to 0, allow up to this number of load pairs per block. As an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">    // example, this may allow 'memcmp(a, b, 3) == 0' in a single block:</td>
    <td class="lineNumber">895</td>
    <td class="codeline">    // example, this may allow 'memcmp(a, b, 3) == 0' in a single block:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    //   a0 = load2bytes &a[0]</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    //   a0 = load2bytes &a[0]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">    //   b0 = load2bytes &b[0]</td>
    <td class="lineNumber">897</td>
    <td class="codeline">    //   b0 = load2bytes &b[0]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">    //   a2 = load1byte  &a[2]</td>
    <td class="lineNumber">898</td>
    <td class="codeline">    //   a2 = load1byte  &a[2]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">    //   b2 = load1byte  &b[2]</td>
    <td class="lineNumber">899</td>
    <td class="codeline">    //   b2 = load1byte  &b[2]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">    //   r  = cmp eq (a0 ^ b0 | a2 ^ b2), 0</td>
    <td class="lineNumber">900</td>
    <td class="codeline">    //   r  = cmp eq (a0 ^ b0 | a2 ^ b2), 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">    unsigned NumLoadsPerBlock = 1;</td>
    <td class="lineNumber">901</td>
    <td class="codeline">    unsigned NumLoadsPerBlock = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">    // Set to true to allow overlapping loads. For example, 7-byte compares can</td>
    <td class="lineNumber">903</td>
    <td class="codeline">    // Set to true to allow overlapping loads. For example, 7-byte compares can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">    // be done with two 4-byte compares instead of 4+2+1-byte compares. This</td>
    <td class="lineNumber">904</td>
    <td class="codeline">    // be done with two 4-byte compares instead of 4+2+1-byte compares. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">    // requires all loads in LoadSizes to be doable in an unaligned way.</td>
    <td class="lineNumber">905</td>
    <td class="codeline">    // requires all loads in LoadSizes to be doable in an unaligned way.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">    bool AllowOverlappingLoads = false;</td>
    <td class="lineNumber">906</td>
    <td class="codeline">    bool AllowOverlappingLoads = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">                                               bool IsZeroCmp) const;</td>
    <td class="lineNumber">909</td>
    <td class="codeline">                                               bool IsZeroCmp) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  /// Should the Select Optimization pass be enabled and ran.</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  /// Should the Select Optimization pass be enabled and ran.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  bool enableSelectOptimize() const;</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  bool enableSelectOptimize() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  /// Enable matching of interleaved access groups.</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  /// Enable matching of interleaved access groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  bool enableInterleavedAccessVectorization() const;</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  bool enableInterleavedAccessVectorization() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  /// Enable matching of interleaved access groups that contain predicated</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  /// Enable matching of interleaved access groups that contain predicated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  /// accesses or gaps and therefore vectorized using masked</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  /// accesses or gaps and therefore vectorized using masked</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">  /// vector loads/stores.</td>
    <td class="lineNumber">919</td>
    <td class="codeline">  /// vector loads/stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">  bool enableMaskedInterleavedAccessVectorization() const;</td>
    <td class="lineNumber">920</td>
    <td class="codeline">  bool enableMaskedInterleavedAccessVectorization() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline"></td>
    <td class="lineNumber">921</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  /// Indicate that it is potentially unsafe to automatically vectorize</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  /// Indicate that it is potentially unsafe to automatically vectorize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">  /// floating-point operations because the semantics of vector and scalar</td>
    <td class="lineNumber">923</td>
    <td class="codeline">  /// floating-point operations because the semantics of vector and scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  /// does not support IEEE-754 denormal numbers, while depending on the</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  /// does not support IEEE-754 denormal numbers, while depending on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">  /// platform, scalar floating-point math does.</td>
    <td class="lineNumber">926</td>
    <td class="codeline">  /// platform, scalar floating-point math does.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">  /// This applies to floating-point math operations and calls, not memory</td>
    <td class="lineNumber">927</td>
    <td class="codeline">  /// This applies to floating-point math operations and calls, not memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">  /// operations, shuffles, or casts.</td>
    <td class="lineNumber">928</td>
    <td class="codeline">  /// operations, shuffles, or casts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">  bool isFPVectorizationPotentiallyUnsafe() const;</td>
    <td class="lineNumber">929</td>
    <td class="codeline">  bool isFPVectorizationPotentiallyUnsafe() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline"></td>
    <td class="lineNumber">930</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">  /// Determine if the target supports unaligned memory accesses.</td>
    <td class="lineNumber">931</td>
    <td class="codeline">  /// Determine if the target supports unaligned memory accesses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">932</td>
    <td class="codeline">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">                                      unsigned AddressSpace = 0,</td>
    <td class="lineNumber">933</td>
    <td class="codeline">                                      unsigned AddressSpace = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">                                      Align Alignment = Align(1),</td>
    <td class="lineNumber">934</td>
    <td class="codeline">                                      Align Alignment = Align(1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">                                      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">935</td>
    <td class="codeline">                                      unsigned *Fast = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline"></td>
    <td class="lineNumber">936</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  /// Return hardware support for population count.</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  /// Return hardware support for population count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) const;</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline"></td>
    <td class="lineNumber">939</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">  /// Return true if the hardware has a fast square-root instruction.</td>
    <td class="lineNumber">940</td>
    <td class="codeline">  /// Return true if the hardware has a fast square-root instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">  bool haveFastSqrt(Type *Ty) const;</td>
    <td class="lineNumber">941</td>
    <td class="codeline">  bool haveFastSqrt(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline"></td>
    <td class="lineNumber">942</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">  /// Return true if the cost of the instruction is too high to speculatively</td>
    <td class="lineNumber">943</td>
    <td class="codeline">  /// Return true if the cost of the instruction is too high to speculatively</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  /// execute and should be kept behind a branch.</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  /// execute and should be kept behind a branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">  /// This normally just wraps around a getInstructionCost() call, but some</td>
    <td class="lineNumber">945</td>
    <td class="codeline">  /// This normally just wraps around a getInstructionCost() call, but some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  /// targets might report a low TCK_SizeAndLatency value that is incompatible</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  /// targets might report a low TCK_SizeAndLatency value that is incompatible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">  /// with the fixed TCC_Expensive value.</td>
    <td class="lineNumber">947</td>
    <td class="codeline">  /// with the fixed TCC_Expensive value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  /// NOTE: This assumes the instruction passes isSafeToSpeculativelyExecute().</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  /// NOTE: This assumes the instruction passes isSafeToSpeculativelyExecute().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">  bool isExpensiveToSpeculativelyExecute(const Instruction *I) const;</td>
    <td class="lineNumber">949</td>
    <td class="codeline">  bool isExpensiveToSpeculativelyExecute(const Instruction *I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline"></td>
    <td class="lineNumber">950</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">  /// Return true if it is faster to check if a floating-point value is NaN</td>
    <td class="lineNumber">951</td>
    <td class="codeline">  /// Return true if it is faster to check if a floating-point value is NaN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">  /// (or not-NaN) versus a comparison against a constant FP zero value.</td>
    <td class="lineNumber">952</td>
    <td class="codeline">  /// (or not-NaN) versus a comparison against a constant FP zero value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">  /// Targets should override this if materializing a 0.0 for comparison is</td>
    <td class="lineNumber">953</td>
    <td class="codeline">  /// Targets should override this if materializing a 0.0 for comparison is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">  /// generally as cheap as checking for ordered/unordered.</td>
    <td class="lineNumber">954</td>
    <td class="codeline">  /// generally as cheap as checking for ordered/unordered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) const;</td>
    <td class="lineNumber">955</td>
    <td class="codeline">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  /// Return the expected cost of supporting the floating point operation</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  /// Return the expected cost of supporting the floating point operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  /// of the specified type.</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  /// of the specified type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">  InstructionCost getFPOpCost(Type *Ty) const;</td>
    <td class="lineNumber">959</td>
    <td class="codeline">  InstructionCost getFPOpCost(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline"></td>
    <td class="lineNumber">960</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  /// Return the expected cost of materializing for the given integer</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  /// Return the expected cost of materializing for the given integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  /// immediate of the specified type.</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  /// immediate of the specified type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">                                TargetCostKind CostKind) const;</td>
    <td class="lineNumber">964</td>
    <td class="codeline">                                TargetCostKind CostKind) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  /// Return the expected cost of materialization for the given integer</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  /// Return the expected cost of materialization for the given integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  /// immediate of the specified type for a given instruction. The cost can be</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  /// immediate of the specified type for a given instruction. The cost can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  /// zero if the immediate can be folded into the specified instruction.</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  /// zero if the immediate can be folded into the specified instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">                                    const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">970</td>
    <td class="codeline">                                    const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">                                    TargetCostKind CostKind,</td>
    <td class="lineNumber">971</td>
    <td class="codeline">                                    TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">                                    Instruction *Inst = nullptr) const;</td>
    <td class="lineNumber">972</td>
    <td class="codeline">                                    Instruction *Inst = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">                                      const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">974</td>
    <td class="codeline">                                      const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">                                      TargetCostKind CostKind) const;</td>
    <td class="lineNumber">975</td>
    <td class="codeline">                                      TargetCostKind CostKind) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline"></td>
    <td class="lineNumber">976</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">  /// Return the expected cost for the given integer when optimising</td>
    <td class="lineNumber">977</td>
    <td class="codeline">  /// Return the expected cost for the given integer when optimising</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  /// for size. This is different than the other integer immediate cost</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  /// for size. This is different than the other integer immediate cost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  /// functions in that it is subtarget agnostic. This is useful when you e.g.</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  /// functions in that it is subtarget agnostic. This is useful when you e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">  /// target one ISA such as Aarch32 but smaller encodings could be possible</td>
    <td class="lineNumber">980</td>
    <td class="codeline">  /// target one ISA such as Aarch32 but smaller encodings could be possible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  /// with another such as Thumb. This return value is used as a penalty when</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  /// with another such as Thumb. This return value is used as a penalty when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  /// the total costs for a constant is calculated (the bigger the cost, the</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  /// the total costs for a constant is calculated (the bigger the cost, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  /// more beneficial constant hoisting is).</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  /// more beneficial constant hoisting is).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">                                        const APInt &Imm, Type *Ty) const;</td>
    <td class="lineNumber">985</td>
    <td class="codeline">                                        const APInt &Imm, Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">  /// \name Vector Target Information</td>
    <td class="lineNumber">988</td>
    <td class="codeline">  /// \name Vector Target Information</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline"></td>
    <td class="lineNumber">990</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">  /// The various kinds of shuffle patterns for vector queries.</td>
    <td class="lineNumber">991</td>
    <td class="codeline">  /// The various kinds of shuffle patterns for vector queries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">  enum ShuffleKind {</td>
    <td class="lineNumber">992</td>
    <td class="codeline">  enum ShuffleKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">    SK_Broadcast,        ///< Broadcast element 0 to all other elements.</td>
    <td class="lineNumber">993</td>
    <td class="codeline">    SK_Broadcast,        ///< Broadcast element 0 to all other elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">    SK_Reverse,          ///< Reverse the order of the vector.</td>
    <td class="lineNumber">994</td>
    <td class="codeline">    SK_Reverse,          ///< Reverse the order of the vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    SK_Select,           ///< Selects elements from the corresponding lane of</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    SK_Select,           ///< Selects elements from the corresponding lane of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">                         ///< either source operand. This is equivalent to a</td>
    <td class="lineNumber">996</td>
    <td class="codeline">                         ///< either source operand. This is equivalent to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">                         ///< vector select with a constant condition operand.</td>
    <td class="lineNumber">997</td>
    <td class="codeline">                         ///< vector select with a constant condition operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">    SK_Transpose,        ///< Transpose two vectors.</td>
    <td class="lineNumber">998</td>
    <td class="codeline">    SK_Transpose,        ///< Transpose two vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">    SK_InsertSubvector,  ///< InsertSubvector. Index indicates start offset.</td>
    <td class="lineNumber">999</td>
    <td class="codeline">    SK_InsertSubvector,  ///< InsertSubvector. Index indicates start offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">    SK_ExtractSubvector, ///< ExtractSubvector Index indicates start offset.</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">    SK_ExtractSubvector, ///< ExtractSubvector Index indicates start offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">    SK_PermuteTwoSrc,    ///< Merge elements from two source vectors into one</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">    SK_PermuteTwoSrc,    ///< Merge elements from two source vectors into one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">                         ///< with any shuffle mask.</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">                         ///< with any shuffle mask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    SK_PermuteSingleSrc, ///< Shuffle elements of single source vector with any</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    SK_PermuteSingleSrc, ///< Shuffle elements of single source vector with any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">                         ///< shuffle mask.</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">                         ///< shuffle mask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">    SK_Splice            ///< Concatenates elements from the first input vector</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">    SK_Splice            ///< Concatenates elements from the first input vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">                         ///< with elements of the second input vector. Returning</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">                         ///< with elements of the second input vector. Returning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">                         ///< a vector of the same type as the input vectors.</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">                         ///< a vector of the same type as the input vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">                         ///< Index indicates start offset in first input vector.</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">                         ///< Index indicates start offset in first input vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  /// Additional information about an operand's possible values.</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  /// Additional information about an operand's possible values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  enum OperandValueKind {</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  enum OperandValueKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">    OK_AnyValue,               // Operand can have any value.</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">    OK_AnyValue,               // Operand can have any value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">    OK_UniformValue,           // Operand is uniform (splat of a value).</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">    OK_UniformValue,           // Operand is uniform (splat of a value).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    OK_UniformConstantValue,   // Operand is uniform constant.</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    OK_UniformConstantValue,   // Operand is uniform constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">    OK_NonUniformConstantValue // Operand is a non uniform constant value.</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">    OK_NonUniformConstantValue // Operand is a non uniform constant value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">  /// Additional properties of an operand's values.</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">  /// Additional properties of an operand's values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">  enum OperandValueProperties {</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">  enum OperandValueProperties {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">    OP_None = 0,</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">    OP_None = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">    OP_PowerOf2 = 1,</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">    OP_PowerOf2 = 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">    OP_NegatedPowerOf2 = 2,</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">    OP_NegatedPowerOf2 = 2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline"></td>
    <td class="lineNumber">1025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">  // Describe the values an operand can take.  We're in the process</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">  // Describe the values an operand can take.  We're in the process</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  // of migrating uses of OperandValueKind and OperandValueProperties</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  // of migrating uses of OperandValueKind and OperandValueProperties</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  // to use this class, and then will change the internal representation.</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  // to use this class, and then will change the internal representation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  struct OperandValueInfo {</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  struct OperandValueInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">    OperandValueKind Kind = OK_AnyValue;</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">    OperandValueKind Kind = OK_AnyValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">    OperandValueProperties Properties = OP_None;</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">    OperandValueProperties Properties = OP_None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">    bool isConstant() const {</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">    bool isConstant() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">      return Kind == OK_UniformConstantValue || Kind == OK_NonUniformConstantValue;</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">      return Kind == OK_UniformConstantValue || Kind == OK_NonUniformConstantValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">    bool isUniform() const {</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">    bool isUniform() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">      return Kind == OK_UniformConstantValue || Kind == OK_UniformValue;</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">      return Kind == OK_UniformConstantValue || Kind == OK_UniformValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">    bool isPowerOf2() const {</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">    bool isPowerOf2() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">      return Properties == OP_PowerOf2;</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">      return Properties == OP_PowerOf2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">    bool isNegatedPowerOf2() const {</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">    bool isNegatedPowerOf2() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">      return Properties == OP_NegatedPowerOf2;</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">      return Properties == OP_NegatedPowerOf2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline"></td>
    <td class="lineNumber">1045</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">    OperandValueInfo getNoProps() const {</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">    OperandValueInfo getNoProps() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">      return {Kind, OP_None};</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">      return {Kind, OP_None};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline"></td>
    <td class="lineNumber">1050</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">  /// \return the number of registers in the target-provided register class.</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">  /// \return the number of registers in the target-provided register class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  unsigned getNumberOfRegisters(unsigned ClassID) const;</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  unsigned getNumberOfRegisters(unsigned ClassID) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline"></td>
    <td class="lineNumber">1053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">  /// \return the target-provided register class ID for the provided type,</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">  /// \return the target-provided register class ID for the provided type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  /// accounting for type promotion and other type-legalization techniques that</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  /// accounting for type promotion and other type-legalization techniques that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  /// the target might apply. However, it specifically does not account for the</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  /// the target might apply. However, it specifically does not account for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  /// scalarization or splitting of vector types. Should a vector type require</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  /// scalarization or splitting of vector types. Should a vector type require</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  /// scalarization or splitting into multiple underlying vector registers, that</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  /// scalarization or splitting into multiple underlying vector registers, that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  /// type should be mapped to a register class containing no registers.</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  /// type should be mapped to a register class containing no registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  /// Specifically, this is designed to provide a simple, high-level view of the</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  /// Specifically, this is designed to provide a simple, high-level view of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  /// register allocation later performed by the backend. These register classes</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  /// register allocation later performed by the backend. These register classes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  /// don't necessarily map onto the register classes used by the backend.</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  /// don't necessarily map onto the register classes used by the backend.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">  /// FIXME: It's not currently possible to determine how many registers</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">  /// FIXME: It's not currently possible to determine how many registers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  /// are used by the provided type.</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  /// are used by the provided type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">  unsigned getRegisterClassForType(bool Vector, Type *Ty = nullptr) const;</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">  unsigned getRegisterClassForType(bool Vector, Type *Ty = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// \return the target-provided register class name</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// \return the target-provided register class name</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">  const char *getRegisterClassName(unsigned ClassID) const;</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">  const char *getRegisterClassName(unsigned ClassID) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  enum RegisterKind { RGK_Scalar, RGK_FixedWidthVector, RGK_ScalableVector };</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  enum RegisterKind { RGK_Scalar, RGK_FixedWidthVector, RGK_ScalableVector };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  /// \return The width of the largest scalar or vector register type.</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  /// \return The width of the largest scalar or vector register type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">  TypeSize getRegisterBitWidth(RegisterKind K) const;</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">  TypeSize getRegisterBitWidth(RegisterKind K) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">  /// \return The width of the smallest vector register type.</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">  /// \return The width of the smallest vector register type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  unsigned getMinVectorRegisterBitWidth() const;</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  unsigned getMinVectorRegisterBitWidth() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline"></td>
    <td class="lineNumber">1077</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">  /// \return The maximum value of vscale if the target specifies an</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">  /// \return The maximum value of vscale if the target specifies an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">  ///  architectural maximum vector length, and std::nullopt otherwise.</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">  ///  architectural maximum vector length, and std::nullopt otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">  std::optional<unsigned> getMaxVScale() const;</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">  std::optional<unsigned> getMaxVScale() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  /// \return the value of vscale to tune the cost model for.</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  /// \return the value of vscale to tune the cost model for.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">  std::optional<unsigned> getVScaleForTuning() const;</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">  std::optional<unsigned> getVScaleForTuning() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline"></td>
    <td class="lineNumber">1084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">  /// \return true if vscale is known to be a power of 2</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">  /// \return true if vscale is known to be a power of 2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">  bool isVScaleKnownToBeAPowerOfTwo() const;</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">  bool isVScaleKnownToBeAPowerOfTwo() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// \return True if the vectorization factor should be chosen to</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// \return True if the vectorization factor should be chosen to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  /// make the vector of the smallest element type match the size of a</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  /// make the vector of the smallest element type match the size of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  /// vector register. For wider element types, this could result in</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  /// vector register. For wider element types, this could result in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">  /// creating vectors that span multiple vector registers.</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">  /// creating vectors that span multiple vector registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  /// If false, the vectorization factor will be chosen based on the</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  /// If false, the vectorization factor will be chosen based on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">  /// size of the widest element type.</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">  /// size of the widest element type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">  /// \p K Register Kind for vectorization.</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">  /// \p K Register Kind for vectorization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">  bool shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const;</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">  bool shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  /// \return The minimum vectorization factor for types of given element</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  /// \return The minimum vectorization factor for types of given element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">  /// bit width, or 0 if there is no minimum VF. The returned value only</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">  /// bit width, or 0 if there is no minimum VF. The returned value only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">  /// applies when shouldMaximizeVectorBandwidth returns true.</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">  /// applies when shouldMaximizeVectorBandwidth returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">  /// If IsScalable is true, the returned ElementCount must be a scalable VF.</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">  /// If IsScalable is true, the returned ElementCount must be a scalable VF.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">  ElementCount getMinimumVF(unsigned ElemWidth, bool IsScalable) const;</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">  ElementCount getMinimumVF(unsigned ElemWidth, bool IsScalable) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline"></td>
    <td class="lineNumber">1102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">  /// \return The maximum vectorization factor for types of given element</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">  /// \return The maximum vectorization factor for types of given element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">  /// bit width and opcode, or 0 if there is no maximum VF.</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">  /// bit width and opcode, or 0 if there is no maximum VF.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// Currently only used by the SLP vectorizer.</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// Currently only used by the SLP vectorizer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const;</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline"></td>
    <td class="lineNumber">1107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  /// \return The minimum vectorization factor for the store instruction. Given</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  /// \return The minimum vectorization factor for the store instruction. Given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">  /// the initial estimation of the minimum vector factor and store value type,</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">  /// the initial estimation of the minimum vector factor and store value type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  /// it tries to find possible lowest VF, which still might be profitable for</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  /// it tries to find possible lowest VF, which still might be profitable for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">  /// the vectorization.</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">  /// the vectorization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  /// \param VF Initial estimation of the minimum vector factor.</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  /// \param VF Initial estimation of the minimum vector factor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  /// \param ScalarMemTy Scalar memory type of the store operation.</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  /// \param ScalarMemTy Scalar memory type of the store operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  /// \param ScalarValTy Scalar type of the stored value.</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  /// \param ScalarValTy Scalar type of the stored value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  /// Currently only used by the SLP vectorizer.</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  /// Currently only used by the SLP vectorizer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">                             Type *ScalarValTy) const;</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">                             Type *ScalarValTy) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline"></td>
    <td class="lineNumber">1118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  /// \return True if it should be considered for address type promotion.</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  /// \return True if it should be considered for address type promotion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  /// \p AllowPromotionWithoutCommonHeader Set true if promoting \p I is</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  /// \p AllowPromotionWithoutCommonHeader Set true if promoting \p I is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  /// profitable without finding other extensions fed by the same input.</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  /// profitable without finding other extensions fed by the same input.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  bool shouldConsiderAddressTypePromotion(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) const;</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline"></td>
    <td class="lineNumber">1124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  /// \return The size of a cache line in bytes.</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  /// \return The size of a cache line in bytes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  unsigned getCacheLineSize() const;</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  unsigned getCacheLineSize() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline"></td>
    <td class="lineNumber">1127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  /// The possible cache levels</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  /// The possible cache levels</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">  enum class CacheLevel {</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">  enum class CacheLevel {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">    L1D, // The L1 data cache</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">    L1D, // The L1 data cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">    L2D, // The L2 data cache</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">    L2D, // The L2 data cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline"></td>
    <td class="lineNumber">1132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">    // We currently do not model L3 caches, as their sizes differ widely between</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">    // We currently do not model L3 caches, as their sizes differ widely between</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">    // microarchitectures. Also, we currently do not have a use for L3 cache</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">    // microarchitectures. Also, we currently do not have a use for L3 cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    // size modeling yet.</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    // size modeling yet.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">  /// \return The size of the cache level in bytes, if available.</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">  /// \return The size of the cache level in bytes, if available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">  std::optional<unsigned> getCacheSize(CacheLevel Level) const;</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">  std::optional<unsigned> getCacheSize(CacheLevel Level) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline"></td>
    <td class="lineNumber">1140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">  /// \return The associativity of the cache level, if available.</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">  /// \return The associativity of the cache level, if available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  std::optional<unsigned> getCacheAssociativity(CacheLevel Level) const;</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  std::optional<unsigned> getCacheAssociativity(CacheLevel Level) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline"></td>
    <td class="lineNumber">1143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">  /// \return How much before a load we should place the prefetch</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">  /// \return How much before a load we should place the prefetch</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  /// instruction.  This is currently measured in number of</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  /// instruction.  This is currently measured in number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">  /// instructions.</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">  /// instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">  unsigned getPrefetchDistance() const;</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">  unsigned getPrefetchDistance() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  /// Some HW prefetchers can handle accesses up to a certain constant stride.</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  /// Some HW prefetchers can handle accesses up to a certain constant stride.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">  /// Sometimes prefetching is beneficial even below the HW prefetcher limit,</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">  /// Sometimes prefetching is beneficial even below the HW prefetcher limit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">  /// and the arguments provided are meant to serve as a basis for deciding this</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">  /// and the arguments provided are meant to serve as a basis for deciding this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">  /// for a particular loop.</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">  /// for a particular loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// \param NumMemAccesses        Number of memory accesses in the loop.</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// \param NumMemAccesses        Number of memory accesses in the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  /// \param NumStridedMemAccesses Number of the memory accesses that</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  /// \param NumStridedMemAccesses Number of the memory accesses that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  ///                              ScalarEvolution could find a known stride</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  ///                              ScalarEvolution could find a known stride</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  ///                              for.</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  ///                              for.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  /// \param NumPrefetches         Number of software prefetches that will be</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  /// \param NumPrefetches         Number of software prefetches that will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">  ///                              emitted as determined by the addresses</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">  ///                              emitted as determined by the addresses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  ///                              involved and the cache line size.</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  ///                              involved and the cache line size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">  /// \param HasCall               True if the loop contains a call.</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">  /// \param HasCall               True if the loop contains a call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// \return This is the minimum stride in bytes where it makes sense to start</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// \return This is the minimum stride in bytes where it makes sense to start</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">  ///         adding SW prefetches. The default is 1, i.e. prefetch with any</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">  ///         adding SW prefetches. The default is 1, i.e. prefetch with any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  ///         stride.</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  ///         stride.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">                                unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">                                unsigned NumStridedMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">                                unsigned NumPrefetches, bool HasCall) const;</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">                                unsigned NumPrefetches, bool HasCall) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline"></td>
    <td class="lineNumber">1169</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  /// the required number of iterations is more than this number, no</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  /// the required number of iterations is more than this number, no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  /// prefetching is performed.</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  /// prefetching is performed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  unsigned getMaxPrefetchIterationsAhead() const;</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  unsigned getMaxPrefetchIterationsAhead() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline"></td>
    <td class="lineNumber">1174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  /// \return True if prefetching should also be done for writes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">  bool enableWritePrefetching() const;</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">  bool enableWritePrefetching() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline"></td>
    <td class="lineNumber">1177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">  /// \return if target want to issue a prefetch in address space \p AS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">  bool shouldPrefetchAddressSpace(unsigned AS) const;</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">  bool shouldPrefetchAddressSpace(unsigned AS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline"></td>
    <td class="lineNumber">1180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">  /// \return The maximum interleave factor that any transform should try to</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">  /// \return The maximum interleave factor that any transform should try to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">  /// perform for this target. This number depends on the level of parallelism</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">  /// perform for this target. This number depends on the level of parallelism</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">  /// and the number of execution units in the CPU.</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">  /// and the number of execution units in the CPU.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">  unsigned getMaxInterleaveFactor(ElementCount VF) const;</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">  unsigned getMaxInterleaveFactor(ElementCount VF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline"></td>
    <td class="lineNumber">1185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">  /// Collect properties of V used in cost analysis, e.g. OP_PowerOf2.</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">  /// Collect properties of V used in cost analysis, e.g. OP_PowerOf2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  static OperandValueInfo getOperandInfo(const Value *V);</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  static OperandValueInfo getOperandInfo(const Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline"></td>
    <td class="lineNumber">1188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// This is an approximation of reciprocal throughput of a math/logic op.</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// This is an approximation of reciprocal throughput of a math/logic op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// A higher cost indicates less expected throughput.</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// A higher cost indicates less expected throughput.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  /// From Agner Fog's guides, reciprocal throughput is "the average number of</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  /// From Agner Fog's guides, reciprocal throughput is "the average number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  /// clock cycles per instruction when the instructions are not part of a</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  /// clock cycles per instruction when the instructions are not part of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  /// limiting dependency chain."</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  /// limiting dependency chain."</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  /// Therefore, costs should be scaled to account for multiple execution units</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  /// Therefore, costs should be scaled to account for multiple execution units</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">  /// on the target that can process this type of instruction. For example, if</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">  /// on the target that can process this type of instruction. For example, if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">  /// there are 5 scalar integer units and 2 vector integer units that can</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">  /// there are 5 scalar integer units and 2 vector integer units that can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">  /// calculate an 'add' in a single cycle, this model should indicate that the</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">  /// calculate an 'add' in a single cycle, this model should indicate that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">  /// cost of the vector add instruction is 2.5 times the cost of the scalar</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">  /// cost of the vector add instruction is 2.5 times the cost of the scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">  /// add instruction.</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">  /// add instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  /// \p Args is an optional argument which holds the instruction operands</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  /// \p Args is an optional argument which holds the instruction operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  /// values so the TTI can analyze those values searching for special</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  /// values so the TTI can analyze those values searching for special</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  /// cases or optimizations based on those values.</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  /// cases or optimizations based on those values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">  /// \p CxtI is the optional original context instruction, if one exists, to</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">  /// \p CxtI is the optional original context instruction, if one exists, to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">  /// provide even more information.</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">  /// provide even more information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  InstructionCost getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">      unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">      unsigned Opcode, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">      const Instruction *CxtI = nullptr) const;</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">      const Instruction *CxtI = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  /// \return The cost of a shuffle instruction of kind Kind and of type Tp.</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  /// \return The cost of a shuffle instruction of kind Kind and of type Tp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  /// The exact mask may be passed as Mask, or else the array will be empty.</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  /// The exact mask may be passed as Mask, or else the array will be empty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">  /// The index and subtype parameters are used by the subvector insertion and</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">  /// The index and subtype parameters are used by the subvector insertion and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  /// extraction shuffle kinds to show the insert/extract point and the type of</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  /// extraction shuffle kinds to show the insert/extract point and the type of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  /// the subvector being inserted/extracted. The operands of the shuffle can be</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  /// the subvector being inserted/extracted. The operands of the shuffle can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  /// passed through \p Args, which helps improve the cost estimation in some</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  /// passed through \p Args, which helps improve the cost estimation in some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">  /// cases, like in broadcast loads.</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">  /// cases, like in broadcast loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  /// NOTE: For subvector extractions Tp represents the source type.</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  /// NOTE: For subvector extractions Tp represents the source type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">                 ArrayRef<int> Mask = std::nullopt,</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">                 ArrayRef<int> Mask = std::nullopt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">                 TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">                 TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">                 int Index = 0, VectorType *SubTp = nullptr,</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">                 int Index = 0, VectorType *SubTp = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">                 ArrayRef<const Value *> Args = std::nullopt) const;</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">                 ArrayRef<const Value *> Args = std::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline"></td>
    <td class="lineNumber">1227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  /// Represents a hint about the context in which a cast is used.</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  /// Represents a hint about the context in which a cast is used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  /// For zext/sext, the context of the cast is the operand, which must be a</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  /// For zext/sext, the context of the cast is the operand, which must be a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  /// load of some kind. For trunc, the context is of the cast is the single</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  /// load of some kind. For trunc, the context is of the cast is the single</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  /// user of the instruction, which must be a store of some kind.</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  /// user of the instruction, which must be a store of some kind.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">  /// This enum allows the vectorizer to give getCastInstrCost an idea of the</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">  /// This enum allows the vectorizer to give getCastInstrCost an idea of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  /// type of cast it's dealing with, as not every cast is equal. For instance,</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  /// type of cast it's dealing with, as not every cast is equal. For instance,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  /// the zext of a load may be free, but the zext of an interleaving load can</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  /// the zext of a load may be free, but the zext of an interleaving load can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  //// be (very) expensive!</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  //// be (very) expensive!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">  /// See \c getCastContextHint to compute a CastContextHint from a cast</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">  /// See \c getCastContextHint to compute a CastContextHint from a cast</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// Instruction*. Callers can use it if they don't need to override the</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// Instruction*. Callers can use it if they don't need to override the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  /// context and just want it to be calculated from the instruction.</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  /// context and just want it to be calculated from the instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  /// FIXME: This handles the types of load/store that the vectorizer can</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  /// FIXME: This handles the types of load/store that the vectorizer can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  /// produce, which are the cases where the context instruction is most</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  /// produce, which are the cases where the context instruction is most</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  /// likely to be incorrect. There are other situations where that can happen</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  /// likely to be incorrect. There are other situations where that can happen</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">  /// too, which might be handled here but in the long run a more general</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">  /// too, which might be handled here but in the long run a more general</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  /// solution of costing multiple instructions at the same times may be better.</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  /// solution of costing multiple instructions at the same times may be better.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  enum class CastContextHint : uint8_t {</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  enum class CastContextHint : uint8_t {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">    None,          ///< The cast is not used with a load/store of any kind.</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">    None,          ///< The cast is not used with a load/store of any kind.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">    Normal,        ///< The cast is used with a normal load/store.</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">    Normal,        ///< The cast is used with a normal load/store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">    Masked,        ///< The cast is used with a masked load/store.</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">    Masked,        ///< The cast is used with a masked load/store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">    GatherScatter, ///< The cast is used with a gather/scatter.</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">    GatherScatter, ///< The cast is used with a gather/scatter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">    Interleave,    ///< The cast is used with an interleaved load/store.</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">    Interleave,    ///< The cast is used with an interleaved load/store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">    Reversed,      ///< The cast is used with a reversed load/store.</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">    Reversed,      ///< The cast is used with a reversed load/store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  /// Calculates a CastContextHint from \p I.</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  /// Calculates a CastContextHint from \p I.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// This should be used by callers of getCastInstrCost if they wish to</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// This should be used by callers of getCastInstrCost if they wish to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  /// determine the context from some instruction.</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  /// determine the context from some instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  /// \returns the CastContextHint for ZExt/SExt/Trunc, None if \p I is nullptr,</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  /// \returns the CastContextHint for ZExt/SExt/Trunc, None if \p I is nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  /// or if it's another type of cast.</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  /// or if it's another type of cast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  static CastContextHint getCastContextHint(const Instruction *I);</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  static CastContextHint getCastContextHint(const Instruction *I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline"></td>
    <td class="lineNumber">1263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  /// \return The expected cost of cast instructions, such as bitcast, trunc,</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  /// \return The expected cost of cast instructions, such as bitcast, trunc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  /// zext, etc. If there is an existing instruction that holds Opcode, it</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  /// zext, etc. If there is an existing instruction that holds Opcode, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">  /// may be passed in the 'I' parameter.</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">  /// may be passed in the 'I' parameter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">                   TTI::CastContextHint CCH,</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">                   TTI::CastContextHint CCH,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">                   TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">                   TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">                   const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">                   const Instruction *I = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  /// \return The expected cost of a sign- or zero-extended vector extract. Use</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  /// \return The expected cost of a sign- or zero-extended vector extract. Use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  /// Index = -1 to indicate that there is no information about the index value.</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  /// Index = -1 to indicate that there is no information about the index value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">                                           VectorType *VecTy,</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">                                           VectorType *VecTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">                                           unsigned Index) const;</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">                                           unsigned Index) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline"></td>
    <td class="lineNumber">1278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  /// \return The expected cost of control-flow related instructions such as</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  /// \return The expected cost of control-flow related instructions such as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// Phi, Ret, Br, Switch.</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// Phi, Ret, Br, Switch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  getCFInstrCost(unsigned Opcode,</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  getCFInstrCost(unsigned Opcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">                 const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">                 const Instruction *I = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  /// \returns The expected cost of compare and select instructions. If there</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  /// \returns The expected cost of compare and select instructions. If there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  /// is an existing instruction that holds Opcode, it may be passed in the</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  /// is an existing instruction that holds Opcode, it may be passed in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">  /// 'I' parameter. The \p VecPred parameter can be used to indicate the select</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">  /// 'I' parameter. The \p VecPred parameter can be used to indicate the select</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// is using a compare with the specified predicate as condition. When vector</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// is using a compare with the specified predicate as condition. When vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  /// types are passed, \p VecPred must be used for all lanes.</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  /// types are passed, \p VecPred must be used for all lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">  getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">  getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">                     CmpInst::Predicate VecPred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">                     TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">                     TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">                     const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">                     const Instruction *I = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline"></td>
    <td class="lineNumber">1296</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">  /// \return The expected cost of vector Insert and Extract.</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">  /// \return The expected cost of vector Insert and Extract.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// Use -1 to indicate that there is no information on the index value.</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// Use -1 to indicate that there is no information on the index value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  /// This is used when the instruction is not available; a typical use</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  /// This is used when the instruction is not available; a typical use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">  /// case is to provision the cost of vectorization/scalarization in</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">  /// case is to provision the cost of vectorization/scalarization in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">  /// vectorizer passes.</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">  /// vectorizer passes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">                                     unsigned Index = -1, Value *Op0 = nullptr,</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">                                     unsigned Index = -1, Value *Op0 = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">                                     Value *Op1 = nullptr) const;</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">                                     Value *Op1 = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline"></td>
    <td class="lineNumber">1306</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">  /// \return The expected cost of vector Insert and Extract.</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">  /// \return The expected cost of vector Insert and Extract.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">  /// This is used when instruction is available, and implementation</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">  /// This is used when instruction is available, and implementation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">  /// asserts 'I' is not nullptr.</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">  /// asserts 'I' is not nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">  /// A typical suitable use case is cost estimation when vector instruction</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">  /// A typical suitable use case is cost estimation when vector instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  /// exists (e.g., from basic blocks during transformation).</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  /// exists (e.g., from basic blocks during transformation).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">                                     unsigned Index = -1) const;</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">                                     unsigned Index = -1) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline"></td>
    <td class="lineNumber">1316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">  /// \return The cost of replication shuffle of \p VF elements typed \p EltTy</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">  /// \return The cost of replication shuffle of \p VF elements typed \p EltTy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  /// \p ReplicationFactor times.</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  /// \p ReplicationFactor times.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  ///   <0,0,0,1,1,1,2,2,2,3,3,3></td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  ///   <0,0,0,1,1,1,2,2,2,3,3,3></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">                                            int VF,</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">                                            int VF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">                                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">                                            const APInt &DemandedDstElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">                                            TTI::TargetCostKind CostKind);</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">                                            TTI::TargetCostKind CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline"></td>
    <td class="lineNumber">1326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  /// \return The cost of Load and Store instructions.</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  /// \return The cost of Load and Store instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">                  unsigned AddressSpace,</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">                  unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">                  TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">                  TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">                  OperandValueInfo OpdInfo = {OK_AnyValue, OP_None},</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">                  OperandValueInfo OpdInfo = {OK_AnyValue, OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">                  const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">                  const Instruction *I = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline"></td>
    <td class="lineNumber">1334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">  /// \return The cost of VP Load and Store instructions.</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">  /// \return The cost of VP Load and Store instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">                    unsigned AddressSpace,</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">                    unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">                    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">                    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">                    const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">                    const Instruction *I = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline"></td>
    <td class="lineNumber">1341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  /// \return The cost of masked Load and Store instructions.</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  /// \return The cost of masked Load and Store instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">  InstructionCost getMaskedMemoryOpCost(</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">  InstructionCost getMaskedMemoryOpCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">      unsigned Opcode, Type *Src, Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">      unsigned Opcode, Type *Src, Align Alignment, unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline"></td>
    <td class="lineNumber">1346</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">  /// \return The cost of Gather or Scatter operation</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">  /// \return The cost of Gather or Scatter operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">  /// \p Opcode - is a type of memory access Load or Store</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">  /// \p Opcode - is a type of memory access Load or Store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">  /// \p DataTy - a vector type of the data to be loaded or stored</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">  /// \p DataTy - a vector type of the data to be loaded or stored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  /// \p Ptr - pointer [or vector of pointers] - address[es] in memory</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  /// \p Ptr - pointer [or vector of pointers] - address[es] in memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">  /// \p VariableMask - true when the memory access is predicated with a mask</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">  /// \p VariableMask - true when the memory access is predicated with a mask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  ///                   that is not a compile-time constant</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  ///                   that is not a compile-time constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  /// \p Alignment - alignment of single element</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  /// \p Alignment - alignment of single element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">  /// \p I - the optional original context instruction, if one exists, e.g. the</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">  /// \p I - the optional original context instruction, if one exists, e.g. the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">  ///        load/store to transform or the call to the gather/scatter intrinsic</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">  ///        load/store to transform or the call to the gather/scatter intrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">  InstructionCost getGatherScatterOpCost(</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">  InstructionCost getGatherScatterOpCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">      unsigned Opcode, Type *DataTy, const Value *Ptr, bool VariableMask,</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">      unsigned Opcode, Type *DataTy, const Value *Ptr, bool VariableMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">      Align Alignment, TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">      Align Alignment, TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">      const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">      const Instruction *I = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline"></td>
    <td class="lineNumber">1360</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">  /// \return The cost of the interleaved memory operation.</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">  /// \return The cost of the interleaved memory operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">  /// \p Opcode is the memory operation code</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">  /// \p Opcode is the memory operation code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  /// \p VecTy is the vector type of the interleaved access.</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  /// \p VecTy is the vector type of the interleaved access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  /// \p Factor is the interleave factor</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  /// \p Factor is the interleave factor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// \p Indices is the indices for interleaved load members (as interleaved</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// \p Indices is the indices for interleaved load members (as interleaved</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">  ///    load allows gaps)</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">  ///    load allows gaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">  /// \p Alignment is the alignment of the memory operation</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">  /// \p Alignment is the alignment of the memory operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  /// \p AddressSpace is address space of the pointer.</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  /// \p AddressSpace is address space of the pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">  /// \p UseMaskForCond indicates if the memory access is predicated.</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">  /// \p UseMaskForCond indicates if the memory access is predicated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  /// \p UseMaskForGaps indicates if gaps should be masked.</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  /// \p UseMaskForGaps indicates if gaps should be masked.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  InstructionCost getInterleavedMemoryOpCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">      Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">      Align Alignment, unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">      bool UseMaskForCond = false, bool UseMaskForGaps = false) const;</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">      bool UseMaskForCond = false, bool UseMaskForGaps = false) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">  /// A helper function to determine the type of reduction algorithm used</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">  /// A helper function to determine the type of reduction algorithm used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  /// for a given \p Opcode and set of FastMathFlags \p FMF.</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  /// for a given \p Opcode and set of FastMathFlags \p FMF.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">  static bool requiresOrderedReduction(std::optional<FastMathFlags> FMF) {</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">  static bool requiresOrderedReduction(std::optional<FastMathFlags> FMF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">    return FMF && !(*FMF).allowReassoc();</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">    return FMF && !(*FMF).allowReassoc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">  /// Calculate the cost of vector reduction intrinsics.</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">  /// Calculate the cost of vector reduction intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">  /// This is the cost of reducing the vector value of type \p Ty to a scalar</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">  /// This is the cost of reducing the vector value of type \p Ty to a scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">  /// value using the operation denoted by \p Opcode. The FastMathFlags</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">  /// value using the operation denoted by \p Opcode. The FastMathFlags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">  /// parameter \p FMF indicates what type of reduction we are performing:</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">  /// parameter \p FMF indicates what type of reduction we are performing:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">  ///   1. Tree-wise. This is the typical 'fast' reduction performed that</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">  ///   1. Tree-wise. This is the typical 'fast' reduction performed that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">  ///   involves successively splitting a vector into half and doing the</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">  ///   involves successively splitting a vector into half and doing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">  ///   operation on the pair of halves until you have a scalar value. For</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">  ///   operation on the pair of halves until you have a scalar value. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  ///   example:</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  ///   example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  ///     (v0, v1, v2, v3)</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  ///     (v0, v1, v2, v3)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">  ///     ((v0+v2), (v1+v3), undef, undef)</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">  ///     ((v0+v2), (v1+v3), undef, undef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  ///     ((v0+v2+v1+v3), undef, undef, undef)</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  ///     ((v0+v2+v1+v3), undef, undef, undef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">  ///   This is the default behaviour for integer operations, whereas for</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">  ///   This is the default behaviour for integer operations, whereas for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">  ///   floating point we only do this if \p FMF indicates that</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">  ///   floating point we only do this if \p FMF indicates that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  ///   reassociation is allowed.</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  ///   reassociation is allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">  ///   2. Ordered. For a vector with N elements this involves performing N</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">  ///   2. Ordered. For a vector with N elements this involves performing N</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">  ///   operations in lane order, starting with an initial scalar value, i.e.</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">  ///   operations in lane order, starting with an initial scalar value, i.e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  ///     result = InitVal + v0</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  ///     result = InitVal + v0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  ///     result = result + v1</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  ///     result = result + v1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  ///     result = result + v2</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  ///     result = result + v2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">  ///     result = result + v3</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">  ///     result = result + v3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">  ///   This is only the case for FP operations and when reassociation is not</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">  ///   This is only the case for FP operations and when reassociation is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">  ///   allowed.</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">  ///   allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">  InstructionCost getArithmeticReductionCost(</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">  InstructionCost getArithmeticReductionCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">      unsigned Opcode, VectorType *Ty, std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">      unsigned Opcode, VectorType *Ty, std::optional<FastMathFlags> FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline"></td>
    <td class="lineNumber">1410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">  InstructionCost getMinMaxReductionCost(</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">  InstructionCost getMinMaxReductionCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">      Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF = FastMathFlags(),</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">      Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF = FastMathFlags(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline"></td>
    <td class="lineNumber">1414</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">  /// Calculate the cost of an extended reduction pattern, similar to</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">  /// Calculate the cost of an extended reduction pattern, similar to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">  /// getArithmeticReductionCost of an Add reduction with multiply and optional</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">  /// getArithmeticReductionCost of an Add reduction with multiply and optional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">  /// extensions. This is the cost of as:</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">  /// extensions. This is the cost of as:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">  /// ResTy vecreduce.add(mul (A, B)).</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">  /// ResTy vecreduce.add(mul (A, B)).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">  /// ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)).</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">  /// ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">  InstructionCost getMulAccReductionCost(</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">  InstructionCost getMulAccReductionCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline"></td>
    <td class="lineNumber">1423</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">  /// Calculate the cost of an extended reduction pattern, similar to</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">  /// Calculate the cost of an extended reduction pattern, similar to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">  /// getArithmeticReductionCost of a reduction with an extension.</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">  /// getArithmeticReductionCost of a reduction with an extension.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">  /// This is the cost of as:</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">  /// This is the cost of as:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">  /// ResTy vecreduce.opcode(ext(Ty A)).</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">  /// ResTy vecreduce.opcode(ext(Ty A)).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  InstructionCost getExtendedReductionCost(</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  InstructionCost getExtendedReductionCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">      FastMathFlags FMF,</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">      FastMathFlags FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline"></td>
    <td class="lineNumber">1432</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">  /// \returns The cost of Intrinsic instructions. Analyses the real arguments.</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">  /// \returns The cost of Intrinsic instructions. Analyses the real arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">  /// Three cases are handled: 1. scalar instruction 2. vector instruction</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">  /// Three cases are handled: 1. scalar instruction 2. vector instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">  /// 3. scalar instruction which is to be vectorized.</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">  /// 3. scalar instruction which is to be vectorized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline"></td>
    <td class="lineNumber">1438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">  /// \returns The cost of Call instructions.</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">  /// \returns The cost of Call instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">  InstructionCost getCallInstrCost(</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">  InstructionCost getCallInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">      Function *F, Type *RetTy, ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">      Function *F, Type *RetTy, ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) const;</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">  /// \returns The number of pieces into which the provided type must be</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">  /// \returns The number of pieces into which the provided type must be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">  /// split during legalization. Zero is returned when the answer is unknown.</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">  /// split during legalization. Zero is returned when the answer is unknown.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">  unsigned getNumberOfParts(Type *Tp) const;</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">  unsigned getNumberOfParts(Type *Tp) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">  /// \returns The cost of the address computation. For most targets this can be</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">  /// \returns The cost of the address computation. For most targets this can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">  /// merged into the instruction indexing mode. Some targets might want to</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">  /// merged into the instruction indexing mode. Some targets might want to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">  /// distinguish between address computation for memory operations on vector</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">  /// distinguish between address computation for memory operations on vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  /// types and scalar types. Such targets should override this function.</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  /// types and scalar types. Such targets should override this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">  /// The 'SE' parameter holds pointer for the scalar evolution object which</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">  /// The 'SE' parameter holds pointer for the scalar evolution object which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">  /// is used in order to get the Ptr step value in case of constant stride.</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">  /// is used in order to get the Ptr step value in case of constant stride.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">  /// The 'Ptr' parameter holds SCEV of the access pointer.</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">  /// The 'Ptr' parameter holds SCEV of the access pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">  InstructionCost getAddressComputationCost(Type *Ty,</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">  InstructionCost getAddressComputationCost(Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">                                            ScalarEvolution *SE = nullptr,</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">                                            ScalarEvolution *SE = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">                                            const SCEV *Ptr = nullptr) const;</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">                                            const SCEV *Ptr = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline"></td>
    <td class="lineNumber">1458</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">  /// \returns The cost, if any, of keeping values of the given types alive</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">  /// \returns The cost, if any, of keeping values of the given types alive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">  /// over a callsite.</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">  /// over a callsite.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">  /// Some types may require the use of register classes that do not have</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">  /// Some types may require the use of register classes that do not have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">  /// any callee-saved registers, so would require a spill and fill.</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">  /// any callee-saved registers, so would require a spill and fill.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) const;</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline"></td>
    <td class="lineNumber">1465</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  /// \returns True if the intrinsic is a supported memory intrinsic.  Info</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  /// \returns True if the intrinsic is a supported memory intrinsic.  Info</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  /// will contain additional information - whether the intrinsic may write</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  /// will contain additional information - whether the intrinsic may write</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  /// or read to memory, volatility and the pointer.  Info is undefined</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  /// or read to memory, volatility and the pointer.  Info is undefined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  /// if false is returned.</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  /// if false is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">  bool getTgtMemIntrinsic(IntrinsicInst *Inst, MemIntrinsicInfo &Info) const;</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">  bool getTgtMemIntrinsic(IntrinsicInst *Inst, MemIntrinsicInfo &Info) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline"></td>
    <td class="lineNumber">1471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">  /// \returns The maximum element size, in bytes, for an element</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">  /// \returns The maximum element size, in bytes, for an element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">  /// unordered-atomic memory intrinsic.</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">  /// unordered-atomic memory intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">  unsigned getAtomicMemIntrinsicMaxElementSize() const;</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">  unsigned getAtomicMemIntrinsicMaxElementSize() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline"></td>
    <td class="lineNumber">1475</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  /// \returns A value which is the result of the given memory intrinsic.  New</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  /// \returns A value which is the result of the given memory intrinsic.  New</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">  /// instructions may be created to extract the result from the given intrinsic</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">  /// instructions may be created to extract the result from the given intrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">  /// memory operation.  Returns nullptr if the target cannot create a result</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">  /// memory operation.  Returns nullptr if the target cannot create a result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">  /// from the given intrinsic.</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">  /// from the given intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">                                           Type *ExpectedType) const;</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">                                           Type *ExpectedType) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline"></td>
    <td class="lineNumber">1482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  /// \returns The type to use in a loop expansion of a memcpy call.</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  /// \returns The type to use in a loop expansion of a memcpy call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">  Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">  Type *getMemcpyLoopLoweringType(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">      std::optional<uint32_t> AtomicElementSize = std::nullopt) const;</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">      std::optional<uint32_t> AtomicElementSize = std::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">  /// \param[out] OpsOut The operand types to copy RemainingBytes of memory.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">  /// \param[out] OpsOut The operand types to copy RemainingBytes of memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  /// \param RemainingBytes The number of bytes to copy.</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  /// \param RemainingBytes The number of bytes to copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  /// Calculates the operand types to use when copying \p RemainingBytes of</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  /// Calculates the operand types to use when copying \p RemainingBytes of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  /// memory, where source and destination alignments are \p SrcAlign and</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  /// memory, where source and destination alignments are \p SrcAlign and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  /// \p DestAlign respectively.</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  /// \p DestAlign respectively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">  void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">  void getMemcpyLoopResidualLoweringType(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">      unsigned SrcAlign, unsigned DestAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">      std::optional<uint32_t> AtomicCpySize = std::nullopt) const;</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">      std::optional<uint32_t> AtomicCpySize = std::nullopt) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline"></td>
    <td class="lineNumber">1500</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">  /// \returns True if the two functions have compatible attributes for inlining</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">  /// \returns True if the two functions have compatible attributes for inlining</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">  /// purposes.</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">  /// purposes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">  bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">  bool areInlineCompatible(const Function *Caller,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">                           const Function *Callee) const;</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">                           const Function *Callee) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline"></td>
    <td class="lineNumber">1505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  /// \returns True if the caller and callee agree on how \p Types will be</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  /// \returns True if the caller and callee agree on how \p Types will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  /// passed to or returned from the callee.</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  /// passed to or returned from the callee.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  /// to the callee.</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  /// to the callee.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">  /// \param Types List of types to check.</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">  /// \param Types List of types to check.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">                             const ArrayRef<Type *> &Types) const;</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">                             const ArrayRef<Type *> &Types) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline"></td>
    <td class="lineNumber">1512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">  /// The type of load/store indexing.</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">  /// The type of load/store indexing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">  enum MemIndexedMode {</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">  enum MemIndexedMode {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">    MIM_Unindexed, ///< No indexing.</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">    MIM_Unindexed, ///< No indexing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">    MIM_PreInc,    ///< Pre-incrementing.</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">    MIM_PreInc,    ///< Pre-incrementing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">    MIM_PreDec,    ///< Pre-decrementing.</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">    MIM_PreDec,    ///< Pre-decrementing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">    MIM_PostInc,   ///< Post-incrementing.</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">    MIM_PostInc,   ///< Post-incrementing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">    MIM_PostDec    ///< Post-decrementing.</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">    MIM_PostDec    ///< Post-decrementing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline"></td>
    <td class="lineNumber">1521</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">  /// \returns True if the specified indexed load for the given type is legal.</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">  /// \returns True if the specified indexed load for the given type is legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">  bool isIndexedLoadLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">  bool isIndexedLoadLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline"></td>
    <td class="lineNumber">1524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">  /// \returns True if the specified indexed store for the given type is legal.</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">  /// \returns True if the specified indexed store for the given type is legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">  bool isIndexedStoreLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">  bool isIndexedStoreLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline"></td>
    <td class="lineNumber">1527</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">  /// \returns The bitwidth of the largest vector type that should be used to</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">  /// \returns The bitwidth of the largest vector type that should be used to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">  /// load/store in the given address space.</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">  /// load/store in the given address space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const;</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
    <td class="lineNumber">1531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">  /// \returns True if the load instruction is legal to vectorize.</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">  /// \returns True if the load instruction is legal to vectorize.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">  bool isLegalToVectorizeLoad(LoadInst *LI) const;</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">  bool isLegalToVectorizeLoad(LoadInst *LI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline"></td>
    <td class="lineNumber">1534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">  /// \returns True if the store instruction is legal to vectorize.</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">  /// \returns True if the store instruction is legal to vectorize.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">  bool isLegalToVectorizeStore(StoreInst *SI) const;</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">  bool isLegalToVectorizeStore(StoreInst *SI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline"></td>
    <td class="lineNumber">1537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  /// \returns True if it is legal to vectorize the given load chain.</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  /// \returns True if it is legal to vectorize the given load chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">                                   unsigned AddrSpace) const;</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">                                   unsigned AddrSpace) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline"></td>
    <td class="lineNumber">1541</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">  /// \returns True if it is legal to vectorize the given store chain.</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">  /// \returns True if it is legal to vectorize the given store chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">                                    unsigned AddrSpace) const;</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">                                    unsigned AddrSpace) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline"></td>
    <td class="lineNumber">1545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  /// \returns True if it is legal to vectorize the given reduction kind.</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  /// \returns True if it is legal to vectorize the given reduction kind.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">                                   ElementCount VF) const;</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">                                   ElementCount VF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline"></td>
    <td class="lineNumber">1549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  /// \returns True if the given type is supported for scalable vectors</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  /// \returns True if the given type is supported for scalable vectors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">  bool isElementTypeLegalForScalableVector(Type *Ty) const;</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">  bool isElementTypeLegalForScalableVector(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  /// \returns The new vector factor value if the target doesn't support \p</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  /// \returns The new vector factor value if the target doesn't support \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">  /// SizeInBytes loads or has a better vector factor.</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">  /// SizeInBytes loads or has a better vector factor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">                               unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">                               unsigned ChainSizeInBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">                               VectorType *VecTy) const;</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">                               VectorType *VecTy) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline"></td>
    <td class="lineNumber">1558</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  /// \returns The new vector factor value if the target doesn't support \p</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  /// \returns The new vector factor value if the target doesn't support \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">  /// SizeInBytes stores or has a better vector factor.</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">  /// SizeInBytes stores or has a better vector factor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">                                unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">                                unsigned ChainSizeInBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">                                VectorType *VecTy) const;</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">                                VectorType *VecTy) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline"></td>
    <td class="lineNumber">1564</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">  /// Flags describing the kind of vector reduction.</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">  /// Flags describing the kind of vector reduction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">  struct ReductionFlags {</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">  struct ReductionFlags {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">    ReductionFlags() = default;</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">    ReductionFlags() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">    bool IsMaxOp =</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">    bool IsMaxOp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">        false; ///< If the op a min/max kind, true if it's a max operation.</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">        false; ///< If the op a min/max kind, true if it's a max operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">    bool IsSigned = false; ///< Whether the operation is a signed int reduction.</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">    bool IsSigned = false; ///< Whether the operation is a signed int reduction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">    bool NoNaN =</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">    bool NoNaN =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">        false; ///< If op is an fp min/max, whether NaNs may be present.</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">        false; ///< If op is an fp min/max, whether NaNs may be present.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
    <td class="lineNumber">1574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">  /// \returns True if the target prefers reductions in loop.</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">  /// \returns True if the target prefers reductions in loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">                             ReductionFlags Flags) const;</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">                             ReductionFlags Flags) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  /// \returns True if the target prefers reductions select kept in the loop</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  /// \returns True if the target prefers reductions select kept in the loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">  /// when tail folding. i.e.</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">  /// when tail folding. i.e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">  /// loop:</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">  /// loop:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">  ///   p = phi (0, s)</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">  ///   p = phi (0, s)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">  ///   a = add (p, x)</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">  ///   a = add (p, x)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">  ///   s = select (mask, a, p)</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">  ///   s = select (mask, a, p)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">  /// vecreduce.add(s)</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">  /// vecreduce.add(s)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">  /// As opposed to the normal scheme of p = phi (0, a) which allows the select</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">  /// As opposed to the normal scheme of p = phi (0, a) which allows the select</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">  /// to be pulled out of the loop. If the select(.., add, ..) can be predicated</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">  /// to be pulled out of the loop. If the select(.., add, ..) can be predicated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">  /// by the target, this can lead to cleaner code generation.</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">  /// by the target, this can lead to cleaner code generation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">                                       ReductionFlags Flags) const;</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">                                       ReductionFlags Flags) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline"></td>
    <td class="lineNumber">1592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">  /// Return true if the loop vectorizer should consider vectorizing an</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">  /// Return true if the loop vectorizer should consider vectorizing an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">  /// otherwise scalar epilogue loop.</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">  /// otherwise scalar epilogue loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">  bool preferEpilogueVectorization() const;</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">  bool preferEpilogueVectorization() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline"></td>
    <td class="lineNumber">1596</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">  /// \returns True if the target wants to expand the given reduction intrinsic</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">  /// \returns True if the target wants to expand the given reduction intrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">  /// into a shuffle sequence.</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">  /// into a shuffle sequence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">  bool shouldExpandReduction(const IntrinsicInst *II) const;</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">  bool shouldExpandReduction(const IntrinsicInst *II) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline"></td>
    <td class="lineNumber">1600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">  /// \returns the size cost of rematerializing a GlobalValue address relative</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">  /// \returns the size cost of rematerializing a GlobalValue address relative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">  /// to a stack reload.</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">  /// to a stack reload.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">  unsigned getGISelRematGlobalCost() const;</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">  unsigned getGISelRematGlobalCost() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">  /// \returns the lower bound of a trip count to decide on vectorization</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">  /// \returns the lower bound of a trip count to decide on vectorization</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">  /// while tail-folding.</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">  /// while tail-folding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">  unsigned getMinTripCountTailFoldingThreshold() const;</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">  unsigned getMinTripCountTailFoldingThreshold() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline"></td>
    <td class="lineNumber">1608</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">  /// \returns True if the target supports scalable vectors.</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">  /// \returns True if the target supports scalable vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">  bool supportsScalableVectors() const;</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">  bool supportsScalableVectors() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline"></td>
    <td class="lineNumber">1611</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">  /// \return true when scalable vectorization is preferred.</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">  /// \return true when scalable vectorization is preferred.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">  bool enableScalableVectorization() const;</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">  bool enableScalableVectorization() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline"></td>
    <td class="lineNumber">1614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">  /// \name Vector Predication Information</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">  /// \name Vector Predication Information</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">  /// Whether the target supports the %evl parameter of VP intrinsic efficiently</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">  /// Whether the target supports the %evl parameter of VP intrinsic efficiently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">  /// in hardware, for the given opcode and type/alignment. (see LLVM Language</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">  /// in hardware, for the given opcode and type/alignment. (see LLVM Language</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">  /// Reference - "Vector Predication Intrinsics").</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">  /// Reference - "Vector Predication Intrinsics").</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">  /// Use of %evl is discouraged when that is not the case.</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">  /// Use of %evl is discouraged when that is not the case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">                             Align Alignment) const;</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">                             Align Alignment) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline"></td>
    <td class="lineNumber">1623</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">  struct VPLegalization {</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">  struct VPLegalization {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">    enum VPTransform {</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">    enum VPTransform {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">      // keep the predicating parameter</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">      // keep the predicating parameter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">      Legal = 0,</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">      Legal = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">      // where legal, discard the predicate parameter</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">      // where legal, discard the predicate parameter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">      Discard = 1,</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">      Discard = 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">      // transform into something else that is also predicating</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">      // transform into something else that is also predicating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">      Convert = 2</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">      Convert = 2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline"></td>
    <td class="lineNumber">1633</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">    // How to transform the EVL parameter.</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">    // How to transform the EVL parameter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">    // Legal:   keep the EVL parameter as it is.</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">    // Legal:   keep the EVL parameter as it is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">    // Discard: Ignore the EVL parameter where it is safe to do so.</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">    // Discard: Ignore the EVL parameter where it is safe to do so.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">    // Convert: Fold the EVL into the mask parameter.</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">    // Convert: Fold the EVL into the mask parameter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">    VPTransform EVLParamStrategy;</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">    VPTransform EVLParamStrategy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline"></td>
    <td class="lineNumber">1639</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">    // How to transform the operator.</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">    // How to transform the operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">    // Legal:   The target supports this operator.</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">    // Legal:   The target supports this operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">    // Convert: Convert this to a non-VP operation.</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">    // Convert: Convert this to a non-VP operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">    // The 'Discard' strategy is invalid.</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">    // The 'Discard' strategy is invalid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">    VPTransform OpStrategy;</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">    VPTransform OpStrategy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline"></td>
    <td class="lineNumber">1645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">    bool shouldDoNothing() const {</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">    bool shouldDoNothing() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">      return (EVLParamStrategy == Legal) && (OpStrategy == Legal);</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">      return (EVLParamStrategy == Legal) && (OpStrategy == Legal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">    VPLegalization(VPTransform EVLParamStrategy, VPTransform OpStrategy)</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">    VPLegalization(VPTransform EVLParamStrategy, VPTransform OpStrategy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">        : EVLParamStrategy(EVLParamStrategy), OpStrategy(OpStrategy) {}</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">        : EVLParamStrategy(EVLParamStrategy), OpStrategy(OpStrategy) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline"></td>
    <td class="lineNumber">1652</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  /// \returns How the target needs this vector-predicated operation to be</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  /// \returns How the target needs this vector-predicated operation to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">  /// transformed.</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">  /// transformed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">  VPLegalization getVPLegalizationStrategy(const VPIntrinsic &PI) const;</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">  VPLegalization getVPLegalizationStrategy(const VPIntrinsic &PI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">  /// \returns Whether a 32-bit branch instruction is available in Arm or Thumb</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">  /// \returns Whether a 32-bit branch instruction is available in Arm or Thumb</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">  /// state.</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">  /// state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">  /// Used by the LowerTypeTests pass, which constructs an IR inline assembler</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">  /// Used by the LowerTypeTests pass, which constructs an IR inline assembler</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">  /// node containing a jump table in a format suitable for the target, so it</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">  /// node containing a jump table in a format suitable for the target, so it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  /// needs to know what format of jump table it can legally use.</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  /// needs to know what format of jump table it can legally use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">  /// For non-Arm targets, this function isn't used. It defaults to returning</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">  /// For non-Arm targets, this function isn't used. It defaults to returning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">  /// false, but it shouldn't matter what it returns anyway.</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">  /// false, but it shouldn't matter what it returns anyway.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">  bool hasArmWideBranch(bool Thumb) const;</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">  bool hasArmWideBranch(bool Thumb) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline"></td>
    <td class="lineNumber">1668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">  /// \return The maximum number of function arguments the target supports.</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">  /// \return The maximum number of function arguments the target supports.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">  unsigned getMaxNumArgs() const;</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">  unsigned getMaxNumArgs() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline"></td>
    <td class="lineNumber">1673</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">  /// The abstract base class used to type erase specific TTI</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">  /// The abstract base class used to type erase specific TTI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">  /// implementations.</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">  /// implementations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  class Concept;</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  class Concept;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  /// The template model for the base class which wraps a concrete</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  /// The template model for the base class which wraps a concrete</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  /// implementation in a type erased interface.</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  /// implementation in a type erased interface.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">  template <typename T> class Model;</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">  template <typename T> class Model;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline"></td>
    <td class="lineNumber">1682</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  std::unique_ptr<Concept> TTIImpl;</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  std::unique_ptr<Concept> TTIImpl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline"></td>
    <td class="lineNumber">1685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">class TargetTransformInfo::Concept {</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">class TargetTransformInfo::Concept {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">  virtual ~Concept() = 0;</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">  virtual ~Concept() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">  virtual const DataLayout &getDataLayout() const = 0;</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">  virtual const DataLayout &getDataLayout() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">  virtual InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">  virtual InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">                                     ArrayRef<const Value *> Operands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">                                     Type *AccessType,</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">                                     Type *AccessType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">                       const TTI::PointersChainInfo &Info, Type *AccessTy,</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">                       const TTI::PointersChainInfo &Info, Type *AccessTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">                       TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">                       TTI::TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">  virtual unsigned getInliningThresholdMultiplier() const = 0;</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">  virtual unsigned getInliningThresholdMultiplier() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">  virtual unsigned adjustInliningThreshold(const CallBase *CB) = 0;</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">  virtual unsigned adjustInliningThreshold(const CallBase *CB) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">  virtual int getInlinerVectorBonusPercent() const = 0;</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">  virtual int getInlinerVectorBonusPercent() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">  virtual unsigned getCallerAllocaCost(const CallBase *CB,</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">  virtual unsigned getCallerAllocaCost(const CallBase *CB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">                                       const AllocaInst *AI) const = 0;</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">                                       const AllocaInst *AI) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">  virtual InstructionCost getMemcpyCost(const Instruction *I) = 0;</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">  virtual InstructionCost getMemcpyCost(const Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">  virtual uint64_t getMaxMemIntrinsicInlineSizeThreshold() const = 0;</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">  virtual uint64_t getMaxMemIntrinsicInlineSizeThreshold() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">  virtual unsigned</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">  virtual unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  getEstimatedNumberOfCaseClusters(const SwitchInst &SI, unsigned &JTSize,</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  getEstimatedNumberOfCaseClusters(const SwitchInst &SI, unsigned &JTSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">                                   ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">                                   ProfileSummaryInfo *PSI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">                                   BlockFrequencyInfo *BFI) = 0;</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">                                   BlockFrequencyInfo *BFI) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">  virtual InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">  virtual InstructionCost getInstructionCost(const User *U,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">                                             ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">                                             ArrayRef<const Value *> Operands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">                                             TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">                                             TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">  virtual BranchProbability getPredictableBranchThreshold() = 0;</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">  virtual BranchProbability getPredictableBranchThreshold() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  virtual bool hasBranchDivergence(const Function *F = nullptr) = 0;</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  virtual bool hasBranchDivergence(const Function *F = nullptr) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  virtual bool isSourceOfDivergence(const Value *V) = 0;</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  virtual bool isSourceOfDivergence(const Value *V) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">  virtual bool isAlwaysUniform(const Value *V) = 0;</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">  virtual bool isAlwaysUniform(const Value *V) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">  virtual bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">  virtual bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">  virtual bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const = 0;</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">  virtual bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">  virtual unsigned getFlatAddressSpace() = 0;</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">  virtual unsigned getFlatAddressSpace() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  virtual bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  virtual bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">                                          Intrinsic::ID IID) const = 0;</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">                                          Intrinsic::ID IID) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">  virtual bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">  virtual bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const = 0;</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">  virtual unsigned getAssumedAddrSpace(const Value *V) const = 0;</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">  virtual unsigned getAssumedAddrSpace(const Value *V) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">  virtual bool isSingleThreaded() const = 0;</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">  virtual bool isSingleThreaded() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">  virtual std::pair<const Value *, unsigned></td>
    <td class="lineNumber">1726</td>
    <td class="codeline">  virtual std::pair<const Value *, unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">  getPredicatedAddrSpace(const Value *V) const = 0;</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">  getPredicatedAddrSpace(const Value *V) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  virtual Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II,</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  virtual Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">                                                  Value *OldV,</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">                                                  Value *OldV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">                                                  Value *NewV) const = 0;</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">                                                  Value *NewV) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">  virtual bool isLoweredToCall(const Function *F) = 0;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">  virtual bool isLoweredToCall(const Function *F) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">  virtual void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">  virtual void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">                                       UnrollingPreferences &UP,</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">                                       UnrollingPreferences &UP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">                                       OptimizationRemarkEmitter *ORE) = 0;</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">                                       OptimizationRemarkEmitter *ORE) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">  virtual void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">  virtual void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">                                     PeelingPreferences &PP) = 0;</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">                                     PeelingPreferences &PP) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">  virtual bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">  virtual bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">                                        AssumptionCache &AC,</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">                                        AssumptionCache &AC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">                                        TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">                                        TargetLibraryInfo *LibInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">                                        HardwareLoopInfo &HWLoopInfo) = 0;</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">                                        HardwareLoopInfo &HWLoopInfo) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">  virtual bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) = 0;</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">  virtual bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">  virtual TailFoldingStyle</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">  virtual TailFoldingStyle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) = 0;</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">  virtual std::optional<Instruction *> instCombineIntrinsic(</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">  virtual std::optional<Instruction *> instCombineIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II) = 0;</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">  virtual std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">  virtual std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedMask,</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">      KnownBits & Known, bool &KnownBitsComputed) = 0;</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">      KnownBits & Known, bool &KnownBitsComputed) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">  virtual std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">  virtual std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts,</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">      APInt &UndefElts, APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">      APInt &UndefElts, APInt &UndefElts2, APInt &UndefElts3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">1752</td>
    <td class="codeline">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">          SimplifyAndSetOp) = 0;</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">          SimplifyAndSetOp) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">  virtual bool isLegalAddImmediate(int64_t Imm) = 0;</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">  virtual bool isLegalAddImmediate(int64_t Imm) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">  virtual bool isLegalICmpImmediate(int64_t Imm) = 0;</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">  virtual bool isLegalICmpImmediate(int64_t Imm) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">  virtual bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">  virtual bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">                                     int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">                                     int64_t BaseOffset, bool HasBaseReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">                                     int64_t Scale, unsigned AddrSpace,</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">                                     int64_t Scale, unsigned AddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">                                     Instruction *I) = 0;</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">                                     Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">  virtual bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">  virtual bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">                             const TargetTransformInfo::LSRCost &C2) = 0;</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">                             const TargetTransformInfo::LSRCost &C2) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">  virtual bool isNumRegsMajorCostOfLSR() = 0;</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">  virtual bool isNumRegsMajorCostOfLSR() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">  virtual bool isProfitableLSRChainElement(Instruction *I) = 0;</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">  virtual bool isProfitableLSRChainElement(Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">  virtual bool canMacroFuseCmp() = 0;</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">  virtual bool canMacroFuseCmp() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">  virtual bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE,</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">  virtual bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">                          LoopInfo *LI, DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">                          LoopInfo *LI, DominatorTree *DT, AssumptionCache *AC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">                          TargetLibraryInfo *LibInfo) = 0;</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">                          TargetLibraryInfo *LibInfo) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">  virtual AddressingModeKind</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">  virtual AddressingModeKind</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">    getPreferredAddressingMode(const Loop *L, ScalarEvolution *SE) const = 0;</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">    getPreferredAddressingMode(const Loop *L, ScalarEvolution *SE) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  virtual bool isLegalMaskedStore(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  virtual bool isLegalMaskedStore(Type *DataType, Align Alignment) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">  virtual bool isLegalMaskedLoad(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">  virtual bool isLegalMaskedLoad(Type *DataType, Align Alignment) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">  virtual bool isLegalNTStore(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">  virtual bool isLegalNTStore(Type *DataType, Align Alignment) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">  virtual bool isLegalNTLoad(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">  virtual bool isLegalNTLoad(Type *DataType, Align Alignment) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">  virtual bool isLegalBroadcastLoad(Type *ElementTy,</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">  virtual bool isLegalBroadcastLoad(Type *ElementTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">                                    ElementCount NumElements) const = 0;</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">                                    ElementCount NumElements) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">  virtual bool isLegalMaskedScatter(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">  virtual bool isLegalMaskedScatter(Type *DataType, Align Alignment) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  virtual bool isLegalMaskedGather(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  virtual bool isLegalMaskedGather(Type *DataType, Align Alignment) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">  virtual bool forceScalarizeMaskedGather(VectorType *DataType,</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">  virtual bool forceScalarizeMaskedGather(VectorType *DataType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">                                          Align Alignment) = 0;</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">                                          Align Alignment) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">  virtual bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">  virtual bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">                                           Align Alignment) = 0;</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">                                           Align Alignment) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  virtual bool isLegalMaskedCompressStore(Type *DataType) = 0;</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  virtual bool isLegalMaskedCompressStore(Type *DataType) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">  virtual bool isLegalMaskedExpandLoad(Type *DataType) = 0;</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">  virtual bool isLegalMaskedExpandLoad(Type *DataType) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  virtual bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0,</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  virtual bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">                               unsigned Opcode1,</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">                               unsigned Opcode1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">                               const SmallBitVector &OpcodeMask) const = 0;</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">                               const SmallBitVector &OpcodeMask) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">  virtual bool enableOrderedReductions() = 0;</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">  virtual bool enableOrderedReductions() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  virtual bool hasDivRemOp(Type *DataType, bool IsSigned) = 0;</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  virtual bool hasDivRemOp(Type *DataType, bool IsSigned) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">  virtual bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) = 0;</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">  virtual bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  virtual bool prefersVectorizedAddressing() = 0;</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  virtual bool prefersVectorizedAddressing() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">  virtual InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">  virtual InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">                                               int64_t BaseOffset,</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">                                               int64_t BaseOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">                                               bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">                                               bool HasBaseReg, int64_t Scale,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">                                               unsigned AddrSpace) = 0;</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">                                               unsigned AddrSpace) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  virtual bool LSRWithInstrQueries() = 0;</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  virtual bool LSRWithInstrQueries() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  virtual bool isTruncateFree(Type *Ty1, Type *Ty2) = 0;</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  virtual bool isTruncateFree(Type *Ty1, Type *Ty2) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  virtual bool isProfitableToHoist(Instruction *I) = 0;</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  virtual bool isProfitableToHoist(Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  virtual bool useAA() = 0;</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  virtual bool useAA() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">  virtual bool isTypeLegal(Type *Ty) = 0;</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">  virtual bool isTypeLegal(Type *Ty) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">  virtual unsigned getRegUsageForType(Type *Ty) = 0;</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">  virtual unsigned getRegUsageForType(Type *Ty) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">  virtual bool shouldBuildLookupTables() = 0;</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">  virtual bool shouldBuildLookupTables() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">  virtual bool shouldBuildLookupTablesForConstant(Constant *C) = 0;</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">  virtual bool shouldBuildLookupTablesForConstant(Constant *C) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">  virtual bool shouldBuildRelLookupTables() = 0;</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">  virtual bool shouldBuildRelLookupTables() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">  virtual bool useColdCCForColdCall(Function &F) = 0;</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">  virtual bool useColdCCForColdCall(Function &F) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">  virtual InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">  virtual InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">                                                   const APInt &DemandedElts,</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">                                                   const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">                                                   bool Insert, bool Extract,</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">                                                   bool Insert, bool Extract,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">                                                   TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">                                                   TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">                                   TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">                                   TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  virtual bool supportsEfficientVectorElementLoadStore() = 0;</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  virtual bool supportsEfficientVectorElementLoadStore() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">  virtual bool supportsTailCalls() = 0;</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">  virtual bool supportsTailCalls() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">  virtual bool supportsTailCallFor(const CallBase *CB) = 0;</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">  virtual bool supportsTailCallFor(const CallBase *CB) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">  virtual bool enableAggressiveInterleaving(bool LoopHasReductions) = 0;</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">  virtual bool enableAggressiveInterleaving(bool LoopHasReductions) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">  virtual MemCmpExpansionOptions</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">  virtual MemCmpExpansionOptions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">  enableMemCmpExpansion(bool OptSize, bool IsZeroCmp) const = 0;</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">  enableMemCmpExpansion(bool OptSize, bool IsZeroCmp) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">  virtual bool enableSelectOptimize() = 0;</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">  virtual bool enableSelectOptimize() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">  virtual bool enableInterleavedAccessVectorization() = 0;</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">  virtual bool enableInterleavedAccessVectorization() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">  virtual bool enableMaskedInterleavedAccessVectorization() = 0;</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">  virtual bool enableMaskedInterleavedAccessVectorization() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">  virtual bool isFPVectorizationPotentiallyUnsafe() = 0;</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">  virtual bool isFPVectorizationPotentiallyUnsafe() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">  virtual bool allowsMisalignedMemoryAccesses(LLVMContext &Context,</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">  virtual bool allowsMisalignedMemoryAccesses(LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">                                              unsigned BitWidth,</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">                                              unsigned BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">                                              unsigned AddressSpace,</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">                                              unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">                                              Align Alignment,</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">                                              Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">                                              unsigned *Fast) = 0;</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">                                              unsigned *Fast) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">  virtual PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) = 0;</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">  virtual PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">  virtual bool haveFastSqrt(Type *Ty) = 0;</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">  virtual bool haveFastSqrt(Type *Ty) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">  virtual bool isExpensiveToSpeculativelyExecute(const Instruction *I) = 0;</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">  virtual bool isExpensiveToSpeculativelyExecute(const Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">  virtual bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) = 0;</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">  virtual bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">  virtual InstructionCost getFPOpCost(Type *Ty) = 0;</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">  virtual InstructionCost getFPOpCost(Type *Ty) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">  virtual InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">  virtual InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">                                                const APInt &Imm, Type *Ty) = 0;</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">                                                const APInt &Imm, Type *Ty) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">  virtual InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">  virtual InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">                                        TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">                                        TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">  virtual InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">  virtual InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">                                            const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">                                            const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">                                            TargetCostKind CostKind,</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">                                            TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">                                            Instruction *Inst = nullptr) = 0;</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">                                            Instruction *Inst = nullptr) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">  virtual InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">  virtual InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">                                              const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">                                              const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">                                              TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">                                              TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">  virtual unsigned getNumberOfRegisters(unsigned ClassID) const = 0;</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">  virtual unsigned getNumberOfRegisters(unsigned ClassID) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">  virtual unsigned getRegisterClassForType(bool Vector,</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">  virtual unsigned getRegisterClassForType(bool Vector,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">                                           Type *Ty = nullptr) const = 0;</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">                                           Type *Ty = nullptr) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">  virtual const char *getRegisterClassName(unsigned ClassID) const = 0;</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">  virtual const char *getRegisterClassName(unsigned ClassID) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">  virtual TypeSize getRegisterBitWidth(RegisterKind K) const = 0;</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">  virtual TypeSize getRegisterBitWidth(RegisterKind K) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">  virtual unsigned getMinVectorRegisterBitWidth() const = 0;</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">  virtual unsigned getMinVectorRegisterBitWidth() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  virtual std::optional<unsigned> getMaxVScale() const = 0;</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  virtual std::optional<unsigned> getMaxVScale() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">  virtual std::optional<unsigned> getVScaleForTuning() const = 0;</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">  virtual std::optional<unsigned> getVScaleForTuning() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  virtual bool isVScaleKnownToBeAPowerOfTwo() const = 0;</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  virtual bool isVScaleKnownToBeAPowerOfTwo() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">  shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const = 0;</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">  shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">  virtual ElementCount getMinimumVF(unsigned ElemWidth,</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">  virtual ElementCount getMinimumVF(unsigned ElemWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">                                    bool IsScalable) const = 0;</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">                                    bool IsScalable) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">  virtual unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const = 0;</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">  virtual unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">  virtual unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  virtual unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">                                     Type *ScalarValTy) const = 0;</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">                                     Type *ScalarValTy) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  virtual bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  virtual bool shouldConsiderAddressTypePromotion(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) = 0;</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  virtual unsigned getCacheLineSize() const = 0;</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  virtual unsigned getCacheLineSize() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  virtual std::optional<unsigned> getCacheSize(CacheLevel Level) const = 0;</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  virtual std::optional<unsigned> getCacheSize(CacheLevel Level) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">  virtual std::optional<unsigned> getCacheAssociativity(CacheLevel Level)</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">  virtual std::optional<unsigned> getCacheAssociativity(CacheLevel Level)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">      const = 0;</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">      const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline"></td>
    <td class="lineNumber">1866</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">  /// \return How much before a load we should place the prefetch</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">  /// \return How much before a load we should place the prefetch</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">  /// instruction.  This is currently measured in number of</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">  /// instruction.  This is currently measured in number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">  /// instructions.</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">  /// instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">  virtual unsigned getPrefetchDistance() const = 0;</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">  virtual unsigned getPrefetchDistance() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline"></td>
    <td class="lineNumber">1871</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">  /// \return Some HW prefetchers can handle accesses up to a certain</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">  /// \return Some HW prefetchers can handle accesses up to a certain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">  /// constant stride.  This is the minimum stride in bytes where it</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">  /// constant stride.  This is the minimum stride in bytes where it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">  /// makes sense to start adding SW prefetches.  The default is 1,</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">  /// makes sense to start adding SW prefetches.  The default is 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">  /// i.e. prefetch with any stride.  Sometimes prefetching is beneficial</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">  /// i.e. prefetch with any stride.  Sometimes prefetching is beneficial</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">  /// even below the HW prefetcher limit, and the arguments provided are</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">  /// even below the HW prefetcher limit, and the arguments provided are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  /// meant to serve as a basis for deciding this for a particular loop.</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  /// meant to serve as a basis for deciding this for a particular loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">                                        unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">                                        unsigned NumStridedMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">                                        unsigned NumPrefetches,</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">                                        unsigned NumPrefetches,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">                                        bool HasCall) const = 0;</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">                                        bool HasCall) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
    <td class="lineNumber">1882</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">  /// the required number of iterations is more than this number, no</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">  /// the required number of iterations is more than this number, no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">  /// prefetching is performed.</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">  /// prefetching is performed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">  virtual unsigned getMaxPrefetchIterationsAhead() const = 0;</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">  virtual unsigned getMaxPrefetchIterationsAhead() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline"></td>
    <td class="lineNumber">1887</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">  /// \return True if prefetching should also be done for writes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">  virtual bool enableWritePrefetching() const = 0;</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">  virtual bool enableWritePrefetching() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline"></td>
    <td class="lineNumber">1890</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">  /// \return if target want to issue a prefetch in address space \p AS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const = 0;</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline"></td>
    <td class="lineNumber">1893</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">  virtual unsigned getMaxInterleaveFactor(ElementCount VF) = 0;</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">  virtual unsigned getMaxInterleaveFactor(ElementCount VF) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  virtual InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  virtual InstructionCost getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">      ArrayRef<const Value *> Args, const Instruction *CxtI = nullptr) = 0;</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">      ArrayRef<const Value *> Args, const Instruction *CxtI = nullptr) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline"></td>
    <td class="lineNumber">1899</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">  virtual InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">  virtual InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">                                         ArrayRef<int> Mask,</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">                                         ArrayRef<int> Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">                                         int Index, VectorType *SubTp,</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">                                         int Index, VectorType *SubTp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">                                         ArrayRef<const Value *> Args) = 0;</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">                                         ArrayRef<const Value *> Args) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">  virtual InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">  virtual InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">                                           Type *Src, CastContextHint CCH,</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">                                           Type *Src, CastContextHint CCH,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">                                           const Instruction *I) = 0;</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">                                           const Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  virtual InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  virtual InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">                                                   VectorType *VecTy,</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">                                                   VectorType *VecTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">                                                   unsigned Index) = 0;</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">                                                   unsigned Index) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">  virtual InstructionCost getCFInstrCost(unsigned Opcode,</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">  virtual InstructionCost getCFInstrCost(unsigned Opcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">                                         const Instruction *I = nullptr) = 0;</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">                                         const Instruction *I = nullptr) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">  virtual InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy,</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">  virtual InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">                                             Type *CondTy,</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">                                             Type *CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">                                             CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">                                             CmpInst::Predicate VecPred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">                                             const Instruction *I) = 0;</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">                                             const Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">  virtual InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">  virtual InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">                                             unsigned Index, Value *Op0,</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">                                             unsigned Index, Value *Op0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">                                             Value *Op1) = 0;</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">                                             Value *Op1) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  virtual InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  virtual InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">                                             unsigned Index) = 0;</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">                                             unsigned Index) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline"></td>
    <td class="lineNumber">1927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">                            const APInt &DemandedDstElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">                            TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">                            TTI::TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">                  OperandValueInfo OpInfo, const Instruction *I) = 0;</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">                  OperandValueInfo OpInfo, const Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  virtual InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src,</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  virtual InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">                                            Align Alignment,</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">                                            Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">                                            unsigned AddressSpace,</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">                                            unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">                                            TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">                                            TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">                                            const Instruction *I) = 0;</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">                                            const Instruction *I) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">  getMaskedMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">  getMaskedMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">                        unsigned AddressSpace,</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">                        unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">                        TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">                        TTI::TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">                         bool VariableMask, Align Alignment,</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">                         bool VariableMask, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">                         const Instruction *I = nullptr) = 0;</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">                         const Instruction *I = nullptr) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">  virtual InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">  virtual InstructionCost getInterleavedMemoryOpCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">      bool UseMaskForCond = false, bool UseMaskForGaps = false) = 0;</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">      bool UseMaskForCond = false, bool UseMaskForGaps = false) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">                             std::optional<FastMathFlags> FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">                             TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">                             TTI::TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  virtual InstructionCost getExtendedReductionCost(</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  virtual InstructionCost getExtendedReductionCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">      FastMathFlags FMF,</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">      FastMathFlags FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">  virtual InstructionCost getMulAccReductionCost(</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">  virtual InstructionCost getMulAccReductionCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">  getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">  getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">                        TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">                        TTI::TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">  virtual InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">  virtual InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">                                           ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">                                           ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">  virtual unsigned getNumberOfParts(Type *Tp) = 0;</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">  virtual unsigned getNumberOfParts(Type *Tp) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">  getAddressComputationCost(Type *Ty, ScalarEvolution *SE, const SCEV *Ptr) = 0;</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">  getAddressComputationCost(Type *Ty, ScalarEvolution *SE, const SCEV *Ptr) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">  virtual InstructionCost</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">  virtual InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">  getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) = 0;</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">  getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">  virtual bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">  virtual bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">                                  MemIntrinsicInfo &Info) = 0;</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">                                  MemIntrinsicInfo &Info) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">  virtual unsigned getAtomicMemIntrinsicMaxElementSize() const = 0;</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">  virtual unsigned getAtomicMemIntrinsicMaxElementSize() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">  virtual Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">  virtual Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">                                                   Type *ExpectedType) = 0;</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">                                                   Type *ExpectedType) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  virtual Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  virtual Type *getMemcpyLoopLoweringType(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">      std::optional<uint32_t> AtomicElementSize) const = 0;</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">      std::optional<uint32_t> AtomicElementSize) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline"></td>
    <td class="lineNumber">1990</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">  virtual void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">  virtual void getMemcpyLoopResidualLoweringType(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">      unsigned SrcAlign, unsigned DestAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">      std::optional<uint32_t> AtomicCpySize) const = 0;</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">      std::optional<uint32_t> AtomicCpySize) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">  virtual bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">  virtual bool areInlineCompatible(const Function *Caller,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">                                   const Function *Callee) const = 0;</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">                                   const Function *Callee) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">  virtual bool areTypesABICompatible(const Function *Caller,</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">  virtual bool areTypesABICompatible(const Function *Caller,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">                                     const Function *Callee,</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">                                     const Function *Callee,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">                                     const ArrayRef<Type *> &Types) const = 0;</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">                                     const ArrayRef<Type *> &Types) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">  virtual bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">  virtual bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">  virtual bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">  virtual bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">  virtual unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">  virtual unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">  virtual bool isLegalToVectorizeLoad(LoadInst *LI) const = 0;</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">  virtual bool isLegalToVectorizeLoad(LoadInst *LI) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">  virtual bool isLegalToVectorizeStore(StoreInst *SI) const = 0;</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">  virtual bool isLegalToVectorizeStore(StoreInst *SI) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">  virtual bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">  virtual bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">                                           Align Alignment,</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">                                           Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">                                           unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">                                           unsigned AddrSpace) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">  virtual bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">  virtual bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">                                            Align Alignment,</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">                                            Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">                                            unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">                                            unsigned AddrSpace) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  virtual bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  virtual bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">                                           ElementCount VF) const = 0;</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">                                           ElementCount VF) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  virtual bool isElementTypeLegalForScalableVector(Type *Ty) const = 0;</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  virtual bool isElementTypeLegalForScalableVector(Type *Ty) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">  virtual unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">  virtual unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">                                       unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">                                       unsigned ChainSizeInBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">                                       VectorType *VecTy) const = 0;</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">                                       VectorType *VecTy) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">  virtual unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">  virtual unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">                                        unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">                                        unsigned ChainSizeInBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">                                        VectorType *VecTy) const = 0;</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">                                        VectorType *VecTy) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">  virtual bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">  virtual bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">                                     ReductionFlags) const = 0;</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">                                     ReductionFlags) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  virtual bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  virtual bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">                                               ReductionFlags) const = 0;</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">                                               ReductionFlags) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">  virtual bool preferEpilogueVectorization() const = 0;</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">  virtual bool preferEpilogueVectorization() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">  virtual bool shouldExpandReduction(const IntrinsicInst *II) const = 0;</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">  virtual bool shouldExpandReduction(const IntrinsicInst *II) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  virtual unsigned getGISelRematGlobalCost() const = 0;</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  virtual unsigned getGISelRematGlobalCost() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">  virtual unsigned getMinTripCountTailFoldingThreshold() const = 0;</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">  virtual unsigned getMinTripCountTailFoldingThreshold() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">  virtual bool enableScalableVectorization() const = 0;</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">  virtual bool enableScalableVectorization() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">  virtual bool supportsScalableVectors() const = 0;</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">  virtual bool supportsScalableVectors() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">  virtual bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">  virtual bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">                                     Align Alignment) const = 0;</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">                                     Align Alignment) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">  virtual VPLegalization</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">  virtual VPLegalization</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">  getVPLegalizationStrategy(const VPIntrinsic &PI) const = 0;</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">  getVPLegalizationStrategy(const VPIntrinsic &PI) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  virtual bool hasArmWideBranch(bool Thumb) const = 0;</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  virtual bool hasArmWideBranch(bool Thumb) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">  virtual unsigned getMaxNumArgs() const = 0;</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">  virtual unsigned getMaxNumArgs() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline"></td>
    <td class="lineNumber">2039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">2040</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">class TargetTransformInfo::Model final : public TargetTransformInfo::Concept {</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">class TargetTransformInfo::Model final : public TargetTransformInfo::Concept {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">  T Impl;</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">  T Impl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline"></td>
    <td class="lineNumber">2043</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  Model(T Impl) : Impl(std::move(Impl)) {}</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  Model(T Impl) : Impl(std::move(Impl)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">  ~Model() override = default;</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">  ~Model() override = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline"></td>
    <td class="lineNumber">2047</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  const DataLayout &getDataLayout() const override {</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  const DataLayout &getDataLayout() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">    return Impl.getDataLayout();</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">    return Impl.getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline"></td>
    <td class="lineNumber">2051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">             ArrayRef<const Value *> Operands, Type *AccessType,</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">             ArrayRef<const Value *> Operands, Type *AccessType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">             TargetTransformInfo::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">             TargetTransformInfo::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">    return Impl.getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">    return Impl.getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">  InstructionCost getPointersChainCost(ArrayRef<const Value *> Ptrs,</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">  InstructionCost getPointersChainCost(ArrayRef<const Value *> Ptrs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">                                       const Value *Base,</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">                                       const Value *Base,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">                                       const PointersChainInfo &Info,</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">                                       const PointersChainInfo &Info,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">                                       Type *AccessTy,</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">                                       Type *AccessTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">                                       TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">                                       TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">    return Impl.getPointersChainCost(Ptrs, Base, Info, AccessTy, CostKind);</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">    return Impl.getPointersChainCost(Ptrs, Base, Info, AccessTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">  unsigned getInliningThresholdMultiplier() const override {</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">  unsigned getInliningThresholdMultiplier() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">    return Impl.getInliningThresholdMultiplier();</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">    return Impl.getInliningThresholdMultiplier();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">  unsigned adjustInliningThreshold(const CallBase *CB) override {</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">  unsigned adjustInliningThreshold(const CallBase *CB) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">    return Impl.adjustInliningThreshold(CB);</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">    return Impl.adjustInliningThreshold(CB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">  int getInlinerVectorBonusPercent() const override {</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">  int getInlinerVectorBonusPercent() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">    return Impl.getInlinerVectorBonusPercent();</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">    return Impl.getInlinerVectorBonusPercent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">  unsigned getCallerAllocaCost(const CallBase *CB,</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">  unsigned getCallerAllocaCost(const CallBase *CB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">                               const AllocaInst *AI) const override {</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">                               const AllocaInst *AI) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">    return Impl.getCallerAllocaCost(CB, AI);</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">    return Impl.getCallerAllocaCost(CB, AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">  InstructionCost getMemcpyCost(const Instruction *I) override {</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">  InstructionCost getMemcpyCost(const Instruction *I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">    return Impl.getMemcpyCost(I);</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">    return Impl.getMemcpyCost(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline"></td>
    <td class="lineNumber">2081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const override {</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">    return Impl.getMaxMemIntrinsicInlineSizeThreshold();</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">    return Impl.getMaxMemIntrinsicInlineSizeThreshold();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline"></td>
    <td class="lineNumber">2085</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  InstructionCost getInstructionCost(const User *U,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">                                     ArrayRef<const Value *> Operands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">                                     TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">                                     TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">    return Impl.getInstructionCost(U, Operands, CostKind);</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">    return Impl.getInstructionCost(U, Operands, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  BranchProbability getPredictableBranchThreshold() override {</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  BranchProbability getPredictableBranchThreshold() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">    return Impl.getPredictableBranchThreshold();</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">    return Impl.getPredictableBranchThreshold();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">  bool hasBranchDivergence(const Function *F = nullptr) override {</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">  bool hasBranchDivergence(const Function *F = nullptr) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">    return Impl.hasBranchDivergence(F);</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">    return Impl.hasBranchDivergence(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">  bool isSourceOfDivergence(const Value *V) override {</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">  bool isSourceOfDivergence(const Value *V) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">    return Impl.isSourceOfDivergence(V);</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">    return Impl.isSourceOfDivergence(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline"></td>
    <td class="lineNumber">2100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">  bool isAlwaysUniform(const Value *V) override {</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">  bool isAlwaysUniform(const Value *V) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">    return Impl.isAlwaysUniform(V);</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">    return Impl.isAlwaysUniform(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline"></td>
    <td class="lineNumber">2104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">    return Impl.isValidAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">    return Impl.isValidAddrSpaceCast(FromAS, ToAS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline"></td>
    <td class="lineNumber">2108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const override {</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">    return Impl.addrspacesMayAlias(AS0, AS1);</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">    return Impl.addrspacesMayAlias(AS0, AS1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline"></td>
    <td class="lineNumber">2112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">  unsigned getFlatAddressSpace() override { return Impl.getFlatAddressSpace(); }</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  unsigned getFlatAddressSpace() override { return Impl.getFlatAddressSpace(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline"></td>
    <td class="lineNumber">2114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">                                  Intrinsic::ID IID) const override {</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">                                  Intrinsic::ID IID) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">    return Impl.collectFlatAddressOperands(OpIndexes, IID);</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">    return Impl.collectFlatAddressOperands(OpIndexes, IID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline"></td>
    <td class="lineNumber">2119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">    return Impl.isNoopAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">    return Impl.isNoopAddrSpaceCast(FromAS, ToAS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline"></td>
    <td class="lineNumber">2123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">  bool</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">  bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const override {</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">    return Impl.canHaveNonUndefGlobalInitializerInAddressSpace(AS);</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">    return Impl.canHaveNonUndefGlobalInitializerInAddressSpace(AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline"></td>
    <td class="lineNumber">2128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">  unsigned getAssumedAddrSpace(const Value *V) const override {</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">  unsigned getAssumedAddrSpace(const Value *V) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">    return Impl.getAssumedAddrSpace(V);</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">    return Impl.getAssumedAddrSpace(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline"></td>
    <td class="lineNumber">2132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  bool isSingleThreaded() const override { return Impl.isSingleThreaded(); }</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  bool isSingleThreaded() const override { return Impl.isSingleThreaded(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline"></td>
    <td class="lineNumber">2134</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">2135</td>
    <td class="codeline">  std::pair<const Value *, unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">  getPredicatedAddrSpace(const Value *V) const override {</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">  getPredicatedAddrSpace(const Value *V) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">    return Impl.getPredicatedAddrSpace(V);</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">    return Impl.getPredicatedAddrSpace(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline"></td>
    <td class="lineNumber">2139</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">                                          Value *NewV) const override {</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">                                          Value *NewV) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">    return Impl.rewriteIntrinsicWithAddressSpace(II, OldV, NewV);</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">    return Impl.rewriteIntrinsicWithAddressSpace(II, OldV, NewV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline"></td>
    <td class="lineNumber">2144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  bool isLoweredToCall(const Function *F) override {</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  bool isLoweredToCall(const Function *F) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">    return Impl.isLoweredToCall(F);</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">    return Impl.isLoweredToCall(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">                               UnrollingPreferences &UP,</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">                               UnrollingPreferences &UP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">                               OptimizationRemarkEmitter *ORE) override {</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">                               OptimizationRemarkEmitter *ORE) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">    return Impl.getUnrollingPreferences(L, SE, UP, ORE);</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">    return Impl.getUnrollingPreferences(L, SE, UP, ORE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">                             PeelingPreferences &PP) override {</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">                             PeelingPreferences &PP) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">    return Impl.getPeelingPreferences(L, SE, PP);</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">    return Impl.getPeelingPreferences(L, SE, PP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">                                HardwareLoopInfo &HWLoopInfo) override {</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">                                HardwareLoopInfo &HWLoopInfo) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">    return Impl.isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">    return Impl.isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) override {</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">    return Impl.preferPredicateOverEpilogue(TFI);</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">    return Impl.preferPredicateOverEpilogue(TFI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  TailFoldingStyle</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  TailFoldingStyle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) override {</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">    return Impl.getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">    return Impl.getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  std::optional<Instruction *></td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  std::optional<Instruction *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">  instCombineIntrinsic(InstCombiner &IC, IntrinsicInst &II) override {</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">  instCombineIntrinsic(InstCombiner &IC, IntrinsicInst &II) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">    return Impl.instCombineIntrinsic(IC, II);</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">    return Impl.instCombineIntrinsic(IC, II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">  std::optional<Value *></td>
    <td class="lineNumber">2173</td>
    <td class="codeline">  std::optional<Value *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">                                   APInt DemandedMask, KnownBits &Known,</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">                                   APInt DemandedMask, KnownBits &Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">                                   bool &KnownBitsComputed) override {</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">                                   bool &KnownBitsComputed) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">    return Impl.simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">    return Impl.simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">                                                 KnownBitsComputed);</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">                                                 KnownBitsComputed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">      APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">      APInt &UndefElts2, APInt &UndefElts3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">2183</td>
    <td class="codeline">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">          SimplifyAndSetOp) override {</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">          SimplifyAndSetOp) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">    return Impl.simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">    return Impl.simplifyDemandedVectorEltsIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">        SimplifyAndSetOp);</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">        SimplifyAndSetOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">  bool isLegalAddImmediate(int64_t Imm) override {</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">  bool isLegalAddImmediate(int64_t Imm) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">    return Impl.isLegalAddImmediate(Imm);</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">    return Impl.isLegalAddImmediate(Imm);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">  bool isLegalICmpImmediate(int64_t Imm) override {</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">  bool isLegalICmpImmediate(int64_t Imm) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">    return Impl.isLegalICmpImmediate(Imm);</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">    return Impl.isLegalICmpImmediate(Imm);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">                             bool HasBaseReg, int64_t Scale, unsigned AddrSpace,</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">                             bool HasBaseReg, int64_t Scale, unsigned AddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">                             Instruction *I) override {</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">                             Instruction *I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">    return Impl.isLegalAddressingMode(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">    return Impl.isLegalAddressingMode(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">                                      AddrSpace, I);</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">                                      AddrSpace, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">                     const TargetTransformInfo::LSRCost &C2) override {</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">                     const TargetTransformInfo::LSRCost &C2) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">    return Impl.isLSRCostLess(C1, C2);</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">    return Impl.isLSRCostLess(C1, C2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">  bool isNumRegsMajorCostOfLSR() override {</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">  bool isNumRegsMajorCostOfLSR() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">    return Impl.isNumRegsMajorCostOfLSR();</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">    return Impl.isNumRegsMajorCostOfLSR();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">  bool isProfitableLSRChainElement(Instruction *I) override {</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">  bool isProfitableLSRChainElement(Instruction *I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">    return Impl.isProfitableLSRChainElement(I);</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">    return Impl.isProfitableLSRChainElement(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">  bool canMacroFuseCmp() override { return Impl.canMacroFuseCmp(); }</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">  bool canMacroFuseCmp() override { return Impl.canMacroFuseCmp(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">                  DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">                  DominatorTree *DT, AssumptionCache *AC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">                  TargetLibraryInfo *LibInfo) override {</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">                  TargetLibraryInfo *LibInfo) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">    return Impl.canSaveCmp(L, BI, SE, LI, DT, AC, LibInfo);</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">    return Impl.canSaveCmp(L, BI, SE, LI, DT, AC, LibInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">  AddressingModeKind</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">  AddressingModeKind</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">    getPreferredAddressingMode(const Loop *L,</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">    getPreferredAddressingMode(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">                               ScalarEvolution *SE) const override {</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">                               ScalarEvolution *SE) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">    return Impl.getPreferredAddressingMode(L, SE);</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">    return Impl.getPreferredAddressingMode(L, SE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">  bool isLegalMaskedStore(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">  bool isLegalMaskedStore(Type *DataType, Align Alignment) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">    return Impl.isLegalMaskedStore(DataType, Alignment);</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">    return Impl.isLegalMaskedStore(DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">    return Impl.isLegalMaskedLoad(DataType, Alignment);</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">    return Impl.isLegalMaskedLoad(DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">  bool isLegalNTStore(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">  bool isLegalNTStore(Type *DataType, Align Alignment) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">    return Impl.isLegalNTStore(DataType, Alignment);</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">    return Impl.isLegalNTStore(DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">  bool isLegalNTLoad(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">  bool isLegalNTLoad(Type *DataType, Align Alignment) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">    return Impl.isLegalNTLoad(DataType, Alignment);</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">    return Impl.isLegalNTLoad(DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  bool isLegalBroadcastLoad(Type *ElementTy,</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  bool isLegalBroadcastLoad(Type *ElementTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">                            ElementCount NumElements) const override {</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">                            ElementCount NumElements) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">    return Impl.isLegalBroadcastLoad(ElementTy, NumElements);</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">    return Impl.isLegalBroadcastLoad(ElementTy, NumElements);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">    return Impl.isLegalMaskedScatter(DataType, Alignment);</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">    return Impl.isLegalMaskedScatter(DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">  bool isLegalMaskedGather(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">  bool isLegalMaskedGather(Type *DataType, Align Alignment) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">    return Impl.isLegalMaskedGather(DataType, Alignment);</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">    return Impl.isLegalMaskedGather(DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">  bool forceScalarizeMaskedGather(VectorType *DataType,</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">  bool forceScalarizeMaskedGather(VectorType *DataType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">                                  Align Alignment) override {</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">                                  Align Alignment) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">    return Impl.forceScalarizeMaskedGather(DataType, Alignment);</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">    return Impl.forceScalarizeMaskedGather(DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">  bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">  bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">                                   Align Alignment) override {</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">                                   Align Alignment) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">    return Impl.forceScalarizeMaskedScatter(DataType, Alignment);</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">    return Impl.forceScalarizeMaskedScatter(DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">  bool isLegalMaskedCompressStore(Type *DataType) override {</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">  bool isLegalMaskedCompressStore(Type *DataType) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">    return Impl.isLegalMaskedCompressStore(DataType);</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">    return Impl.isLegalMaskedCompressStore(DataType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">  bool isLegalMaskedExpandLoad(Type *DataType) override {</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">  bool isLegalMaskedExpandLoad(Type *DataType) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">    return Impl.isLegalMaskedExpandLoad(DataType);</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">    return Impl.isLegalMaskedExpandLoad(DataType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">                       const SmallBitVector &OpcodeMask) const override {</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">                       const SmallBitVector &OpcodeMask) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    return Impl.isLegalAltInstr(VecTy, Opcode0, Opcode1, OpcodeMask);</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    return Impl.isLegalAltInstr(VecTy, Opcode0, Opcode1, OpcodeMask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">  bool enableOrderedReductions() override {</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">  bool enableOrderedReductions() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">    return Impl.enableOrderedReductions();</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">    return Impl.enableOrderedReductions();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  bool hasDivRemOp(Type *DataType, bool IsSigned) override {</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  bool hasDivRemOp(Type *DataType, bool IsSigned) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">    return Impl.hasDivRemOp(DataType, IsSigned);</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">    return Impl.hasDivRemOp(DataType, IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) override {</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">    return Impl.hasVolatileVariant(I, AddrSpace);</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">    return Impl.hasVolatileVariant(I, AddrSpace);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">  bool prefersVectorizedAddressing() override {</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">  bool prefersVectorizedAddressing() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">    return Impl.prefersVectorizedAddressing();</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">    return Impl.prefersVectorizedAddressing();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">                                       int64_t BaseOffset, bool HasBaseReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">                                       int64_t Scale,</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">                                       int64_t Scale,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">                                       unsigned AddrSpace) override {</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">                                       unsigned AddrSpace) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">    return Impl.getScalingFactorCost(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">    return Impl.getScalingFactorCost(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">                                     AddrSpace);</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">                                     AddrSpace);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">  bool LSRWithInstrQueries() override { return Impl.LSRWithInstrQueries(); }</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">  bool LSRWithInstrQueries() override { return Impl.LSRWithInstrQueries(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">  bool isTruncateFree(Type *Ty1, Type *Ty2) override {</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">  bool isTruncateFree(Type *Ty1, Type *Ty2) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">    return Impl.isTruncateFree(Ty1, Ty2);</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">    return Impl.isTruncateFree(Ty1, Ty2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">  bool isProfitableToHoist(Instruction *I) override {</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">  bool isProfitableToHoist(Instruction *I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">    return Impl.isProfitableToHoist(I);</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">    return Impl.isProfitableToHoist(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">  bool useAA() override { return Impl.useAA(); }</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">  bool useAA() override { return Impl.useAA(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">  bool isTypeLegal(Type *Ty) override { return Impl.isTypeLegal(Ty); }</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">  bool isTypeLegal(Type *Ty) override { return Impl.isTypeLegal(Ty); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">  unsigned getRegUsageForType(Type *Ty) override {</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">  unsigned getRegUsageForType(Type *Ty) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">    return Impl.getRegUsageForType(Ty);</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">    return Impl.getRegUsageForType(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">  bool shouldBuildLookupTables() override {</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">  bool shouldBuildLookupTables() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">    return Impl.shouldBuildLookupTables();</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">    return Impl.shouldBuildLookupTables();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">  bool shouldBuildLookupTablesForConstant(Constant *C) override {</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">  bool shouldBuildLookupTablesForConstant(Constant *C) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">    return Impl.shouldBuildLookupTablesForConstant(C);</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">    return Impl.shouldBuildLookupTablesForConstant(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">  bool shouldBuildRelLookupTables() override {</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">  bool shouldBuildRelLookupTables() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">    return Impl.shouldBuildRelLookupTables();</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">    return Impl.shouldBuildRelLookupTables();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">  bool useColdCCForColdCall(Function &F) override {</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">  bool useColdCCForColdCall(Function &F) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">    return Impl.useColdCCForColdCall(F);</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">    return Impl.useColdCCForColdCall(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline"></td>
    <td class="lineNumber">2305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">                                           const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">                                           bool Insert, bool Extract,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">                                           TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">                                           TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">    return Impl.getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">    return Impl.getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">                                         CostKind);</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">                                         CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">                                   TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">                                   TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">    return Impl.getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">    return Impl.getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline"></td>
    <td class="lineNumber">2319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">  bool supportsEfficientVectorElementLoadStore() override {</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">  bool supportsEfficientVectorElementLoadStore() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">    return Impl.supportsEfficientVectorElementLoadStore();</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">    return Impl.supportsEfficientVectorElementLoadStore();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline"></td>
    <td class="lineNumber">2323</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  bool supportsTailCalls() override { return Impl.supportsTailCalls(); }</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  bool supportsTailCalls() override { return Impl.supportsTailCalls(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">  bool supportsTailCallFor(const CallBase *CB) override {</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">  bool supportsTailCallFor(const CallBase *CB) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">    return Impl.supportsTailCallFor(CB);</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">    return Impl.supportsTailCallFor(CB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline"></td>
    <td class="lineNumber">2328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">  bool enableAggressiveInterleaving(bool LoopHasReductions) override {</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">  bool enableAggressiveInterleaving(bool LoopHasReductions) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">    return Impl.enableAggressiveInterleaving(LoopHasReductions);</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">    return Impl.enableAggressiveInterleaving(LoopHasReductions);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">                                               bool IsZeroCmp) const override {</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">                                               bool IsZeroCmp) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">    return Impl.enableMemCmpExpansion(OptSize, IsZeroCmp);</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">    return Impl.enableMemCmpExpansion(OptSize, IsZeroCmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">  bool enableInterleavedAccessVectorization() override {</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">  bool enableInterleavedAccessVectorization() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">    return Impl.enableInterleavedAccessVectorization();</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">    return Impl.enableInterleavedAccessVectorization();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">  bool enableSelectOptimize() override {</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">  bool enableSelectOptimize() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">    return Impl.enableSelectOptimize();</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">    return Impl.enableSelectOptimize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">  bool enableMaskedInterleavedAccessVectorization() override {</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">  bool enableMaskedInterleavedAccessVectorization() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">    return Impl.enableMaskedInterleavedAccessVectorization();</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">    return Impl.enableMaskedInterleavedAccessVectorization();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">  bool isFPVectorizationPotentiallyUnsafe() override {</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">  bool isFPVectorizationPotentiallyUnsafe() override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">    return Impl.isFPVectorizationPotentiallyUnsafe();</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">    return Impl.isFPVectorizationPotentiallyUnsafe();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">                                      unsigned AddressSpace, Align Alignment,</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">                                      unsigned AddressSpace, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">                                      unsigned *Fast) override {</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">                                      unsigned *Fast) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">    return Impl.allowsMisalignedMemoryAccesses(Context, BitWidth, AddressSpace,</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">    return Impl.allowsMisalignedMemoryAccesses(Context, BitWidth, AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">                                               Alignment, Fast);</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">                                               Alignment, Fast);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) override {</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">    return Impl.getPopcntSupport(IntTyWidthInBit);</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">    return Impl.getPopcntSupport(IntTyWidthInBit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">  bool haveFastSqrt(Type *Ty) override { return Impl.haveFastSqrt(Ty); }</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">  bool haveFastSqrt(Type *Ty) override { return Impl.haveFastSqrt(Ty); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline"></td>
    <td class="lineNumber">2358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">  bool isExpensiveToSpeculativelyExecute(const Instruction* I) override {</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">  bool isExpensiveToSpeculativelyExecute(const Instruction* I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">    return Impl.isExpensiveToSpeculativelyExecute(I);</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">    return Impl.isExpensiveToSpeculativelyExecute(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) override {</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">    return Impl.isFCmpOrdCheaperThanFCmpZero(Ty);</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">    return Impl.isFCmpOrdCheaperThanFCmpZero(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline"></td>
    <td class="lineNumber">2366</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">  InstructionCost getFPOpCost(Type *Ty) override {</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">  InstructionCost getFPOpCost(Type *Ty) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">    return Impl.getFPOpCost(Ty);</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">    return Impl.getFPOpCost(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline"></td>
    <td class="lineNumber">2370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">                                        const APInt &Imm, Type *Ty) override {</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">                                        const APInt &Imm, Type *Ty) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">    return Impl.getIntImmCodeSizeCost(Opc, Idx, Imm, Ty);</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">    return Impl.getIntImmCodeSizeCost(Opc, Idx, Imm, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">                                TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">                                TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">    return Impl.getIntImmCost(Imm, Ty, CostKind);</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">    return Impl.getIntImmCost(Imm, Ty, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">                                    const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">                                    const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">                                    TargetCostKind CostKind,</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">                                    TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">                                    Instruction *Inst = nullptr) override {</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">                                    Instruction *Inst = nullptr) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">    return Impl.getIntImmCostInst(Opc, Idx, Imm, Ty, CostKind, Inst);</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">    return Impl.getIntImmCostInst(Opc, Idx, Imm, Ty, CostKind, Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">                                      const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">                                      const APInt &Imm, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">                                      TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">                                      TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">    return Impl.getIntImmCostIntrin(IID, Idx, Imm, Ty, CostKind);</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">    return Impl.getIntImmCostIntrin(IID, Idx, Imm, Ty, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">  unsigned getNumberOfRegisters(unsigned ClassID) const override {</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">  unsigned getNumberOfRegisters(unsigned ClassID) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">    return Impl.getNumberOfRegisters(ClassID);</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">    return Impl.getNumberOfRegisters(ClassID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">  unsigned getRegisterClassForType(bool Vector,</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">  unsigned getRegisterClassForType(bool Vector,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">                                   Type *Ty = nullptr) const override {</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">                                   Type *Ty = nullptr) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">    return Impl.getRegisterClassForType(Vector, Ty);</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">    return Impl.getRegisterClassForType(Vector, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">  const char *getRegisterClassName(unsigned ClassID) const override {</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">  const char *getRegisterClassName(unsigned ClassID) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">    return Impl.getRegisterClassName(ClassID);</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">    return Impl.getRegisterClassName(ClassID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">  TypeSize getRegisterBitWidth(RegisterKind K) const override {</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">  TypeSize getRegisterBitWidth(RegisterKind K) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">    return Impl.getRegisterBitWidth(K);</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">    return Impl.getRegisterBitWidth(K);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">  unsigned getMinVectorRegisterBitWidth() const override {</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">  unsigned getMinVectorRegisterBitWidth() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">    return Impl.getMinVectorRegisterBitWidth();</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">    return Impl.getMinVectorRegisterBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">  std::optional<unsigned> getMaxVScale() const override {</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">  std::optional<unsigned> getMaxVScale() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">    return Impl.getMaxVScale();</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">    return Impl.getMaxVScale();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">  std::optional<unsigned> getVScaleForTuning() const override {</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">  std::optional<unsigned> getVScaleForTuning() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">    return Impl.getVScaleForTuning();</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">    return Impl.getVScaleForTuning();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">  bool isVScaleKnownToBeAPowerOfTwo() const override {</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">  bool isVScaleKnownToBeAPowerOfTwo() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">    return Impl.isVScaleKnownToBeAPowerOfTwo();</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">    return Impl.isVScaleKnownToBeAPowerOfTwo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">  bool shouldMaximizeVectorBandwidth(</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">  bool shouldMaximizeVectorBandwidth(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">      TargetTransformInfo::RegisterKind K) const override {</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">      TargetTransformInfo::RegisterKind K) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">    return Impl.shouldMaximizeVectorBandwidth(K);</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">    return Impl.shouldMaximizeVectorBandwidth(K);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">  ElementCount getMinimumVF(unsigned ElemWidth,</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">  ElementCount getMinimumVF(unsigned ElemWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">                            bool IsScalable) const override {</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">                            bool IsScalable) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">    return Impl.getMinimumVF(ElemWidth, IsScalable);</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">    return Impl.getMinimumVF(ElemWidth, IsScalable);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const override {</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">    return Impl.getMaximumVF(ElemWidth, Opcode);</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">    return Impl.getMaximumVF(ElemWidth, Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">                             Type *ScalarValTy) const override {</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">                             Type *ScalarValTy) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">    return Impl.getStoreMinimumVF(VF, ScalarMemTy, ScalarValTy);</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">    return Impl.getStoreMinimumVF(VF, ScalarMemTy, ScalarValTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">  bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">  bool shouldConsiderAddressTypePromotion(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) override {</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">    return Impl.shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">    return Impl.shouldConsiderAddressTypePromotion(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">        I, AllowPromotionWithoutCommonHeader);</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">        I, AllowPromotionWithoutCommonHeader);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">  unsigned getCacheLineSize() const override { return Impl.getCacheLineSize(); }</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">  unsigned getCacheLineSize() const override { return Impl.getCacheLineSize(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">  std::optional<unsigned> getCacheSize(CacheLevel Level) const override {</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">  std::optional<unsigned> getCacheSize(CacheLevel Level) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">    return Impl.getCacheSize(Level);</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">    return Impl.getCacheSize(Level);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">  std::optional<unsigned></td>
    <td class="lineNumber">2439</td>
    <td class="codeline">  std::optional<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">  getCacheAssociativity(CacheLevel Level) const override {</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">  getCacheAssociativity(CacheLevel Level) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">    return Impl.getCacheAssociativity(Level);</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">    return Impl.getCacheAssociativity(Level);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline"></td>
    <td class="lineNumber">2443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">  /// Return the preferred prefetch distance in terms of instructions.</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">  /// Return the preferred prefetch distance in terms of instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">  unsigned getPrefetchDistance() const override {</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">  unsigned getPrefetchDistance() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">    return Impl.getPrefetchDistance();</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">    return Impl.getPrefetchDistance();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline"></td>
    <td class="lineNumber">2449</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">  /// Return the minimum stride necessary to trigger software</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">  /// Return the minimum stride necessary to trigger software</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">  /// prefetching.</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">  /// prefetching.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">                                unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">                                unsigned NumStridedMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">                                unsigned NumPrefetches,</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">                                unsigned NumPrefetches,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">                                bool HasCall) const override {</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">                                bool HasCall) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">    return Impl.getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">    return Impl.getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">                                     NumPrefetches, HasCall);</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">                                     NumPrefetches, HasCall);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline"></td>
    <td class="lineNumber">2460</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">  /// Return the maximum prefetch distance in terms of loop</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">  /// Return the maximum prefetch distance in terms of loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">  /// iterations.</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">  /// iterations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">  unsigned getMaxPrefetchIterationsAhead() const override {</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">  unsigned getMaxPrefetchIterationsAhead() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">    return Impl.getMaxPrefetchIterationsAhead();</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">    return Impl.getMaxPrefetchIterationsAhead();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline"></td>
    <td class="lineNumber">2467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">  /// \return True if prefetching should also be done for writes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">  bool enableWritePrefetching() const override {</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">  bool enableWritePrefetching() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">    return Impl.enableWritePrefetching();</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">    return Impl.enableWritePrefetching();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">  /// \return if target want to issue a prefetch in address space \p AS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">  bool shouldPrefetchAddressSpace(unsigned AS) const override {</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">  bool shouldPrefetchAddressSpace(unsigned AS) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">    return Impl.shouldPrefetchAddressSpace(AS);</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">    return Impl.shouldPrefetchAddressSpace(AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline"></td>
    <td class="lineNumber">2477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">  unsigned getMaxInterleaveFactor(ElementCount VF) override {</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">  unsigned getMaxInterleaveFactor(ElementCount VF) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">    return Impl.getMaxInterleaveFactor(VF);</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">    return Impl.getMaxInterleaveFactor(VF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">                                            unsigned &JTSize,</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">                                            unsigned &JTSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">                                            ProfileSummaryInfo *PSI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">                                            BlockFrequencyInfo *BFI) override {</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">                                            BlockFrequencyInfo *BFI) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">    return Impl.getEstimatedNumberOfCaseClusters(SI, JTSize, PSI, BFI);</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">    return Impl.getEstimatedNumberOfCaseClusters(SI, JTSize, PSI, BFI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">  InstructionCost getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">      ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">      ArrayRef<const Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">      const Instruction *CxtI = nullptr) override {</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">      const Instruction *CxtI = nullptr) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">    return Impl.getArithmeticInstrCost(Opcode, Ty, CostKind, Opd1Info, Opd2Info,</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">    return Impl.getArithmeticInstrCost(Opcode, Ty, CostKind, Opd1Info, Opd2Info,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">                                       Args, CxtI);</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">                                       Args, CxtI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline"></td>
    <td class="lineNumber">2495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">  InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">  InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">                                 ArrayRef<int> Mask,</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">                                 ArrayRef<int> Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">                                 TTI::TargetCostKind CostKind, int Index,</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">                                 TTI::TargetCostKind CostKind, int Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">                                 VectorType *SubTp,</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">                                 VectorType *SubTp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">                                 ArrayRef<const Value *> Args) override {</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">                                 ArrayRef<const Value *> Args) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">    return Impl.getShuffleCost(Kind, Tp, Mask, CostKind, Index, SubTp, Args);</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">    return Impl.getShuffleCost(Kind, Tp, Mask, CostKind, Index, SubTp, Args);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">                                   CastContextHint CCH,</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">                                   CastContextHint CCH,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">                                   const Instruction *I) override {</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">                                   const Instruction *I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">    return Impl.getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I);</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">    return Impl.getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">                                           VectorType *VecTy,</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">                                           VectorType *VecTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">                                           unsigned Index) override {</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">                                           unsigned Index) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline">    return Impl.getExtractWithExtendCost(Opcode, Dst, VecTy, Index);</td>
    <td class="lineNumber">2512</td>
    <td class="codeline">    return Impl.getExtractWithExtendCost(Opcode, Dst, VecTy, Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">                                 const Instruction *I = nullptr) override {</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">                                 const Instruction *I = nullptr) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">    return Impl.getCFInstrCost(Opcode, CostKind, I);</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">    return Impl.getCFInstrCost(Opcode, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">                                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">                                     CmpInst::Predicate VecPred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">                                     const Instruction *I) override {</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">                                     const Instruction *I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">    return Impl.getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind, I);</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">    return Impl.getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">                                     unsigned Index, Value *Op0,</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">                                     unsigned Index, Value *Op0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">                                     Value *Op1) override {</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">                                     Value *Op1) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">    return Impl.getVectorInstrCost(Opcode, Val, CostKind, Index, Op0, Op1);</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">    return Impl.getVectorInstrCost(Opcode, Val, CostKind, Index, Op0, Op1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2531</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">                                     unsigned Index) override {</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">                                     unsigned Index) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">    return Impl.getVectorInstrCost(I, Val, CostKind, Index);</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">    return Impl.getVectorInstrCost(I, Val, CostKind, Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">                            const APInt &DemandedDstElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">                            TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">                            TTI::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">    return Impl.getReplicationShuffleCost(EltTy, ReplicationFactor, VF,</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">    return Impl.getReplicationShuffleCost(EltTy, ReplicationFactor, VF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">                                          DemandedDstElts, CostKind);</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">                                          DemandedDstElts, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">  InstructionCost getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">  InstructionCost getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">                                  unsigned AddressSpace,</td>
    <td class="lineNumber">2543</td>
    <td class="codeline">                                  unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">                                  TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">                                  TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">                                  OperandValueInfo OpInfo,</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">                                  OperandValueInfo OpInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">                                  const Instruction *I) override {</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">                                  const Instruction *I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">    return Impl.getMemoryOpCost(Opcode, Src, Alignment, AddressSpace, CostKind,</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">    return Impl.getMemoryOpCost(Opcode, Src, Alignment, AddressSpace, CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">                                OpInfo, I);</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">                                OpInfo, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2549</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">  InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">  InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">                                    unsigned AddressSpace,</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">                                    unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">                                    TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">                                    TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">                                    const Instruction *I) override {</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">                                    const Instruction *I) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline">    return Impl.getVPMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
    <td class="lineNumber">2554</td>
    <td class="codeline">    return Impl.getVPMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">                                  CostKind, I);</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">                                  CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *Src,</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">                                        Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">                                        Align Alignment, unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">    return Impl.getMaskedMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">    return Impl.getMaskedMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">                                      CostKind);</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">                                      CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">                         bool VariableMask, Align Alignment,</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">                         bool VariableMask, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2566</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">                         const Instruction *I = nullptr) override {</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">                         const Instruction *I = nullptr) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">    return Impl.getGatherScatterOpCost(Opcode, DataTy, Ptr, VariableMask,</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">    return Impl.getGatherScatterOpCost(Opcode, DataTy, Ptr, VariableMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">                                       Alignment, CostKind, I);</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">                                       Alignment, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">  InstructionCost getInterleavedMemoryOpCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">      bool UseMaskForCond, bool UseMaskForGaps) override {</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">      bool UseMaskForCond, bool UseMaskForGaps) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">    return Impl.getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">    return Impl.getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">                                           Alignment, AddressSpace, CostKind,</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">                                           Alignment, AddressSpace, CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">                                           UseMaskForCond, UseMaskForGaps);</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">                                           UseMaskForCond, UseMaskForGaps);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">                             std::optional<FastMathFlags> FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">                             TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">                             TTI::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">    return Impl.getArithmeticReductionCost(Opcode, Ty, FMF, CostKind);</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">    return Impl.getArithmeticReductionCost(Opcode, Ty, FMF, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">2585</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">    return Impl.getMinMaxReductionCost(IID, Ty, FMF, CostKind);</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">    return Impl.getMinMaxReductionCost(IID, Ty, FMF, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">  getExtendedReductionCost(unsigned Opcode, bool IsUnsigned, Type *ResTy,</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">  getExtendedReductionCost(unsigned Opcode, bool IsUnsigned, Type *ResTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">                           VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">2592</td>
    <td class="codeline">                           VectorType *Ty, FastMathFlags FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">                           TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">                           TTI::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">    return Impl.getExtendedReductionCost(Opcode, IsUnsigned, ResTy, Ty, FMF,</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">    return Impl.getExtendedReductionCost(Opcode, IsUnsigned, ResTy, Ty, FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">                                         CostKind);</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">                                         CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">2597</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">  getMulAccReductionCost(bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">  getMulAccReductionCost(bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">                         TTI::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline">    return Impl.getMulAccReductionCost(IsUnsigned, ResTy, Ty, CostKind);</td>
    <td class="lineNumber">2600</td>
    <td class="codeline">    return Impl.getMulAccReductionCost(IsUnsigned, ResTy, Ty, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline">    return Impl.getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">2604</td>
    <td class="codeline">    return Impl.getIntrinsicInstrCost(ICA, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">2607</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">    return Impl.getCallInstrCost(F, RetTy, Tys, CostKind);</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">    return Impl.getCallInstrCost(F, RetTy, Tys, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">  unsigned getNumberOfParts(Type *Tp) override {</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">  unsigned getNumberOfParts(Type *Tp) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">    return Impl.getNumberOfParts(Tp);</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">    return Impl.getNumberOfParts(Tp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *SE,</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">                                            const SCEV *Ptr) override {</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">                                            const SCEV *Ptr) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline">    return Impl.getAddressComputationCost(Ty, SE, Ptr);</td>
    <td class="lineNumber">2616</td>
    <td class="codeline">    return Impl.getAddressComputationCost(Ty, SE, Ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) override {</td>
    <td class="lineNumber">2618</td>
    <td class="codeline">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline">    return Impl.getCostOfKeepingLiveOverCall(Tys);</td>
    <td class="lineNumber">2619</td>
    <td class="codeline">    return Impl.getCostOfKeepingLiveOverCall(Tys);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2620</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">  bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">  bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">                          MemIntrinsicInfo &Info) override {</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">                          MemIntrinsicInfo &Info) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">    return Impl.getTgtMemIntrinsic(Inst, Info);</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">    return Impl.getTgtMemIntrinsic(Inst, Info);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2624</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">  unsigned getAtomicMemIntrinsicMaxElementSize() const override {</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">  unsigned getAtomicMemIntrinsicMaxElementSize() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline">    return Impl.getAtomicMemIntrinsicMaxElementSize();</td>
    <td class="lineNumber">2626</td>
    <td class="codeline">    return Impl.getAtomicMemIntrinsicMaxElementSize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">                                           Type *ExpectedType) override {</td>
    <td class="lineNumber">2629</td>
    <td class="codeline">                                           Type *ExpectedType) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">    return Impl.getOrCreateResultFromMemIntrinsic(Inst, ExpectedType);</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">    return Impl.getOrCreateResultFromMemIntrinsic(Inst, ExpectedType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">  Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">2632</td>
    <td class="codeline">  Type *getMemcpyLoopLoweringType(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">      std::optional<uint32_t> AtomicElementSize) const override {</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">      std::optional<uint32_t> AtomicElementSize) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">    return Impl.getMemcpyLoopLoweringType(Context, Length, SrcAddrSpace,</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">    return Impl.getMemcpyLoopLoweringType(Context, Length, SrcAddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">                                          DestAddrSpace, SrcAlign, DestAlign,</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">                                          DestAddrSpace, SrcAlign, DestAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline">                                          AtomicElementSize);</td>
    <td class="lineNumber">2638</td>
    <td class="codeline">                                          AtomicElementSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline">  void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">2640</td>
    <td class="codeline">  void getMemcpyLoopResidualLoweringType(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">      unsigned SrcAlign, unsigned DestAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline">      std::optional<uint32_t> AtomicCpySize) const override {</td>
    <td class="lineNumber">2644</td>
    <td class="codeline">      std::optional<uint32_t> AtomicCpySize) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">    Impl.getMemcpyLoopResidualLoweringType(OpsOut, Context, RemainingBytes,</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">    Impl.getMemcpyLoopResidualLoweringType(OpsOut, Context, RemainingBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">                                           SrcAddrSpace, DestAddrSpace,</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">                                           SrcAddrSpace, DestAddrSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline">                                           SrcAlign, DestAlign, AtomicCpySize);</td>
    <td class="lineNumber">2647</td>
    <td class="codeline">                                           SrcAlign, DestAlign, AtomicCpySize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline">  bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">2649</td>
    <td class="codeline">  bool areInlineCompatible(const Function *Caller,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">                           const Function *Callee) const override {</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">                           const Function *Callee) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline">    return Impl.areInlineCompatible(Caller, Callee);</td>
    <td class="lineNumber">2651</td>
    <td class="codeline">    return Impl.areInlineCompatible(Caller, Callee);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2652</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline">                             const ArrayRef<Type *> &Types) const override {</td>
    <td class="lineNumber">2654</td>
    <td class="codeline">                             const ArrayRef<Type *> &Types) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">    return Impl.areTypesABICompatible(Caller, Callee, Types);</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">    return Impl.areTypesABICompatible(Caller, Callee, Types);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline">  bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
    <td class="lineNumber">2657</td>
    <td class="codeline">  bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline">    return Impl.isIndexedLoadLegal(Mode, Ty, getDataLayout());</td>
    <td class="lineNumber">2658</td>
    <td class="codeline">    return Impl.isIndexedLoadLegal(Mode, Ty, getDataLayout());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2659</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline">  bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
    <td class="lineNumber">2660</td>
    <td class="codeline">  bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline">    return Impl.isIndexedStoreLegal(Mode, Ty, getDataLayout());</td>
    <td class="lineNumber">2661</td>
    <td class="codeline">    return Impl.isIndexedStoreLegal(Mode, Ty, getDataLayout());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const override {</td>
    <td class="lineNumber">2663</td>
    <td class="codeline">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline">    return Impl.getLoadStoreVecRegBitWidth(AddrSpace);</td>
    <td class="lineNumber">2664</td>
    <td class="codeline">    return Impl.getLoadStoreVecRegBitWidth(AddrSpace);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline">  bool isLegalToVectorizeLoad(LoadInst *LI) const override {</td>
    <td class="lineNumber">2666</td>
    <td class="codeline">  bool isLegalToVectorizeLoad(LoadInst *LI) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">    return Impl.isLegalToVectorizeLoad(LI);</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">    return Impl.isLegalToVectorizeLoad(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2668</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">  bool isLegalToVectorizeStore(StoreInst *SI) const override {</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">  bool isLegalToVectorizeStore(StoreInst *SI) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline">    return Impl.isLegalToVectorizeStore(SI);</td>
    <td class="lineNumber">2670</td>
    <td class="codeline">    return Impl.isLegalToVectorizeStore(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2671</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeline">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">2672</td>
    <td class="codeline">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeline">                                   unsigned AddrSpace) const override {</td>
    <td class="lineNumber">2673</td>
    <td class="codeline">                                   unsigned AddrSpace) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeline">    return Impl.isLegalToVectorizeLoadChain(ChainSizeInBytes, Alignment,</td>
    <td class="lineNumber">2674</td>
    <td class="codeline">    return Impl.isLegalToVectorizeLoadChain(ChainSizeInBytes, Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeline">                                            AddrSpace);</td>
    <td class="lineNumber">2675</td>
    <td class="codeline">                                            AddrSpace);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2676</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeline">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">2677</td>
    <td class="codeline">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeline">                                    unsigned AddrSpace) const override {</td>
    <td class="lineNumber">2678</td>
    <td class="codeline">                                    unsigned AddrSpace) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeline">    return Impl.isLegalToVectorizeStoreChain(ChainSizeInBytes, Alignment,</td>
    <td class="lineNumber">2679</td>
    <td class="codeline">    return Impl.isLegalToVectorizeStoreChain(ChainSizeInBytes, Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeline">                                             AddrSpace);</td>
    <td class="lineNumber">2680</td>
    <td class="codeline">                                             AddrSpace);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2681</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeline">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">2682</td>
    <td class="codeline">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeline">                                   ElementCount VF) const override {</td>
    <td class="lineNumber">2683</td>
    <td class="codeline">                                   ElementCount VF) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeline">    return Impl.isLegalToVectorizeReduction(RdxDesc, VF);</td>
    <td class="lineNumber">2684</td>
    <td class="codeline">    return Impl.isLegalToVectorizeReduction(RdxDesc, VF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2685</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeline">  bool isElementTypeLegalForScalableVector(Type *Ty) const override {</td>
    <td class="lineNumber">2686</td>
    <td class="codeline">  bool isElementTypeLegalForScalableVector(Type *Ty) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeline">    return Impl.isElementTypeLegalForScalableVector(Ty);</td>
    <td class="lineNumber">2687</td>
    <td class="codeline">    return Impl.isElementTypeLegalForScalableVector(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2688</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeline">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">2689</td>
    <td class="codeline">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeline">                               unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">2690</td>
    <td class="codeline">                               unsigned ChainSizeInBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeline">                               VectorType *VecTy) const override {</td>
    <td class="lineNumber">2691</td>
    <td class="codeline">                               VectorType *VecTy) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeline">    return Impl.getLoadVectorFactor(VF, LoadSize, ChainSizeInBytes, VecTy);</td>
    <td class="lineNumber">2692</td>
    <td class="codeline">    return Impl.getLoadVectorFactor(VF, LoadSize, ChainSizeInBytes, VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2693</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeline">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">2694</td>
    <td class="codeline">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeline">                                unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">2695</td>
    <td class="codeline">                                unsigned ChainSizeInBytes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeline">                                VectorType *VecTy) const override {</td>
    <td class="lineNumber">2696</td>
    <td class="codeline">                                VectorType *VecTy) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeline">    return Impl.getStoreVectorFactor(VF, StoreSize, ChainSizeInBytes, VecTy);</td>
    <td class="lineNumber">2697</td>
    <td class="codeline">    return Impl.getStoreVectorFactor(VF, StoreSize, ChainSizeInBytes, VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2698</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeline">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">2699</td>
    <td class="codeline">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeline">                             ReductionFlags Flags) const override {</td>
    <td class="lineNumber">2700</td>
    <td class="codeline">                             ReductionFlags Flags) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeline">    return Impl.preferInLoopReduction(Opcode, Ty, Flags);</td>
    <td class="lineNumber">2701</td>
    <td class="codeline">    return Impl.preferInLoopReduction(Opcode, Ty, Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2702</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeline">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">2703</td>
    <td class="codeline">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeline">                                       ReductionFlags Flags) const override {</td>
    <td class="lineNumber">2704</td>
    <td class="codeline">                                       ReductionFlags Flags) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeline">    return Impl.preferPredicatedReductionSelect(Opcode, Ty, Flags);</td>
    <td class="lineNumber">2705</td>
    <td class="codeline">    return Impl.preferPredicatedReductionSelect(Opcode, Ty, Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2706</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeline">  bool preferEpilogueVectorization() const override {</td>
    <td class="lineNumber">2707</td>
    <td class="codeline">  bool preferEpilogueVectorization() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeline">    return Impl.preferEpilogueVectorization();</td>
    <td class="lineNumber">2708</td>
    <td class="codeline">    return Impl.preferEpilogueVectorization();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2709</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeline"></td>
    <td class="lineNumber">2710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeline">  bool shouldExpandReduction(const IntrinsicInst *II) const override {</td>
    <td class="lineNumber">2711</td>
    <td class="codeline">  bool shouldExpandReduction(const IntrinsicInst *II) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeline">    return Impl.shouldExpandReduction(II);</td>
    <td class="lineNumber">2712</td>
    <td class="codeline">    return Impl.shouldExpandReduction(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2713</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeline"></td>
    <td class="lineNumber">2714</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeline">  unsigned getGISelRematGlobalCost() const override {</td>
    <td class="lineNumber">2715</td>
    <td class="codeline">  unsigned getGISelRematGlobalCost() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeline">    return Impl.getGISelRematGlobalCost();</td>
    <td class="lineNumber">2716</td>
    <td class="codeline">    return Impl.getGISelRematGlobalCost();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2717</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeline"></td>
    <td class="lineNumber">2718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeline">  unsigned getMinTripCountTailFoldingThreshold() const override {</td>
    <td class="lineNumber">2719</td>
    <td class="codeline">  unsigned getMinTripCountTailFoldingThreshold() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeline">    return Impl.getMinTripCountTailFoldingThreshold();</td>
    <td class="lineNumber">2720</td>
    <td class="codeline">    return Impl.getMinTripCountTailFoldingThreshold();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2721</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeline"></td>
    <td class="lineNumber">2722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeline">  bool supportsScalableVectors() const override {</td>
    <td class="lineNumber">2723</td>
    <td class="codeline">  bool supportsScalableVectors() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeline">    return Impl.supportsScalableVectors();</td>
    <td class="lineNumber">2724</td>
    <td class="codeline">    return Impl.supportsScalableVectors();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2725</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeline"></td>
    <td class="lineNumber">2726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeline">  bool enableScalableVectorization() const override {</td>
    <td class="lineNumber">2727</td>
    <td class="codeline">  bool enableScalableVectorization() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeline">    return Impl.enableScalableVectorization();</td>
    <td class="lineNumber">2728</td>
    <td class="codeline">    return Impl.enableScalableVectorization();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2729</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeline"></td>
    <td class="lineNumber">2730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeline">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">2731</td>
    <td class="codeline">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeline">                             Align Alignment) const override {</td>
    <td class="lineNumber">2732</td>
    <td class="codeline">                             Align Alignment) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeline">    return Impl.hasActiveVectorLength(Opcode, DataType, Alignment);</td>
    <td class="lineNumber">2733</td>
    <td class="codeline">    return Impl.hasActiveVectorLength(Opcode, DataType, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2734</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeline"></td>
    <td class="lineNumber">2735</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeline">  VPLegalization</td>
    <td class="lineNumber">2736</td>
    <td class="codeline">  VPLegalization</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeline">  getVPLegalizationStrategy(const VPIntrinsic &PI) const override {</td>
    <td class="lineNumber">2737</td>
    <td class="codeline">  getVPLegalizationStrategy(const VPIntrinsic &PI) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeline">    return Impl.getVPLegalizationStrategy(PI);</td>
    <td class="lineNumber">2738</td>
    <td class="codeline">    return Impl.getVPLegalizationStrategy(PI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2739</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeline"></td>
    <td class="lineNumber">2740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeline">  bool hasArmWideBranch(bool Thumb) const override {</td>
    <td class="lineNumber">2741</td>
    <td class="codeline">  bool hasArmWideBranch(bool Thumb) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeline">    return Impl.hasArmWideBranch(Thumb);</td>
    <td class="lineNumber">2742</td>
    <td class="codeline">    return Impl.hasArmWideBranch(Thumb);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2743</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeline"></td>
    <td class="lineNumber">2744</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeline">  unsigned getMaxNumArgs() const override {</td>
    <td class="lineNumber">2745</td>
    <td class="codeline">  unsigned getMaxNumArgs() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeline">    return Impl.getMaxNumArgs();</td>
    <td class="lineNumber">2746</td>
    <td class="codeline">    return Impl.getMaxNumArgs();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2747</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2748</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeline"></td>
    <td class="lineNumber">2749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">2750</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeline">TargetTransformInfo::TargetTransformInfo(T Impl)</td>
    <td class="lineNumber">2751</td>
    <td class="codeline">TargetTransformInfo::TargetTransformInfo(T Impl)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeline">    : TTIImpl(new Model<T>(Impl)) {}</td>
    <td class="lineNumber">2752</td>
    <td class="codeline">    : TTIImpl(new Model<T>(Impl)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeline"></td>
    <td class="lineNumber">2753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeline">/// Analysis pass providing the \c TargetTransformInfo.</td>
    <td class="lineNumber">2754</td>
    <td class="codeline">/// Analysis pass providing the \c TargetTransformInfo.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2755</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeline">/// The core idea of the TargetIRAnalysis is to expose an interface through</td>
    <td class="lineNumber">2756</td>
    <td class="codeline">/// The core idea of the TargetIRAnalysis is to expose an interface through</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeline">/// which LLVM targets can analyze and provide information about the middle</td>
    <td class="lineNumber">2757</td>
    <td class="codeline">/// which LLVM targets can analyze and provide information about the middle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeline">/// end's target-independent IR. This supports use cases such as target-aware</td>
    <td class="lineNumber">2758</td>
    <td class="codeline">/// end's target-independent IR. This supports use cases such as target-aware</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeline">/// cost modeling of IR constructs.</td>
    <td class="lineNumber">2759</td>
    <td class="codeline">/// cost modeling of IR constructs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2760</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeline">/// This is a function analysis because much of the cost modeling for targets</td>
    <td class="lineNumber">2761</td>
    <td class="codeline">/// This is a function analysis because much of the cost modeling for targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeline">/// is done in a subtarget specific way and LLVM supports compiling different</td>
    <td class="lineNumber">2762</td>
    <td class="codeline">/// is done in a subtarget specific way and LLVM supports compiling different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeline">/// functions targeting different subtargets in order to support runtime</td>
    <td class="lineNumber">2763</td>
    <td class="codeline">/// functions targeting different subtargets in order to support runtime</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeline">/// dispatch according to the observed subtarget.</td>
    <td class="lineNumber">2764</td>
    <td class="codeline">/// dispatch according to the observed subtarget.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeline">class TargetIRAnalysis : public AnalysisInfoMixin<TargetIRAnalysis> {</td>
    <td class="lineNumber">2765</td>
    <td class="codeline">class TargetIRAnalysis : public AnalysisInfoMixin<TargetIRAnalysis> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2766</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeline">  typedef TargetTransformInfo Result;</td>
    <td class="lineNumber">2767</td>
    <td class="codeline">  typedef TargetTransformInfo Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeline"></td>
    <td class="lineNumber">2768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeline">  /// Default construct a target IR analysis.</td>
    <td class="lineNumber">2769</td>
    <td class="codeline">  /// Default construct a target IR analysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2770</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeline">  /// This will use the module's datalayout to construct a baseline</td>
    <td class="lineNumber">2771</td>
    <td class="codeline">  /// This will use the module's datalayout to construct a baseline</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeline">  /// conservative TTI result.</td>
    <td class="lineNumber">2772</td>
    <td class="codeline">  /// conservative TTI result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeline">  TargetIRAnalysis();</td>
    <td class="lineNumber">2773</td>
    <td class="codeline">  TargetIRAnalysis();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeline"></td>
    <td class="lineNumber">2774</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeline">  /// Construct an IR analysis pass around a target-provide callback.</td>
    <td class="lineNumber">2775</td>
    <td class="codeline">  /// Construct an IR analysis pass around a target-provide callback.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2776</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeline">  /// The callback will be called with a particular function for which the TTI</td>
    <td class="lineNumber">2777</td>
    <td class="codeline">  /// The callback will be called with a particular function for which the TTI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeline">  /// is needed and must return a TTI object for that function.</td>
    <td class="lineNumber">2778</td>
    <td class="codeline">  /// is needed and must return a TTI object for that function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeline">  TargetIRAnalysis(std::function<Result(const Function &)> TTICallback);</td>
    <td class="lineNumber">2779</td>
    <td class="codeline">  TargetIRAnalysis(std::function<Result(const Function &)> TTICallback);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeline"></td>
    <td class="lineNumber">2780</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeline">  // Value semantics. We spell out the constructors for MSVC.</td>
    <td class="lineNumber">2781</td>
    <td class="codeline">  // Value semantics. We spell out the constructors for MSVC.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeline">  TargetIRAnalysis(const TargetIRAnalysis &Arg)</td>
    <td class="lineNumber">2782</td>
    <td class="codeline">  TargetIRAnalysis(const TargetIRAnalysis &Arg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeline">      : TTICallback(Arg.TTICallback) {}</td>
    <td class="lineNumber">2783</td>
    <td class="codeline">      : TTICallback(Arg.TTICallback) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeline">  TargetIRAnalysis(TargetIRAnalysis &&Arg)</td>
    <td class="lineNumber">2784</td>
    <td class="codeline">  TargetIRAnalysis(TargetIRAnalysis &&Arg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeline">      : TTICallback(std::move(Arg.TTICallback)) {}</td>
    <td class="lineNumber">2785</td>
    <td class="codeline">      : TTICallback(std::move(Arg.TTICallback)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeline">  TargetIRAnalysis &operator=(const TargetIRAnalysis &RHS) {</td>
    <td class="lineNumber">2786</td>
    <td class="codeline">  TargetIRAnalysis &operator=(const TargetIRAnalysis &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeline">    TTICallback = RHS.TTICallback;</td>
    <td class="lineNumber">2787</td>
    <td class="codeline">    TTICallback = RHS.TTICallback;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">2788</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2789</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeline">  TargetIRAnalysis &operator=(TargetIRAnalysis &&RHS) {</td>
    <td class="lineNumber">2790</td>
    <td class="codeline">  TargetIRAnalysis &operator=(TargetIRAnalysis &&RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeline">    TTICallback = std::move(RHS.TTICallback);</td>
    <td class="lineNumber">2791</td>
    <td class="codeline">    TTICallback = std::move(RHS.TTICallback);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">2792</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2793</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeline"></td>
    <td class="lineNumber">2794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeline">  Result run(const Function &F, FunctionAnalysisManager &);</td>
    <td class="lineNumber">2795</td>
    <td class="codeline">  Result run(const Function &F, FunctionAnalysisManager &);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeline"></td>
    <td class="lineNumber">2796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">2797</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeline">  friend AnalysisInfoMixin<TargetIRAnalysis>;</td>
    <td class="lineNumber">2798</td>
    <td class="codeline">  friend AnalysisInfoMixin<TargetIRAnalysis>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeline">  static AnalysisKey Key;</td>
    <td class="lineNumber">2799</td>
    <td class="codeline">  static AnalysisKey Key;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeline"></td>
    <td class="lineNumber">2800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeline">  /// The callback used to produce a result.</td>
    <td class="lineNumber">2801</td>
    <td class="codeline">  /// The callback used to produce a result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2802</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeline">  /// We use a completely opaque callback so that targets can provide whatever</td>
    <td class="lineNumber">2803</td>
    <td class="codeline">  /// We use a completely opaque callback so that targets can provide whatever</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeline">  /// mechanism they desire for constructing the TTI for a given function.</td>
    <td class="lineNumber">2804</td>
    <td class="codeline">  /// mechanism they desire for constructing the TTI for a given function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2805</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeline">  /// FIXME: Should we really use std::function? It's relatively inefficient.</td>
    <td class="lineNumber">2806</td>
    <td class="codeline">  /// FIXME: Should we really use std::function? It's relatively inefficient.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeline">  /// It might be possible to arrange for even stateful callbacks to outlive</td>
    <td class="lineNumber">2807</td>
    <td class="codeline">  /// It might be possible to arrange for even stateful callbacks to outlive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeline">  /// the analysis and thus use a function_ref which would be lighter weight.</td>
    <td class="lineNumber">2808</td>
    <td class="codeline">  /// the analysis and thus use a function_ref which would be lighter weight.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeline">  /// This may also be less error prone as the callback is likely to reference</td>
    <td class="lineNumber">2809</td>
    <td class="codeline">  /// This may also be less error prone as the callback is likely to reference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeline">  /// the external TargetMachine, and that reference needs to never dangle.</td>
    <td class="lineNumber">2810</td>
    <td class="codeline">  /// the external TargetMachine, and that reference needs to never dangle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeline">  std::function<Result(const Function &)> TTICallback;</td>
    <td class="lineNumber">2811</td>
    <td class="codeline">  std::function<Result(const Function &)> TTICallback;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeline"></td>
    <td class="lineNumber">2812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeline">  /// Helper function used as the callback in the default constructor.</td>
    <td class="lineNumber">2813</td>
    <td class="codeline">  /// Helper function used as the callback in the default constructor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeline">  static Result getDefaultTTI(const Function &F);</td>
    <td class="lineNumber">2814</td>
    <td class="codeline">  static Result getDefaultTTI(const Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2815</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeline"></td>
    <td class="lineNumber">2816</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeline">/// Wrapper pass for TargetTransformInfo.</td>
    <td class="lineNumber">2817</td>
    <td class="codeline">/// Wrapper pass for TargetTransformInfo.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2818</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeline">/// This pass can be constructed from a TTI object which it stores internally</td>
    <td class="lineNumber">2819</td>
    <td class="codeline">/// This pass can be constructed from a TTI object which it stores internally</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeline">/// and is queried by passes.</td>
    <td class="lineNumber">2820</td>
    <td class="codeline">/// and is queried by passes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeline">class TargetTransformInfoWrapperPass : public ImmutablePass {</td>
    <td class="lineNumber">2821</td>
    <td class="codeline">class TargetTransformInfoWrapperPass : public ImmutablePass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeline">  TargetIRAnalysis TIRA;</td>
    <td class="lineNumber">2822</td>
    <td class="codeline">  TargetIRAnalysis TIRA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeline">  std::optional<TargetTransformInfo> TTI;</td>
    <td class="lineNumber">2823</td>
    <td class="codeline">  std::optional<TargetTransformInfo> TTI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeline"></td>
    <td class="lineNumber">2824</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeline">  virtual void anchor();</td>
    <td class="lineNumber">2825</td>
    <td class="codeline">  virtual void anchor();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeline"></td>
    <td class="lineNumber">2826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2827</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">2828</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeline"></td>
    <td class="lineNumber">2829</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeline">  /// We must provide a default constructor for the pass but it should</td>
    <td class="lineNumber">2830</td>
    <td class="codeline">  /// We must provide a default constructor for the pass but it should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeline">  /// never be used.</td>
    <td class="lineNumber">2831</td>
    <td class="codeline">  /// never be used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2832</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeline">  /// Use the constructor below or call one of the creation routines.</td>
    <td class="lineNumber">2833</td>
    <td class="codeline">  /// Use the constructor below or call one of the creation routines.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeline">  TargetTransformInfoWrapperPass();</td>
    <td class="lineNumber">2834</td>
    <td class="codeline">  TargetTransformInfoWrapperPass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeline"></td>
    <td class="lineNumber">2835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeline">  explicit TargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
    <td class="lineNumber">2836</td>
    <td class="codeline">  explicit TargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeline"></td>
    <td class="lineNumber">2837</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeline">  TargetTransformInfo &getTTI(const Function &F);</td>
    <td class="lineNumber">2838</td>
    <td class="codeline">  TargetTransformInfo &getTTI(const Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2839</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeline"></td>
    <td class="lineNumber">2840</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeline">/// Create an analysis pass wrapper around a TTI object.</td>
    <td class="lineNumber">2841</td>
    <td class="codeline">/// Create an analysis pass wrapper around a TTI object.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2842</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeline">/// This analysis pass just holds the TTI instance and makes it available to</td>
    <td class="lineNumber">2843</td>
    <td class="codeline">/// This analysis pass just holds the TTI instance and makes it available to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeline">/// clients.</td>
    <td class="lineNumber">2844</td>
    <td class="codeline">/// clients.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeline">ImmutablePass *createTargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
    <td class="lineNumber">2845</td>
    <td class="codeline">ImmutablePass *createTargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeline"></td>
    <td class="lineNumber">2846</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeline">} // namespace llvm</td>
    <td class="lineNumber">2847</td>
    <td class="codeline">} // namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeline"></td>
    <td class="lineNumber">2848</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">2849</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeline"></td>
    <td class="lineNumber">2850</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// This pass exposes codegen information to IR-level passes. Every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// This pass exposes codegen information to IR-level passes. Every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// transformation that uses codegen information is broken into three parts:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// transformation that uses codegen information is broken into three parts:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// 1. The IR-level analysis pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// 1. The IR-level analysis pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">/// 2. The IR-level transformation interface which provides the needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">/// 2. The IR-level transformation interface which provides the needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">///    information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">///    information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">/// 3. Codegen-level implementation which uses target-specific hooks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">/// 3. Codegen-level implementation which uses target-specific hooks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">/// This file defines #2, which is the interface that IR-level transformations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">/// This file defines #2, which is the interface that IR-level transformations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">/// use for querying the codegen.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">/// use for querying the codegen.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#ifndef LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#ifndef LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#define LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#define LLVM_ANALYSIS_TARGETTRANSFORMINFO_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/IR/FMF.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/IR/FMF.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/Support/AtomicOrdering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Support/InstructionCost.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Support/InstructionCost.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include <functional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include <functional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">namespace Intrinsic {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">namespace Intrinsic {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">typedef unsigned ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">typedef unsigned ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">class AllocaInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">class AllocaInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">class AssumptionCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">class AssumptionCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">class BlockFrequencyInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">class BlockFrequencyInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">class DominatorTree;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">class DominatorTree;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">class BranchInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">class BranchInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">class CallBase;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">class CallBase;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">class Function;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">class Function;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">class GlobalValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">class GlobalValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">class InstCombiner;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">class InstCombiner;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">class OptimizationRemarkEmitter;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">class OptimizationRemarkEmitter;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">class InterleavedAccessInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">class InterleavedAccessInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">class IntrinsicInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">class IntrinsicInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">class LoadInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">class LoadInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">class Loop;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">class Loop;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">class LoopInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">class LoopInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">class LoopVectorizationLegality;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">class LoopVectorizationLegality;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">class ProfileSummaryInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">class ProfileSummaryInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">class RecurrenceDescriptor;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">class RecurrenceDescriptor;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">class SCEV;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">class SCEV;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">class ScalarEvolution;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">class ScalarEvolution;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">class StoreInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">class StoreInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">class SwitchInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">class SwitchInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">class TargetLibraryInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">class TargetLibraryInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">class Type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">class Type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">class User;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">class User;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">class Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">class Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">class VPIntrinsic;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">class VPIntrinsic;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">struct KnownBits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">struct KnownBits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">/// Information about a load/store intrinsic defined by the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">/// Information about a load/store intrinsic defined by the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">struct MemIntrinsicInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">struct MemIntrinsicInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">  /// This is the pointer that the intrinsic is loading from or storing to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">  /// This is the pointer that the intrinsic is loading from or storing to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">  /// If this is non-null, then analysis/optimization passes can assume that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">  /// If this is non-null, then analysis/optimization passes can assume that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">  /// this intrinsic is functionally equivalent to a load/store from this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">  /// this intrinsic is functionally equivalent to a load/store from this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">  /// pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">  /// pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">  Value *PtrVal = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">  Value *PtrVal = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  // Ordering for atomic operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  // Ordering for atomic operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  // Same Id is set by the target for corresponding load/store intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  // Same Id is set by the target for corresponding load/store intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  unsigned short MatchingId = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  unsigned short MatchingId = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  bool ReadMem = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  bool ReadMem = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  bool WriteMem = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  bool WriteMem = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  bool IsVolatile = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  bool IsVolatile = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  bool isUnordered() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  bool isUnordered() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">    return (Ordering == AtomicOrdering::NotAtomic ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">    return (Ordering == AtomicOrdering::NotAtomic ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">            Ordering == AtomicOrdering::Unordered) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">            Ordering == AtomicOrdering::Unordered) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">           !IsVolatile;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">           !IsVolatile;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">/// Attributes of a target dependent hardware loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">/// Attributes of a target dependent hardware loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">struct HardwareLoopInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">struct HardwareLoopInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  HardwareLoopInfo() = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  HardwareLoopInfo() = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  HardwareLoopInfo(Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  HardwareLoopInfo(Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  Loop *L = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  Loop *L = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  BasicBlock *ExitBlock = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  BasicBlock *ExitBlock = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  BranchInst *ExitBranch = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  BranchInst *ExitBranch = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  const SCEV *ExitCount = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  const SCEV *ExitCount = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  IntegerType *CountType = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  IntegerType *CountType = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  Value *LoopDecrement = nullptr; // Decrement the loop counter by this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  Value *LoopDecrement = nullptr; // Decrement the loop counter by this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">                                  // value in every iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">                                  // value in every iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  bool IsNestingLegal = false;    // Can a hardware loop be a parent to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  bool IsNestingLegal = false;    // Can a hardware loop be a parent to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">                                  // another hardware loop?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">                                  // another hardware loop?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  bool CounterInReg = false;      // Should loop counter be updated in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  bool CounterInReg = false;      // Should loop counter be updated in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">                                  // the loop via a phi?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">                                  // the loop via a phi?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  bool PerformEntryTest = false;  // Generate the intrinsic which also performs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  bool PerformEntryTest = false;  // Generate the intrinsic which also performs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">                                  // icmp ne zero on the loop counter value and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">                                  // icmp ne zero on the loop counter value and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">                                  // produces an i1 to guard the loop entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">                                  // produces an i1 to guard the loop entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  bool isHardwareLoopCandidate(ScalarEvolution &SE, LoopInfo &LI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  bool isHardwareLoopCandidate(ScalarEvolution &SE, LoopInfo &LI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">                               DominatorTree &DT, bool ForceNestedLoop = false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">                               DominatorTree &DT, bool ForceNestedLoop = false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">                               bool ForceHardwareLoopPHI = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">                               bool ForceHardwareLoopPHI = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  bool canAnalyze(LoopInfo &LI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  bool canAnalyze(LoopInfo &LI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">class IntrinsicCostAttributes {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">class IntrinsicCostAttributes {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  const IntrinsicInst *II = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  const IntrinsicInst *II = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  Type *RetTy = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  Type *RetTy = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  Intrinsic::ID IID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  Intrinsic::ID IID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  SmallVector<Type *, 4> ParamTys;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  SmallVector<Type *, 4> ParamTys;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  SmallVector<const Value *, 4> Arguments;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  SmallVector<const Value *, 4> Arguments;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  FastMathFlags FMF;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  FastMathFlags FMF;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  // If ScalarizationCost is UINT_MAX, the cost of scalarizing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  // If ScalarizationCost is UINT_MAX, the cost of scalarizing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  // arguments and the return value will be computed based on types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  // arguments and the return value will be computed based on types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">      Intrinsic::ID Id, const CallBase &CI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">      Intrinsic::ID Id, const CallBase &CI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">      InstructionCost ScalarCost = InstructionCost::getInvalid(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">      InstructionCost ScalarCost = InstructionCost::getInvalid(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">      bool TypeBasedOnly = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">      bool TypeBasedOnly = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">      Intrinsic::ID Id, Type *RTy, ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">      Intrinsic::ID Id, Type *RTy, ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">      FastMathFlags Flags = FastMathFlags(), const IntrinsicInst *I = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">      FastMathFlags Flags = FastMathFlags(), const IntrinsicInst *I = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  IntrinsicCostAttributes(Intrinsic::ID Id, Type *RTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  IntrinsicCostAttributes(Intrinsic::ID Id, Type *RTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">                          ArrayRef<const Value *> Args);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">                          ArrayRef<const Value *> Args);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  IntrinsicCostAttributes(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">      Intrinsic::ID Id, Type *RTy, ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">      Intrinsic::ID Id, Type *RTy, ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">      ArrayRef<Type *> Tys, FastMathFlags Flags = FastMathFlags(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">      ArrayRef<Type *> Tys, FastMathFlags Flags = FastMathFlags(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">      const IntrinsicInst *I = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">      const IntrinsicInst *I = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">      InstructionCost ScalarCost = InstructionCost::getInvalid());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">  Intrinsic::ID getID() const { return IID; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">  Intrinsic::ID getID() const { return IID; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">  const IntrinsicInst *getInst() const { return II; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">  const IntrinsicInst *getInst() const { return II; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">  Type *getReturnType() const { return RetTy; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">  Type *getReturnType() const { return RetTy; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  FastMathFlags getFlags() const { return FMF; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  FastMathFlags getFlags() const { return FMF; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  InstructionCost getScalarizationCost() const { return ScalarizationCost; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  InstructionCost getScalarizationCost() const { return ScalarizationCost; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  const SmallVectorImpl<const Value *> &getArgs() const { return Arguments; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  const SmallVectorImpl<const Value *> &getArgs() const { return Arguments; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  const SmallVectorImpl<Type *> &getArgTypes() const { return ParamTys; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  const SmallVectorImpl<Type *> &getArgTypes() const { return ParamTys; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  bool isTypeBasedOnly() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  bool isTypeBasedOnly() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">    return Arguments.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">    return Arguments.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  bool skipScalarizationCost() const { return ScalarizationCost.isValid(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  bool skipScalarizationCost() const { return ScalarizationCost.isValid(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">enum class TailFoldingStyle {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">enum class TailFoldingStyle {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  /// Don't use tail folding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  /// Don't use tail folding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  None,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  None,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  /// Use predicate only to mask operations on data in the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  /// Use predicate only to mask operations on data in the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  /// When the VL is not known to be a power-of-2, this method requires a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  /// When the VL is not known to be a power-of-2, this method requires a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  /// runtime overflow check for the i + VL in the loop because it compares the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  /// runtime overflow check for the i + VL in the loop because it compares the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  /// scalar induction variable against the tripcount rounded up by VL which may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  /// scalar induction variable against the tripcount rounded up by VL which may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  /// overflow. When the VL is a power-of-2, both the increment and uprounded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  /// overflow. When the VL is a power-of-2, both the increment and uprounded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  /// tripcount will overflow to 0, which does not require a runtime check</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  /// tripcount will overflow to 0, which does not require a runtime check</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  /// since the loop is exited when the loop induction variable equals the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  /// since the loop is exited when the loop induction variable equals the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  /// uprounded trip-count, which are both 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  /// uprounded trip-count, which are both 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  Data,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  Data,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  /// Same as Data, but avoids using the get.active.lane.mask intrinsic to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  /// Same as Data, but avoids using the get.active.lane.mask intrinsic to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  /// calculate the mask and instead implements this with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  /// calculate the mask and instead implements this with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  /// splat/stepvector/cmp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  /// splat/stepvector/cmp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  /// active.lane.mask intrinsic when it is not natively supported?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  /// active.lane.mask intrinsic when it is not natively supported?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  DataWithoutLaneMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  DataWithoutLaneMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  /// Use predicate to control both data and control flow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  /// Use predicate to control both data and control flow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  /// This method always requires a runtime overflow check for the i + VL</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  /// This method always requires a runtime overflow check for the i + VL</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  /// increment inside the loop, because it uses the result direclty in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  /// increment inside the loop, because it uses the result direclty in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  /// active.lane.mask to calculate the mask for the next iteration. If the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  /// active.lane.mask to calculate the mask for the next iteration. If the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">  /// increment overflows, the mask is no longer correct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">  /// increment overflows, the mask is no longer correct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  DataAndControlFlow,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  DataAndControlFlow,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  /// Use predicate to control both data and control flow, but modify</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  /// Use predicate to control both data and control flow, but modify</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  /// the trip count so that a runtime overflow check can be avoided</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  /// the trip count so that a runtime overflow check can be avoided</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  /// and such that the scalar epilogue loop can always be removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  /// and such that the scalar epilogue loop can always be removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  DataAndControlFlowWithoutRuntimeCheck</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  DataAndControlFlowWithoutRuntimeCheck</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">struct TailFoldingInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">struct TailFoldingInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  TargetLibraryInfo *TLI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  LoopVectorizationLegality *LVL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  LoopVectorizationLegality *LVL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  InterleavedAccessInfo *IAI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  InterleavedAccessInfo *IAI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">  TailFoldingInfo(TargetLibraryInfo *TLI, LoopVectorizationLegality *LVL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">  TailFoldingInfo(TargetLibraryInfo *TLI, LoopVectorizationLegality *LVL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">                  InterleavedAccessInfo *IAI)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">                  InterleavedAccessInfo *IAI)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">      : TLI(TLI), LVL(LVL), IAI(IAI) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">      : TLI(TLI), LVL(LVL), IAI(IAI) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">class TargetTransformInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">class TargetTransformInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">typedef TargetTransformInfo TTI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">typedef TargetTransformInfo TTI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">/// This pass provides access to the codegen interfaces that are needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">/// This pass provides access to the codegen interfaces that are needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">/// for IR-level transformations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">/// for IR-level transformations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">class TargetTransformInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">class TargetTransformInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  /// Construct a TTI object using a type implementing the \c Concept</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  /// Construct a TTI object using a type implementing the \c Concept</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  /// API below.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  /// API below.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">  /// This is used by targets to construct a TTI wrapping their target-specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">  /// This is used by targets to construct a TTI wrapping their target-specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// implementation that encodes appropriate costs for their target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// implementation that encodes appropriate costs for their target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  template <typename T> TargetTransformInfo(T Impl);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  template <typename T> TargetTransformInfo(T Impl);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  /// Construct a baseline TTI object using a minimal implementation of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  /// Construct a baseline TTI object using a minimal implementation of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">  /// the \c Concept API below.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">  /// the \c Concept API below.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  /// The TTI implementation will reflect the information in the DataLayout</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  /// The TTI implementation will reflect the information in the DataLayout</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  /// provided if non-null.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  /// provided if non-null.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  explicit TargetTransformInfo(const DataLayout &DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  explicit TargetTransformInfo(const DataLayout &DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  // Provide move semantics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  // Provide move semantics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  TargetTransformInfo(TargetTransformInfo &&Arg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  TargetTransformInfo(TargetTransformInfo &&Arg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  TargetTransformInfo &operator=(TargetTransformInfo &&RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  TargetTransformInfo &operator=(TargetTransformInfo &&RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  // We need to define the destructor out-of-line to define our sub-classes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  // We need to define the destructor out-of-line to define our sub-classes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  // out-of-line.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  // out-of-line.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  ~TargetTransformInfo();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  ~TargetTransformInfo();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  /// Handle the invalidation of this information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  /// Handle the invalidation of this information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  /// When used as a result of \c TargetIRAnalysis this method will be called</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  /// When used as a result of \c TargetIRAnalysis this method will be called</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  /// when the function this was computed for changes. When it returns false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  /// when the function this was computed for changes. When it returns false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  /// the information is preserved across those changes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  /// the information is preserved across those changes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  bool invalidate(Function &, const PreservedAnalyses &,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  bool invalidate(Function &, const PreservedAnalyses &,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">                  FunctionAnalysisManager::Invalidator &) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">                  FunctionAnalysisManager::Invalidator &) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">    // FIXME: We should probably in some way ensure that the subtarget</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">    // FIXME: We should probably in some way ensure that the subtarget</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">    // information for a function hasn't changed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">    // information for a function hasn't changed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  /// \name Generic Target Information</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  /// \name Generic Target Information</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  /// The kind of cost model.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  /// The kind of cost model.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  /// There are several different cost models that can be customized by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  /// There are several different cost models that can be customized by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  /// target. The normalization of each cost model may be target specific.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  /// target. The normalization of each cost model may be target specific.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  /// e.g. TCK_SizeAndLatency should be comparable to target thresholds such as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  /// e.g. TCK_SizeAndLatency should be comparable to target thresholds such as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  /// those derived from MCSchedModel::LoopMicroOpBufferSize etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  /// those derived from MCSchedModel::LoopMicroOpBufferSize etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  enum TargetCostKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  enum TargetCostKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">    TCK_RecipThroughput, ///< Reciprocal throughput.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">    TCK_RecipThroughput, ///< Reciprocal throughput.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">    TCK_Latency,         ///< The latency of instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">    TCK_Latency,         ///< The latency of instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">    TCK_CodeSize,        ///< Instruction code size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">    TCK_CodeSize,        ///< Instruction code size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">    TCK_SizeAndLatency   ///< The weighted sum of size and latency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">    TCK_SizeAndLatency   ///< The weighted sum of size and latency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  /// Underlying constants for 'cost' values in this interface.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  /// Underlying constants for 'cost' values in this interface.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  /// Many APIs in this interface return a cost. This enum defines the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  /// Many APIs in this interface return a cost. This enum defines the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  /// fundamental values that should be used to interpret (and produce) those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  /// fundamental values that should be used to interpret (and produce) those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  /// costs. The costs are returned as an int rather than a member of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  /// costs. The costs are returned as an int rather than a member of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  /// enumeration because it is expected that the cost of one IR instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  /// enumeration because it is expected that the cost of one IR instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  /// may have a multiplicative factor to it or otherwise won't fit directly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  /// may have a multiplicative factor to it or otherwise won't fit directly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  /// into the enum. Moreover, it is common to sum or average costs which works</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  /// into the enum. Moreover, it is common to sum or average costs which works</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  /// better as simple integral values. Thus this enum only provides constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  /// better as simple integral values. Thus this enum only provides constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// Also note that the returned costs are signed integers to make it natural</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// Also note that the returned costs are signed integers to make it natural</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// to add, subtract, and test with zero (a common boundary condition). It is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// to add, subtract, and test with zero (a common boundary condition). It is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// not expected that 2^32 is a realistic cost to be modeling at any point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// not expected that 2^32 is a realistic cost to be modeling at any point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// Note that these costs should usually reflect the intersection of code-size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// Note that these costs should usually reflect the intersection of code-size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  /// cost and execution cost. A free instruction is typically one that folds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  /// cost and execution cost. A free instruction is typically one that folds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  /// into another instruction. For example, reg-to-reg moves can often be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  /// into another instruction. For example, reg-to-reg moves can often be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  /// skipped by renaming the registers in the CPU, but they still are encoded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  /// skipped by renaming the registers in the CPU, but they still are encoded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  /// and thus wouldn't be considered 'free' here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  /// and thus wouldn't be considered 'free' here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  enum TargetCostConstants {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  enum TargetCostConstants {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">    TCC_Free = 0,     ///< Expected to fold away in lowering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">    TCC_Free = 0,     ///< Expected to fold away in lowering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">    TCC_Basic = 1,    ///< The cost of a typical 'add' instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">    TCC_Basic = 1,    ///< The cost of a typical 'add' instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">    TCC_Expensive = 4 ///< The cost of a 'div' instruction on x86.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">    TCC_Expensive = 4 ///< The cost of a 'div' instruction on x86.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  /// Estimate the cost of a GEP operation when lowered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  /// Estimate the cost of a GEP operation when lowered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  /// \p PointeeType is the source element type of the GEP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  /// \p PointeeType is the source element type of the GEP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// \p Ptr is the base pointer operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// \p Ptr is the base pointer operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// \p Operands is the list of indices following the base pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// \p Operands is the list of indices following the base pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  /// \p AccessType is a hint as to what type of memory might be accessed by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  /// \p AccessType is a hint as to what type of memory might be accessed by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// users of the GEP. getGEPCost will use it to determine if the GEP can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// users of the GEP. getGEPCost will use it to determine if the GEP can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// folded into the addressing mode of a load/store. If AccessType is null,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// folded into the addressing mode of a load/store. If AccessType is null,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  /// then the resulting target type based off of PointeeType will be used as an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  /// then the resulting target type based off of PointeeType will be used as an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  /// approximation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  /// approximation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">             ArrayRef<const Value *> Operands, Type *AccessType = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">             ArrayRef<const Value *> Operands, Type *AccessType = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">             TargetCostKind CostKind = TCK_SizeAndLatency) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">             TargetCostKind CostKind = TCK_SizeAndLatency) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  /// Describe known properties for a set of pointers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  /// Describe known properties for a set of pointers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  struct PointersChainInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  struct PointersChainInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    /// All the GEPs in a set have same base address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    /// All the GEPs in a set have same base address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">    unsigned IsSameBaseAddress : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">    unsigned IsSameBaseAddress : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    /// These properties only valid if SameBaseAddress is set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    /// These properties only valid if SameBaseAddress is set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">    /// True if all pointers are separated by a unit stride.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">    /// True if all pointers are separated by a unit stride.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    unsigned IsUnitStride : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    unsigned IsUnitStride : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">    /// True if distance between any two neigbouring pointers is a known value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">    /// True if distance between any two neigbouring pointers is a known value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    unsigned IsKnownStride : 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    unsigned IsKnownStride : 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    unsigned Reserved : 29;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    unsigned Reserved : 29;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">    bool isSameBase() const { return IsSameBaseAddress; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">    bool isSameBase() const { return IsSameBaseAddress; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">    bool isUnitStride() const { return IsSameBaseAddress && IsUnitStride; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">    bool isUnitStride() const { return IsSameBaseAddress && IsUnitStride; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">    bool isKnownStride() const { return IsSameBaseAddress && IsKnownStride; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">    bool isKnownStride() const { return IsSameBaseAddress && IsKnownStride; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">    static PointersChainInfo getUnitStride() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">    static PointersChainInfo getUnitStride() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">              /*IsKnownStride=*/1, 0};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">              /*IsKnownStride=*/1, 0};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">    static PointersChainInfo getKnownStride() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">    static PointersChainInfo getKnownStride() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">              /*IsKnownStride=*/1, 0};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">              /*IsKnownStride=*/1, 0};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">    static PointersChainInfo getUnknownStride() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">    static PointersChainInfo getUnknownStride() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">      return {/*IsSameBaseAddress=*/1, /*IsUnitStride=*/0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">              /*IsKnownStride=*/0, 0};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">              /*IsKnownStride=*/0, 0};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  static_assert(sizeof(PointersChainInfo) == 4, "Was size increase justified?");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  static_assert(sizeof(PointersChainInfo) == 4, "Was size increase justified?");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  /// Estimate the cost of a chain of pointers (typically pointer operands of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  /// Estimate the cost of a chain of pointers (typically pointer operands of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  /// chain of loads or stores within same block) operations set when lowered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  /// chain of loads or stores within same block) operations set when lowered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  /// \p AccessTy is the type of the loads/stores that will ultimately use the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  /// \p AccessTy is the type of the loads/stores that will ultimately use the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  /// \p Ptrs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  /// \p Ptrs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">                       const PointersChainInfo &Info, Type *AccessTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">                       const PointersChainInfo &Info, Type *AccessTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">                       TargetCostKind CostKind = TTI::TCK_RecipThroughput</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">                       TargetCostKind CostKind = TTI::TCK_RecipThroughput</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">  ) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">  ) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  /// \returns A value by which our inlining threshold should be multiplied.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  /// \returns A value by which our inlining threshold should be multiplied.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  /// This is primarily used to bump up the inlining threshold wholesale on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  /// This is primarily used to bump up the inlining threshold wholesale on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  /// targets where calls are unusually expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  /// targets where calls are unusually expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">  /// TODO: This is a rather blunt instrument.  Perhaps altering the costs of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">  /// TODO: This is a rather blunt instrument.  Perhaps altering the costs of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  /// individual classes of instructions would be better.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  /// individual classes of instructions would be better.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  unsigned getInliningThresholdMultiplier() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  unsigned getInliningThresholdMultiplier() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  /// \returns A value to be added to the inlining threshold.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  /// \returns A value to be added to the inlining threshold.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  unsigned adjustInliningThreshold(const CallBase *CB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  unsigned adjustInliningThreshold(const CallBase *CB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  /// \returns The cost of having an Alloca in the caller if not inlined, to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  /// \returns The cost of having an Alloca in the caller if not inlined, to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  /// added to the threshold</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  /// added to the threshold</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  /// \returns Vector bonus in percent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  /// \returns Vector bonus in percent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  /// Vector bonuses: We want to more aggressively inline vector-dense kernels</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  /// Vector bonuses: We want to more aggressively inline vector-dense kernels</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">  /// and apply this bonus based on the percentage of vector instructions. A</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">  /// and apply this bonus based on the percentage of vector instructions. A</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  /// bonus is applied if the vector instructions exceed 50% and half that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  /// bonus is applied if the vector instructions exceed 50% and half that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  /// amount is applied if it exceeds 10%. Note that these bonuses are some what</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  /// amount is applied if it exceeds 10%. Note that these bonuses are some what</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  /// arbitrary and evolved over time by accident as much as because they are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  /// arbitrary and evolved over time by accident as much as because they are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  /// principled bonuses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  /// principled bonuses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  /// FIXME: It would be nice to base the bonus values on something more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  /// FIXME: It would be nice to base the bonus values on something more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  /// scientific. A target may has no bonus on vector instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  /// scientific. A target may has no bonus on vector instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  int getInlinerVectorBonusPercent() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  int getInlinerVectorBonusPercent() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  /// \return the expected cost of a memcpy, which could e.g. depend on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  /// \return the expected cost of a memcpy, which could e.g. depend on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  /// source/destination type and alignment and the number of bytes copied.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  /// source/destination type and alignment and the number of bytes copied.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  InstructionCost getMemcpyCost(const Instruction *I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  InstructionCost getMemcpyCost(const Instruction *I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  /// Returns the maximum memset / memcpy size in bytes that still makes it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  /// Returns the maximum memset / memcpy size in bytes that still makes it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  /// profitable to inline the call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  /// profitable to inline the call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">  /// \return The estimated number of case clusters when lowering \p 'SI'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">  /// \return The estimated number of case clusters when lowering \p 'SI'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  /// \p JTSize Set a jump table size only when \p SI is suitable for a jump</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  /// \p JTSize Set a jump table size only when \p SI is suitable for a jump</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  /// table.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  /// table.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">                                            unsigned &JTSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">                                            unsigned &JTSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">                                            BlockFrequencyInfo *BFI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">                                            BlockFrequencyInfo *BFI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  /// Estimate the cost of a given IR user when lowered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  /// Estimate the cost of a given IR user when lowered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">  /// This can estimate the cost of either a ConstantExpr or Instruction when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">  /// This can estimate the cost of either a ConstantExpr or Instruction when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  /// lowered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  /// lowered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  /// \p Operands is a list of operands which can be a result of transformations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  /// \p Operands is a list of operands which can be a result of transformations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  /// of the current operands. The number of the operands on the list must equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  /// of the current operands. The number of the operands on the list must equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  /// to the number of the current operands the IR user has. Their order on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  /// to the number of the current operands the IR user has. Their order on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  /// list must be the same as the order of the current operands the IR user</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  /// list must be the same as the order of the current operands the IR user</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  /// has.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  /// has.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  /// The returned cost is defined in terms of \c TargetCostConstants, see its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  /// The returned cost is defined in terms of \c TargetCostConstants, see its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  /// comments for a detailed explanation of the cost values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  /// comments for a detailed explanation of the cost values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">                                     TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">                                     TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// This is a helper function which calls the three-argument</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// This is a helper function which calls the three-argument</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  /// getInstructionCost with \p Operands which are the current operands U has.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  /// getInstructionCost with \p Operands which are the current operands U has.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">                                     TargetCostKind CostKind) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">                                     TargetCostKind CostKind) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">    SmallVector<const Value *, 4> Operands(U->operand_values());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">    SmallVector<const Value *, 4> Operands(U->operand_values());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">    return getInstructionCost(U, Operands, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">    return getInstructionCost(U, Operands, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// If a branch or a select condition is skewed in one direction by more than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// If a branch or a select condition is skewed in one direction by more than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  /// this factor, it is very likely to be predicted correctly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  /// this factor, it is very likely to be predicted correctly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  BranchProbability getPredictableBranchThreshold() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  BranchProbability getPredictableBranchThreshold() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  /// Return true if branch divergence exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  /// Return true if branch divergence exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  /// Branch divergence has a significantly negative impact on GPU performance</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  /// Branch divergence has a significantly negative impact on GPU performance</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  /// when threads in the same wavefront take different paths due to conditional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  /// when threads in the same wavefront take different paths due to conditional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// branches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// branches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  /// If \p F is passed, provides a context function. If \p F is known to only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  /// If \p F is passed, provides a context function. If \p F is known to only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  /// execute in a single threaded environment, the target may choose to skip</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  /// execute in a single threaded environment, the target may choose to skip</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  /// uniformity analysis and assume all values are uniform.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  /// uniformity analysis and assume all values are uniform.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  bool hasBranchDivergence(const Function *F = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  bool hasBranchDivergence(const Function *F = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  /// Returns whether V is a source of divergence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  /// Returns whether V is a source of divergence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  /// This function provides the target-dependent information for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  /// This function provides the target-dependent information for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  /// the target-independent UniformityAnalysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  /// the target-independent UniformityAnalysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  bool isSourceOfDivergence(const Value *V) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  bool isSourceOfDivergence(const Value *V) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  // Returns true for the target specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  // Returns true for the target specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  // set of operations which produce uniform result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  // set of operations which produce uniform result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  // even taking non-uniform arguments</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  // even taking non-uniform arguments</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  bool isAlwaysUniform(const Value *V) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  bool isAlwaysUniform(const Value *V) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  /// Query the target whether the specified address space cast from FromAS to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  /// Query the target whether the specified address space cast from FromAS to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  /// ToAS is valid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  /// ToAS is valid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  /// Return false if a \p AS0 address cannot possibly alias a \p AS1 address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  /// Return false if a \p AS0 address cannot possibly alias a \p AS1 address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  /// Returns the address space ID for a target's 'flat' address space. Note</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  /// Returns the address space ID for a target's 'flat' address space. Note</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  /// this is not necessarily the same as addrspace(0), which LLVM sometimes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  /// this is not necessarily the same as addrspace(0), which LLVM sometimes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  /// refers to as the generic address space. The flat address space is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  /// refers to as the generic address space. The flat address space is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  /// generic address space that can be used access multiple segments of memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  /// generic address space that can be used access multiple segments of memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  /// with different address spaces. Access of a memory location through a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  /// with different address spaces. Access of a memory location through a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  /// pointer with this address space is expected to be legal but slower</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  /// pointer with this address space is expected to be legal but slower</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  /// compared to the same memory location accessed through a pointer with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  /// compared to the same memory location accessed through a pointer with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">  /// different address space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">  /// different address space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  /// This is for targets with different pointer representations which can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  /// This is for targets with different pointer representations which can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  /// be converted with the addrspacecast instruction. If a pointer is converted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  /// be converted with the addrspacecast instruction. If a pointer is converted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  /// to this address space, optimizations should attempt to replace the access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  /// to this address space, optimizations should attempt to replace the access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">  /// with the source address space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">  /// with the source address space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// \returns ~0u if the target does not have such a flat address space to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// \returns ~0u if the target does not have such a flat address space to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  /// optimize away.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  /// optimize away.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">  unsigned getFlatAddressSpace() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">  unsigned getFlatAddressSpace() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  /// Return any intrinsic address operand indexes which may be rewritten if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  /// Return any intrinsic address operand indexes which may be rewritten if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  /// they use a flat address space pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  /// they use a flat address space pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  /// \returns true if the intrinsic was handled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  /// \returns true if the intrinsic was handled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">                                  Intrinsic::ID IID) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">                                  Intrinsic::ID IID) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">  /// Return true if globals in this address space can have initializers other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">  /// Return true if globals in this address space can have initializers other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  /// than `undef`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  /// than `undef`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  bool canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  bool canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  unsigned getAssumedAddrSpace(const Value *V) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  unsigned getAssumedAddrSpace(const Value *V) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  bool isSingleThreaded() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  bool isSingleThreaded() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">  getPredicatedAddrSpace(const Value *V) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">  getPredicatedAddrSpace(const Value *V) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  /// Rewrite intrinsic call \p II such that \p OldV will be replaced with \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  /// Rewrite intrinsic call \p II such that \p OldV will be replaced with \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">  /// NewV, which has a different address space. This should happen for every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">  /// NewV, which has a different address space. This should happen for every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  /// operand index that collectFlatAddressOperands returned for the intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  /// operand index that collectFlatAddressOperands returned for the intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  /// \returns nullptr if the intrinsic was not handled. Otherwise, returns the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  /// \returns nullptr if the intrinsic was not handled. Otherwise, returns the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  /// new value (which may be the original \p II with modified operands).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  /// new value (which may be the original \p II with modified operands).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">                                          Value *NewV) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">                                          Value *NewV) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">  /// Test whether calls to a function lower to actual program function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">  /// Test whether calls to a function lower to actual program function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// The idea is to test whether the program is likely to require a 'call'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// The idea is to test whether the program is likely to require a 'call'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// instruction or equivalent in order to call the given function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// instruction or equivalent in order to call the given function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  /// FIXME: It's not clear that this is a good or useful query API. Client's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  /// FIXME: It's not clear that this is a good or useful query API. Client's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  /// should probably move to simpler cost metrics using the above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  /// should probably move to simpler cost metrics using the above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  /// Alternatively, we could split the cost interface into distinct code-size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  /// Alternatively, we could split the cost interface into distinct code-size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  /// and execution-speed costs. This would allow modelling the core of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  /// and execution-speed costs. This would allow modelling the core of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  /// query more accurately as a call is a single small instruction, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  /// query more accurately as a call is a single small instruction, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">  /// incurs significant execution cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">  /// incurs significant execution cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  bool isLoweredToCall(const Function *F) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  bool isLoweredToCall(const Function *F) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  struct LSRCost {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  struct LSRCost {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">    /// TODO: Some of these could be merged. Also, a lexical ordering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">    /// TODO: Some of these could be merged. Also, a lexical ordering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">    /// isn't always optimal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">    /// isn't always optimal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    unsigned Insns;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    unsigned Insns;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">    unsigned NumRegs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">    unsigned NumRegs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">    unsigned AddRecCost;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">    unsigned AddRecCost;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">    unsigned NumIVMuls;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">    unsigned NumIVMuls;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">    unsigned NumBaseAdds;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">    unsigned NumBaseAdds;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">    unsigned ImmCost;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">    unsigned ImmCost;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">    unsigned SetupCost;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">    unsigned SetupCost;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">    unsigned ScaleCost;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">    unsigned ScaleCost;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  /// Parameters that control the generic loop unrolling transformation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  /// Parameters that control the generic loop unrolling transformation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  struct UnrollingPreferences {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  struct UnrollingPreferences {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">    /// The cost threshold for the unrolled loop. Should be relative to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">    /// The cost threshold for the unrolled loop. Should be relative to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">    /// getInstructionCost values returned by this API, and the expectation is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">    /// getInstructionCost values returned by this API, and the expectation is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">    /// that the unrolled loop's instructions when run through that interface</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">    /// that the unrolled loop's instructions when run through that interface</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">    /// should not exceed this cost. However, this is only an estimate. Also,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">    /// should not exceed this cost. However, this is only an estimate. Also,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">    /// specific loops may be unrolled even with a cost above this threshold if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">    /// specific loops may be unrolled even with a cost above this threshold if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">    /// deemed profitable. Set this to UINT_MAX to disable the loop body cost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">    /// deemed profitable. Set this to UINT_MAX to disable the loop body cost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">    /// restriction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">    /// restriction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">    unsigned Threshold;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">    unsigned Threshold;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">    /// If complete unrolling will reduce the cost of the loop, we will boost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">    /// If complete unrolling will reduce the cost of the loop, we will boost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">    /// the Threshold by a certain percent to allow more aggressive complete</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">    /// the Threshold by a certain percent to allow more aggressive complete</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">    /// unrolling. This value provides the maximum boost percentage that we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">    /// unrolling. This value provides the maximum boost percentage that we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    /// can apply to Threshold (The value should be no less than 100).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    /// can apply to Threshold (The value should be no less than 100).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">    /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">    /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    ///                                    MaxPercentThresholdBoost / 100)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    ///                                    MaxPercentThresholdBoost / 100)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">    /// E.g. if complete unrolling reduces the loop execution time by 50%</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">    /// E.g. if complete unrolling reduces the loop execution time by 50%</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    /// then we boost the threshold by the factor of 2x. If unrolling is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    /// then we boost the threshold by the factor of 2x. If unrolling is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">    /// expected to reduce the running time, then we do not increase the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">    /// expected to reduce the running time, then we do not increase the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">    /// threshold.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">    /// threshold.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">    unsigned MaxPercentThresholdBoost;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">    unsigned MaxPercentThresholdBoost;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">    /// The cost threshold for the unrolled loop when optimizing for size (set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">    /// The cost threshold for the unrolled loop when optimizing for size (set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    /// to UINT_MAX to disable).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    /// to UINT_MAX to disable).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">    unsigned OptSizeThreshold;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">    unsigned OptSizeThreshold;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">    /// The cost threshold for the unrolled loop, like Threshold, but used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">    /// The cost threshold for the unrolled loop, like Threshold, but used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">    /// for partial/runtime unrolling (set to UINT_MAX to disable).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">    /// for partial/runtime unrolling (set to UINT_MAX to disable).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">    unsigned PartialThreshold;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">    unsigned PartialThreshold;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">    /// The cost threshold for the unrolled loop when optimizing for size, like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">    /// The cost threshold for the unrolled loop when optimizing for size, like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">    /// OptSizeThreshold, but used for partial/runtime unrolling (set to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">    /// OptSizeThreshold, but used for partial/runtime unrolling (set to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">    /// UINT_MAX to disable).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">    /// UINT_MAX to disable).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">    unsigned PartialOptSizeThreshold;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">    unsigned PartialOptSizeThreshold;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">    /// A forced unrolling factor (the number of concatenated bodies of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">    /// A forced unrolling factor (the number of concatenated bodies of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">    /// original loop in the unrolled loop body). When set to 0, the unrolling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">    /// original loop in the unrolled loop body). When set to 0, the unrolling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">    /// transformation will select an unrolling factor based on the current cost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">    /// transformation will select an unrolling factor based on the current cost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">    /// threshold and other factors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">    /// threshold and other factors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">    unsigned Count;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">    unsigned Count;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">    /// Default unroll count for loops with run-time trip count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">    /// Default unroll count for loops with run-time trip count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">    unsigned DefaultUnrollRuntimeCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">    unsigned DefaultUnrollRuntimeCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">    // Set the maximum unrolling factor. The unrolling factor may be selected</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">    // Set the maximum unrolling factor. The unrolling factor may be selected</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">    // using the appropriate cost threshold, but may not exceed this number</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">    // using the appropriate cost threshold, but may not exceed this number</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    // (set to UINT_MAX to disable). This does not apply in cases where the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    // (set to UINT_MAX to disable). This does not apply in cases where the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">    // loop is being fully unrolled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">    // loop is being fully unrolled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">    unsigned MaxCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">    unsigned MaxCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">    /// Set the maximum unrolling factor for full unrolling. Like MaxCount, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">    /// Set the maximum unrolling factor for full unrolling. Like MaxCount, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">    /// applies even if full unrolling is selected. This allows a target to fall</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">    /// applies even if full unrolling is selected. This allows a target to fall</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">    /// back to Partial unrolling if full unrolling is above FullUnrollMaxCount.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">    /// back to Partial unrolling if full unrolling is above FullUnrollMaxCount.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">    unsigned FullUnrollMaxCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">    unsigned FullUnrollMaxCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">    // Represents number of instructions optimized when "back edge"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">    // Represents number of instructions optimized when "back edge"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">    // becomes "fall through" in unrolled loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">    // becomes "fall through" in unrolled loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">    // For now we count a conditional branch on a backedge and a comparison</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">    // For now we count a conditional branch on a backedge and a comparison</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">    // feeding it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">    // feeding it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">    unsigned BEInsns;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">    unsigned BEInsns;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">    /// Allow partial unrolling (unrolling of loops to expand the size of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">    /// Allow partial unrolling (unrolling of loops to expand the size of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">    /// loop body, not only to eliminate small constant-trip-count loops).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">    /// loop body, not only to eliminate small constant-trip-count loops).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">    bool Partial;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">    bool Partial;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">    /// Allow runtime unrolling (unrolling of loops to expand the size of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">    /// Allow runtime unrolling (unrolling of loops to expand the size of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">    /// loop body even when the number of loop iterations is not known at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">    /// loop body even when the number of loop iterations is not known at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">    /// compile time).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">    /// compile time).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">    bool Runtime;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">    bool Runtime;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">    /// Allow generation of a loop remainder (extra iterations after unroll).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">    /// Allow generation of a loop remainder (extra iterations after unroll).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">    bool AllowRemainder;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">    bool AllowRemainder;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">    /// Allow emitting expensive instructions (such as divisions) when computing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">    /// Allow emitting expensive instructions (such as divisions) when computing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">    /// the trip count of a loop for runtime unrolling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">    /// the trip count of a loop for runtime unrolling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">    bool AllowExpensiveTripCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">    bool AllowExpensiveTripCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">    /// Apply loop unroll on any kind of loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">    /// Apply loop unroll on any kind of loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    /// (mainly to loops that fail runtime unrolling).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    /// (mainly to loops that fail runtime unrolling).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    bool Force;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    bool Force;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">    /// Allow using trip count upper bound to unroll loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">    /// Allow using trip count upper bound to unroll loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">    bool UpperBound;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">    bool UpperBound;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">    /// Allow unrolling of all the iterations of the runtime loop remainder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">    /// Allow unrolling of all the iterations of the runtime loop remainder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">    bool UnrollRemainder;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">    bool UnrollRemainder;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    /// Allow unroll and jam. Used to enable unroll and jam for the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    /// Allow unroll and jam. Used to enable unroll and jam for the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">    bool UnrollAndJam;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">    bool UnrollAndJam;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">    /// Threshold for unroll and jam, for inner loop size. The 'Threshold'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">    /// Threshold for unroll and jam, for inner loop size. The 'Threshold'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    /// value above is used during unroll and jam for the outer loop size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    /// value above is used during unroll and jam for the outer loop size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">    /// This value is used in the same manner to limit the size of the inner</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">    /// This value is used in the same manner to limit the size of the inner</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    /// loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    /// loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">    unsigned UnrollAndJamInnerLoopThreshold;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">    unsigned UnrollAndJamInnerLoopThreshold;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    /// Don't allow loop unrolling to simulate more than this number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    /// Don't allow loop unrolling to simulate more than this number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">    /// iterations when checking full unroll profitability</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">    /// iterations when checking full unroll profitability</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    unsigned MaxIterationsCountToAnalyze;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    unsigned MaxIterationsCountToAnalyze;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">    /// Don't disable runtime unroll for the loops which were vectorized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">    /// Don't disable runtime unroll for the loops which were vectorized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">    bool UnrollVectorizedLoop = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">    bool UnrollVectorizedLoop = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// Get target-customized preferences for the generic loop unrolling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// Get target-customized preferences for the generic loop unrolling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// transformation. The caller will initialize UP with the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// transformation. The caller will initialize UP with the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  /// target-independent defaults.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  /// target-independent defaults.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">                               UnrollingPreferences &UP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">                               UnrollingPreferences &UP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">                               OptimizationRemarkEmitter *ORE) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">                               OptimizationRemarkEmitter *ORE) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  /// Query the target whether it would be profitable to convert the given loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  /// Query the target whether it would be profitable to convert the given loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  /// into a hardware loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  /// into a hardware loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">                                HardwareLoopInfo &HWLoopInfo) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">                                HardwareLoopInfo &HWLoopInfo) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// Query the target whether it would be prefered to create a predicated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// Query the target whether it would be prefered to create a predicated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  /// vector loop, which can avoid the need to emit a scalar epilogue loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  /// vector loop, which can avoid the need to emit a scalar epilogue loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  /// Query the target what the preferred style of tail folding is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  /// Query the target what the preferred style of tail folding is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">  /// \param IVUpdateMayOverflow Tells whether it is known if the IV update</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">  /// \param IVUpdateMayOverflow Tells whether it is known if the IV update</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">  /// may (or will never) overflow for the suggested VF/UF in the given loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">  /// may (or will never) overflow for the suggested VF/UF in the given loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">  /// Targets can use this information to select a more optimal tail folding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">  /// Targets can use this information to select a more optimal tail folding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  /// style. The value conservatively defaults to true, such that no assumptions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  /// style. The value conservatively defaults to true, such that no assumptions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// are made on overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// are made on overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  TailFoldingStyle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  TailFoldingStyle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  // Parameters that control the loop peeling transformation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  // Parameters that control the loop peeling transformation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  struct PeelingPreferences {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  struct PeelingPreferences {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">    /// A forced peeling factor (the number of bodied of the original loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">    /// A forced peeling factor (the number of bodied of the original loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">    /// that should be peeled off before the loop body). When set to 0, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">    /// that should be peeled off before the loop body). When set to 0, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">    /// a peeling factor based on profile information and other factors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">    /// a peeling factor based on profile information and other factors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">    unsigned PeelCount;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">    unsigned PeelCount;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">    /// Allow peeling off loop iterations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">    /// Allow peeling off loop iterations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">    bool AllowPeeling;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">    bool AllowPeeling;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    /// Allow peeling off loop iterations for loop nests.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    /// Allow peeling off loop iterations for loop nests.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">    bool AllowLoopNestsPeeling;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">    bool AllowLoopNestsPeeling;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">    /// Allow peeling basing on profile. Uses to enable peeling off all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">    /// Allow peeling basing on profile. Uses to enable peeling off all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">    /// iterations basing on provided profile.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">    /// iterations basing on provided profile.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    /// If the value is true the peeling cost model can decide to peel only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    /// If the value is true the peeling cost model can decide to peel only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    /// some iterations and in this case it will set this to false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    /// some iterations and in this case it will set this to false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">    bool PeelProfiledIterations;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">    bool PeelProfiledIterations;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  /// Get target-customized preferences for the generic loop peeling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  /// Get target-customized preferences for the generic loop peeling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  /// transformation. The caller will initialize \p PP with the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  /// transformation. The caller will initialize \p PP with the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  /// target-independent defaults with information from \p L and \p SE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  /// target-independent defaults with information from \p L and \p SE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">                             PeelingPreferences &PP) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">                             PeelingPreferences &PP) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  /// Targets can implement their own combinations for target-specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  /// Targets can implement their own combinations for target-specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  /// intrinsics. This function will be called from the InstCombine pass every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  /// intrinsics. This function will be called from the InstCombine pass every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  /// time a target-specific intrinsic is encountered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  /// time a target-specific intrinsic is encountered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  /// \returns std::nullopt to not do anything target specific or a value that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  /// \returns std::nullopt to not do anything target specific or a value that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  /// will be returned from the InstCombiner. It is possible to return null and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  /// will be returned from the InstCombiner. It is possible to return null and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  /// stop further processing of the intrinsic by returning nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  /// stop further processing of the intrinsic by returning nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner & IC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner & IC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">                                                    IntrinsicInst & II) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">                                                    IntrinsicInst & II) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  /// Can be used to implement target-specific instruction combining.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  /// Can be used to implement target-specific instruction combining.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  /// \see instCombineIntrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  /// \see instCombineIntrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">      KnownBits & Known, bool &KnownBitsComputed) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">      KnownBits & Known, bool &KnownBitsComputed) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  /// Can be used to implement target-specific instruction combining.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  /// Can be used to implement target-specific instruction combining.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  /// \see instCombineIntrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  /// \see instCombineIntrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">      InstCombiner & IC, IntrinsicInst & II, APInt DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">      APInt & UndefElts, APInt & UndefElts2, APInt & UndefElts3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">      APInt & UndefElts, APInt & UndefElts2, APInt & UndefElts3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">          SimplifyAndSetOp) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">          SimplifyAndSetOp) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  /// \name Scalar Target Information</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  /// \name Scalar Target Information</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  /// Flags indicating the kind of support for population count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  /// Flags indicating the kind of support for population count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// Compared to the SW implementation, HW support is supposed to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// Compared to the SW implementation, HW support is supposed to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  /// significantly boost the performance when the population is dense, and it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  /// significantly boost the performance when the population is dense, and it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  /// may or may not degrade performance if the population is sparse. A HW</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  /// may or may not degrade performance if the population is sparse. A HW</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  /// support is considered as "Fast" if it can outperform, or is on a par</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  /// support is considered as "Fast" if it can outperform, or is on a par</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  /// with, SW implementation when the population is sparse; otherwise, it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  /// with, SW implementation when the population is sparse; otherwise, it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  /// considered as "Slow".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  /// considered as "Slow".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">  enum PopcntSupportKind { PSK_Software, PSK_SlowHardware, PSK_FastHardware };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">  enum PopcntSupportKind { PSK_Software, PSK_SlowHardware, PSK_FastHardware };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal add immediate, that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal add immediate, that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  /// is the target has add instructions which can add a register with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  /// is the target has add instructions which can add a register with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  /// immediate without having to materialize the immediate into a register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  /// immediate without having to materialize the immediate into a register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  bool isLegalAddImmediate(int64_t Imm) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  bool isLegalAddImmediate(int64_t Imm) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal icmp immediate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  /// Return true if the specified immediate is legal icmp immediate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  /// that is the target has icmp instructions which can compare a register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  /// that is the target has icmp instructions which can compare a register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// against the immediate without having to materialize the immediate into a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// against the immediate without having to materialize the immediate into a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  bool isLegalICmpImmediate(int64_t Imm) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  bool isLegalICmpImmediate(int64_t Imm) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// Return true if the addressing mode represented by AM is legal for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// Return true if the addressing mode represented by AM is legal for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// this target, for a load/store of the specified type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// this target, for a load/store of the specified type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  /// The type may be VoidTy, in which case only return true if the addressing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  /// The type may be VoidTy, in which case only return true if the addressing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  /// mode is legal for a load/store of any legal type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  /// mode is legal for a load/store of any legal type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">  /// If target returns true in LSRWithInstrQueries(), I may be valid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">  /// If target returns true in LSRWithInstrQueries(), I may be valid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">  /// TODO: Handle pre/postinc as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">  /// TODO: Handle pre/postinc as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">                             bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">                             bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">                             unsigned AddrSpace = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">                             unsigned AddrSpace = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">                             Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">                             Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  /// Return true if LSR cost of C1 is lower than C2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  /// Return true if LSR cost of C1 is lower than C2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">                     const TargetTransformInfo::LSRCost &C2) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">                     const TargetTransformInfo::LSRCost &C2) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// Return true if LSR major cost is number of registers. Targets which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// Return true if LSR major cost is number of registers. Targets which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  /// implement their own isLSRCostLess and unset number of registers as major</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  /// implement their own isLSRCostLess and unset number of registers as major</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">  /// cost should return false, otherwise return true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">  /// cost should return false, otherwise return true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  bool isNumRegsMajorCostOfLSR() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  bool isNumRegsMajorCostOfLSR() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  /// \returns true if LSR should not optimize a chain that includes \p I.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  /// \returns true if LSR should not optimize a chain that includes \p I.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  bool isProfitableLSRChainElement(Instruction *I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  bool isProfitableLSRChainElement(Instruction *I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  /// Return true if the target can fuse a compare and branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  /// Return true if the target can fuse a compare and branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  /// Loop-strength-reduction (LSR) uses that knowledge to adjust its cost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  /// Loop-strength-reduction (LSR) uses that knowledge to adjust its cost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  /// calculation for the instructions in a loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  /// calculation for the instructions in a loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">  bool canMacroFuseCmp() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">  bool canMacroFuseCmp() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">  /// Return true if the target can save a compare for loop count, for example</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">  /// Return true if the target can save a compare for loop count, for example</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">  /// hardware loop saves a compare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">  /// hardware loop saves a compare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">                  DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">                  DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">                  TargetLibraryInfo *LibInfo) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">                  TargetLibraryInfo *LibInfo) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  enum AddressingModeKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  enum AddressingModeKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">    AMK_PreIndexed,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">    AMK_PreIndexed,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    AMK_PostIndexed,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    AMK_PostIndexed,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    AMK_None</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    AMK_None</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  /// Return the preferred addressing mode LSR should make efforts to generate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  /// Return the preferred addressing mode LSR should make efforts to generate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  AddressingModeKind getPreferredAddressingMode(const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  AddressingModeKind getPreferredAddressingMode(const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">                                                ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">                                                ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">  /// Return true if the target supports masked store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">  /// Return true if the target supports masked store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">  bool isLegalMaskedStore(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">  bool isLegalMaskedStore(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  /// Return true if the target supports masked load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  /// Return true if the target supports masked load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  /// Return true if the target supports nontemporal store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  /// Return true if the target supports nontemporal store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  bool isLegalNTStore(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  bool isLegalNTStore(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  /// Return true if the target supports nontemporal load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  /// Return true if the target supports nontemporal load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">  bool isLegalNTLoad(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">  bool isLegalNTLoad(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">  /// \Returns true if the target supports broadcasting a load to a vector of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">  /// \Returns true if the target supports broadcasting a load to a vector of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  /// type <NumElements x ElementTy>.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  /// type <NumElements x ElementTy>.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">  bool isLegalBroadcastLoad(Type *ElementTy, ElementCount NumElements) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">  bool isLegalBroadcastLoad(Type *ElementTy, ElementCount NumElements) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// Return true if the target supports masked scatter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// Return true if the target supports masked scatter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  /// Return true if the target supports masked gather.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  /// Return true if the target supports masked gather.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">  bool isLegalMaskedGather(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">  bool isLegalMaskedGather(Type *DataType, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">  /// Return true if the target forces scalarizing of llvm.masked.gather</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">  /// Return true if the target forces scalarizing of llvm.masked.gather</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">  /// intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">  /// intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">  bool forceScalarizeMaskedGather(VectorType *Type, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">  bool forceScalarizeMaskedGather(VectorType *Type, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">  /// Return true if the target forces scalarizing of llvm.masked.scatter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">  /// Return true if the target forces scalarizing of llvm.masked.scatter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">  /// intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">  /// intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">  bool forceScalarizeMaskedScatter(VectorType *Type, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">  bool forceScalarizeMaskedScatter(VectorType *Type, Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  /// Return true if the target supports masked compress store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  /// Return true if the target supports masked compress store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">  bool isLegalMaskedCompressStore(Type *DataType) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">  bool isLegalMaskedCompressStore(Type *DataType) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  /// Return true if the target supports masked expand load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  /// Return true if the target supports masked expand load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">  bool isLegalMaskedExpandLoad(Type *DataType) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">  bool isLegalMaskedExpandLoad(Type *DataType) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  /// Return true if this is an alternating opcode pattern that can be lowered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  /// Return true if this is an alternating opcode pattern that can be lowered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">  /// to a single instruction on the target. In X86 this is for the addsub</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">  /// to a single instruction on the target. In X86 this is for the addsub</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">  /// instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">  /// instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">  /// This function expectes two opcodes: \p Opcode1 and \p Opcode2 being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">  /// This function expectes two opcodes: \p Opcode1 and \p Opcode2 being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  /// when \p Opcode0 is selected and `1` when Opcode1 is selected.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  /// when \p Opcode0 is selected and `1` when Opcode1 is selected.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">  /// \p VecTy is the vector type of the instruction to be generated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">  /// \p VecTy is the vector type of the instruction to be generated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">                       const SmallBitVector &OpcodeMask) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">                       const SmallBitVector &OpcodeMask) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  /// Return true if we should be enabling ordered reductions for the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  /// Return true if we should be enabling ordered reductions for the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  bool enableOrderedReductions() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  bool enableOrderedReductions() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">  /// Return true if the target has a unified operation to calculate division</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">  /// Return true if the target has a unified operation to calculate division</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  /// and remainder. If so, the additional implicit multiplication and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  /// and remainder. If so, the additional implicit multiplication and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  /// subtraction required to calculate a remainder from division are free. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  /// subtraction required to calculate a remainder from division are free. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">  /// can enable more aggressive transformations for division and remainder than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">  /// can enable more aggressive transformations for division and remainder than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  /// would typically be allowed using throughput or size cost models.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  /// would typically be allowed using throughput or size cost models.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  bool hasDivRemOp(Type *DataType, bool IsSigned) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  bool hasDivRemOp(Type *DataType, bool IsSigned) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  /// Return true if the given instruction (assumed to be a memory access</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  /// Return true if the given instruction (assumed to be a memory access</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  /// instruction) has a volatile variant. If that's the case then we can avoid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  /// instruction) has a volatile variant. If that's the case then we can avoid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  /// addrspacecast to generic AS for volatile loads/stores. Default</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  /// addrspacecast to generic AS for volatile loads/stores. Default</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">  /// implementation returns false, which prevents address space inference for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">  /// implementation returns false, which prevents address space inference for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">  /// volatile loads/stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">  /// volatile loads/stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">  /// Return true if target doesn't mind addresses in vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">  /// Return true if target doesn't mind addresses in vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">  bool prefersVectorizedAddressing() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">  bool prefersVectorizedAddressing() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">  /// Return the cost of the scaling factor used in the addressing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">  /// Return the cost of the scaling factor used in the addressing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">  /// mode represented by AM for this target, for a load/store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">  /// mode represented by AM for this target, for a load/store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  /// of the specified type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  /// of the specified type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  /// If the AM is supported, the return value must be >= 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  /// If the AM is supported, the return value must be >= 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  /// If the AM is not supported, it returns a negative value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  /// If the AM is not supported, it returns a negative value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">  /// TODO: Handle pre/postinc as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">  /// TODO: Handle pre/postinc as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">                                       int64_t Scale,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">                                       int64_t Scale,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">                                       unsigned AddrSpace = 0) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">                                       unsigned AddrSpace = 0) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  /// Return true if the loop strength reduce pass should make</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  /// Return true if the loop strength reduce pass should make</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  /// Instruction* based TTI queries to isLegalAddressingMode(). This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  /// Instruction* based TTI queries to isLegalAddressingMode(). This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">  /// needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">  /// needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  /// immediate offset and no index register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  /// immediate offset and no index register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  bool LSRWithInstrQueries() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  bool LSRWithInstrQueries() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// Return true if it's free to truncate a value of type Ty1 to type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// Return true if it's free to truncate a value of type Ty1 to type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// Ty2. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// Ty2. e.g. On x86 it's free to truncate a i32 value in register EAX to i16</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  /// by referencing its sub-register AX.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  /// by referencing its sub-register AX.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">  bool isTruncateFree(Type *Ty1, Type *Ty2) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">  bool isTruncateFree(Type *Ty1, Type *Ty2) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  /// Return true if it is profitable to hoist instruction in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  /// Return true if it is profitable to hoist instruction in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  /// then/else to before if.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  /// then/else to before if.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  bool isProfitableToHoist(Instruction *I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  bool isProfitableToHoist(Instruction *I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  bool useAA() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  bool useAA() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  /// Return true if this type is legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  /// Return true if this type is legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  bool isTypeLegal(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  bool isTypeLegal(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  /// Returns the estimated number of registers required to represent \p Ty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  /// Returns the estimated number of registers required to represent \p Ty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  unsigned getRegUsageForType(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  unsigned getRegUsageForType(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">  /// Return true if switches should be turned into lookup tables for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">  /// Return true if switches should be turned into lookup tables for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  /// target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  /// target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  bool shouldBuildLookupTables() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  bool shouldBuildLookupTables() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  /// Return true if switches should be turned into lookup tables</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  /// Return true if switches should be turned into lookup tables</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">  /// containing this constant value for the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">  /// containing this constant value for the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  bool shouldBuildLookupTablesForConstant(Constant *C) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  bool shouldBuildLookupTablesForConstant(Constant *C) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  /// Return true if lookup tables should be turned into relative lookup tables.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  /// Return true if lookup tables should be turned into relative lookup tables.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  bool shouldBuildRelLookupTables() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  bool shouldBuildRelLookupTables() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  /// Return true if the input function which is cold at all call sites,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  /// Return true if the input function which is cold at all call sites,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  ///  should use coldcc calling convention.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  ///  should use coldcc calling convention.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  bool useColdCCForColdCall(Function &F) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  bool useColdCCForColdCall(Function &F) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  /// are set if the demanded result elements need to be inserted and/or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  /// are set if the demanded result elements need to be inserted and/or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  /// extracted from vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  /// extracted from vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing an instructions unique</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing an instructions unique</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  /// non-constant operands. The (potentially vector) types to use for each of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  /// non-constant operands. The (potentially vector) types to use for each of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  /// argument are passes via Tys.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  /// argument are passes via Tys.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  /// If target has efficient vector element load/store instructions, it can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  /// If target has efficient vector element load/store instructions, it can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  /// return true here so that insertion/extraction costs are not added to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  /// return true here so that insertion/extraction costs are not added to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  /// the scalarization cost of a load/store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  /// the scalarization cost of a load/store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  bool supportsEfficientVectorElementLoadStore() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  bool supportsEfficientVectorElementLoadStore() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  /// If the target supports tail calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  /// If the target supports tail calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  bool supportsTailCalls() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  bool supportsTailCalls() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// If target supports tail call on \p CB</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// If target supports tail call on \p CB</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  bool supportsTailCallFor(const CallBase *CB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  bool supportsTailCallFor(const CallBase *CB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  /// Don't restrict interleaved unrolling to small loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  /// Don't restrict interleaved unrolling to small loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">  bool enableAggressiveInterleaving(bool LoopHasReductions) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">  bool enableAggressiveInterleaving(bool LoopHasReductions) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">  /// Returns options for expansion of memcmp. IsZeroCmp is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">  /// Returns options for expansion of memcmp. IsZeroCmp is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">  // true if this is the expansion of memcmp(p1, p2, s) == 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">  // true if this is the expansion of memcmp(p1, p2, s) == 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  struct MemCmpExpansionOptions {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  struct MemCmpExpansionOptions {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">    // Return true if memcmp expansion is enabled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">    // Return true if memcmp expansion is enabled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">    operator bool() const { return MaxNumLoads > 0; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">    operator bool() const { return MaxNumLoads > 0; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">    // Maximum number of load operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">    // Maximum number of load operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">    unsigned MaxNumLoads = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">    unsigned MaxNumLoads = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">    // The list of available load sizes (in bytes), sorted in decreasing order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">    // The list of available load sizes (in bytes), sorted in decreasing order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">    SmallVector<unsigned, 8> LoadSizes;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">    SmallVector<unsigned, 8> LoadSizes;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">    // For memcmp expansion when the memcmp result is only compared equal or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">    // For memcmp expansion when the memcmp result is only compared equal or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">    // not-equal to 0, allow up to this number of load pairs per block. As an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">    // not-equal to 0, allow up to this number of load pairs per block. As an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">    // example, this may allow 'memcmp(a, b, 3) == 0' in a single block:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">    // example, this may allow 'memcmp(a, b, 3) == 0' in a single block:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">    //   a0 = load2bytes &a[0]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">    //   a0 = load2bytes &a[0]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">    //   b0 = load2bytes &b[0]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">    //   b0 = load2bytes &b[0]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">    //   a2 = load1byte  &a[2]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">    //   a2 = load1byte  &a[2]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">    //   b2 = load1byte  &b[2]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">    //   b2 = load1byte  &b[2]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">    //   r  = cmp eq (a0 ^ b0 | a2 ^ b2), 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">    //   r  = cmp eq (a0 ^ b0 | a2 ^ b2), 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">    unsigned NumLoadsPerBlock = 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">    unsigned NumLoadsPerBlock = 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">    // Set to true to allow overlapping loads. For example, 7-byte compares can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">    // Set to true to allow overlapping loads. For example, 7-byte compares can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">    // be done with two 4-byte compares instead of 4+2+1-byte compares. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">    // be done with two 4-byte compares instead of 4+2+1-byte compares. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">    // requires all loads in LoadSizes to be doable in an unaligned way.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">    // requires all loads in LoadSizes to be doable in an unaligned way.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">    bool AllowOverlappingLoads = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">    bool AllowOverlappingLoads = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">                                               bool IsZeroCmp) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">                                               bool IsZeroCmp) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">  /// Should the Select Optimization pass be enabled and ran.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">  /// Should the Select Optimization pass be enabled and ran.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  bool enableSelectOptimize() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  bool enableSelectOptimize() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  /// Enable matching of interleaved access groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  /// Enable matching of interleaved access groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  bool enableInterleavedAccessVectorization() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  bool enableInterleavedAccessVectorization() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  /// Enable matching of interleaved access groups that contain predicated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  /// Enable matching of interleaved access groups that contain predicated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  /// accesses or gaps and therefore vectorized using masked</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  /// accesses or gaps and therefore vectorized using masked</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">  /// vector loads/stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">  /// vector loads/stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">  bool enableMaskedInterleavedAccessVectorization() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">  bool enableMaskedInterleavedAccessVectorization() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  /// Indicate that it is potentially unsafe to automatically vectorize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  /// Indicate that it is potentially unsafe to automatically vectorize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">  /// floating-point operations because the semantics of vector and scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">  /// floating-point operations because the semantics of vector and scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  /// does not support IEEE-754 denormal numbers, while depending on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  /// does not support IEEE-754 denormal numbers, while depending on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">  /// platform, scalar floating-point math does.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">  /// platform, scalar floating-point math does.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">  /// This applies to floating-point math operations and calls, not memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">  /// This applies to floating-point math operations and calls, not memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">  /// operations, shuffles, or casts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">  /// operations, shuffles, or casts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">  bool isFPVectorizationPotentiallyUnsafe() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">  bool isFPVectorizationPotentiallyUnsafe() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">  /// Determine if the target supports unaligned memory accesses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">  /// Determine if the target supports unaligned memory accesses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">                                      unsigned AddressSpace = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">                                      unsigned AddressSpace = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">                                      Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">                                      Align Alignment = Align(1),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">                                      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">                                      unsigned *Fast = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  /// Return hardware support for population count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  /// Return hardware support for population count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">  /// Return true if the hardware has a fast square-root instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">  /// Return true if the hardware has a fast square-root instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">  bool haveFastSqrt(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">  bool haveFastSqrt(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">  /// Return true if the cost of the instruction is too high to speculatively</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">  /// Return true if the cost of the instruction is too high to speculatively</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  /// execute and should be kept behind a branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  /// execute and should be kept behind a branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">  /// This normally just wraps around a getInstructionCost() call, but some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">  /// This normally just wraps around a getInstructionCost() call, but some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  /// targets might report a low TCK_SizeAndLatency value that is incompatible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  /// targets might report a low TCK_SizeAndLatency value that is incompatible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">  /// with the fixed TCC_Expensive value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">  /// with the fixed TCC_Expensive value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  /// NOTE: This assumes the instruction passes isSafeToSpeculativelyExecute().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  /// NOTE: This assumes the instruction passes isSafeToSpeculativelyExecute().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">  bool isExpensiveToSpeculativelyExecute(const Instruction *I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">  bool isExpensiveToSpeculativelyExecute(const Instruction *I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">  /// Return true if it is faster to check if a floating-point value is NaN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">  /// Return true if it is faster to check if a floating-point value is NaN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">  /// (or not-NaN) versus a comparison against a constant FP zero value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">  /// (or not-NaN) versus a comparison against a constant FP zero value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">  /// Targets should override this if materializing a 0.0 for comparison is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">  /// Targets should override this if materializing a 0.0 for comparison is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">  /// generally as cheap as checking for ordered/unordered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">  /// generally as cheap as checking for ordered/unordered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  /// Return the expected cost of supporting the floating point operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  /// Return the expected cost of supporting the floating point operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  /// of the specified type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  /// of the specified type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">  InstructionCost getFPOpCost(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">  InstructionCost getFPOpCost(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  /// Return the expected cost of materializing for the given integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  /// Return the expected cost of materializing for the given integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  /// immediate of the specified type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  /// immediate of the specified type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">                                TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">                                TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// Return the expected cost of materialization for the given integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// Return the expected cost of materialization for the given integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  /// immediate of the specified type for a given instruction. The cost can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  /// immediate of the specified type for a given instruction. The cost can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  /// zero if the immediate can be folded into the specified instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  /// zero if the immediate can be folded into the specified instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">                                    const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">                                    const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">                                    TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">                                    TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">                                    Instruction *Inst = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">                                    Instruction *Inst = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">                                      const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">                                      const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">                                      TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">                                      TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">  /// Return the expected cost for the given integer when optimising</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">  /// Return the expected cost for the given integer when optimising</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  /// for size. This is different than the other integer immediate cost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  /// for size. This is different than the other integer immediate cost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  /// functions in that it is subtarget agnostic. This is useful when you e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  /// functions in that it is subtarget agnostic. This is useful when you e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">  /// target one ISA such as Aarch32 but smaller encodings could be possible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">  /// target one ISA such as Aarch32 but smaller encodings could be possible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  /// with another such as Thumb. This return value is used as a penalty when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  /// with another such as Thumb. This return value is used as a penalty when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">  /// the total costs for a constant is calculated (the bigger the cost, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">  /// the total costs for a constant is calculated (the bigger the cost, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// more beneficial constant hoisting is).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// more beneficial constant hoisting is).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">                                        const APInt &Imm, Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">                                        const APInt &Imm, Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">  /// \name Vector Target Information</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">  /// \name Vector Target Information</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">  /// The various kinds of shuffle patterns for vector queries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">  /// The various kinds of shuffle patterns for vector queries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">  enum ShuffleKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">  enum ShuffleKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">    SK_Broadcast,        ///< Broadcast element 0 to all other elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">    SK_Broadcast,        ///< Broadcast element 0 to all other elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">    SK_Reverse,          ///< Reverse the order of the vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">    SK_Reverse,          ///< Reverse the order of the vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">    SK_Select,           ///< Selects elements from the corresponding lane of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">    SK_Select,           ///< Selects elements from the corresponding lane of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">                         ///< either source operand. This is equivalent to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">                         ///< either source operand. This is equivalent to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">                         ///< vector select with a constant condition operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">                         ///< vector select with a constant condition operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">    SK_Transpose,        ///< Transpose two vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">    SK_Transpose,        ///< Transpose two vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">    SK_InsertSubvector,  ///< InsertSubvector. Index indicates start offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">    SK_InsertSubvector,  ///< InsertSubvector. Index indicates start offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">    SK_ExtractSubvector, ///< ExtractSubvector Index indicates start offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">    SK_ExtractSubvector, ///< ExtractSubvector Index indicates start offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">    SK_PermuteTwoSrc,    ///< Merge elements from two source vectors into one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">    SK_PermuteTwoSrc,    ///< Merge elements from two source vectors into one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">                         ///< with any shuffle mask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">                         ///< with any shuffle mask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    SK_PermuteSingleSrc, ///< Shuffle elements of single source vector with any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    SK_PermuteSingleSrc, ///< Shuffle elements of single source vector with any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">                         ///< shuffle mask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">                         ///< shuffle mask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">    SK_Splice            ///< Concatenates elements from the first input vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">    SK_Splice            ///< Concatenates elements from the first input vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">                         ///< with elements of the second input vector. Returning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">                         ///< with elements of the second input vector. Returning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">                         ///< a vector of the same type as the input vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">                         ///< a vector of the same type as the input vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">                         ///< Index indicates start offset in first input vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">                         ///< Index indicates start offset in first input vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  /// Additional information about an operand's possible values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  /// Additional information about an operand's possible values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  enum OperandValueKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  enum OperandValueKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">    OK_AnyValue,               // Operand can have any value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">    OK_AnyValue,               // Operand can have any value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">    OK_UniformValue,           // Operand is uniform (splat of a value).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">    OK_UniformValue,           // Operand is uniform (splat of a value).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    OK_UniformConstantValue,   // Operand is uniform constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    OK_UniformConstantValue,   // Operand is uniform constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">    OK_NonUniformConstantValue // Operand is a non uniform constant value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">    OK_NonUniformConstantValue // Operand is a non uniform constant value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">  /// Additional properties of an operand's values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">  /// Additional properties of an operand's values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">  enum OperandValueProperties {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">  enum OperandValueProperties {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">    OP_None = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">    OP_None = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">    OP_PowerOf2 = 1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">    OP_PowerOf2 = 1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">    OP_NegatedPowerOf2 = 2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">    OP_NegatedPowerOf2 = 2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">  // Describe the values an operand can take.  We're in the process</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">  // Describe the values an operand can take.  We're in the process</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  // of migrating uses of OperandValueKind and OperandValueProperties</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  // of migrating uses of OperandValueKind and OperandValueProperties</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // to use this class, and then will change the internal representation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // to use this class, and then will change the internal representation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  struct OperandValueInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  struct OperandValueInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">    OperandValueKind Kind = OK_AnyValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">    OperandValueKind Kind = OK_AnyValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">    OperandValueProperties Properties = OP_None;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">    OperandValueProperties Properties = OP_None;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">    bool isConstant() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">    bool isConstant() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">      return Kind == OK_UniformConstantValue || Kind == OK_NonUniformConstantValue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">      return Kind == OK_UniformConstantValue || Kind == OK_NonUniformConstantValue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">    bool isUniform() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">    bool isUniform() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">      return Kind == OK_UniformConstantValue || Kind == OK_UniformValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">      return Kind == OK_UniformConstantValue || Kind == OK_UniformValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">    bool isPowerOf2() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">    bool isPowerOf2() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">      return Properties == OP_PowerOf2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">      return Properties == OP_PowerOf2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">    bool isNegatedPowerOf2() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">    bool isNegatedPowerOf2() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">      return Properties == OP_NegatedPowerOf2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">      return Properties == OP_NegatedPowerOf2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">    OperandValueInfo getNoProps() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">    OperandValueInfo getNoProps() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">      return {Kind, OP_None};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">      return {Kind, OP_None};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">  /// \return the number of registers in the target-provided register class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">  /// \return the number of registers in the target-provided register class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  unsigned getNumberOfRegisters(unsigned ClassID) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  unsigned getNumberOfRegisters(unsigned ClassID) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">  /// \return the target-provided register class ID for the provided type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">  /// \return the target-provided register class ID for the provided type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  /// accounting for type promotion and other type-legalization techniques that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  /// accounting for type promotion and other type-legalization techniques that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  /// the target might apply. However, it specifically does not account for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  /// the target might apply. However, it specifically does not account for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  /// scalarization or splitting of vector types. Should a vector type require</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  /// scalarization or splitting of vector types. Should a vector type require</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  /// scalarization or splitting into multiple underlying vector registers, that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  /// scalarization or splitting into multiple underlying vector registers, that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  /// type should be mapped to a register class containing no registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  /// type should be mapped to a register class containing no registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  /// Specifically, this is designed to provide a simple, high-level view of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  /// Specifically, this is designed to provide a simple, high-level view of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  /// register allocation later performed by the backend. These register classes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  /// register allocation later performed by the backend. These register classes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  /// don't necessarily map onto the register classes used by the backend.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  /// don't necessarily map onto the register classes used by the backend.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">  /// FIXME: It's not currently possible to determine how many registers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">  /// FIXME: It's not currently possible to determine how many registers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  /// are used by the provided type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  /// are used by the provided type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">  unsigned getRegisterClassForType(bool Vector, Type *Ty = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">  unsigned getRegisterClassForType(bool Vector, Type *Ty = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// \return the target-provided register class name</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// \return the target-provided register class name</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">  const char *getRegisterClassName(unsigned ClassID) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">  const char *getRegisterClassName(unsigned ClassID) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  enum RegisterKind { RGK_Scalar, RGK_FixedWidthVector, RGK_ScalableVector };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  enum RegisterKind { RGK_Scalar, RGK_FixedWidthVector, RGK_ScalableVector };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  /// \return The width of the largest scalar or vector register type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  /// \return The width of the largest scalar or vector register type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">  TypeSize getRegisterBitWidth(RegisterKind K) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">  TypeSize getRegisterBitWidth(RegisterKind K) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">  /// \return The width of the smallest vector register type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">  /// \return The width of the smallest vector register type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  unsigned getMinVectorRegisterBitWidth() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  unsigned getMinVectorRegisterBitWidth() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">  /// \return The maximum value of vscale if the target specifies an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">  /// \return The maximum value of vscale if the target specifies an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">  ///  architectural maximum vector length, and std::nullopt otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">  ///  architectural maximum vector length, and std::nullopt otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">  std::optional<unsigned> getMaxVScale() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">  std::optional<unsigned> getMaxVScale() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  /// \return the value of vscale to tune the cost model for.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  /// \return the value of vscale to tune the cost model for.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">  std::optional<unsigned> getVScaleForTuning() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">  std::optional<unsigned> getVScaleForTuning() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">  /// \return true if vscale is known to be a power of 2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">  /// \return true if vscale is known to be a power of 2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">  bool isVScaleKnownToBeAPowerOfTwo() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">  bool isVScaleKnownToBeAPowerOfTwo() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// \return True if the vectorization factor should be chosen to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// \return True if the vectorization factor should be chosen to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  /// make the vector of the smallest element type match the size of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  /// make the vector of the smallest element type match the size of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  /// vector register. For wider element types, this could result in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  /// vector register. For wider element types, this could result in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">  /// creating vectors that span multiple vector registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">  /// creating vectors that span multiple vector registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  /// If false, the vectorization factor will be chosen based on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  /// If false, the vectorization factor will be chosen based on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">  /// size of the widest element type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">  /// size of the widest element type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">  /// \p K Register Kind for vectorization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">  /// \p K Register Kind for vectorization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">  bool shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">  bool shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  /// \return The minimum vectorization factor for types of given element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  /// \return The minimum vectorization factor for types of given element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">  /// bit width, or 0 if there is no minimum VF. The returned value only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">  /// bit width, or 0 if there is no minimum VF. The returned value only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">  /// applies when shouldMaximizeVectorBandwidth returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">  /// applies when shouldMaximizeVectorBandwidth returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">  /// If IsScalable is true, the returned ElementCount must be a scalable VF.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">  /// If IsScalable is true, the returned ElementCount must be a scalable VF.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">  ElementCount getMinimumVF(unsigned ElemWidth, bool IsScalable) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">  ElementCount getMinimumVF(unsigned ElemWidth, bool IsScalable) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">  /// \return The maximum vectorization factor for types of given element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">  /// \return The maximum vectorization factor for types of given element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">  /// bit width and opcode, or 0 if there is no maximum VF.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">  /// bit width and opcode, or 0 if there is no maximum VF.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// Currently only used by the SLP vectorizer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// Currently only used by the SLP vectorizer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  /// \return The minimum vectorization factor for the store instruction. Given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  /// \return The minimum vectorization factor for the store instruction. Given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">  /// the initial estimation of the minimum vector factor and store value type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">  /// the initial estimation of the minimum vector factor and store value type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  /// it tries to find possible lowest VF, which still might be profitable for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  /// it tries to find possible lowest VF, which still might be profitable for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">  /// the vectorization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">  /// the vectorization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  /// \param VF Initial estimation of the minimum vector factor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  /// \param VF Initial estimation of the minimum vector factor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  /// \param ScalarMemTy Scalar memory type of the store operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  /// \param ScalarMemTy Scalar memory type of the store operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  /// \param ScalarValTy Scalar type of the stored value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  /// \param ScalarValTy Scalar type of the stored value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  /// Currently only used by the SLP vectorizer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  /// Currently only used by the SLP vectorizer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">                             Type *ScalarValTy) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">                             Type *ScalarValTy) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  /// \return True if it should be considered for address type promotion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  /// \return True if it should be considered for address type promotion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">  /// \p AllowPromotionWithoutCommonHeader Set true if promoting \p I is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">  /// \p AllowPromotionWithoutCommonHeader Set true if promoting \p I is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  /// profitable without finding other extensions fed by the same input.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  /// profitable without finding other extensions fed by the same input.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  /// \return The size of a cache line in bytes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  /// \return The size of a cache line in bytes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  unsigned getCacheLineSize() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  unsigned getCacheLineSize() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  /// The possible cache levels</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  /// The possible cache levels</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">  enum class CacheLevel {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">  enum class CacheLevel {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">    L1D, // The L1 data cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">    L1D, // The L1 data cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">    L2D, // The L2 data cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">    L2D, // The L2 data cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">    // We currently do not model L3 caches, as their sizes differ widely between</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">    // We currently do not model L3 caches, as their sizes differ widely between</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">    // microarchitectures. Also, we currently do not have a use for L3 cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">    // microarchitectures. Also, we currently do not have a use for L3 cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    // size modeling yet.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    // size modeling yet.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">  /// \return The size of the cache level in bytes, if available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">  /// \return The size of the cache level in bytes, if available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">  std::optional<unsigned> getCacheSize(CacheLevel Level) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">  std::optional<unsigned> getCacheSize(CacheLevel Level) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">  /// \return The associativity of the cache level, if available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">  /// \return The associativity of the cache level, if available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  std::optional<unsigned> getCacheAssociativity(CacheLevel Level) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  std::optional<unsigned> getCacheAssociativity(CacheLevel Level) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">  /// \return How much before a load we should place the prefetch</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">  /// \return How much before a load we should place the prefetch</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">  /// instruction.  This is currently measured in number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">  /// instruction.  This is currently measured in number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">  /// instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">  /// instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">  unsigned getPrefetchDistance() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">  unsigned getPrefetchDistance() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  /// Some HW prefetchers can handle accesses up to a certain constant stride.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  /// Some HW prefetchers can handle accesses up to a certain constant stride.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">  /// Sometimes prefetching is beneficial even below the HW prefetcher limit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">  /// Sometimes prefetching is beneficial even below the HW prefetcher limit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">  /// and the arguments provided are meant to serve as a basis for deciding this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">  /// and the arguments provided are meant to serve as a basis for deciding this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">  /// for a particular loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">  /// for a particular loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// \param NumMemAccesses        Number of memory accesses in the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// \param NumMemAccesses        Number of memory accesses in the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  /// \param NumStridedMemAccesses Number of the memory accesses that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  /// \param NumStridedMemAccesses Number of the memory accesses that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  ///                              ScalarEvolution could find a known stride</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  ///                              ScalarEvolution could find a known stride</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  ///                              for.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  ///                              for.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  /// \param NumPrefetches         Number of software prefetches that will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  /// \param NumPrefetches         Number of software prefetches that will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">  ///                              emitted as determined by the addresses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">  ///                              emitted as determined by the addresses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  ///                              involved and the cache line size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  ///                              involved and the cache line size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">  /// \param HasCall               True if the loop contains a call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">  /// \param HasCall               True if the loop contains a call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// \return This is the minimum stride in bytes where it makes sense to start</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// \return This is the minimum stride in bytes where it makes sense to start</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">  ///         adding SW prefetches. The default is 1, i.e. prefetch with any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">  ///         adding SW prefetches. The default is 1, i.e. prefetch with any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  ///         stride.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  ///         stride.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">                                unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">                                unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">                                unsigned NumPrefetches, bool HasCall) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">                                unsigned NumPrefetches, bool HasCall) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  /// the required number of iterations is more than this number, no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  /// the required number of iterations is more than this number, no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  /// prefetching is performed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  /// prefetching is performed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  unsigned getMaxPrefetchIterationsAhead() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  unsigned getMaxPrefetchIterationsAhead() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">  bool enableWritePrefetching() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">  bool enableWritePrefetching() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">  bool shouldPrefetchAddressSpace(unsigned AS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">  bool shouldPrefetchAddressSpace(unsigned AS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">  /// \return The maximum interleave factor that any transform should try to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">  /// \return The maximum interleave factor that any transform should try to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">  /// perform for this target. This number depends on the level of parallelism</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">  /// perform for this target. This number depends on the level of parallelism</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">  /// and the number of execution units in the CPU.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">  /// and the number of execution units in the CPU.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">  unsigned getMaxInterleaveFactor(ElementCount VF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">  unsigned getMaxInterleaveFactor(ElementCount VF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">  /// Collect properties of V used in cost analysis, e.g. OP_PowerOf2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">  /// Collect properties of V used in cost analysis, e.g. OP_PowerOf2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  static OperandValueInfo getOperandInfo(const Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  static OperandValueInfo getOperandInfo(const Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// This is an approximation of reciprocal throughput of a math/logic op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// This is an approximation of reciprocal throughput of a math/logic op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// A higher cost indicates less expected throughput.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// A higher cost indicates less expected throughput.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  /// From Agner Fog's guides, reciprocal throughput is "the average number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  /// From Agner Fog's guides, reciprocal throughput is "the average number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  /// clock cycles per instruction when the instructions are not part of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  /// clock cycles per instruction when the instructions are not part of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  /// limiting dependency chain."</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  /// limiting dependency chain."</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  /// Therefore, costs should be scaled to account for multiple execution units</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  /// Therefore, costs should be scaled to account for multiple execution units</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">  /// on the target that can process this type of instruction. For example, if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">  /// on the target that can process this type of instruction. For example, if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">  /// there are 5 scalar integer units and 2 vector integer units that can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">  /// there are 5 scalar integer units and 2 vector integer units that can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">  /// calculate an 'add' in a single cycle, this model should indicate that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">  /// calculate an 'add' in a single cycle, this model should indicate that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">  /// cost of the vector add instruction is 2.5 times the cost of the scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">  /// cost of the vector add instruction is 2.5 times the cost of the scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">  /// add instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">  /// add instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  /// \p Args is an optional argument which holds the instruction operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  /// \p Args is an optional argument which holds the instruction operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  /// values so the TTI can analyze those values searching for special</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  /// values so the TTI can analyze those values searching for special</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  /// cases or optimizations based on those values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  /// cases or optimizations based on those values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">  /// \p CxtI is the optional original context instruction, if one exists, to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">  /// \p CxtI is the optional original context instruction, if one exists, to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">  /// provide even more information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">  /// provide even more information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">      unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">      unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">      const Instruction *CxtI = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">      const Instruction *CxtI = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">  /// \return The cost of a shuffle instruction of kind Kind and of type Tp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">  /// \return The cost of a shuffle instruction of kind Kind and of type Tp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  /// The exact mask may be passed as Mask, or else the array will be empty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  /// The exact mask may be passed as Mask, or else the array will be empty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">  /// The index and subtype parameters are used by the subvector insertion and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">  /// The index and subtype parameters are used by the subvector insertion and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  /// extraction shuffle kinds to show the insert/extract point and the type of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  /// extraction shuffle kinds to show the insert/extract point and the type of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  /// the subvector being inserted/extracted. The operands of the shuffle can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  /// the subvector being inserted/extracted. The operands of the shuffle can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  /// passed through \p Args, which helps improve the cost estimation in some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  /// passed through \p Args, which helps improve the cost estimation in some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">  /// cases, like in broadcast loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">  /// cases, like in broadcast loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  /// NOTE: For subvector extractions Tp represents the source type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  /// NOTE: For subvector extractions Tp represents the source type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">                 ArrayRef<int> Mask = std::nullopt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">                 ArrayRef<int> Mask = std::nullopt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">                 TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">                 TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">                 int Index = 0, VectorType *SubTp = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">                 int Index = 0, VectorType *SubTp = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">                 ArrayRef<const Value *> Args = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">                 ArrayRef<const Value *> Args = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  /// Represents a hint about the context in which a cast is used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  /// Represents a hint about the context in which a cast is used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  /// For zext/sext, the context of the cast is the operand, which must be a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  /// For zext/sext, the context of the cast is the operand, which must be a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  /// load of some kind. For trunc, the context is of the cast is the single</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  /// load of some kind. For trunc, the context is of the cast is the single</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  /// user of the instruction, which must be a store of some kind.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  /// user of the instruction, which must be a store of some kind.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">  /// This enum allows the vectorizer to give getCastInstrCost an idea of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">  /// This enum allows the vectorizer to give getCastInstrCost an idea of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  /// type of cast it's dealing with, as not every cast is equal. For instance,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  /// type of cast it's dealing with, as not every cast is equal. For instance,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  /// the zext of a load may be free, but the zext of an interleaving load can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  /// the zext of a load may be free, but the zext of an interleaving load can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  //// be (very) expensive!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  //// be (very) expensive!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">  /// See \c getCastContextHint to compute a CastContextHint from a cast</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">  /// See \c getCastContextHint to compute a CastContextHint from a cast</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// Instruction*. Callers can use it if they don't need to override the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// Instruction*. Callers can use it if they don't need to override the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  /// context and just want it to be calculated from the instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  /// context and just want it to be calculated from the instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  /// FIXME: This handles the types of load/store that the vectorizer can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  /// FIXME: This handles the types of load/store that the vectorizer can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  /// produce, which are the cases where the context instruction is most</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  /// produce, which are the cases where the context instruction is most</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  /// likely to be incorrect. There are other situations where that can happen</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  /// likely to be incorrect. There are other situations where that can happen</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">  /// too, which might be handled here but in the long run a more general</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">  /// too, which might be handled here but in the long run a more general</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  /// solution of costing multiple instructions at the same times may be better.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  /// solution of costing multiple instructions at the same times may be better.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  enum class CastContextHint : uint8_t {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  enum class CastContextHint : uint8_t {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">    None,          ///< The cast is not used with a load/store of any kind.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">    None,          ///< The cast is not used with a load/store of any kind.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">    Normal,        ///< The cast is used with a normal load/store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">    Normal,        ///< The cast is used with a normal load/store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">    Masked,        ///< The cast is used with a masked load/store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">    Masked,        ///< The cast is used with a masked load/store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">    GatherScatter, ///< The cast is used with a gather/scatter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">    GatherScatter, ///< The cast is used with a gather/scatter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">    Interleave,    ///< The cast is used with an interleaved load/store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">    Interleave,    ///< The cast is used with an interleaved load/store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">    Reversed,      ///< The cast is used with a reversed load/store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">    Reversed,      ///< The cast is used with a reversed load/store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  /// Calculates a CastContextHint from \p I.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  /// Calculates a CastContextHint from \p I.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// This should be used by callers of getCastInstrCost if they wish to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// This should be used by callers of getCastInstrCost if they wish to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  /// determine the context from some instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  /// determine the context from some instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  /// \returns the CastContextHint for ZExt/SExt/Trunc, None if \p I is nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  /// \returns the CastContextHint for ZExt/SExt/Trunc, None if \p I is nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  /// or if it's another type of cast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  /// or if it's another type of cast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  static CastContextHint getCastContextHint(const Instruction *I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  static CastContextHint getCastContextHint(const Instruction *I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  /// \return The expected cost of cast instructions, such as bitcast, trunc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  /// \return The expected cost of cast instructions, such as bitcast, trunc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  /// zext, etc. If there is an existing instruction that holds Opcode, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  /// zext, etc. If there is an existing instruction that holds Opcode, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">  /// may be passed in the 'I' parameter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">  /// may be passed in the 'I' parameter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">                   TTI::CastContextHint CCH,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">                   TTI::CastContextHint CCH,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">                   TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">                   TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">                   const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">                   const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  /// \return The expected cost of a sign- or zero-extended vector extract. Use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  /// \return The expected cost of a sign- or zero-extended vector extract. Use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  /// Index = -1 to indicate that there is no information about the index value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  /// Index = -1 to indicate that there is no information about the index value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">                                           VectorType *VecTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">                                           VectorType *VecTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">                                           unsigned Index) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">                                           unsigned Index) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  /// \return The expected cost of control-flow related instructions such as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  /// \return The expected cost of control-flow related instructions such as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// Phi, Ret, Br, Switch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// Phi, Ret, Br, Switch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  getCFInstrCost(unsigned Opcode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  getCFInstrCost(unsigned Opcode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">                 const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">                 const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  /// \returns The expected cost of compare and select instructions. If there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  /// \returns The expected cost of compare and select instructions. If there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  /// is an existing instruction that holds Opcode, it may be passed in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  /// is an existing instruction that holds Opcode, it may be passed in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">  /// 'I' parameter. The \p VecPred parameter can be used to indicate the select</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">  /// 'I' parameter. The \p VecPred parameter can be used to indicate the select</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// is using a compare with the specified predicate as condition. When vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// is using a compare with the specified predicate as condition. When vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  /// types are passed, \p VecPred must be used for all lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  /// types are passed, \p VecPred must be used for all lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">  getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">  getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">                     TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">                     TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">                     const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">                     const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">  /// \return The expected cost of vector Insert and Extract.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">  /// \return The expected cost of vector Insert and Extract.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// Use -1 to indicate that there is no information on the index value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// Use -1 to indicate that there is no information on the index value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  /// This is used when the instruction is not available; a typical use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  /// This is used when the instruction is not available; a typical use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">  /// case is to provision the cost of vectorization/scalarization in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">  /// case is to provision the cost of vectorization/scalarization in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">  /// vectorizer passes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">  /// vectorizer passes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">                                     unsigned Index = -1, Value *Op0 = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">                                     unsigned Index = -1, Value *Op0 = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">                                     Value *Op1 = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">                                     Value *Op1 = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">  /// \return The expected cost of vector Insert and Extract.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">  /// \return The expected cost of vector Insert and Extract.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">  /// This is used when instruction is available, and implementation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">  /// This is used when instruction is available, and implementation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">  /// asserts 'I' is not nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">  /// asserts 'I' is not nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">  /// A typical suitable use case is cost estimation when vector instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">  /// A typical suitable use case is cost estimation when vector instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  /// exists (e.g., from basic blocks during transformation).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  /// exists (e.g., from basic blocks during transformation).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">                                     unsigned Index = -1) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">                                     unsigned Index = -1) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">  /// \return The cost of replication shuffle of \p VF elements typed \p EltTy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">  /// \return The cost of replication shuffle of \p VF elements typed \p EltTy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  /// \p ReplicationFactor times.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  /// \p ReplicationFactor times.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  ///   <0,0,0,1,1,1,2,2,2,3,3,3></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  ///   <0,0,0,1,1,1,2,2,2,3,3,3></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">                                            int VF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">                                            int VF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">                                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">                                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">                                            TTI::TargetCostKind CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">                                            TTI::TargetCostKind CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  /// \return The cost of Load and Store instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  /// \return The cost of Load and Store instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">                  unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">                  unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">                  TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">                  TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">                  OperandValueInfo OpdInfo = {OK_AnyValue, OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">                  OperandValueInfo OpdInfo = {OK_AnyValue, OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">                  const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">                  const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">  /// \return The cost of VP Load and Store instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">  /// \return The cost of VP Load and Store instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">                    unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">                    unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">                    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">                    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">                    const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">                    const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  /// \return The cost of masked Load and Store instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  /// \return The cost of masked Load and Store instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">  InstructionCost getMaskedMemoryOpCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">  InstructionCost getMaskedMemoryOpCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">      unsigned Opcode, Type *Src, Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">      unsigned Opcode, Type *Src, Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">  /// \return The cost of Gather or Scatter operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">  /// \return The cost of Gather or Scatter operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">  /// \p Opcode - is a type of memory access Load or Store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">  /// \p Opcode - is a type of memory access Load or Store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">  /// \p DataTy - a vector type of the data to be loaded or stored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">  /// \p DataTy - a vector type of the data to be loaded or stored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  /// \p Ptr - pointer [or vector of pointers] - address[es] in memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  /// \p Ptr - pointer [or vector of pointers] - address[es] in memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">  /// \p VariableMask - true when the memory access is predicated with a mask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">  /// \p VariableMask - true when the memory access is predicated with a mask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  ///                   that is not a compile-time constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  ///                   that is not a compile-time constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  /// \p Alignment - alignment of single element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  /// \p Alignment - alignment of single element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">  /// \p I - the optional original context instruction, if one exists, e.g. the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">  /// \p I - the optional original context instruction, if one exists, e.g. the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">  ///        load/store to transform or the call to the gather/scatter intrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">  ///        load/store to transform or the call to the gather/scatter intrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">  InstructionCost getGatherScatterOpCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">  InstructionCost getGatherScatterOpCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">      unsigned Opcode, Type *DataTy, const Value *Ptr, bool VariableMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">      unsigned Opcode, Type *DataTy, const Value *Ptr, bool VariableMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">      Align Alignment, TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">      Align Alignment, TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">      const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">      const Instruction *I = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">  /// \return The cost of the interleaved memory operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">  /// \return The cost of the interleaved memory operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">  /// \p Opcode is the memory operation code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">  /// \p Opcode is the memory operation code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  /// \p VecTy is the vector type of the interleaved access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  /// \p VecTy is the vector type of the interleaved access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  /// \p Factor is the interleave factor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  /// \p Factor is the interleave factor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// \p Indices is the indices for interleaved load members (as interleaved</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// \p Indices is the indices for interleaved load members (as interleaved</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">  ///    load allows gaps)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">  ///    load allows gaps)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">  /// \p Alignment is the alignment of the memory operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">  /// \p Alignment is the alignment of the memory operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  /// \p AddressSpace is address space of the pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  /// \p AddressSpace is address space of the pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">  /// \p UseMaskForCond indicates if the memory access is predicated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">  /// \p UseMaskForCond indicates if the memory access is predicated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  /// \p UseMaskForGaps indicates if gaps should be masked.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  /// \p UseMaskForGaps indicates if gaps should be masked.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">      Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">      Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">      bool UseMaskForCond = false, bool UseMaskForGaps = false) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">      bool UseMaskForCond = false, bool UseMaskForGaps = false) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">  /// A helper function to determine the type of reduction algorithm used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">  /// A helper function to determine the type of reduction algorithm used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  /// for a given \p Opcode and set of FastMathFlags \p FMF.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  /// for a given \p Opcode and set of FastMathFlags \p FMF.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">  static bool requiresOrderedReduction(std::optional<FastMathFlags> FMF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">  static bool requiresOrderedReduction(std::optional<FastMathFlags> FMF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">    return FMF && !(*FMF).allowReassoc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">    return FMF && !(*FMF).allowReassoc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">  /// Calculate the cost of vector reduction intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">  /// Calculate the cost of vector reduction intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">  /// This is the cost of reducing the vector value of type \p Ty to a scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">  /// This is the cost of reducing the vector value of type \p Ty to a scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">  /// value using the operation denoted by \p Opcode. The FastMathFlags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">  /// value using the operation denoted by \p Opcode. The FastMathFlags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">  /// parameter \p FMF indicates what type of reduction we are performing:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">  /// parameter \p FMF indicates what type of reduction we are performing:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">  ///   1. Tree-wise. This is the typical 'fast' reduction performed that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">  ///   1. Tree-wise. This is the typical 'fast' reduction performed that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">  ///   involves successively splitting a vector into half and doing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">  ///   involves successively splitting a vector into half and doing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">  ///   operation on the pair of halves until you have a scalar value. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">  ///   operation on the pair of halves until you have a scalar value. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  ///   example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  ///   example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  ///     (v0, v1, v2, v3)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  ///     (v0, v1, v2, v3)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">  ///     ((v0+v2), (v1+v3), undef, undef)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">  ///     ((v0+v2), (v1+v3), undef, undef)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">  ///     ((v0+v2+v1+v3), undef, undef, undef)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">  ///     ((v0+v2+v1+v3), undef, undef, undef)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">  ///   This is the default behaviour for integer operations, whereas for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">  ///   This is the default behaviour for integer operations, whereas for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">  ///   floating point we only do this if \p FMF indicates that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">  ///   floating point we only do this if \p FMF indicates that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  ///   reassociation is allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  ///   reassociation is allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">  ///   2. Ordered. For a vector with N elements this involves performing N</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">  ///   2. Ordered. For a vector with N elements this involves performing N</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">  ///   operations in lane order, starting with an initial scalar value, i.e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">  ///   operations in lane order, starting with an initial scalar value, i.e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  ///     result = InitVal + v0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  ///     result = InitVal + v0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  ///     result = result + v1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  ///     result = result + v1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  ///     result = result + v2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  ///     result = result + v2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">  ///     result = result + v3</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">  ///     result = result + v3</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">  ///   This is only the case for FP operations and when reassociation is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">  ///   This is only the case for FP operations and when reassociation is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">  ///   allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">  ///   allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">  InstructionCost getArithmeticReductionCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">  InstructionCost getArithmeticReductionCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">      unsigned Opcode, VectorType *Ty, std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">      unsigned Opcode, VectorType *Ty, std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">  InstructionCost getMinMaxReductionCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">  InstructionCost getMinMaxReductionCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">      Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF = FastMathFlags(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">      Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF = FastMathFlags(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">  /// Calculate the cost of an extended reduction pattern, similar to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">  /// Calculate the cost of an extended reduction pattern, similar to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">  /// getArithmeticReductionCost of an Add reduction with multiply and optional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">  /// getArithmeticReductionCost of an Add reduction with multiply and optional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">  /// extensions. This is the cost of as:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">  /// extensions. This is the cost of as:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">  /// ResTy vecreduce.add(mul (A, B)).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">  /// ResTy vecreduce.add(mul (A, B)).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">  /// ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">  /// ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">  InstructionCost getMulAccReductionCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">  InstructionCost getMulAccReductionCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">  /// Calculate the cost of an extended reduction pattern, similar to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">  /// Calculate the cost of an extended reduction pattern, similar to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">  /// getArithmeticReductionCost of a reduction with an extension.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">  /// getArithmeticReductionCost of a reduction with an extension.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">  /// This is the cost of as:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">  /// This is the cost of as:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">  /// ResTy vecreduce.opcode(ext(Ty A)).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">  /// ResTy vecreduce.opcode(ext(Ty A)).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  InstructionCost getExtendedReductionCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  InstructionCost getExtendedReductionCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">      FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">      FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">  /// \returns The cost of Intrinsic instructions. Analyses the real arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">  /// \returns The cost of Intrinsic instructions. Analyses the real arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">  /// Three cases are handled: 1. scalar instruction 2. vector instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">  /// Three cases are handled: 1. scalar instruction 2. vector instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">  /// 3. scalar instruction which is to be vectorized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">  /// 3. scalar instruction which is to be vectorized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">  /// \returns The cost of Call instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">  /// \returns The cost of Call instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">  InstructionCost getCallInstrCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">  InstructionCost getCallInstrCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">      Function *F, Type *RetTy, ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">      Function *F, Type *RetTy, ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">  /// \returns The number of pieces into which the provided type must be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">  /// \returns The number of pieces into which the provided type must be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">  /// split during legalization. Zero is returned when the answer is unknown.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">  /// split during legalization. Zero is returned when the answer is unknown.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">  unsigned getNumberOfParts(Type *Tp) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">  unsigned getNumberOfParts(Type *Tp) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">  /// \returns The cost of the address computation. For most targets this can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">  /// \returns The cost of the address computation. For most targets this can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">  /// merged into the instruction indexing mode. Some targets might want to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">  /// merged into the instruction indexing mode. Some targets might want to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">  /// distinguish between address computation for memory operations on vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">  /// distinguish between address computation for memory operations on vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  /// types and scalar types. Such targets should override this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  /// types and scalar types. Such targets should override this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">  /// The 'SE' parameter holds pointer for the scalar evolution object which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">  /// The 'SE' parameter holds pointer for the scalar evolution object which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">  /// is used in order to get the Ptr step value in case of constant stride.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">  /// is used in order to get the Ptr step value in case of constant stride.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">  /// The 'Ptr' parameter holds SCEV of the access pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">  /// The 'Ptr' parameter holds SCEV of the access pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">  InstructionCost getAddressComputationCost(Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">  InstructionCost getAddressComputationCost(Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">                                            ScalarEvolution *SE = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">                                            ScalarEvolution *SE = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">                                            const SCEV *Ptr = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">                                            const SCEV *Ptr = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">  /// \returns The cost, if any, of keeping values of the given types alive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">  /// \returns The cost, if any, of keeping values of the given types alive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">  /// over a callsite.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">  /// over a callsite.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">  /// Some types may require the use of register classes that do not have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">  /// Some types may require the use of register classes that do not have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">  /// any callee-saved registers, so would require a spill and fill.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">  /// any callee-saved registers, so would require a spill and fill.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  /// \returns True if the intrinsic is a supported memory intrinsic.  Info</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  /// \returns True if the intrinsic is a supported memory intrinsic.  Info</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  /// will contain additional information - whether the intrinsic may write</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  /// will contain additional information - whether the intrinsic may write</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  /// or read to memory, volatility and the pointer.  Info is undefined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  /// or read to memory, volatility and the pointer.  Info is undefined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  /// if false is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  /// if false is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">  bool getTgtMemIntrinsic(IntrinsicInst *Inst, MemIntrinsicInfo &Info) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">  bool getTgtMemIntrinsic(IntrinsicInst *Inst, MemIntrinsicInfo &Info) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">  /// \returns The maximum element size, in bytes, for an element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">  /// \returns The maximum element size, in bytes, for an element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">  /// unordered-atomic memory intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">  /// unordered-atomic memory intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">  unsigned getAtomicMemIntrinsicMaxElementSize() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">  unsigned getAtomicMemIntrinsicMaxElementSize() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  /// \returns A value which is the result of the given memory intrinsic.  New</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  /// \returns A value which is the result of the given memory intrinsic.  New</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">  /// instructions may be created to extract the result from the given intrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">  /// instructions may be created to extract the result from the given intrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">  /// memory operation.  Returns nullptr if the target cannot create a result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">  /// memory operation.  Returns nullptr if the target cannot create a result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">  /// from the given intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">  /// from the given intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">                                           Type *ExpectedType) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">                                           Type *ExpectedType) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  /// \returns The type to use in a loop expansion of a memcpy call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  /// \returns The type to use in a loop expansion of a memcpy call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">  Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">  Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicElementSize = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicElementSize = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">  /// \param[out] OpsOut The operand types to copy RemainingBytes of memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">  /// \param[out] OpsOut The operand types to copy RemainingBytes of memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  /// \param RemainingBytes The number of bytes to copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  /// \param RemainingBytes The number of bytes to copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  /// Calculates the operand types to use when copying \p RemainingBytes of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  /// Calculates the operand types to use when copying \p RemainingBytes of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  /// memory, where source and destination alignments are \p SrcAlign and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  /// memory, where source and destination alignments are \p SrcAlign and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  /// \p DestAlign respectively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  /// \p DestAlign respectively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">  void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">  void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicCpySize = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicCpySize = std::nullopt) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">  /// \returns True if the two functions have compatible attributes for inlining</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">  /// \returns True if the two functions have compatible attributes for inlining</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">  /// purposes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">  /// purposes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">  bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">  bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">                           const Function *Callee) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">                           const Function *Callee) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  /// \returns True if the caller and callee agree on how \p Types will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  /// \returns True if the caller and callee agree on how \p Types will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  /// passed to or returned from the callee.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  /// passed to or returned from the callee.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  /// to the callee.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  /// to the callee.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">  /// \param Types List of types to check.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">  /// \param Types List of types to check.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">                             const ArrayRef<Type *> &Types) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">                             const ArrayRef<Type *> &Types) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">  /// The type of load/store indexing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">  /// The type of load/store indexing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">  enum MemIndexedMode {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">  enum MemIndexedMode {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">    MIM_Unindexed, ///< No indexing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">    MIM_Unindexed, ///< No indexing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">    MIM_PreInc,    ///< Pre-incrementing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">    MIM_PreInc,    ///< Pre-incrementing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">    MIM_PreDec,    ///< Pre-decrementing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">    MIM_PreDec,    ///< Pre-decrementing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">    MIM_PostInc,   ///< Post-incrementing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">    MIM_PostInc,   ///< Post-incrementing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">    MIM_PostDec    ///< Post-decrementing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">    MIM_PostDec    ///< Post-decrementing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">  /// \returns True if the specified indexed load for the given type is legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">  /// \returns True if the specified indexed load for the given type is legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">  bool isIndexedLoadLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">  bool isIndexedLoadLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">  /// \returns True if the specified indexed store for the given type is legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">  /// \returns True if the specified indexed store for the given type is legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">  bool isIndexedStoreLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">  bool isIndexedStoreLegal(enum MemIndexedMode Mode, Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">  /// \returns The bitwidth of the largest vector type that should be used to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">  /// \returns The bitwidth of the largest vector type that should be used to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">  /// load/store in the given address space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">  /// load/store in the given address space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">  /// \returns True if the load instruction is legal to vectorize.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">  /// \returns True if the load instruction is legal to vectorize.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">  bool isLegalToVectorizeLoad(LoadInst *LI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">  bool isLegalToVectorizeLoad(LoadInst *LI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">  /// \returns True if the store instruction is legal to vectorize.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">  /// \returns True if the store instruction is legal to vectorize.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">  bool isLegalToVectorizeStore(StoreInst *SI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">  bool isLegalToVectorizeStore(StoreInst *SI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  /// \returns True if it is legal to vectorize the given load chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  /// \returns True if it is legal to vectorize the given load chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">                                   unsigned AddrSpace) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">                                   unsigned AddrSpace) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">  /// \returns True if it is legal to vectorize the given store chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">  /// \returns True if it is legal to vectorize the given store chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">                                    unsigned AddrSpace) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">                                    unsigned AddrSpace) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  /// \returns True if it is legal to vectorize the given reduction kind.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  /// \returns True if it is legal to vectorize the given reduction kind.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">                                   ElementCount VF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">                                   ElementCount VF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  /// \returns True if the given type is supported for scalable vectors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  /// \returns True if the given type is supported for scalable vectors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">  bool isElementTypeLegalForScalableVector(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">  bool isElementTypeLegalForScalableVector(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  /// \returns The new vector factor value if the target doesn't support \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  /// \returns The new vector factor value if the target doesn't support \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">  /// SizeInBytes loads or has a better vector factor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">  /// SizeInBytes loads or has a better vector factor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">                               unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">                               unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">                               VectorType *VecTy) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">                               VectorType *VecTy) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  /// \returns The new vector factor value if the target doesn't support \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  /// \returns The new vector factor value if the target doesn't support \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">  /// SizeInBytes stores or has a better vector factor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">  /// SizeInBytes stores or has a better vector factor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">                                unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">                                unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">                                VectorType *VecTy) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">                                VectorType *VecTy) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">  /// Flags describing the kind of vector reduction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">  /// Flags describing the kind of vector reduction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">  struct ReductionFlags {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">  struct ReductionFlags {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">    ReductionFlags() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">    ReductionFlags() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">    bool IsMaxOp =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">    bool IsMaxOp =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">        false; ///< If the op a min/max kind, true if it's a max operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">        false; ///< If the op a min/max kind, true if it's a max operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">    bool IsSigned = false; ///< Whether the operation is a signed int reduction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">    bool IsSigned = false; ///< Whether the operation is a signed int reduction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">    bool NoNaN =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">    bool NoNaN =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">        false; ///< If op is an fp min/max, whether NaNs may be present.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">        false; ///< If op is an fp min/max, whether NaNs may be present.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">  /// \returns True if the target prefers reductions in loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">  /// \returns True if the target prefers reductions in loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">                             ReductionFlags Flags) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">                             ReductionFlags Flags) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  /// \returns True if the target prefers reductions select kept in the loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  /// \returns True if the target prefers reductions select kept in the loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">  /// when tail folding. i.e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">  /// when tail folding. i.e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">  /// loop:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">  /// loop:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">  ///   p = phi (0, s)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">  ///   p = phi (0, s)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">  ///   a = add (p, x)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">  ///   a = add (p, x)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">  ///   s = select (mask, a, p)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">  ///   s = select (mask, a, p)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">  /// vecreduce.add(s)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">  /// vecreduce.add(s)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">  /// As opposed to the normal scheme of p = phi (0, a) which allows the select</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">  /// As opposed to the normal scheme of p = phi (0, a) which allows the select</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">  /// to be pulled out of the loop. If the select(.., add, ..) can be predicated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">  /// to be pulled out of the loop. If the select(.., add, ..) can be predicated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">  /// by the target, this can lead to cleaner code generation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">  /// by the target, this can lead to cleaner code generation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">                                       ReductionFlags Flags) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">                                       ReductionFlags Flags) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">  /// Return true if the loop vectorizer should consider vectorizing an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">  /// Return true if the loop vectorizer should consider vectorizing an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">  /// otherwise scalar epilogue loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">  /// otherwise scalar epilogue loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">  bool preferEpilogueVectorization() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">  bool preferEpilogueVectorization() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">  /// \returns True if the target wants to expand the given reduction intrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">  /// \returns True if the target wants to expand the given reduction intrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">  /// into a shuffle sequence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">  /// into a shuffle sequence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">  bool shouldExpandReduction(const IntrinsicInst *II) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">  bool shouldExpandReduction(const IntrinsicInst *II) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">  /// \returns the size cost of rematerializing a GlobalValue address relative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">  /// \returns the size cost of rematerializing a GlobalValue address relative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">  /// to a stack reload.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">  /// to a stack reload.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">  unsigned getGISelRematGlobalCost() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">  unsigned getGISelRematGlobalCost() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">  /// \returns the lower bound of a trip count to decide on vectorization</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">  /// \returns the lower bound of a trip count to decide on vectorization</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">  /// while tail-folding.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">  /// while tail-folding.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">  unsigned getMinTripCountTailFoldingThreshold() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">  unsigned getMinTripCountTailFoldingThreshold() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">  /// \returns True if the target supports scalable vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">  /// \returns True if the target supports scalable vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">  bool supportsScalableVectors() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">  bool supportsScalableVectors() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">  /// \return true when scalable vectorization is preferred.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">  /// \return true when scalable vectorization is preferred.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">  bool enableScalableVectorization() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">  bool enableScalableVectorization() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">  /// \name Vector Predication Information</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">  /// \name Vector Predication Information</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">  /// Whether the target supports the %evl parameter of VP intrinsic efficiently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">  /// Whether the target supports the %evl parameter of VP intrinsic efficiently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">  /// in hardware, for the given opcode and type/alignment. (see LLVM Language</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">  /// in hardware, for the given opcode and type/alignment. (see LLVM Language</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">  /// Reference - "Vector Predication Intrinsics").</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">  /// Reference - "Vector Predication Intrinsics").</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">  /// Use of %evl is discouraged when that is not the case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">  /// Use of %evl is discouraged when that is not the case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">                             Align Alignment) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">                             Align Alignment) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">  struct VPLegalization {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">  struct VPLegalization {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">    enum VPTransform {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">    enum VPTransform {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">      // keep the predicating parameter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">      // keep the predicating parameter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">      Legal = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">      Legal = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">      // where legal, discard the predicate parameter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">      // where legal, discard the predicate parameter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">      Discard = 1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">      Discard = 1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">      // transform into something else that is also predicating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">      // transform into something else that is also predicating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">      Convert = 2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">      Convert = 2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">    // How to transform the EVL parameter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">    // How to transform the EVL parameter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">    // Legal:   keep the EVL parameter as it is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">    // Legal:   keep the EVL parameter as it is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">    // Discard: Ignore the EVL parameter where it is safe to do so.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">    // Discard: Ignore the EVL parameter where it is safe to do so.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">    // Convert: Fold the EVL into the mask parameter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">    // Convert: Fold the EVL into the mask parameter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">    VPTransform EVLParamStrategy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">    VPTransform EVLParamStrategy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">    // How to transform the operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">    // How to transform the operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">    // Legal:   The target supports this operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">    // Legal:   The target supports this operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">    // Convert: Convert this to a non-VP operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">    // Convert: Convert this to a non-VP operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">    // The 'Discard' strategy is invalid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">    // The 'Discard' strategy is invalid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">    VPTransform OpStrategy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">    VPTransform OpStrategy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">    bool shouldDoNothing() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">    bool shouldDoNothing() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">      return (EVLParamStrategy == Legal) && (OpStrategy == Legal);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">      return (EVLParamStrategy == Legal) && (OpStrategy == Legal);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">    VPLegalization(VPTransform EVLParamStrategy, VPTransform OpStrategy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">    VPLegalization(VPTransform EVLParamStrategy, VPTransform OpStrategy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">        : EVLParamStrategy(EVLParamStrategy), OpStrategy(OpStrategy) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">        : EVLParamStrategy(EVLParamStrategy), OpStrategy(OpStrategy) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  /// \returns How the target needs this vector-predicated operation to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  /// \returns How the target needs this vector-predicated operation to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">  /// transformed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">  /// transformed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">  VPLegalization getVPLegalizationStrategy(const VPIntrinsic &PI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">  VPLegalization getVPLegalizationStrategy(const VPIntrinsic &PI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">  /// \returns Whether a 32-bit branch instruction is available in Arm or Thumb</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">  /// \returns Whether a 32-bit branch instruction is available in Arm or Thumb</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">  /// state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">  /// state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">  /// Used by the LowerTypeTests pass, which constructs an IR inline assembler</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">  /// Used by the LowerTypeTests pass, which constructs an IR inline assembler</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">  /// node containing a jump table in a format suitable for the target, so it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">  /// node containing a jump table in a format suitable for the target, so it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  /// needs to know what format of jump table it can legally use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  /// needs to know what format of jump table it can legally use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">  /// For non-Arm targets, this function isn't used. It defaults to returning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">  /// For non-Arm targets, this function isn't used. It defaults to returning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">  /// false, but it shouldn't matter what it returns anyway.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">  /// false, but it shouldn't matter what it returns anyway.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">  bool hasArmWideBranch(bool Thumb) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">  bool hasArmWideBranch(bool Thumb) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">  /// \return The maximum number of function arguments the target supports.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">  /// \return The maximum number of function arguments the target supports.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">  unsigned getMaxNumArgs() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">  unsigned getMaxNumArgs() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">  /// The abstract base class used to type erase specific TTI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">  /// The abstract base class used to type erase specific TTI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">  /// implementations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">  /// implementations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  class Concept;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  class Concept;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  /// The template model for the base class which wraps a concrete</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  /// The template model for the base class which wraps a concrete</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  /// implementation in a type erased interface.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  /// implementation in a type erased interface.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">  template <typename T> class Model;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">  template <typename T> class Model;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  std::unique_ptr<Concept> TTIImpl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  std::unique_ptr<Concept> TTIImpl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">class TargetTransformInfo::Concept {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">class TargetTransformInfo::Concept {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">  virtual ~Concept() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">  virtual ~Concept() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">  virtual const DataLayout &getDataLayout() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">  virtual const DataLayout &getDataLayout() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">  virtual InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">  virtual InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">                                     Type *AccessType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">                                     Type *AccessType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">  getPointersChainCost(ArrayRef<const Value *> Ptrs, const Value *Base,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">                       const TTI::PointersChainInfo &Info, Type *AccessTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">                       const TTI::PointersChainInfo &Info, Type *AccessTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">                       TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">                       TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">  virtual unsigned getInliningThresholdMultiplier() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">  virtual unsigned getInliningThresholdMultiplier() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">  virtual unsigned adjustInliningThreshold(const CallBase *CB) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">  virtual unsigned adjustInliningThreshold(const CallBase *CB) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">  virtual int getInlinerVectorBonusPercent() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">  virtual int getInlinerVectorBonusPercent() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">  virtual unsigned getCallerAllocaCost(const CallBase *CB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">  virtual unsigned getCallerAllocaCost(const CallBase *CB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">                                       const AllocaInst *AI) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">                                       const AllocaInst *AI) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">  virtual InstructionCost getMemcpyCost(const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">  virtual InstructionCost getMemcpyCost(const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">  virtual uint64_t getMaxMemIntrinsicInlineSizeThreshold() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">  virtual uint64_t getMaxMemIntrinsicInlineSizeThreshold() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  getEstimatedNumberOfCaseClusters(const SwitchInst &SI, unsigned &JTSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  getEstimatedNumberOfCaseClusters(const SwitchInst &SI, unsigned &JTSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">                                   ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">                                   ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">                                   BlockFrequencyInfo *BFI) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">                                   BlockFrequencyInfo *BFI) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">  virtual InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">  virtual InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">                                             ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">                                             ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">                                             TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">                                             TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">  virtual BranchProbability getPredictableBranchThreshold() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">  virtual BranchProbability getPredictableBranchThreshold() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  virtual bool hasBranchDivergence(const Function *F = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  virtual bool hasBranchDivergence(const Function *F = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  virtual bool isSourceOfDivergence(const Value *V) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  virtual bool isSourceOfDivergence(const Value *V) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">  virtual bool isAlwaysUniform(const Value *V) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">  virtual bool isAlwaysUniform(const Value *V) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">  virtual bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">  virtual bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">  virtual bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">  virtual bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">  virtual unsigned getFlatAddressSpace() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">  virtual unsigned getFlatAddressSpace() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  virtual bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  virtual bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">                                          Intrinsic::ID IID) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">                                          Intrinsic::ID IID) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">  virtual bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">  virtual bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">  virtual unsigned getAssumedAddrSpace(const Value *V) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">  virtual unsigned getAssumedAddrSpace(const Value *V) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">  virtual bool isSingleThreaded() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">  virtual bool isSingleThreaded() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">  virtual std::pair<const Value *, unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">  virtual std::pair<const Value *, unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">  getPredicatedAddrSpace(const Value *V) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">  getPredicatedAddrSpace(const Value *V) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  virtual Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  virtual Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">                                                  Value *OldV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">                                                  Value *OldV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">                                                  Value *NewV) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">                                                  Value *NewV) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">  virtual bool isLoweredToCall(const Function *F) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">  virtual bool isLoweredToCall(const Function *F) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">  virtual void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">  virtual void getUnrollingPreferences(Loop *L, ScalarEvolution &,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">                                       UnrollingPreferences &UP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">                                       UnrollingPreferences &UP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">                                       OptimizationRemarkEmitter *ORE) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">                                       OptimizationRemarkEmitter *ORE) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">  virtual void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">  virtual void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">                                     PeelingPreferences &PP) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">                                     PeelingPreferences &PP) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">  virtual bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">  virtual bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">                                        AssumptionCache &AC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">                                        AssumptionCache &AC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">                                        TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">                                        TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">                                        HardwareLoopInfo &HWLoopInfo) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">                                        HardwareLoopInfo &HWLoopInfo) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">  virtual bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">  virtual bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">  virtual TailFoldingStyle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">  virtual TailFoldingStyle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">  virtual std::optional<Instruction *> instCombineIntrinsic(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">  virtual std::optional<Instruction *> instCombineIntrinsic(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">  virtual std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">  virtual std::optional<Value *> simplifyDemandedUseBitsIntrinsic(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">      KnownBits & Known, bool &KnownBitsComputed) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">      KnownBits & Known, bool &KnownBitsComputed) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">  virtual std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">  virtual std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">      APInt &UndefElts, APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">      APInt &UndefElts, APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">          SimplifyAndSetOp) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">          SimplifyAndSetOp) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">  virtual bool isLegalAddImmediate(int64_t Imm) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">  virtual bool isLegalAddImmediate(int64_t Imm) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">  virtual bool isLegalICmpImmediate(int64_t Imm) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">  virtual bool isLegalICmpImmediate(int64_t Imm) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">  virtual bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">  virtual bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">                                     int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">                                     int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">                                     int64_t Scale, unsigned AddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">                                     int64_t Scale, unsigned AddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">                                     Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">                                     Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">  virtual bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">  virtual bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">                             const TargetTransformInfo::LSRCost &C2) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">                             const TargetTransformInfo::LSRCost &C2) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">  virtual bool isNumRegsMajorCostOfLSR() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">  virtual bool isNumRegsMajorCostOfLSR() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">  virtual bool isProfitableLSRChainElement(Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">  virtual bool isProfitableLSRChainElement(Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">  virtual bool canMacroFuseCmp() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">  virtual bool canMacroFuseCmp() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">  virtual bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">  virtual bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">                          LoopInfo *LI, DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">                          LoopInfo *LI, DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">                          TargetLibraryInfo *LibInfo) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">                          TargetLibraryInfo *LibInfo) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">  virtual AddressingModeKind</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">  virtual AddressingModeKind</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">    getPreferredAddressingMode(const Loop *L, ScalarEvolution *SE) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">    getPreferredAddressingMode(const Loop *L, ScalarEvolution *SE) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  virtual bool isLegalMaskedStore(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  virtual bool isLegalMaskedStore(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">  virtual bool isLegalMaskedLoad(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">  virtual bool isLegalMaskedLoad(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">  virtual bool isLegalNTStore(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">  virtual bool isLegalNTStore(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">  virtual bool isLegalNTLoad(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">  virtual bool isLegalNTLoad(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">  virtual bool isLegalBroadcastLoad(Type *ElementTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">  virtual bool isLegalBroadcastLoad(Type *ElementTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">                                    ElementCount NumElements) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">                                    ElementCount NumElements) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">  virtual bool isLegalMaskedScatter(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">  virtual bool isLegalMaskedScatter(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  virtual bool isLegalMaskedGather(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  virtual bool isLegalMaskedGather(Type *DataType, Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">  virtual bool forceScalarizeMaskedGather(VectorType *DataType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">  virtual bool forceScalarizeMaskedGather(VectorType *DataType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">                                          Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">                                          Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">  virtual bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">  virtual bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">                                           Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">                                           Align Alignment) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  virtual bool isLegalMaskedCompressStore(Type *DataType) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  virtual bool isLegalMaskedCompressStore(Type *DataType) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">  virtual bool isLegalMaskedExpandLoad(Type *DataType) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">  virtual bool isLegalMaskedExpandLoad(Type *DataType) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  virtual bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  virtual bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">                               unsigned Opcode1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">                               unsigned Opcode1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">                               const SmallBitVector &OpcodeMask) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">                               const SmallBitVector &OpcodeMask) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">  virtual bool enableOrderedReductions() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">  virtual bool enableOrderedReductions() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  virtual bool hasDivRemOp(Type *DataType, bool IsSigned) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  virtual bool hasDivRemOp(Type *DataType, bool IsSigned) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">  virtual bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">  virtual bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  virtual bool prefersVectorizedAddressing() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  virtual bool prefersVectorizedAddressing() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">  virtual InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">  virtual InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">                                               int64_t BaseOffset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">                                               int64_t BaseOffset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">                                               bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">                                               bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">                                               unsigned AddrSpace) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">                                               unsigned AddrSpace) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  virtual bool LSRWithInstrQueries() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  virtual bool LSRWithInstrQueries() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  virtual bool isTruncateFree(Type *Ty1, Type *Ty2) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  virtual bool isTruncateFree(Type *Ty1, Type *Ty2) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  virtual bool isProfitableToHoist(Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  virtual bool isProfitableToHoist(Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  virtual bool useAA() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  virtual bool useAA() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">  virtual bool isTypeLegal(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">  virtual bool isTypeLegal(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">  virtual unsigned getRegUsageForType(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">  virtual unsigned getRegUsageForType(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">  virtual bool shouldBuildLookupTables() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">  virtual bool shouldBuildLookupTables() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">  virtual bool shouldBuildLookupTablesForConstant(Constant *C) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">  virtual bool shouldBuildLookupTablesForConstant(Constant *C) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">  virtual bool shouldBuildRelLookupTables() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">  virtual bool shouldBuildRelLookupTables() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">  virtual bool useColdCCForColdCall(Function &F) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">  virtual bool useColdCCForColdCall(Function &F) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">  virtual InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">  virtual InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">                                                   const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">                                                   const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">                                                   bool Insert, bool Extract,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">                                                   bool Insert, bool Extract,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">                                                   TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">                                                   TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">                                   TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">                                   TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  virtual bool supportsEfficientVectorElementLoadStore() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  virtual bool supportsEfficientVectorElementLoadStore() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">  virtual bool supportsTailCalls() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">  virtual bool supportsTailCalls() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">  virtual bool supportsTailCallFor(const CallBase *CB) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">  virtual bool supportsTailCallFor(const CallBase *CB) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">  virtual bool enableAggressiveInterleaving(bool LoopHasReductions) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">  virtual bool enableAggressiveInterleaving(bool LoopHasReductions) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">  virtual MemCmpExpansionOptions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">  virtual MemCmpExpansionOptions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">  enableMemCmpExpansion(bool OptSize, bool IsZeroCmp) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">  enableMemCmpExpansion(bool OptSize, bool IsZeroCmp) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">  virtual bool enableSelectOptimize() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">  virtual bool enableSelectOptimize() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">  virtual bool enableInterleavedAccessVectorization() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">  virtual bool enableInterleavedAccessVectorization() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">  virtual bool enableMaskedInterleavedAccessVectorization() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">  virtual bool enableMaskedInterleavedAccessVectorization() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">  virtual bool isFPVectorizationPotentiallyUnsafe() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">  virtual bool isFPVectorizationPotentiallyUnsafe() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">  virtual bool allowsMisalignedMemoryAccesses(LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">  virtual bool allowsMisalignedMemoryAccesses(LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">                                              unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">                                              unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">                                              unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">                                              unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">                                              Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">                                              Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">                                              unsigned *Fast) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">                                              unsigned *Fast) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">  virtual PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">  virtual PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">  virtual bool haveFastSqrt(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">  virtual bool haveFastSqrt(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">  virtual bool isExpensiveToSpeculativelyExecute(const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">  virtual bool isExpensiveToSpeculativelyExecute(const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">  virtual bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">  virtual bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">  virtual InstructionCost getFPOpCost(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">  virtual InstructionCost getFPOpCost(Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">  virtual InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">  virtual InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">                                                const APInt &Imm, Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">                                                const APInt &Imm, Type *Ty) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">  virtual InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">  virtual InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">                                        TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">                                        TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">  virtual InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">  virtual InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">                                            const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">                                            const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">                                            TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">                                            TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">                                            Instruction *Inst = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">                                            Instruction *Inst = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">  virtual InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">  virtual InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">                                              const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">                                              const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">                                              TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">                                              TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">  virtual unsigned getNumberOfRegisters(unsigned ClassID) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">  virtual unsigned getNumberOfRegisters(unsigned ClassID) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">  virtual unsigned getRegisterClassForType(bool Vector,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">  virtual unsigned getRegisterClassForType(bool Vector,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">                                           Type *Ty = nullptr) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">                                           Type *Ty = nullptr) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">  virtual const char *getRegisterClassName(unsigned ClassID) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">  virtual const char *getRegisterClassName(unsigned ClassID) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">  virtual TypeSize getRegisterBitWidth(RegisterKind K) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">  virtual TypeSize getRegisterBitWidth(RegisterKind K) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">  virtual unsigned getMinVectorRegisterBitWidth() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">  virtual unsigned getMinVectorRegisterBitWidth() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  virtual std::optional<unsigned> getMaxVScale() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  virtual std::optional<unsigned> getMaxVScale() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">  virtual std::optional<unsigned> getVScaleForTuning() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">  virtual std::optional<unsigned> getVScaleForTuning() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  virtual bool isVScaleKnownToBeAPowerOfTwo() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  virtual bool isVScaleKnownToBeAPowerOfTwo() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">  shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">  shouldMaximizeVectorBandwidth(TargetTransformInfo::RegisterKind K) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">  virtual ElementCount getMinimumVF(unsigned ElemWidth,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">  virtual ElementCount getMinimumVF(unsigned ElemWidth,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">                                    bool IsScalable) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">                                    bool IsScalable) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">  virtual unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">  virtual unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">  virtual unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  virtual unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">                                     Type *ScalarValTy) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">                                     Type *ScalarValTy) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  virtual bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  virtual bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  virtual unsigned getCacheLineSize() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  virtual unsigned getCacheLineSize() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  virtual std::optional<unsigned> getCacheSize(CacheLevel Level) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  virtual std::optional<unsigned> getCacheSize(CacheLevel Level) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">  virtual std::optional<unsigned> getCacheAssociativity(CacheLevel Level)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">  virtual std::optional<unsigned> getCacheAssociativity(CacheLevel Level)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">      const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">      const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">  /// \return How much before a load we should place the prefetch</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">  /// \return How much before a load we should place the prefetch</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">  /// instruction.  This is currently measured in number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">  /// instruction.  This is currently measured in number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">  /// instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">  /// instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">  virtual unsigned getPrefetchDistance() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">  virtual unsigned getPrefetchDistance() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">  /// \return Some HW prefetchers can handle accesses up to a certain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">  /// \return Some HW prefetchers can handle accesses up to a certain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">  /// constant stride.  This is the minimum stride in bytes where it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">  /// constant stride.  This is the minimum stride in bytes where it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">  /// makes sense to start adding SW prefetches.  The default is 1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">  /// makes sense to start adding SW prefetches.  The default is 1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">  /// i.e. prefetch with any stride.  Sometimes prefetching is beneficial</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">  /// i.e. prefetch with any stride.  Sometimes prefetching is beneficial</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">  /// even below the HW prefetcher limit, and the arguments provided are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">  /// even below the HW prefetcher limit, and the arguments provided are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  /// meant to serve as a basis for deciding this for a particular loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  /// meant to serve as a basis for deciding this for a particular loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">                                        unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">                                        unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">                                        unsigned NumPrefetches,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">                                        unsigned NumPrefetches,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">                                        bool HasCall) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">                                        bool HasCall) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  /// \return The maximum number of iterations to prefetch ahead.  If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">  /// the required number of iterations is more than this number, no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">  /// the required number of iterations is more than this number, no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">  /// prefetching is performed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">  /// prefetching is performed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">  virtual unsigned getMaxPrefetchIterationsAhead() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">  virtual unsigned getMaxPrefetchIterationsAhead() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">  virtual bool enableWritePrefetching() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">  virtual bool enableWritePrefetching() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">  virtual unsigned getMaxInterleaveFactor(ElementCount VF) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">  virtual unsigned getMaxInterleaveFactor(ElementCount VF) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  virtual InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  virtual InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">      ArrayRef<const Value *> Args, const Instruction *CxtI = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">      ArrayRef<const Value *> Args, const Instruction *CxtI = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">  virtual InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">  virtual InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">                                         ArrayRef<int> Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">                                         ArrayRef<int> Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">                                         int Index, VectorType *SubTp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">                                         int Index, VectorType *SubTp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">                                         ArrayRef<const Value *> Args) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">                                         ArrayRef<const Value *> Args) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">  virtual InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">  virtual InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">                                           Type *Src, CastContextHint CCH,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">                                           Type *Src, CastContextHint CCH,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">                                           const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">                                           const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  virtual InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  virtual InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">                                                   VectorType *VecTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">                                                   VectorType *VecTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">                                                   unsigned Index) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">                                                   unsigned Index) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">  virtual InstructionCost getCFInstrCost(unsigned Opcode,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">  virtual InstructionCost getCFInstrCost(unsigned Opcode,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">                                         const Instruction *I = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">                                         const Instruction *I = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">  virtual InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">  virtual InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">                                             Type *CondTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">                                             Type *CondTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">                                             CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">                                             CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">                                             const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">                                             const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">  virtual InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">  virtual InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">                                             unsigned Index, Value *Op0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">                                             unsigned Index, Value *Op0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">                                             Value *Op1) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">                                             Value *Op1) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">  virtual InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">  virtual InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">                                             unsigned Index) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">                                             unsigned Index) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">                            TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">                            TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">  getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">                  OperandValueInfo OpInfo, const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">                  OperandValueInfo OpInfo, const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">  virtual InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">  virtual InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">                                            Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">                                            Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">                                            unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">                                            unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">                                            TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">                                            TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">                                            const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">                                            const Instruction *I) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">  getMaskedMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">  getMaskedMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">                        unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">                        unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">                        TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">                        TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">                         bool VariableMask, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">                         bool VariableMask, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">                         const Instruction *I = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">                         const Instruction *I = nullptr) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">  virtual InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">  virtual InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">      bool UseMaskForCond = false, bool UseMaskForGaps = false) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">      bool UseMaskForCond = false, bool UseMaskForGaps = false) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">                             TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">                             TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  virtual InstructionCost getExtendedReductionCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  virtual InstructionCost getExtendedReductionCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">      unsigned Opcode, bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">      FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">      FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">  virtual InstructionCost getMulAccReductionCost(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">  virtual InstructionCost getMulAccReductionCost(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">      bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">  getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">  getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">                        TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">                        TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">  virtual InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">  virtual InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">                                           ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">                                           ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">  virtual unsigned getNumberOfParts(Type *Tp) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">  virtual unsigned getNumberOfParts(Type *Tp) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">  getAddressComputationCost(Type *Ty, ScalarEvolution *SE, const SCEV *Ptr) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">  getAddressComputationCost(Type *Ty, ScalarEvolution *SE, const SCEV *Ptr) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">  virtual InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">  getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">  getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">  virtual bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">  virtual bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">                                  MemIntrinsicInfo &Info) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">                                  MemIntrinsicInfo &Info) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">  virtual unsigned getAtomicMemIntrinsicMaxElementSize() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">  virtual unsigned getAtomicMemIntrinsicMaxElementSize() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">  virtual Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">  virtual Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">                                                   Type *ExpectedType) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">                                                   Type *ExpectedType) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  virtual Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  virtual Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicElementSize) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicElementSize) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">  virtual void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">  virtual void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicCpySize) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicCpySize) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">  virtual bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">  virtual bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">                                   const Function *Callee) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">                                   const Function *Callee) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">  virtual bool areTypesABICompatible(const Function *Caller,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">  virtual bool areTypesABICompatible(const Function *Caller,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">                                     const Function *Callee,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">                                     const Function *Callee,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">                                     const ArrayRef<Type *> &Types) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">                                     const ArrayRef<Type *> &Types) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">  virtual bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">  virtual bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">  virtual bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">  virtual bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">  virtual unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">  virtual unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeLoad(LoadInst *LI) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeLoad(LoadInst *LI) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeStore(StoreInst *SI) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeStore(StoreInst *SI) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">                                           Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">                                           Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                           unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                           unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">                                            Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">                                            Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">                                            unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">                                            unsigned AddrSpace) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  virtual bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">                                           ElementCount VF) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">                                           ElementCount VF) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  virtual bool isElementTypeLegalForScalableVector(Type *Ty) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  virtual bool isElementTypeLegalForScalableVector(Type *Ty) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">  virtual unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">  virtual unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">                                       unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">                                       unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">                                       VectorType *VecTy) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">                                       VectorType *VecTy) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">  virtual unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">  virtual unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">                                        unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">                                        unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">                                        VectorType *VecTy) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">                                        VectorType *VecTy) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">  virtual bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">  virtual bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">                                     ReductionFlags) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">                                     ReductionFlags) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  virtual bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  virtual bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">                                               ReductionFlags) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">                                               ReductionFlags) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">  virtual bool preferEpilogueVectorization() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">  virtual bool preferEpilogueVectorization() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">  virtual bool shouldExpandReduction(const IntrinsicInst *II) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">  virtual bool shouldExpandReduction(const IntrinsicInst *II) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  virtual unsigned getGISelRematGlobalCost() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  virtual unsigned getGISelRematGlobalCost() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">  virtual unsigned getMinTripCountTailFoldingThreshold() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">  virtual unsigned getMinTripCountTailFoldingThreshold() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">  virtual bool enableScalableVectorization() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">  virtual bool enableScalableVectorization() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">  virtual bool supportsScalableVectors() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">  virtual bool supportsScalableVectors() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">  virtual bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">  virtual bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">                                     Align Alignment) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">                                     Align Alignment) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">  virtual VPLegalization</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">  virtual VPLegalization</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">  getVPLegalizationStrategy(const VPIntrinsic &PI) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">  getVPLegalizationStrategy(const VPIntrinsic &PI) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  virtual bool hasArmWideBranch(bool Thumb) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  virtual bool hasArmWideBranch(bool Thumb) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">  virtual unsigned getMaxNumArgs() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">  virtual unsigned getMaxNumArgs() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">class TargetTransformInfo::Model final : public TargetTransformInfo::Concept {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">class TargetTransformInfo::Model final : public TargetTransformInfo::Concept {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">  T Impl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">  T Impl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine coveredLine">  Model(T Impl) : Impl(std::move(Impl)) {}</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine coveredLine">  Model(T Impl) : Impl(std::move(Impl)) {}</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine coveredLine">  ~Model() override = default;</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine coveredLine">  ~Model() override = default;</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">  const DataLayout &getDataLayout() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">  const DataLayout &getDataLayout() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">    return Impl.getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">    return Impl.getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">  getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">             ArrayRef<const Value *> Operands, Type *AccessType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">             ArrayRef<const Value *> Operands, Type *AccessType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">             TargetTransformInfo::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">             TargetTransformInfo::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">    return Impl.getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">    return Impl.getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">  InstructionCost getPointersChainCost(ArrayRef<const Value *> Ptrs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">  InstructionCost getPointersChainCost(ArrayRef<const Value *> Ptrs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">                                       const Value *Base,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">                                       const Value *Base,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">                                       const PointersChainInfo &Info,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">                                       const PointersChainInfo &Info,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">                                       Type *AccessTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">                                       Type *AccessTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">                                       TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">                                       TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">    return Impl.getPointersChainCost(Ptrs, Base, Info, AccessTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">    return Impl.getPointersChainCost(Ptrs, Base, Info, AccessTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">  unsigned getInliningThresholdMultiplier() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">  unsigned getInliningThresholdMultiplier() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">    return Impl.getInliningThresholdMultiplier();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">    return Impl.getInliningThresholdMultiplier();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">  unsigned adjustInliningThreshold(const CallBase *CB) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">  unsigned adjustInliningThreshold(const CallBase *CB) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">    return Impl.adjustInliningThreshold(CB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">    return Impl.adjustInliningThreshold(CB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">  int getInlinerVectorBonusPercent() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">  int getInlinerVectorBonusPercent() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">    return Impl.getInlinerVectorBonusPercent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">    return Impl.getInlinerVectorBonusPercent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">  unsigned getCallerAllocaCost(const CallBase *CB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">  unsigned getCallerAllocaCost(const CallBase *CB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">                               const AllocaInst *AI) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">                               const AllocaInst *AI) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">    return Impl.getCallerAllocaCost(CB, AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">    return Impl.getCallerAllocaCost(CB, AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">  InstructionCost getMemcpyCost(const Instruction *I) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">  InstructionCost getMemcpyCost(const Instruction *I) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">    return Impl.getMemcpyCost(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">    return Impl.getMemcpyCost(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">  uint64_t getMaxMemIntrinsicInlineSizeThreshold() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">    return Impl.getMaxMemIntrinsicInlineSizeThreshold();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">    return Impl.getMaxMemIntrinsicInlineSizeThreshold();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  InstructionCost getInstructionCost(const User *U,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">                                     ArrayRef<const Value *> Operands,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">                                     TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">                                     TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">    return Impl.getInstructionCost(U, Operands, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">    return Impl.getInstructionCost(U, Operands, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  BranchProbability getPredictableBranchThreshold() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  BranchProbability getPredictableBranchThreshold() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">    return Impl.getPredictableBranchThreshold();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">    return Impl.getPredictableBranchThreshold();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine coveredLine">  bool hasBranchDivergence(const Function *F = nullptr) override {</td>
    <td class="lineNumber">21</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine coveredLine">  bool hasBranchDivergence(const Function *F = nullptr) override {</td>
    <td class="lineNumber">21</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine coveredLine">    return Impl.hasBranchDivergence(F);</td>
    <td class="lineNumber">21</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine coveredLine">    return Impl.hasBranchDivergence(F);</td>
    <td class="lineNumber">21</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">  bool isSourceOfDivergence(const Value *V) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">  bool isSourceOfDivergence(const Value *V) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">    return Impl.isSourceOfDivergence(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">    return Impl.isSourceOfDivergence(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">  bool isAlwaysUniform(const Value *V) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">  bool isAlwaysUniform(const Value *V) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">    return Impl.isAlwaysUniform(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">    return Impl.isAlwaysUniform(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">    return Impl.isValidAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">    return Impl.isValidAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">    return Impl.addrspacesMayAlias(AS0, AS1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">    return Impl.addrspacesMayAlias(AS0, AS1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">  unsigned getFlatAddressSpace() override { return Impl.getFlatAddressSpace(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  unsigned getFlatAddressSpace() override { return Impl.getFlatAddressSpace(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">                                  Intrinsic::ID IID) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">                                  Intrinsic::ID IID) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">    return Impl.collectFlatAddressOperands(OpIndexes, IID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">    return Impl.collectFlatAddressOperands(OpIndexes, IID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">    return Impl.isNoopAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">    return Impl.isNoopAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">  bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">  bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  canHaveNonUndefGlobalInitializerInAddressSpace(unsigned AS) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">    return Impl.canHaveNonUndefGlobalInitializerInAddressSpace(AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">    return Impl.canHaveNonUndefGlobalInitializerInAddressSpace(AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">  unsigned getAssumedAddrSpace(const Value *V) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">  unsigned getAssumedAddrSpace(const Value *V) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">    return Impl.getAssumedAddrSpace(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">    return Impl.getAssumedAddrSpace(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  bool isSingleThreaded() const override { return Impl.isSingleThreaded(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  bool isSingleThreaded() const override { return Impl.isSingleThreaded(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">  getPredicatedAddrSpace(const Value *V) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">  getPredicatedAddrSpace(const Value *V) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">    return Impl.getPredicatedAddrSpace(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">    return Impl.getPredicatedAddrSpace(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">                                          Value *NewV) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">                                          Value *NewV) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">    return Impl.rewriteIntrinsicWithAddressSpace(II, OldV, NewV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">    return Impl.rewriteIntrinsicWithAddressSpace(II, OldV, NewV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  bool isLoweredToCall(const Function *F) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  bool isLoweredToCall(const Function *F) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">    return Impl.isLoweredToCall(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">    return Impl.isLoweredToCall(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">                               UnrollingPreferences &UP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">                               UnrollingPreferences &UP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">                               OptimizationRemarkEmitter *ORE) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">                               OptimizationRemarkEmitter *ORE) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">    return Impl.getUnrollingPreferences(L, SE, UP, ORE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">    return Impl.getUnrollingPreferences(L, SE, UP, ORE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">                             PeelingPreferences &PP) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">                             PeelingPreferences &PP) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">    return Impl.getPeelingPreferences(L, SE, PP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">    return Impl.getPeelingPreferences(L, SE, PP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">                                HardwareLoopInfo &HWLoopInfo) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">                                HardwareLoopInfo &HWLoopInfo) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">    return Impl.isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">    return Impl.isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">    return Impl.preferPredicateOverEpilogue(TFI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">    return Impl.preferPredicateOverEpilogue(TFI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  TailFoldingStyle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  TailFoldingStyle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">    return Impl.getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">    return Impl.getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  std::optional<Instruction *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  std::optional<Instruction *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">  instCombineIntrinsic(InstCombiner &IC, IntrinsicInst &II) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">  instCombineIntrinsic(InstCombiner &IC, IntrinsicInst &II) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">    return Impl.instCombineIntrinsic(IC, II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">    return Impl.instCombineIntrinsic(IC, II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">  std::optional<Value *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">  std::optional<Value *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">                                   APInt DemandedMask, KnownBits &Known,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">                                   APInt DemandedMask, KnownBits &Known,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">                                   bool &KnownBitsComputed) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">                                   bool &KnownBitsComputed) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">    return Impl.simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">    return Impl.simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">                                                 KnownBitsComputed);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">                                                 KnownBitsComputed);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">      APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">      APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">          SimplifyAndSetOp) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">          SimplifyAndSetOp) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">    return Impl.simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">    return Impl.simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">        SimplifyAndSetOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">        SimplifyAndSetOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">  bool isLegalAddImmediate(int64_t Imm) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">  bool isLegalAddImmediate(int64_t Imm) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">    return Impl.isLegalAddImmediate(Imm);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">    return Impl.isLegalAddImmediate(Imm);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">  bool isLegalICmpImmediate(int64_t Imm) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">  bool isLegalICmpImmediate(int64_t Imm) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">    return Impl.isLegalICmpImmediate(Imm);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">    return Impl.isLegalICmpImmediate(Imm);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">                             bool HasBaseReg, int64_t Scale, unsigned AddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">                             bool HasBaseReg, int64_t Scale, unsigned AddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">                             Instruction *I) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">                             Instruction *I) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">    return Impl.isLegalAddressingMode(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">    return Impl.isLegalAddressingMode(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">                                      AddrSpace, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">                                      AddrSpace, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">  bool isLSRCostLess(const TargetTransformInfo::LSRCost &C1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">                     const TargetTransformInfo::LSRCost &C2) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">                     const TargetTransformInfo::LSRCost &C2) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">    return Impl.isLSRCostLess(C1, C2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">    return Impl.isLSRCostLess(C1, C2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">  bool isNumRegsMajorCostOfLSR() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">  bool isNumRegsMajorCostOfLSR() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">    return Impl.isNumRegsMajorCostOfLSR();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">    return Impl.isNumRegsMajorCostOfLSR();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">  bool isProfitableLSRChainElement(Instruction *I) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">  bool isProfitableLSRChainElement(Instruction *I) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">    return Impl.isProfitableLSRChainElement(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">    return Impl.isProfitableLSRChainElement(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">  bool canMacroFuseCmp() override { return Impl.canMacroFuseCmp(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">  bool canMacroFuseCmp() override { return Impl.canMacroFuseCmp(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">                  DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">                  DominatorTree *DT, AssumptionCache *AC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">                  TargetLibraryInfo *LibInfo) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">                  TargetLibraryInfo *LibInfo) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">    return Impl.canSaveCmp(L, BI, SE, LI, DT, AC, LibInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">    return Impl.canSaveCmp(L, BI, SE, LI, DT, AC, LibInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">  AddressingModeKind</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">  AddressingModeKind</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">    getPreferredAddressingMode(const Loop *L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">    getPreferredAddressingMode(const Loop *L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">                               ScalarEvolution *SE) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">                               ScalarEvolution *SE) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">    return Impl.getPreferredAddressingMode(L, SE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">    return Impl.getPreferredAddressingMode(L, SE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">  bool isLegalMaskedStore(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">  bool isLegalMaskedStore(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">    return Impl.isLegalMaskedStore(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">    return Impl.isLegalMaskedStore(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">  bool isLegalMaskedLoad(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">    return Impl.isLegalMaskedLoad(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">    return Impl.isLegalMaskedLoad(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">  bool isLegalNTStore(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">  bool isLegalNTStore(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">    return Impl.isLegalNTStore(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">    return Impl.isLegalNTStore(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">  bool isLegalNTLoad(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">  bool isLegalNTLoad(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">    return Impl.isLegalNTLoad(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">    return Impl.isLegalNTLoad(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  bool isLegalBroadcastLoad(Type *ElementTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  bool isLegalBroadcastLoad(Type *ElementTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">                            ElementCount NumElements) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">                            ElementCount NumElements) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">    return Impl.isLegalBroadcastLoad(ElementTy, NumElements);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">    return Impl.isLegalBroadcastLoad(ElementTy, NumElements);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">  bool isLegalMaskedScatter(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">    return Impl.isLegalMaskedScatter(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">    return Impl.isLegalMaskedScatter(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">  bool isLegalMaskedGather(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">  bool isLegalMaskedGather(Type *DataType, Align Alignment) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">    return Impl.isLegalMaskedGather(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">    return Impl.isLegalMaskedGather(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">  bool forceScalarizeMaskedGather(VectorType *DataType,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">  bool forceScalarizeMaskedGather(VectorType *DataType,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">                                  Align Alignment) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">                                  Align Alignment) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">    return Impl.forceScalarizeMaskedGather(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">    return Impl.forceScalarizeMaskedGather(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">  bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">  bool forceScalarizeMaskedScatter(VectorType *DataType,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">                                   Align Alignment) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">                                   Align Alignment) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">    return Impl.forceScalarizeMaskedScatter(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">    return Impl.forceScalarizeMaskedScatter(DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">  bool isLegalMaskedCompressStore(Type *DataType) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">  bool isLegalMaskedCompressStore(Type *DataType) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">    return Impl.isLegalMaskedCompressStore(DataType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">    return Impl.isLegalMaskedCompressStore(DataType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">  bool isLegalMaskedExpandLoad(Type *DataType) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">  bool isLegalMaskedExpandLoad(Type *DataType) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">    return Impl.isLegalMaskedExpandLoad(DataType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">    return Impl.isLegalMaskedExpandLoad(DataType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  bool isLegalAltInstr(VectorType *VecTy, unsigned Opcode0, unsigned Opcode1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">                       const SmallBitVector &OpcodeMask) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">                       const SmallBitVector &OpcodeMask) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return Impl.isLegalAltInstr(VecTy, Opcode0, Opcode1, OpcodeMask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return Impl.isLegalAltInstr(VecTy, Opcode0, Opcode1, OpcodeMask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">  bool enableOrderedReductions() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">  bool enableOrderedReductions() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">    return Impl.enableOrderedReductions();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">    return Impl.enableOrderedReductions();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  bool hasDivRemOp(Type *DataType, bool IsSigned) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  bool hasDivRemOp(Type *DataType, bool IsSigned) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">    return Impl.hasDivRemOp(DataType, IsSigned);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">    return Impl.hasDivRemOp(DataType, IsSigned);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">    return Impl.hasVolatileVariant(I, AddrSpace);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">    return Impl.hasVolatileVariant(I, AddrSpace);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">  bool prefersVectorizedAddressing() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">  bool prefersVectorizedAddressing() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">    return Impl.prefersVectorizedAddressing();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">    return Impl.prefersVectorizedAddressing();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">                                       int64_t Scale,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">                                       int64_t Scale,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">                                       unsigned AddrSpace) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">                                       unsigned AddrSpace) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">    return Impl.getScalingFactorCost(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">    return Impl.getScalingFactorCost(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">                                     AddrSpace);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">                                     AddrSpace);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">  bool LSRWithInstrQueries() override { return Impl.LSRWithInstrQueries(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">  bool LSRWithInstrQueries() override { return Impl.LSRWithInstrQueries(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">  bool isTruncateFree(Type *Ty1, Type *Ty2) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">  bool isTruncateFree(Type *Ty1, Type *Ty2) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">    return Impl.isTruncateFree(Ty1, Ty2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">    return Impl.isTruncateFree(Ty1, Ty2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">  bool isProfitableToHoist(Instruction *I) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">  bool isProfitableToHoist(Instruction *I) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">    return Impl.isProfitableToHoist(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">    return Impl.isProfitableToHoist(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">  bool useAA() override { return Impl.useAA(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">  bool useAA() override { return Impl.useAA(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">  bool isTypeLegal(Type *Ty) override { return Impl.isTypeLegal(Ty); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">  bool isTypeLegal(Type *Ty) override { return Impl.isTypeLegal(Ty); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">  unsigned getRegUsageForType(Type *Ty) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">  unsigned getRegUsageForType(Type *Ty) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">    return Impl.getRegUsageForType(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">    return Impl.getRegUsageForType(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">  bool shouldBuildLookupTables() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">  bool shouldBuildLookupTables() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">    return Impl.shouldBuildLookupTables();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">    return Impl.shouldBuildLookupTables();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">  bool shouldBuildLookupTablesForConstant(Constant *C) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">  bool shouldBuildLookupTablesForConstant(Constant *C) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">    return Impl.shouldBuildLookupTablesForConstant(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">    return Impl.shouldBuildLookupTablesForConstant(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">  bool shouldBuildRelLookupTables() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">  bool shouldBuildRelLookupTables() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">    return Impl.shouldBuildRelLookupTables();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">    return Impl.shouldBuildRelLookupTables();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">  bool useColdCCForColdCall(Function &F) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">  bool useColdCCForColdCall(Function &F) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">    return Impl.useColdCCForColdCall(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">    return Impl.useColdCCForColdCall(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">                                           TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">                                           TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">    return Impl.getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">    return Impl.getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">                                         CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">                                         CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">                                   TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">                                   TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">    return Impl.getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">    return Impl.getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">  bool supportsEfficientVectorElementLoadStore() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">  bool supportsEfficientVectorElementLoadStore() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">    return Impl.supportsEfficientVectorElementLoadStore();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">    return Impl.supportsEfficientVectorElementLoadStore();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  bool supportsTailCalls() override { return Impl.supportsTailCalls(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  bool supportsTailCalls() override { return Impl.supportsTailCalls(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">  bool supportsTailCallFor(const CallBase *CB) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">  bool supportsTailCallFor(const CallBase *CB) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">    return Impl.supportsTailCallFor(CB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">    return Impl.supportsTailCallFor(CB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">  bool enableAggressiveInterleaving(bool LoopHasReductions) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">  bool enableAggressiveInterleaving(bool LoopHasReductions) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">    return Impl.enableAggressiveInterleaving(LoopHasReductions);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">    return Impl.enableAggressiveInterleaving(LoopHasReductions);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">                                               bool IsZeroCmp) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">                                               bool IsZeroCmp) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">    return Impl.enableMemCmpExpansion(OptSize, IsZeroCmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">    return Impl.enableMemCmpExpansion(OptSize, IsZeroCmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">  bool enableInterleavedAccessVectorization() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">  bool enableInterleavedAccessVectorization() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">    return Impl.enableInterleavedAccessVectorization();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">    return Impl.enableInterleavedAccessVectorization();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">  bool enableSelectOptimize() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">  bool enableSelectOptimize() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">    return Impl.enableSelectOptimize();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">    return Impl.enableSelectOptimize();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">  bool enableMaskedInterleavedAccessVectorization() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">  bool enableMaskedInterleavedAccessVectorization() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">    return Impl.enableMaskedInterleavedAccessVectorization();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">    return Impl.enableMaskedInterleavedAccessVectorization();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">  bool isFPVectorizationPotentiallyUnsafe() override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">  bool isFPVectorizationPotentiallyUnsafe() override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">    return Impl.isFPVectorizationPotentiallyUnsafe();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">    return Impl.isFPVectorizationPotentiallyUnsafe();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">                                      unsigned AddressSpace, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">                                      unsigned AddressSpace, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">                                      unsigned *Fast) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">                                      unsigned *Fast) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">    return Impl.allowsMisalignedMemoryAccesses(Context, BitWidth, AddressSpace,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">    return Impl.allowsMisalignedMemoryAccesses(Context, BitWidth, AddressSpace,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">                                               Alignment, Fast);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">                                               Alignment, Fast);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">    return Impl.getPopcntSupport(IntTyWidthInBit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">    return Impl.getPopcntSupport(IntTyWidthInBit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">  bool haveFastSqrt(Type *Ty) override { return Impl.haveFastSqrt(Ty); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">  bool haveFastSqrt(Type *Ty) override { return Impl.haveFastSqrt(Ty); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">  bool isExpensiveToSpeculativelyExecute(const Instruction* I) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">  bool isExpensiveToSpeculativelyExecute(const Instruction* I) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">    return Impl.isExpensiveToSpeculativelyExecute(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">    return Impl.isExpensiveToSpeculativelyExecute(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">    return Impl.isFCmpOrdCheaperThanFCmpZero(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">    return Impl.isFCmpOrdCheaperThanFCmpZero(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">  InstructionCost getFPOpCost(Type *Ty) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">  InstructionCost getFPOpCost(Type *Ty) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">    return Impl.getFPOpCost(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">    return Impl.getFPOpCost(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">  InstructionCost getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">                                        const APInt &Imm, Type *Ty) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">                                        const APInt &Imm, Type *Ty) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">    return Impl.getIntImmCodeSizeCost(Opc, Idx, Imm, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">    return Impl.getIntImmCodeSizeCost(Opc, Idx, Imm, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">  InstructionCost getIntImmCost(const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">                                TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">                                TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">    return Impl.getIntImmCost(Imm, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">    return Impl.getIntImmCost(Imm, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">  InstructionCost getIntImmCostInst(unsigned Opc, unsigned Idx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">                                    const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">                                    const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">                                    TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">                                    TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">                                    Instruction *Inst = nullptr) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">                                    Instruction *Inst = nullptr) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">    return Impl.getIntImmCostInst(Opc, Idx, Imm, Ty, CostKind, Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">    return Impl.getIntImmCostInst(Opc, Idx, Imm, Ty, CostKind, Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">  InstructionCost getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">                                      const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">                                      const APInt &Imm, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">                                      TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">                                      TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">    return Impl.getIntImmCostIntrin(IID, Idx, Imm, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">    return Impl.getIntImmCostIntrin(IID, Idx, Imm, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">  unsigned getNumberOfRegisters(unsigned ClassID) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">  unsigned getNumberOfRegisters(unsigned ClassID) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">    return Impl.getNumberOfRegisters(ClassID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">    return Impl.getNumberOfRegisters(ClassID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">  unsigned getRegisterClassForType(bool Vector,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">  unsigned getRegisterClassForType(bool Vector,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">                                   Type *Ty = nullptr) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">                                   Type *Ty = nullptr) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">    return Impl.getRegisterClassForType(Vector, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">    return Impl.getRegisterClassForType(Vector, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">  const char *getRegisterClassName(unsigned ClassID) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">  const char *getRegisterClassName(unsigned ClassID) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">    return Impl.getRegisterClassName(ClassID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">    return Impl.getRegisterClassName(ClassID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">  TypeSize getRegisterBitWidth(RegisterKind K) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">  TypeSize getRegisterBitWidth(RegisterKind K) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">    return Impl.getRegisterBitWidth(K);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">    return Impl.getRegisterBitWidth(K);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">  unsigned getMinVectorRegisterBitWidth() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">  unsigned getMinVectorRegisterBitWidth() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">    return Impl.getMinVectorRegisterBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">    return Impl.getMinVectorRegisterBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">  std::optional<unsigned> getMaxVScale() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">  std::optional<unsigned> getMaxVScale() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">    return Impl.getMaxVScale();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">    return Impl.getMaxVScale();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">  std::optional<unsigned> getVScaleForTuning() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">  std::optional<unsigned> getVScaleForTuning() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">    return Impl.getVScaleForTuning();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">    return Impl.getVScaleForTuning();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">  bool isVScaleKnownToBeAPowerOfTwo() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">  bool isVScaleKnownToBeAPowerOfTwo() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">    return Impl.isVScaleKnownToBeAPowerOfTwo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">    return Impl.isVScaleKnownToBeAPowerOfTwo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">  bool shouldMaximizeVectorBandwidth(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">  bool shouldMaximizeVectorBandwidth(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">      TargetTransformInfo::RegisterKind K) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">      TargetTransformInfo::RegisterKind K) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">    return Impl.shouldMaximizeVectorBandwidth(K);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">    return Impl.shouldMaximizeVectorBandwidth(K);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">  ElementCount getMinimumVF(unsigned ElemWidth,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">  ElementCount getMinimumVF(unsigned ElemWidth,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">                            bool IsScalable) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">                            bool IsScalable) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">    return Impl.getMinimumVF(ElemWidth, IsScalable);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">    return Impl.getMinimumVF(ElemWidth, IsScalable);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">    return Impl.getMaximumVF(ElemWidth, Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">    return Impl.getMaximumVF(ElemWidth, Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">                             Type *ScalarValTy) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">                             Type *ScalarValTy) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">    return Impl.getStoreMinimumVF(VF, ScalarMemTy, ScalarValTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">    return Impl.getStoreMinimumVF(VF, ScalarMemTy, ScalarValTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">  bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">  bool shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">    return Impl.shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">    return Impl.shouldConsiderAddressTypePromotion(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">        I, AllowPromotionWithoutCommonHeader);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">        I, AllowPromotionWithoutCommonHeader);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">  unsigned getCacheLineSize() const override { return Impl.getCacheLineSize(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">  unsigned getCacheLineSize() const override { return Impl.getCacheLineSize(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">  std::optional<unsigned> getCacheSize(CacheLevel Level) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">  std::optional<unsigned> getCacheSize(CacheLevel Level) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">    return Impl.getCacheSize(Level);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">    return Impl.getCacheSize(Level);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">  std::optional<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">  std::optional<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">  getCacheAssociativity(CacheLevel Level) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">  getCacheAssociativity(CacheLevel Level) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">    return Impl.getCacheAssociativity(Level);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">    return Impl.getCacheAssociativity(Level);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">  /// Return the preferred prefetch distance in terms of instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">  /// Return the preferred prefetch distance in terms of instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">  unsigned getPrefetchDistance() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">  unsigned getPrefetchDistance() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">    return Impl.getPrefetchDistance();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">    return Impl.getPrefetchDistance();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">  /// Return the minimum stride necessary to trigger software</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">  /// Return the minimum stride necessary to trigger software</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">  /// prefetching.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">  /// prefetching.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">  unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">                                unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">                                unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">                                unsigned NumPrefetches,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">                                unsigned NumPrefetches,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">                                bool HasCall) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">                                bool HasCall) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">    return Impl.getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">    return Impl.getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">                                     NumPrefetches, HasCall);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">                                     NumPrefetches, HasCall);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">  /// Return the maximum prefetch distance in terms of loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">  /// Return the maximum prefetch distance in terms of loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">  /// iterations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">  /// iterations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">  unsigned getMaxPrefetchIterationsAhead() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">  unsigned getMaxPrefetchIterationsAhead() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">    return Impl.getMaxPrefetchIterationsAhead();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">    return Impl.getMaxPrefetchIterationsAhead();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">  /// \return True if prefetching should also be done for writes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">  bool enableWritePrefetching() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">  bool enableWritePrefetching() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">    return Impl.enableWritePrefetching();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">    return Impl.enableWritePrefetching();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">  /// \return if target want to issue a prefetch in address space \p AS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">  bool shouldPrefetchAddressSpace(unsigned AS) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">  bool shouldPrefetchAddressSpace(unsigned AS) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">    return Impl.shouldPrefetchAddressSpace(AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">    return Impl.shouldPrefetchAddressSpace(AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">  unsigned getMaxInterleaveFactor(ElementCount VF) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">  unsigned getMaxInterleaveFactor(ElementCount VF) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">    return Impl.getMaxInterleaveFactor(VF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">    return Impl.getMaxInterleaveFactor(VF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">                                            unsigned &JTSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">                                            unsigned &JTSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">                                            BlockFrequencyInfo *BFI) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">                                            BlockFrequencyInfo *BFI) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">    return Impl.getEstimatedNumberOfCaseClusters(SI, JTSize, PSI, BFI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">    return Impl.getEstimatedNumberOfCaseClusters(SI, JTSize, PSI, BFI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">      OperandValueInfo Opd1Info, OperandValueInfo Opd2Info,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">      ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">      ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">      const Instruction *CxtI = nullptr) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">      const Instruction *CxtI = nullptr) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">    return Impl.getArithmeticInstrCost(Opcode, Ty, CostKind, Opd1Info, Opd2Info,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">    return Impl.getArithmeticInstrCost(Opcode, Ty, CostKind, Opd1Info, Opd2Info,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">                                       Args, CxtI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">                                       Args, CxtI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">  InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">  InstructionCost getShuffleCost(ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">                                 ArrayRef<int> Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">                                 ArrayRef<int> Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">                                 TTI::TargetCostKind CostKind, int Index,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">                                 TTI::TargetCostKind CostKind, int Index,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">                                 VectorType *SubTp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">                                 VectorType *SubTp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">                                 ArrayRef<const Value *> Args) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">                                 ArrayRef<const Value *> Args) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">    return Impl.getShuffleCost(Kind, Tp, Mask, CostKind, Index, SubTp, Args);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">    return Impl.getShuffleCost(Kind, Tp, Mask, CostKind, Index, SubTp, Args);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">                                   CastContextHint CCH,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">                                   CastContextHint CCH,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">                                   const Instruction *I) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">                                   const Instruction *I) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">    return Impl.getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">    return Impl.getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">                                           VectorType *VecTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">                                           VectorType *VecTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">                                           unsigned Index) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">                                           unsigned Index) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine">    return Impl.getExtractWithExtendCost(Opcode, Dst, VecTy, Index);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine">    return Impl.getExtractWithExtendCost(Opcode, Dst, VecTy, Index);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">                                 const Instruction *I = nullptr) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">                                 const Instruction *I = nullptr) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">    return Impl.getCFInstrCost(Opcode, CostKind, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">    return Impl.getCFInstrCost(Opcode, CostKind, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">                                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">                                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">                                     const Instruction *I) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">                                     const Instruction *I) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">    return Impl.getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">    return Impl.getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">                                     unsigned Index, Value *Op0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">                                     unsigned Index, Value *Op0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">                                     Value *Op1) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">                                     Value *Op1) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">    return Impl.getVectorInstrCost(Opcode, Val, CostKind, Index, Op0, Op1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">    return Impl.getVectorInstrCost(Opcode, Val, CostKind, Index, Op0, Op1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">                                     unsigned Index) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">                                     unsigned Index) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">    return Impl.getVectorInstrCost(I, Val, CostKind, Index);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">    return Impl.getVectorInstrCost(I, Val, CostKind, Index);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">  getReplicationShuffleCost(Type *EltTy, int ReplicationFactor, int VF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">                            TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">                            TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">    return Impl.getReplicationShuffleCost(EltTy, ReplicationFactor, VF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">    return Impl.getReplicationShuffleCost(EltTy, ReplicationFactor, VF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">                                          DemandedDstElts, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">                                          DemandedDstElts, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">  InstructionCost getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">  InstructionCost getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">                                  unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">                                  unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">                                  TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">                                  TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">                                  OperandValueInfo OpInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">                                  OperandValueInfo OpInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">                                  const Instruction *I) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">                                  const Instruction *I) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine">    return Impl.getMemoryOpCost(Opcode, Src, Alignment, AddressSpace, CostKind,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine">    return Impl.getMemoryOpCost(Opcode, Src, Alignment, AddressSpace, CostKind,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">                                OpInfo, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">                                OpInfo, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">  InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">  InstructionCost getVPMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">                                    unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">                                    unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">                                    TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">                                    TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">                                    const Instruction *I) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">                                    const Instruction *I) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine">    return Impl.getVPMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine">    return Impl.getVPMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine">                                  CostKind, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine">                                  CostKind, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *Src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *Src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">                                        Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">                                        Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine">    return Impl.getMaskedMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine">    return Impl.getMaskedMemoryOpCost(Opcode, Src, Alignment, AddressSpace,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">                                      CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">                                      CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">  getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">                         bool VariableMask, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">                         bool VariableMask, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">                         const Instruction *I = nullptr) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">                         const Instruction *I = nullptr) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">    return Impl.getGatherScatterOpCost(Opcode, DataTy, Ptr, VariableMask,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">    return Impl.getGatherScatterOpCost(Opcode, DataTy, Ptr, VariableMask,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">                                       Alignment, CostKind, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">                                       Alignment, CostKind, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">      bool UseMaskForCond, bool UseMaskForGaps) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">      bool UseMaskForCond, bool UseMaskForGaps) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">    return Impl.getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">    return Impl.getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">                                           Alignment, AddressSpace, CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">                                           Alignment, AddressSpace, CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">                                           UseMaskForCond, UseMaskForGaps);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">                                           UseMaskForCond, UseMaskForGaps);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">  getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine">                             TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine">                             TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine">    return Impl.getArithmeticReductionCost(Opcode, Ty, FMF, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine">    return Impl.getArithmeticReductionCost(Opcode, Ty, FMF, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">  getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">    return Impl.getMinMaxReductionCost(IID, Ty, FMF, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">    return Impl.getMinMaxReductionCost(IID, Ty, FMF, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">  getExtendedReductionCost(unsigned Opcode, bool IsUnsigned, Type *ResTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">  getExtendedReductionCost(unsigned Opcode, bool IsUnsigned, Type *ResTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine">                           VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine">                           VectorType *Ty, FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine">                           TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine">                           TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">    return Impl.getExtendedReductionCost(Opcode, IsUnsigned, ResTy, Ty, FMF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">    return Impl.getExtendedReductionCost(Opcode, IsUnsigned, ResTy, Ty, FMF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">                                         CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">                                         CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">  getMulAccReductionCost(bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">  getMulAccReductionCost(bool IsUnsigned, Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">                         TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine">    return Impl.getMulAccReductionCost(IsUnsigned, ResTy, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine">    return Impl.getMulAccReductionCost(IsUnsigned, ResTy, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine">    return Impl.getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine">    return Impl.getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine">    return Impl.getCallInstrCost(F, RetTy, Tys, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine">    return Impl.getCallInstrCost(F, RetTy, Tys, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">  unsigned getNumberOfParts(Type *Tp) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">  unsigned getNumberOfParts(Type *Tp) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">    return Impl.getNumberOfParts(Tp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">    return Impl.getNumberOfParts(Tp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *SE,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *SE,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine">                                            const SCEV *Ptr) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine">                                            const SCEV *Ptr) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine">    return Impl.getAddressComputationCost(Ty, SE, Ptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine">    return Impl.getAddressComputationCost(Ty, SE, Ptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine">  InstructionCost getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine">    return Impl.getCostOfKeepingLiveOverCall(Tys);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine">    return Impl.getCostOfKeepingLiveOverCall(Tys);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">  bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">  bool getTgtMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine">                          MemIntrinsicInfo &Info) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine">                          MemIntrinsicInfo &Info) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">    return Impl.getTgtMemIntrinsic(Inst, Info);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">    return Impl.getTgtMemIntrinsic(Inst, Info);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine">  unsigned getAtomicMemIntrinsicMaxElementSize() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine">  unsigned getAtomicMemIntrinsicMaxElementSize() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine">    return Impl.getAtomicMemIntrinsicMaxElementSize();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine">    return Impl.getAtomicMemIntrinsicMaxElementSize();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine">                                           Type *ExpectedType) override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine">                                           Type *ExpectedType) override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine">    return Impl.getOrCreateResultFromMemIntrinsic(Inst, ExpectedType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine">    return Impl.getOrCreateResultFromMemIntrinsic(Inst, ExpectedType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine">  Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine">  Type *getMemcpyLoopLoweringType(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine">      LLVMContext &Context, Value *Length, unsigned SrcAddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">      unsigned DestAddrSpace, unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicElementSize) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicElementSize) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">    return Impl.getMemcpyLoopLoweringType(Context, Length, SrcAddrSpace,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">    return Impl.getMemcpyLoopLoweringType(Context, Length, SrcAddrSpace,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">                                          DestAddrSpace, SrcAlign, DestAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">                                          DestAddrSpace, SrcAlign, DestAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine">                                          AtomicElementSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine">                                          AtomicElementSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine">  void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine">  void getMemcpyLoopResidualLoweringType(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">      unsigned SrcAlign, unsigned DestAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicCpySize) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine">      std::optional<uint32_t> AtomicCpySize) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine">    Impl.getMemcpyLoopResidualLoweringType(OpsOut, Context, RemainingBytes,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine">    Impl.getMemcpyLoopResidualLoweringType(OpsOut, Context, RemainingBytes,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine">                                           SrcAddrSpace, DestAddrSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine">                                           SrcAddrSpace, DestAddrSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine">                                           SrcAlign, DestAlign, AtomicCpySize);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine">                                           SrcAlign, DestAlign, AtomicCpySize);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine">  bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine">  bool areInlineCompatible(const Function *Caller,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine">                           const Function *Callee) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine">                           const Function *Callee) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine">    return Impl.areInlineCompatible(Caller, Callee);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine">    return Impl.areInlineCompatible(Caller, Callee);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine">  bool areTypesABICompatible(const Function *Caller, const Function *Callee,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine">                             const ArrayRef<Type *> &Types) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine">                             const ArrayRef<Type *> &Types) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine">    return Impl.areTypesABICompatible(Caller, Callee, Types);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine">    return Impl.areTypesABICompatible(Caller, Callee, Types);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine">  bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine">  bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine">    return Impl.isIndexedLoadLegal(Mode, Ty, getDataLayout());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine">    return Impl.isIndexedLoadLegal(Mode, Ty, getDataLayout());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine">  bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine">  bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine">    return Impl.isIndexedStoreLegal(Mode, Ty, getDataLayout());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine">    return Impl.isIndexedStoreLegal(Mode, Ty, getDataLayout());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine">  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine">    return Impl.getLoadStoreVecRegBitWidth(AddrSpace);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine">    return Impl.getLoadStoreVecRegBitWidth(AddrSpace);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine">  bool isLegalToVectorizeLoad(LoadInst *LI) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine">  bool isLegalToVectorizeLoad(LoadInst *LI) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeLoad(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeLoad(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">  bool isLegalToVectorizeStore(StoreInst *SI) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">  bool isLegalToVectorizeStore(StoreInst *SI) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeStore(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeStore(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeLine">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2672</td>
    <td class="codeLine">  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeLine">                                   unsigned AddrSpace) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2673</td>
    <td class="codeLine">                                   unsigned AddrSpace) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeLoadChain(ChainSizeInBytes, Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2674</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeLoadChain(ChainSizeInBytes, Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeLine">                                            AddrSpace);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2675</td>
    <td class="codeLine">                                            AddrSpace);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2676</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeLine">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2677</td>
    <td class="codeLine">  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeLine">                                    unsigned AddrSpace) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2678</td>
    <td class="codeLine">                                    unsigned AddrSpace) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeStoreChain(ChainSizeInBytes, Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2679</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeStoreChain(ChainSizeInBytes, Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeLine">                                             AddrSpace);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2680</td>
    <td class="codeLine">                                             AddrSpace);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeLine">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2682</td>
    <td class="codeLine">  bool isLegalToVectorizeReduction(const RecurrenceDescriptor &RdxDesc,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeLine">                                   ElementCount VF) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2683</td>
    <td class="codeLine">                                   ElementCount VF) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeReduction(RdxDesc, VF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2684</td>
    <td class="codeLine">    return Impl.isLegalToVectorizeReduction(RdxDesc, VF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2685</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeLine">  bool isElementTypeLegalForScalableVector(Type *Ty) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2686</td>
    <td class="codeLine">  bool isElementTypeLegalForScalableVector(Type *Ty) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeLine">    return Impl.isElementTypeLegalForScalableVector(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2687</td>
    <td class="codeLine">    return Impl.isElementTypeLegalForScalableVector(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2688</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeLine">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2689</td>
    <td class="codeLine">  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeLine">                               unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2690</td>
    <td class="codeLine">                               unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeLine">                               VectorType *VecTy) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2691</td>
    <td class="codeLine">                               VectorType *VecTy) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeLine">    return Impl.getLoadVectorFactor(VF, LoadSize, ChainSizeInBytes, VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2692</td>
    <td class="codeLine">    return Impl.getLoadVectorFactor(VF, LoadSize, ChainSizeInBytes, VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2693</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeLine">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2694</td>
    <td class="codeLine">  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeLine">                                unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2695</td>
    <td class="codeLine">                                unsigned ChainSizeInBytes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeLine">                                VectorType *VecTy) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2696</td>
    <td class="codeLine">                                VectorType *VecTy) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeLine">    return Impl.getStoreVectorFactor(VF, StoreSize, ChainSizeInBytes, VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2697</td>
    <td class="codeLine">    return Impl.getStoreVectorFactor(VF, StoreSize, ChainSizeInBytes, VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeLine">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2699</td>
    <td class="codeLine">  bool preferInLoopReduction(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeLine">                             ReductionFlags Flags) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2700</td>
    <td class="codeLine">                             ReductionFlags Flags) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeLine">    return Impl.preferInLoopReduction(Opcode, Ty, Flags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2701</td>
    <td class="codeLine">    return Impl.preferInLoopReduction(Opcode, Ty, Flags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2702</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeLine">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2703</td>
    <td class="codeLine">  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeLine">                                       ReductionFlags Flags) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2704</td>
    <td class="codeLine">                                       ReductionFlags Flags) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeLine">    return Impl.preferPredicatedReductionSelect(Opcode, Ty, Flags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2705</td>
    <td class="codeLine">    return Impl.preferPredicatedReductionSelect(Opcode, Ty, Flags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2706</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeLine">  bool preferEpilogueVectorization() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2707</td>
    <td class="codeLine">  bool preferEpilogueVectorization() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeLine">    return Impl.preferEpilogueVectorization();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2708</td>
    <td class="codeLine">    return Impl.preferEpilogueVectorization();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeLine">  bool shouldExpandReduction(const IntrinsicInst *II) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2711</td>
    <td class="codeLine">  bool shouldExpandReduction(const IntrinsicInst *II) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeLine">    return Impl.shouldExpandReduction(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2712</td>
    <td class="codeLine">    return Impl.shouldExpandReduction(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2713</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2714</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeLine">  unsigned getGISelRematGlobalCost() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2715</td>
    <td class="codeLine">  unsigned getGISelRematGlobalCost() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeLine">    return Impl.getGISelRematGlobalCost();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2716</td>
    <td class="codeLine">    return Impl.getGISelRematGlobalCost();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2717</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeLine">  unsigned getMinTripCountTailFoldingThreshold() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2719</td>
    <td class="codeLine">  unsigned getMinTripCountTailFoldingThreshold() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeLine">    return Impl.getMinTripCountTailFoldingThreshold();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2720</td>
    <td class="codeLine">    return Impl.getMinTripCountTailFoldingThreshold();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2721</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeLine">  bool supportsScalableVectors() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2723</td>
    <td class="codeLine">  bool supportsScalableVectors() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeLine">    return Impl.supportsScalableVectors();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2724</td>
    <td class="codeLine">    return Impl.supportsScalableVectors();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2725</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeLine">  bool enableScalableVectorization() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2727</td>
    <td class="codeLine">  bool enableScalableVectorization() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeLine">    return Impl.enableScalableVectorization();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2728</td>
    <td class="codeLine">    return Impl.enableScalableVectorization();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeLine">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2731</td>
    <td class="codeLine">  bool hasActiveVectorLength(unsigned Opcode, Type *DataType,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeLine">                             Align Alignment) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2732</td>
    <td class="codeLine">                             Align Alignment) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeLine">    return Impl.hasActiveVectorLength(Opcode, DataType, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2733</td>
    <td class="codeLine">    return Impl.hasActiveVectorLength(Opcode, DataType, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2734</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeLine">  VPLegalization</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2736</td>
    <td class="codeLine">  VPLegalization</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeLine">  getVPLegalizationStrategy(const VPIntrinsic &PI) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2737</td>
    <td class="codeLine">  getVPLegalizationStrategy(const VPIntrinsic &PI) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeLine">    return Impl.getVPLegalizationStrategy(PI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2738</td>
    <td class="codeLine">    return Impl.getVPLegalizationStrategy(PI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2739</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeLine">  bool hasArmWideBranch(bool Thumb) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2741</td>
    <td class="codeLine">  bool hasArmWideBranch(bool Thumb) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeLine">    return Impl.hasArmWideBranch(Thumb);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2742</td>
    <td class="codeLine">    return Impl.hasArmWideBranch(Thumb);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2743</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2744</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeLine">  unsigned getMaxNumArgs() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2745</td>
    <td class="codeLine">  unsigned getMaxNumArgs() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeLine">    return Impl.getMaxNumArgs();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2746</td>
    <td class="codeLine">    return Impl.getMaxNumArgs();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2747</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2748</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2750</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeLine coveredLine">TargetTransformInfo::TargetTransformInfo(T Impl)</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2751</td>
    <td class="codeLine coveredLine">TargetTransformInfo::TargetTransformInfo(T Impl)</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeLine coveredLine">    : TTIImpl(new Model<T>(Impl)) {}</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2752</td>
    <td class="codeLine coveredLine">    : TTIImpl(new Model<T>(Impl)) {}</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeLine">/// Analysis pass providing the \c TargetTransformInfo.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2754</td>
    <td class="codeLine">/// Analysis pass providing the \c TargetTransformInfo.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2755</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeLine">/// The core idea of the TargetIRAnalysis is to expose an interface through</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2756</td>
    <td class="codeLine">/// The core idea of the TargetIRAnalysis is to expose an interface through</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeLine">/// which LLVM targets can analyze and provide information about the middle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2757</td>
    <td class="codeLine">/// which LLVM targets can analyze and provide information about the middle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeLine">/// end's target-independent IR. This supports use cases such as target-aware</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2758</td>
    <td class="codeLine">/// end's target-independent IR. This supports use cases such as target-aware</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeLine">/// cost modeling of IR constructs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2759</td>
    <td class="codeLine">/// cost modeling of IR constructs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2760</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeLine">/// This is a function analysis because much of the cost modeling for targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2761</td>
    <td class="codeLine">/// This is a function analysis because much of the cost modeling for targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeLine">/// is done in a subtarget specific way and LLVM supports compiling different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2762</td>
    <td class="codeLine">/// is done in a subtarget specific way and LLVM supports compiling different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeLine">/// functions targeting different subtargets in order to support runtime</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2763</td>
    <td class="codeLine">/// functions targeting different subtargets in order to support runtime</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeLine">/// dispatch according to the observed subtarget.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2764</td>
    <td class="codeLine">/// dispatch according to the observed subtarget.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeLine">class TargetIRAnalysis : public AnalysisInfoMixin<TargetIRAnalysis> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2765</td>
    <td class="codeLine">class TargetIRAnalysis : public AnalysisInfoMixin<TargetIRAnalysis> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2766</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeLine">  typedef TargetTransformInfo Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2767</td>
    <td class="codeLine">  typedef TargetTransformInfo Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeLine">  /// Default construct a target IR analysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2769</td>
    <td class="codeLine">  /// Default construct a target IR analysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2770</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeLine">  /// This will use the module's datalayout to construct a baseline</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2771</td>
    <td class="codeLine">  /// This will use the module's datalayout to construct a baseline</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeLine">  /// conservative TTI result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2772</td>
    <td class="codeLine">  /// conservative TTI result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeLine">  TargetIRAnalysis();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2773</td>
    <td class="codeLine">  TargetIRAnalysis();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2774</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeLine">  /// Construct an IR analysis pass around a target-provide callback.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2775</td>
    <td class="codeLine">  /// Construct an IR analysis pass around a target-provide callback.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2776</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeLine">  /// The callback will be called with a particular function for which the TTI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2777</td>
    <td class="codeLine">  /// The callback will be called with a particular function for which the TTI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeLine">  /// is needed and must return a TTI object for that function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2778</td>
    <td class="codeLine">  /// is needed and must return a TTI object for that function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeLine">  TargetIRAnalysis(std::function<Result(const Function &)> TTICallback);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2779</td>
    <td class="codeLine">  TargetIRAnalysis(std::function<Result(const Function &)> TTICallback);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeLine">  // Value semantics. We spell out the constructors for MSVC.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2781</td>
    <td class="codeLine">  // Value semantics. We spell out the constructors for MSVC.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeLine">  TargetIRAnalysis(const TargetIRAnalysis &Arg)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2782</td>
    <td class="codeLine">  TargetIRAnalysis(const TargetIRAnalysis &Arg)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeLine">      : TTICallback(Arg.TTICallback) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2783</td>
    <td class="codeLine">      : TTICallback(Arg.TTICallback) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeLine coveredLine">  TargetIRAnalysis(TargetIRAnalysis &&Arg)</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">2784</td>
    <td class="codeLine coveredLine">  TargetIRAnalysis(TargetIRAnalysis &&Arg)</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeLine coveredLine">      : TTICallback(std::move(Arg.TTICallback)) {}</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">2785</td>
    <td class="codeLine coveredLine">      : TTICallback(std::move(Arg.TTICallback)) {}</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeLine">  TargetIRAnalysis &operator=(const TargetIRAnalysis &RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2786</td>
    <td class="codeLine">  TargetIRAnalysis &operator=(const TargetIRAnalysis &RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeLine">    TTICallback = RHS.TTICallback;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2787</td>
    <td class="codeLine">    TTICallback = RHS.TTICallback;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2788</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2789</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeLine">  TargetIRAnalysis &operator=(TargetIRAnalysis &&RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2790</td>
    <td class="codeLine">  TargetIRAnalysis &operator=(TargetIRAnalysis &&RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeLine">    TTICallback = std::move(RHS.TTICallback);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2791</td>
    <td class="codeLine">    TTICallback = std::move(RHS.TTICallback);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2792</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2793</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeLine">  Result run(const Function &F, FunctionAnalysisManager &);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2795</td>
    <td class="codeLine">  Result run(const Function &F, FunctionAnalysisManager &);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2797</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeLine">  friend AnalysisInfoMixin<TargetIRAnalysis>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2798</td>
    <td class="codeLine">  friend AnalysisInfoMixin<TargetIRAnalysis>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeLine">  static AnalysisKey Key;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2799</td>
    <td class="codeLine">  static AnalysisKey Key;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeLine">  /// The callback used to produce a result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2801</td>
    <td class="codeLine">  /// The callback used to produce a result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2802</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeLine">  /// We use a completely opaque callback so that targets can provide whatever</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2803</td>
    <td class="codeLine">  /// We use a completely opaque callback so that targets can provide whatever</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeLine">  /// mechanism they desire for constructing the TTI for a given function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2804</td>
    <td class="codeLine">  /// mechanism they desire for constructing the TTI for a given function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2805</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeLine">  /// FIXME: Should we really use std::function? It's relatively inefficient.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2806</td>
    <td class="codeLine">  /// FIXME: Should we really use std::function? It's relatively inefficient.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeLine">  /// It might be possible to arrange for even stateful callbacks to outlive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2807</td>
    <td class="codeLine">  /// It might be possible to arrange for even stateful callbacks to outlive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeLine">  /// the analysis and thus use a function_ref which would be lighter weight.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2808</td>
    <td class="codeLine">  /// the analysis and thus use a function_ref which would be lighter weight.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeLine">  /// This may also be less error prone as the callback is likely to reference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2809</td>
    <td class="codeLine">  /// This may also be less error prone as the callback is likely to reference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeLine">  /// the external TargetMachine, and that reference needs to never dangle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2810</td>
    <td class="codeLine">  /// the external TargetMachine, and that reference needs to never dangle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeLine">  std::function<Result(const Function &)> TTICallback;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2811</td>
    <td class="codeLine">  std::function<Result(const Function &)> TTICallback;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeLine">  /// Helper function used as the callback in the default constructor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2813</td>
    <td class="codeLine">  /// Helper function used as the callback in the default constructor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeLine">  static Result getDefaultTTI(const Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2814</td>
    <td class="codeLine">  static Result getDefaultTTI(const Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2815</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeLine">/// Wrapper pass for TargetTransformInfo.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2817</td>
    <td class="codeLine">/// Wrapper pass for TargetTransformInfo.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2818</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeLine">/// This pass can be constructed from a TTI object which it stores internally</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2819</td>
    <td class="codeLine">/// This pass can be constructed from a TTI object which it stores internally</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeLine">/// and is queried by passes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2820</td>
    <td class="codeLine">/// and is queried by passes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeLine">class TargetTransformInfoWrapperPass : public ImmutablePass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2821</td>
    <td class="codeLine">class TargetTransformInfoWrapperPass : public ImmutablePass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeLine">  TargetIRAnalysis TIRA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2822</td>
    <td class="codeLine">  TargetIRAnalysis TIRA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeLine">  std::optional<TargetTransformInfo> TTI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2823</td>
    <td class="codeLine">  std::optional<TargetTransformInfo> TTI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeLine">  virtual void anchor();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2825</td>
    <td class="codeLine">  virtual void anchor();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2827</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2828</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeLine">  /// We must provide a default constructor for the pass but it should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2830</td>
    <td class="codeLine">  /// We must provide a default constructor for the pass but it should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeLine">  /// never be used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2831</td>
    <td class="codeLine">  /// never be used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2832</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeLine">  /// Use the constructor below or call one of the creation routines.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2833</td>
    <td class="codeLine">  /// Use the constructor below or call one of the creation routines.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeLine">  TargetTransformInfoWrapperPass();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2834</td>
    <td class="codeLine">  TargetTransformInfoWrapperPass();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeLine">  explicit TargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2836</td>
    <td class="codeLine">  explicit TargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeLine">  TargetTransformInfo &getTTI(const Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2838</td>
    <td class="codeLine">  TargetTransformInfo &getTTI(const Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2839</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeLine">/// Create an analysis pass wrapper around a TTI object.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2841</td>
    <td class="codeLine">/// Create an analysis pass wrapper around a TTI object.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2842</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeLine">/// This analysis pass just holds the TTI instance and makes it available to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2843</td>
    <td class="codeLine">/// This analysis pass just holds the TTI instance and makes it available to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeLine">/// clients.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2844</td>
    <td class="codeLine">/// clients.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeLine">ImmutablePass *createTargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2845</td>
    <td class="codeLine">ImmutablePass *createTargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2847</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2849</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>