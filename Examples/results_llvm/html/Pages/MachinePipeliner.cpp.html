<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>MachinePipeliner.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// This SMS implementation is a target-independent back-end pass. When enabled,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// the pass runs just prior to the register allocation pass, while the machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">// IR is in SSA form. If software pipelining is successful, then the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// loop is replaced by the optimized loop. The optimized loop contains one or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">// more prolog blocks, the pipelined kernel, and one or more epilog blocks. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">// the instructions cannot be scheduled in a given MII, we increase the MII by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">// one and try again.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">// The SMS implementation is an extension of the ScheduleDAGInstrs class. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">// represent loop carried dependences in the DAG as order edges to the Phi</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">// nodes. We also perform several passes over the DAG to eliminate unnecessary</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">// edges that inhibit the ability to pipeline. The implementation uses the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">// DFAPacketizer class to compute the minimum initiation interval and the check</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">// where an instruction may be inserted in the pipelined schedule.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">// In order for the SMS pass to work, several target specific hooks need to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">// implemented to get information about the loop structure and to rewrite</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">// instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/CodeGen/MachinePipeliner.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/ADT/BitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/ADT/MapVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/ADT/PriorityQueue.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/ADT/SetOperations.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/ADT/SetVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/ADT/SmallSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/ADT/iterator_range.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/Analysis/CycleAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/CodeGen/DFAPacketizer.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include "llvm/CodeGen/LiveIntervals.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include "llvm/CodeGen/MachineDominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">#include "llvm/CodeGen/MachineMemOperand.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">#include "llvm/CodeGen/ModuloSchedule.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">#include "llvm/CodeGen/RegisterPressure.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">#include "llvm/CodeGen/ScheduleDAG.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">#include "llvm/CodeGen/ScheduleDAGMutation.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">#include "llvm/CodeGen/TargetOpcodes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">#include "llvm/Config/llvm-config.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">#include "llvm/IR/Attributes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">#include "llvm/MC/LaneBitmask.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">#include "llvm/MC/MCInstrDesc.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">#include "llvm/MC/MCInstrItineraries.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">#include "llvm/MC/MCRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">#include "llvm/Support/Compiler.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">#include "llvm/Support/MathExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">#include <climits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">#include <deque></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">#include <functional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">#include <iomanip></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">#include <map></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">#include <memory></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">#include <sstream></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">#include <tuple></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">#define DEBUG_TYPE "pipeliner"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">STATISTIC(NumTrytoPipeline, "Number of loops that we attempt to pipeline");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">STATISTIC(NumPipelined, "Number of loops software pipelined");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">STATISTIC(NumNodeOrderIssues, "Number of node order issues found");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">STATISTIC(NumFailBranch, "Pipeliner abort due to unknown branch");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">STATISTIC(NumFailLoop, "Pipeliner abort due to unsupported loop");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">STATISTIC(NumFailPreheader, "Pipeliner abort due to missing preheader");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">STATISTIC(NumFailLargeMaxMII, "Pipeliner abort due to MaxMII too large");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">STATISTIC(NumFailZeroMII, "Pipeliner abort due to zero MII");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">STATISTIC(NumFailNoSchedule, "Pipeliner abort due to no schedule found");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">STATISTIC(NumFailZeroStage, "Pipeliner abort due to zero stage");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">STATISTIC(NumFailLargeMaxStage, "Pipeliner abort due to too many stages");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">/// A command line option to turn software pipelining on or off.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">static cl::opt<bool> EnableSWP("enable-pipeliner", cl::Hidden, cl::init(true),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">                               cl::desc("Enable Software Pipelining"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">/// A command line option to enable SWP at -Os.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">static cl::opt<bool> EnableSWPOptSize("enable-pipeliner-opt-size",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">                                      cl::desc("Enable SWP at Os."), cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">                                      cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">/// A command line argument to limit minimum initial interval for pipelining.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">static cl::opt<int> SwpMaxMii("pipeliner-max-mii",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">                              cl::desc("Size limit for the MII."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">                              cl::Hidden, cl::init(27));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">/// A command line argument to force pipeliner to use specified initial</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">/// interval.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">static cl::opt<int> SwpForceII("pipeliner-force-ii",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">                               cl::desc("Force pipeliner to use specified II."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">                               cl::Hidden, cl::init(-1));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">/// A command line argument to limit the number of stages in the pipeline.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">static cl::opt<int></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">    SwpMaxStages("pipeliner-max-stages",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">                 cl::desc("Maximum stages allowed in the generated scheduled."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">                 cl::Hidden, cl::init(3));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">/// A command line option to disable the pruning of chain dependences due to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">/// an unrelated Phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">static cl::opt<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">    SwpPruneDeps("pipeliner-prune-deps",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">                 cl::desc("Prune dependences between unrelated Phi nodes."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">                 cl::Hidden, cl::init(true));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">/// A command line option to disable the pruning of loop carried order</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">/// dependences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">static cl::opt<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">    SwpPruneLoopCarried("pipeliner-prune-loop-carried",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">                        cl::desc("Prune loop carried order dependences."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">                        cl::Hidden, cl::init(true));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">static cl::opt<int> SwpLoopLimit("pipeliner-max", cl::Hidden, cl::init(-1));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">static cl::opt<bool> SwpIgnoreRecMII("pipeliner-ignore-recmii",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">                                     cl::ReallyHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">                                     cl::desc("Ignore RecMII"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">static cl::opt<bool> SwpShowResMask("pipeliner-show-mask", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">                                    cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">static cl::opt<bool> SwpDebugResource("pipeliner-dbg-res", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">                                      cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">static cl::opt<bool> EmitTestAnnotations(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">    "pipeliner-annotate-for-testing", cl::Hidden, cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">    cl::desc("Instead of emitting the pipelined code, annotate instructions "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">             "with the generated schedule for feeding into the "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">             "-modulo-schedule-test pass"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">static cl::opt<bool> ExperimentalCodeGen(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">    "pipeliner-experimental-cg", cl::Hidden, cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">    cl::desc(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">        "Use the experimental peeling code generator for software pipelining"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">// A command line option to enable the CopyToPhi DAG mutation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">cl::opt<bool> SwpEnableCopyToPhi("pipeliner-enable-copytophi", cl::ReallyHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">                                 cl::init(true),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">                                 cl::desc("Enable CopyToPhi DAG Mutation"));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">/// A command line argument to force pipeliner to use specified issue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">/// width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">cl::opt<int> SwpForceIssueWidth(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">    "pipeliner-force-issue-width",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">    cl::desc("Force pipeliner to use specified issue width."), cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">    cl::init(-1));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">unsigned SwingSchedulerDAG::Circuits::MaxPaths = 5;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">char MachinePipeliner::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">int MachinePipeliner::NumTries = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">char &llvm::MachinePipelinerID = MachinePipeliner::ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(MachinePipeliner, DEBUG_TYPE,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">                      "Modulo Software Pipelining", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="coveredLine">INITIALIZE_PASS_END(MachinePipeliner, DEBUG_TYPE,</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">                    "Modulo Software Pipelining", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">/// The "main" function for implementing Swing Modulo Scheduling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="uncoveredLine">bool MachinePipeliner::runOnMachineFunction(MachineFunction &mf) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="uncoveredLine">  if (skipFunction(mf.getFunction()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">  if (!EnableSWP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">  if (mf.getFunction().getAttributes().hasFnAttr(Attribute::OptimizeForSize) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">      !EnableSWPOptSize.getPosition())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">  if (!mf.getSubtarget().enableMachinePipeliner())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  // Cannot pipeline loops without instruction itineraries if we are using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">  // DFA for the pipeliner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">  if (mf.getSubtarget().useDFAforSMS() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">      (!mf.getSubtarget().getInstrItineraryData() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">       mf.getSubtarget().getInstrItineraryData()->isEmpty()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">  MF = &mf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">  MLI = &getAnalysis<MachineLoopInfo>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  MDT = &getAnalysis<MachineDominatorTree>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">  TII = MF->getSubtarget().getInstrInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">  RegClassInfo.runOnMachineFunction(*MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">  for (const auto &L : *MLI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">    scheduleLoop(*L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">/// Attempt to perform the SMS algorithm on the specified loop. This function is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">/// the main entry point for the algorithm.  The function identifies candidate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">/// loops, calculates the minimum initiation interval, and attempts to schedule</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">/// the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">bool MachinePipeliner::scheduleLoop(MachineLoop &L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">  for (const auto &InnerLoop : L)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">    Changed |= scheduleLoop(*InnerLoop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  // Stop trying after reaching the limit (if any).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">  int Limit = SwpLoopLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">  if (Limit >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">    if (NumTries >= SwpLoopLimit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">      return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="uncoveredLine">    NumTries++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">  setPragmaPipelineOptions(L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">  if (!canPipelineLoop(L)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "\n!!! Can not pipeline loop.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">    ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkMissed(DEBUG_TYPE, "canPipelineLoop",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">                                             L.getStartLoc(), L.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="uncoveredLine">             << "Failed to pipeline loop";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">    LI.LoopPipelinerInfo.reset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="uncoveredLine">    return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">  ++NumTrytoPipeline;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">  Changed = swingModuloScheduler(L);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="uncoveredLine">  LI.LoopPipelinerInfo.reset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="uncoveredLine">void MachinePipeliner::setPragmaPipelineOptions(MachineLoop &L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  // Reset the pragma for the next loop in iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="uncoveredLine">  disabledByPragma = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="uncoveredLine">  II_setByPragma = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">  MachineBasicBlock *LBLK = L.getTopBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">  if (LBLK == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">  const BasicBlock *BBLK = LBLK->getBasicBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">  if (BBLK == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">  const Instruction *TI = BBLK->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="uncoveredLine">  if (TI == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">  MDNode *LoopID = TI->getMetadata(LLVMContext::MD_loop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">  if (LoopID == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">  assert(LoopID->getNumOperands() > 0 && "requires atleast one operand");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">  assert(LoopID->getOperand(0) == LoopID && "invalid loop");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">  for (unsigned i = 1, e = LoopID->getNumOperands(); i < e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">    MDNode *MD = dyn_cast<MDNode>(LoopID->getOperand(i));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">    if (MD == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="uncoveredLine">    MDString *S = dyn_cast<MDString>(MD->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">    if (S == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">    if (S->getString() == "llvm.loop.pipeline.initiationinterval") {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">      assert(MD->getNumOperands() == 2 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">             "Pipeline initiation interval hint metadata should have two operands.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="uncoveredLine">      II_setByPragma =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">          mdconst::extract<ConstantInt>(MD->getOperand(1))->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">      assert(II_setByPragma >= 1 && "Pipeline initiation interval must be positive.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">    } else if (S->getString() == "llvm.loop.pipeline.disable") {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">      disabledByPragma = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">/// Return true if the loop can be software pipelined.  The algorithm is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">/// restricted to loops with a single basic block.  Make sure that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">/// branch in the loop can be analyzed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="uncoveredLine">bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="uncoveredLine">  if (L.getNumBlocks() != 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">    ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">             << "Not a single basic block: "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">             << ore::NV("NumBlocks", L.getNumBlocks());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">  if (disabledByPragma) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">    ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">             << "Disabled by Pragma.";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">  // Check if the branch can't be understood because we can't do pipelining</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">  // if that's the case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">  LI.TBB = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">  LI.FBB = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">  LI.BrCond.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">  if (TII->analyzeBranch(*L.getHeader(), LI.TBB, LI.FBB, LI.BrCond)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Unable to analyzeBranch, can NOT pipeline Loop\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">    NumFailBranch++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="uncoveredLine">    ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="uncoveredLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">             << "The branch can't be understood";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">  LI.LoopInductionVar = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">  LI.LoopCompare = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">  LI.LoopPipelinerInfo = TII->analyzeLoopForPipelining(L.getTopBlock());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">  if (!LI.LoopPipelinerInfo) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Unable to analyzeLoop, can NOT pipeline Loop\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">    NumFailLoop++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">    ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">             << "The loop structure is not supported";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">  if (!L.getLoopPreheader()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Preheader not found, can NOT pipeline Loop\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">    NumFailPreheader++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">    ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">             << "No loop preheader found";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  // Remove any subregisters from inputs to phi nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">  preprocessPhiNodes(*L.getHeader());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">void MachinePipeliner::preprocessPhiNodes(MachineBasicBlock &B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">  MachineRegisterInfo &MRI = MF->getRegInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">  SlotIndexes &Slots = *getAnalysis<LiveIntervals>().getSlotIndexes();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">  for (MachineInstr &PI : B.phis()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    MachineOperand &DefOp = PI.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">    assert(DefOp.getSubReg() == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">    auto *RC = MRI.getRegClass(DefOp.getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">    for (unsigned i = 1, n = PI.getNumOperands(); i != n; i += 2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="uncoveredLine">      MachineOperand &RegOp = PI.getOperand(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">      if (RegOp.getSubReg() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">      // If the operand uses a subregister, replace it with a new register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">      // without subregisters, and generate a copy to the new register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">      Register NewReg = MRI.createVirtualRegister(RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="uncoveredLine">      MachineBasicBlock &PredB = *PI.getOperand(i+1).getMBB();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="uncoveredLine">      MachineBasicBlock::iterator At = PredB.getFirstTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">      const DebugLoc &DL = PredB.findDebugLoc(At);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">      auto Copy = BuildMI(PredB, At, DL, TII->get(TargetOpcode::COPY), NewReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">                    .addReg(RegOp.getReg(), getRegState(RegOp),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">                            RegOp.getSubReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">      Slots.insertMachineInstrInMaps(*Copy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">      RegOp.setReg(NewReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">      RegOp.setSubReg(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">/// The SMS algorithm consists of the following main steps:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">/// 1. Computation and analysis of the dependence graph.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">/// 2. Ordering of the nodes (instructions).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">/// 3. Attempt to Schedule the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">bool MachinePipeliner::swingModuloScheduler(MachineLoop &L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">  assert(L.getBlocks().size() == 1 && "SMS works on single blocks only.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">  SwingSchedulerDAG SMS(*this, L, getAnalysis<LiveIntervals>(), RegClassInfo,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">                        II_setByPragma, LI.LoopPipelinerInfo.get());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">  MachineBasicBlock *MBB = L.getHeader();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  // The kernel should not include any terminator instructions.  These</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">  // will be added back later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">  SMS.startBlock(MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">  // Compute the number of 'real' instructions in the basic block by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">  // ignoring terminators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="uncoveredLine">  unsigned size = MBB->size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">  for (MachineBasicBlock::iterator I = MBB->getFirstTerminator(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">                                   E = MBB->instr_end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">       I != E; ++I, --size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">    ;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">  SMS.enterRegion(MBB, MBB->begin(), MBB->getFirstTerminator(), size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">  SMS.schedule();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">  SMS.exitRegion();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">  SMS.finishBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="uncoveredLine">  return SMS.hasNewSchedule();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">void MachinePipeliner::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">  AU.addRequired<AAResultsWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">  AU.addPreserved<AAResultsWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">  AU.addRequired<MachineLoopInfo>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">  AU.addRequired<MachineDominatorTree>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="uncoveredLine">  AU.addRequired<LiveIntervals>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="uncoveredLine">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::setMII(unsigned ResMII, unsigned RecMII) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">  if (SwpForceII > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">    MII = SwpForceII;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">  else if (II_setByPragma > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">    MII = II_setByPragma;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="uncoveredLine">    MII = std::max(ResMII, RecMII);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::setMAX_II() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">  if (SwpForceII > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">    MAX_II = SwpForceII;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">  else if (II_setByPragma > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">    MAX_II = II_setByPragma;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">    MAX_II = MII + 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">/// We override the schedule function in ScheduleDAGInstrs to implement the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">/// scheduling part of the Swing Modulo Scheduling algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::schedule() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">  AliasAnalysis *AA = &Pass.getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">  buildSchedGraph(AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">  addLoopCarriedDependences(AA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">  updatePhiDependences();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">  Topo.InitDAGTopologicalSorting();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="uncoveredLine">  changeDependences();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">  postProcessDAG();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dump());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">  NodeSetType NodeSets;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">  findCircuits(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="uncoveredLine">  NodeSetType Circuits = NodeSets;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">  // Calculate the MII.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">  unsigned ResMII = calculateResMII();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">  unsigned RecMII = calculateRecMII(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="uncoveredLine">  fuseRecs(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  // This flag is used for testing and can cause correctness problems.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="uncoveredLine">  if (SwpIgnoreRecMII)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">    RecMII = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">  setMII(ResMII, RecMII);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">  setMAX_II();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "MII = " << MII << " MAX_II = " << MAX_II</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">                    << " (rec=" << RecMII << ", res=" << ResMII << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  // Can't schedule a loop without a valid MII.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">  if (MII == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Invalid Minimal Initiation Interval: 0\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">    NumFailZeroMII++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="uncoveredLine">    Pass.ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">             << "Invalid Minimal Initiation Interval: 0";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">  // Don't pipeline large loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">  if (SwpMaxMii != -1 && (int)MII > SwpMaxMii) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "MII > " << SwpMaxMii</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">                      << ", we don't pipeline large loops\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">    NumFailLargeMaxMII++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">    Pass.ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">             << "Minimal Initiation Interval too large: "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="uncoveredLine">             << ore::NV("MII", (int)MII) << " > "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">             << ore::NV("SwpMaxMii", SwpMaxMii) << "."</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">             << "Refer to -pipeliner-max-mii.";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">  computeNodeFunctions(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">  registerPressureFilter(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">  colocateNodeSets(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">  checkNodeSets(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">    for (auto &I : NodeSets) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">      dbgs() << "  Rec NodeSet ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">      I.dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="uncoveredLine">  llvm::stable_sort(NodeSets, std::greater<NodeSet>());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="uncoveredLine">  groupRemainingNodes(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">  removeDuplicateNodes(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">    for (auto &I : NodeSets) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">      dbgs() << "  NodeSet ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">      I.dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">  computeNodeOrder(NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">  // check for node order issues</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">  checkValidNodeOrder(Circuits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">  SMSchedule Schedule(Pass.MF, this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">  Scheduled = schedulePipeline(Schedule);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">  if (!Scheduled){</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "No schedule found, return\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">    NumFailNoSchedule++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">    Pass.ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">             << "Unable to find schedule";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">  unsigned numStages = Schedule.getMaxStageCount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">  // No need to generate pipeline if there are no overlapped iterations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  if (numStages == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "No overlapped iterations, skip.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">    NumFailZeroStage++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">    Pass.ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">             << "No need to pipeline - no overlapped iterations in schedule.";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">  // Check that the maximum stage count is less than user-defined limit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">  if (SwpMaxStages > -1 && (int)numStages > SwpMaxStages) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "numStages:" << numStages << ">" << SwpMaxStages</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">                      << " : too many stages, abort\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">    NumFailLargeMaxStage++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">    Pass.ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">             << "Too many stages in schedule: "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="uncoveredLine">             << ore::NV("numStages", (int)numStages) << " > "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">             << ore::NV("SwpMaxStages", SwpMaxStages)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">             << ". Refer to -pipeliner-max-stages.";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">  Pass.ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">    return MachineOptimizationRemark(DEBUG_TYPE, "schedule", Loop.getStartLoc(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">                                     Loop.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">           << "Pipelined succesfully!";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">  // Generate the schedule as a ModuloSchedule.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">  DenseMap<MachineInstr *, int> Cycles, Stages;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">  std::vector<MachineInstr *> OrderedInsts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">  for (int Cycle = Schedule.getFirstCycle(); Cycle <= Schedule.getFinalCycle();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">       ++Cycle) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">    for (SUnit *SU : Schedule.getInstructions(Cycle)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">      OrderedInsts.push_back(SU->getInstr());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">      Cycles[SU->getInstr()] = Cycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">      Stages[SU->getInstr()] = Schedule.stageScheduled(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">  DenseMap<MachineInstr *, std::pair<unsigned, int64_t>> NewInstrChanges;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  for (auto &KV : NewMIs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">    Cycles[KV.first] = Cycles[KV.second];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">    Stages[KV.first] = Stages[KV.second];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">    NewInstrChanges[KV.first] = InstrChanges[getSUnit(KV.first)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">  ModuloSchedule MS(MF, &Loop, std::move(OrderedInsts), std::move(Cycles),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">                    std::move(Stages));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">  if (EmitTestAnnotations) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">    assert(NewInstrChanges.empty() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">           "Cannot serialize a schedule with InstrChanges!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">    ModuloScheduleTestAnnotater MSTI(MF, MS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">    MSTI.annotate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  // The experimental code generator can't work if there are InstChanges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">  if (ExperimentalCodeGen && NewInstrChanges.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">    PeelingModuloScheduleExpander MSE(MF, MS, &LIS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">    MSE.expand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">    ModuloScheduleExpander MSE(MF, MS, LIS, std::move(NewInstrChanges));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">    MSE.expand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">    MSE.cleanup();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">  ++NumPipelined;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">/// Clean up after the software pipeliner runs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::finishBlock() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">  for (auto &KV : NewMIs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">    MF.deleteMachineInstr(KV.second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">  NewMIs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">  // Call the superclass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">  ScheduleDAGInstrs::finishBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">/// Return the register values for  the operands of a Phi instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">/// This function assume the instruction is a Phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">static void getPhiRegs(MachineInstr &Phi, MachineBasicBlock *Loop,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">                       unsigned &InitVal, unsigned &LoopVal) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">  InitVal = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">  LoopVal = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">    if (Phi.getOperand(i + 1).getMBB() != Loop)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">      InitVal = Phi.getOperand(i).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">      LoopVal = Phi.getOperand(i).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">  assert(InitVal != 0 && LoopVal != 0 && "Unexpected Phi structure.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">/// Return the Phi register value that comes the loop block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="uncoveredLine">static unsigned getLoopPhiReg(MachineInstr &Phi, MachineBasicBlock *LoopBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">    if (Phi.getOperand(i + 1).getMBB() == LoopBB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">      return Phi.getOperand(i).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">/// Return true if SUb can be reached from SUa following the chain edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">static bool isSuccOrder(SUnit *SUa, SUnit *SUb) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">  SmallVector<SUnit *, 8> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">  Worklist.push_back(SUa);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">    const SUnit *SU = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">    for (const auto &SI : SU->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">      SUnit *SuccSU = SI.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">      if (SI.getKind() == SDep::Order) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">        if (Visited.count(SuccSU))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">        if (SuccSU == SUb)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">        Worklist.push_back(SuccSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">        Visited.insert(SuccSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">/// Return true if the instruction causes a chain between memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">/// references before and after it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">static bool isDependenceBarrier(MachineInstr &MI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">  return MI.isCall() || MI.mayRaiseFPException() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">         MI.hasUnmodeledSideEffects() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">         (MI.hasOrderedMemoryRef() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">          (!MI.mayLoad() || !MI.isDereferenceableInvariantLoad()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">/// Return the underlying objects for the memory references of an instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">/// This function calls the code in ValueTracking, but first checks that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">/// instruction has a memory operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">static void getUnderlyingObjects(const MachineInstr *MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">                                 SmallVectorImpl<const Value *> &Objs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">  if (!MI->hasOneMemOperand())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">  MachineMemOperand *MM = *MI->memoperands_begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">  if (!MM->getValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">  getUnderlyingObjects(MM->getValue(), Objs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="uncoveredLine">  for (const Value *V : Objs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">    if (!isIdentifiedObject(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">      Objs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">    Objs.push_back(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">/// Add a chain edge between a load and store if the store can be an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">/// alias of the load on a subsequent iteration, i.e., a loop carried</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">/// dependence. This code is very similar to the code in ScheduleDAGInstrs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">/// but that code doesn't create loop carried dependences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::addLoopCarriedDependences(AliasAnalysis *AA) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">  MapVector<const Value *, SmallVector<SUnit *, 4>> PendingLoads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">  Value *UnknownValue =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">    UndefValue::get(Type::getVoidTy(MF.getFunction().getContext()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">  for (auto &SU : SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">    MachineInstr &MI = *SU.getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">    if (isDependenceBarrier(MI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">      PendingLoads.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">    else if (MI.mayLoad()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">      SmallVector<const Value *, 4> Objs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">      ::getUnderlyingObjects(&MI, Objs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">      if (Objs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">        Objs.push_back(UnknownValue);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">      for (const auto *V : Objs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">        SmallVector<SUnit *, 4> &SUs = PendingLoads[V];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">        SUs.push_back(&SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">    } else if (MI.mayStore()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">      SmallVector<const Value *, 4> Objs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">      ::getUnderlyingObjects(&MI, Objs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">      if (Objs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="uncoveredLine">        Objs.push_back(UnknownValue);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">      for (const auto *V : Objs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">        MapVector<const Value *, SmallVector<SUnit *, 4>>::iterator I =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">            PendingLoads.find(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">        if (I == PendingLoads.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">        for (auto *Load : I->second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">          if (isSuccOrder(Load, &SU))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">          MachineInstr &LdMI = *Load->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">          // First, perform the cheaper check that compares the base register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">          // If they are the same and the load offset is less than the store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">          // offset, then mark the dependence as loop carried potentially.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">          const MachineOperand *BaseOp1, *BaseOp2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">          int64_t Offset1, Offset2;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">          bool Offset1IsScalable, Offset2IsScalable;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">          if (TII->getMemOperandWithOffset(LdMI, BaseOp1, Offset1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">                                           Offset1IsScalable, TRI) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">              TII->getMemOperandWithOffset(MI, BaseOp2, Offset2,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">                                           Offset2IsScalable, TRI)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">            if (BaseOp1->isIdenticalTo(*BaseOp2) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">                Offset1IsScalable == Offset2IsScalable &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">                (int)Offset1 < (int)Offset2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">              assert(TII->areMemAccessesTriviallyDisjoint(LdMI, MI) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">                     "What happened to the chain edge?");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">              SDep Dep(Load, SDep::Barrier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">              Dep.setLatency(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">              SU.addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">            }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">          // Second, the more expensive check that uses alias analysis on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">          // base registers. If they alias, and the load offset is less than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">          // the store offset, the mark the dependence as loop carried.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">          if (!AA) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">            Dep.setLatency(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">            SU.addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">          }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">          MachineMemOperand *MMO1 = *LdMI.memoperands_begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="uncoveredLine">          MachineMemOperand *MMO2 = *MI.memoperands_begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">          if (!MMO1->getValue() || !MMO2->getValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">            Dep.setLatency(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">            SU.addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="uncoveredLine">          }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">          if (MMO1->getValue() == MMO2->getValue() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">              MMO1->getOffset() <= MMO2->getOffset()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">            Dep.setLatency(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">            SU.addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">          }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="uncoveredLine">          if (!AA->isNoAlias(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">                  MemoryLocation::getAfter(MMO1->getValue(), MMO1->getAAInfo()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">                  MemoryLocation::getAfter(MMO2->getValue(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">                                           MMO2->getAAInfo()))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">            Dep.setLatency(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">            SU.addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">/// processes dependences for PHIs. This function adds true dependences</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">/// from a PHI to a use, and a loop carried dependence from the use to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">/// PHI. The loop carried dependence is represented as an anti dependence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">/// edge. This function also removes chain dependences between unrelated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">/// PHIs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::updatePhiDependences() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">  SmallVector<SDep, 4> RemoveDeps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">  const TargetSubtargetInfo &ST = MF.getSubtarget<TargetSubtargetInfo>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  // Iterate over each DAG node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">  for (SUnit &I : SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">    RemoveDeps.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">    // Set to true if the instruction has an operand defined by a Phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">    unsigned HasPhiUse = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">    unsigned HasPhiDef = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">    MachineInstr *MI = I.getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">    // Iterate over each operand, and we process the definitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">    for (const MachineOperand &MO : MI->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">      if (!MO.isReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">      Register Reg = MO.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">      if (MO.isDef()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">        // If the register is used by a Phi, then create an anti dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">        for (MachineRegisterInfo::use_instr_iterator</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">                 UI = MRI.use_instr_begin(Reg),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">                 UE = MRI.use_instr_end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">             UI != UE; ++UI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">          MachineInstr *UseMI = &*UI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">          SUnit *SU = getSUnit(UseMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">          if (SU != nullptr && UseMI->isPHI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">            if (!MI->isPHI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">              SDep Dep(SU, SDep::Anti, Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="uncoveredLine">              Dep.setLatency(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="uncoveredLine">              I.addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">            } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="uncoveredLine">              HasPhiDef = Reg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">              // Add a chain edge to a dependent Phi that isn't an existing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">              // predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">              if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">                I.addPred(SDep(SU, SDep::Barrier));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">      } else if (MO.isUse()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">        // If the register is defined by a Phi, then create a true dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">        MachineInstr *DefMI = MRI.getUniqueVRegDef(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">        if (DefMI == nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="uncoveredLine">        SUnit *SU = getSUnit(DefMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">        if (SU != nullptr && DefMI->isPHI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">          if (!MI->isPHI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">            SDep Dep(SU, SDep::Data, Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">            Dep.setLatency(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">            ST.adjustSchedDependency(SU, 0, &I, MO.getOperandNo(), Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">            I.addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">          } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">            HasPhiUse = Reg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">            // Add a chain edge to a dependent Phi that isn't an existing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">            // predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="uncoveredLine">            if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">              I.addPred(SDep(SU, SDep::Barrier));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">    // Remove order dependences from an unrelated Phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">    if (!SwpPruneDeps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">    for (auto &PI : I.Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">      MachineInstr *PMI = PI.getSUnit()->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">      if (PMI->isPHI() && PI.getKind() == SDep::Order) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">        if (I.getInstr()->isPHI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">          if (PMI->getOperand(0).getReg() == HasPhiUse)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">          if (getLoopPhiReg(*PMI, PMI->getParent()) == HasPhiDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">        RemoveDeps.push_back(PI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">    for (int i = 0, e = RemoveDeps.size(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">      I.removePred(RemoveDeps[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">/// Iterate over each DAG node and see if we can change any dependences</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">/// in order to reduce the recurrence MII.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::changeDependences() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">  // See if an instruction can use a value from the previous iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">  // If so, we update the base and offset of the instruction and change</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">  // the dependences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="uncoveredLine">  for (SUnit &I : SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">    unsigned BasePos = 0, OffsetPos = 0, NewBase = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">    int64_t NewOffset = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">    if (!canUseLastOffsetValue(I.getInstr(), BasePos, OffsetPos, NewBase,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">                               NewOffset))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">    // Get the MI and SUnit for the instruction that defines the original base.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">    Register OrigBase = I.getInstr()->getOperand(BasePos).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">    MachineInstr *DefMI = MRI.getUniqueVRegDef(OrigBase);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">    if (!DefMI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">    SUnit *DefSU = getSUnit(DefMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">    if (!DefSU)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">    // Get the MI and SUnit for the instruction that defins the new base.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">    MachineInstr *LastMI = MRI.getUniqueVRegDef(NewBase);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">    if (!LastMI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">    SUnit *LastSU = getSUnit(LastMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="uncoveredLine">    if (!LastSU)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="uncoveredLine">    if (Topo.IsReachable(&I, LastSU))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">    // Remove the dependence. The value now depends on a prior iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">    SmallVector<SDep, 4> Deps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">    for (const SDep &P : I.Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">      if (P.getSUnit() == DefSU)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">        Deps.push_back(P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="uncoveredLine">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">      Topo.RemovePred(&I, Deps[i].getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">      I.removePred(Deps[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">    // Remove the chain dependence between the instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">    Deps.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">    for (auto &P : LastSU->Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">      if (P.getSUnit() == &I && P.getKind() == SDep::Order)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="uncoveredLine">        Deps.push_back(P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">      Topo.RemovePred(LastSU, Deps[i].getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">      LastSU->removePred(Deps[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">    // Add a dependence between the new instruction and the instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">    // that defines the new base.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">    SDep Dep(&I, SDep::Anti, NewBase);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">    Topo.AddPred(LastSU, &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">    LastSU->addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">    // Remember the base and offset information so that we can update the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">    // instruction during code generation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">    InstrChanges[&I] = std::make_pair(NewBase, NewOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">// FuncUnitSorter - Comparison operator used to sort instructions by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">// the number of functional unit choices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">struct FuncUnitSorter {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">  const InstrItineraryData *InstrItins;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">  const MCSubtargetInfo *STI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">  DenseMap<InstrStage::FuncUnits, unsigned> Resources;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="uncoveredLine">  FuncUnitSorter(const TargetSubtargetInfo &TSI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">      : InstrItins(TSI.getInstrItineraryData()), STI(&TSI) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">  // Compute the number of functional unit alternatives needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">  // at each stage, and take the minimum value. We prioritize the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">  // instructions by the least number of choices first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">  unsigned minFuncUnits(const MachineInstr *Inst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">                        InstrStage::FuncUnits &F) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">    unsigned SchedClass = Inst->getDesc().getSchedClass();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="uncoveredLine">    unsigned min = UINT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">    if (InstrItins && !InstrItins->isEmpty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">      for (const InstrStage &IS :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">           make_range(InstrItins->beginStage(SchedClass),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">                      InstrItins->endStage(SchedClass))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="uncoveredLine">        InstrStage::FuncUnits funcUnits = IS.getUnits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">        unsigned numAlternatives = llvm::popcount(funcUnits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">        if (numAlternatives < min) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">          min = numAlternatives;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="uncoveredLine">          F = funcUnits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="uncoveredLine">      return min;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">      const MCSchedClassDesc *SCDesc =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="uncoveredLine">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">      if (!SCDesc->isValid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">        // No valid Schedule Class Desc for schedClass, should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">        // Pseudo/PostRAPseudo</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">        return min;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">      for (const MCWriteProcResEntry &PRE :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="uncoveredLine">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">                      STI->getWriteProcResEnd(SCDesc))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">        if (!PRE.Cycles)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">        const MCProcResourceDesc *ProcResource =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">            STI->getSchedModel().getProcResource(PRE.ProcResourceIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">        unsigned NumUnits = ProcResource->NumUnits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">        if (NumUnits < min) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">          min = NumUnits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">          F = PRE.ProcResourceIdx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="uncoveredLine">      return min;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">  // Compute the critical resources needed by the instruction. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">  // function records the functional units needed by instructions that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  // must use only one functional unit. We use this as a tie breaker</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  // for computing the resource MII. The instrutions that require</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  // the same, highly used, functional unit have high priority.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">  void calcCriticalResources(MachineInstr &MI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">    unsigned SchedClass = MI.getDesc().getSchedClass();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">    if (InstrItins && !InstrItins->isEmpty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">      for (const InstrStage &IS :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="uncoveredLine">           make_range(InstrItins->beginStage(SchedClass),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="uncoveredLine">                      InstrItins->endStage(SchedClass))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="uncoveredLine">        InstrStage::FuncUnits FuncUnits = IS.getUnits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">        if (llvm::popcount(FuncUnits) == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">          Resources[FuncUnits]++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">      const MCSchedClassDesc *SCDesc =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">      if (!SCDesc->isValid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">        // No valid Schedule Class Desc for schedClass, should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">        // Pseudo/PostRAPseudo</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">        return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">      for (const MCWriteProcResEntry &PRE :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">                      STI->getWriteProcResEnd(SCDesc))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">        if (!PRE.Cycles)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">        Resources[PRE.ProcResourceIdx]++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">  /// Return true if IS1 has less priority than IS2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">  bool operator()(const MachineInstr *IS1, const MachineInstr *IS2) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">    InstrStage::FuncUnits F1 = 0, F2 = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="uncoveredLine">    unsigned MFUs1 = minFuncUnits(IS1, F1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">    unsigned MFUs2 = minFuncUnits(IS2, F2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">    if (MFUs1 == MFUs2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">      return Resources.lookup(F1) < Resources.lookup(F2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">    return MFUs1 > MFUs2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">/// Calculate the resource constrained minimum initiation interval for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">/// specified loop. We use the DFA to model the resources needed for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">/// each instruction, and we ignore dependences. A different DFA is created</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">/// for each cycle that is required. When adding a new instruction, we attempt</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">/// to add it to each existing DFA, until a legal space is found. If the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">/// instruction cannot be reserved in an existing DFA, we create a new one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="uncoveredLine">unsigned SwingSchedulerDAG::calculateResMII() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "calculateResMII:\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">  ResourceManager RM(&MF.getSubtarget(), this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">  return RM.calculateResMII();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">/// Calculate the recurrence-constrainted minimum initiation interval.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">/// Iterate over each circuit.  Compute the delay(c) and distance(c)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">/// for each circuit. The II needs to satisfy the inequality</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">/// delay(c) - II*distance(c) <= 0. For each circuit, choose the smallest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="">/// II that satisfies the inequality, and the RecMII is the maximum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">/// of those values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="uncoveredLine">unsigned SwingSchedulerDAG::calculateRecMII(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">  unsigned RecMII = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">  for (NodeSet &Nodes : NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">    if (Nodes.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">    unsigned Delay = Nodes.getLatency();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="uncoveredLine">    unsigned Distance = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">    // ii = ceil(delay / distance)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">    unsigned CurMII = (Delay + Distance - 1) / Distance;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="uncoveredLine">    Nodes.setRecMII(CurMII);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">    if (CurMII > RecMII)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">      RecMII = CurMII;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">  return RecMII;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">/// Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">/// but we do this to find the circuits, and then change them back.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">static void swapAntiDependences(std::vector<SUnit> &SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">  SmallVector<std::pair<SUnit *, SDep>, 8> DepsAdded;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">  for (SUnit &SU : SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">    for (SDep &Pred : SU.Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">      if (Pred.getKind() == SDep::Anti)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">        DepsAdded.push_back(std::make_pair(&SU, Pred));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">  for (std::pair<SUnit *, SDep> &P : DepsAdded) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">    // Remove this anti dependency and add one in the reverse direction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">    SUnit *SU = P.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">    SDep &D = P.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">    SUnit *TargetSU = D.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">    unsigned Reg = D.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">    unsigned Lat = D.getLatency();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">    SU->removePred(D);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">    SDep Dep(SU, SDep::Anti, Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">    Dep.setLatency(Lat);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">    TargetSU->addPred(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">/// Create the adjacency structure of the nodes in the graph.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::Circuits::createAdjacencyStructure(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">    SwingSchedulerDAG *DAG) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">  BitVector Added(SUnits.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">  DenseMap<int, int> OutputDeps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">    Added.reset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">    // Add any successor to the adjacency matrix and exclude duplicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">    for (auto &SI : SUnits[i].Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">      // Only create a back-edge on the first and last nodes of a dependence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">      // chain. This records any chains and adds them later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">      if (SI.getKind() == SDep::Output) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">        int N = SI.getSUnit()->NodeNum;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">        int BackEdge = i;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">        auto Dep = OutputDeps.find(BackEdge);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">        if (Dep != OutputDeps.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="uncoveredLine">          BackEdge = Dep->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">          OutputDeps.erase(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">        OutputDeps[N] = BackEdge;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">      // Do not process a boundary node, an artificial node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">      // A back-edge is processed only if it goes to a Phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="uncoveredLine">      if (SI.getSUnit()->isBoundaryNode() || SI.isArtificial() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="uncoveredLine">          (SI.getKind() == SDep::Anti && !SI.getSUnit()->getInstr()->isPHI()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">      int N = SI.getSUnit()->NodeNum;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">      if (!Added.test(N)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">        AdjK[i].push_back(N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">        Added.set(N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">    // A chain edge between a store and a load is treated as a back-edge in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">    // adjacency matrix.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">    for (auto &PI : SUnits[i].Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">      if (!SUnits[i].getInstr()->mayStore() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">          !DAG->isLoopCarriedDep(&SUnits[i], PI, false))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">      if (PI.getKind() == SDep::Order && PI.getSUnit()->getInstr()->mayLoad()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">        int N = PI.getSUnit()->NodeNum;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">        if (!Added.test(N)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">          AdjK[i].push_back(N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">          Added.set(N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">  // Add back-edges in the adjacency matrix for the output dependences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="uncoveredLine">  for (auto &OD : OutputDeps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">    if (!Added.test(OD.second)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="uncoveredLine">      AdjK[OD.first].push_back(OD.second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">      Added.set(OD.second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">/// Identify an elementary circuit in the dependence graph starting at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">/// specified node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">bool SwingSchedulerDAG::Circuits::circuit(int V, int S, NodeSetType &NodeSets,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">                                          bool HasBackedge) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="uncoveredLine">  SUnit *SV = &SUnits[V];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">  bool F = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">  Stack.insert(SV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">  Blocked.set(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">  for (auto W : AdjK[V]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">    if (NumPaths > MaxPaths)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="uncoveredLine">    if (W < S)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="uncoveredLine">    if (W == S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">      if (!HasBackedge)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">        NodeSets.push_back(NodeSet(Stack.begin(), Stack.end()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="uncoveredLine">      F = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">      ++NumPaths;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">    } else if (!Blocked.test(W)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="uncoveredLine">      if (circuit(W, S, NodeSets,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="uncoveredLine">                  Node2Idx->at(W) < Node2Idx->at(V) ? true : HasBackedge))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="uncoveredLine">        F = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="uncoveredLine">  if (F)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">    unblock(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="uncoveredLine">    for (auto W : AdjK[V]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="uncoveredLine">      if (W < S)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="uncoveredLine">      B[W].insert(SV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="uncoveredLine">  Stack.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">  return F;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">/// Unblock a node in the circuit finding algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::Circuits::unblock(int U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">  Blocked.reset(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">  SmallPtrSet<SUnit *, 4> &BU = B[U];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">  while (!BU.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">    SmallPtrSet<SUnit *, 4>::iterator SI = BU.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="uncoveredLine">    assert(SI != BU.end() && "Invalid B set.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">    SUnit *W = *SI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">    BU.erase(W);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">    if (Blocked.test(W->NodeNum))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">      unblock(W->NodeNum);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">/// Identify all the elementary circuits in the dependence graph using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">/// Johnson's circuit algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::findCircuits(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  // Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  // but we do this to find the circuits, and then change them back.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="uncoveredLine">  swapAntiDependences(SUnits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">  Circuits Cir(SUnits, Topo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">  // Create the adjacency structure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="uncoveredLine">  Cir.createAdjacencyStructure(this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="uncoveredLine">    Cir.reset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">    Cir.circuit(i, i, NodeSets);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">  // Change the dependences back so that we've created a DAG again.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="uncoveredLine">  swapAntiDependences(SUnits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">// Create artificial dependencies between the source of COPY/REG_SEQUENCE that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">// is loop-carried to the USE in next iteration. This will help pipeliner avoid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">// additional copies that are needed across iterations. An artificial dependence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">// edge is added from USE to SOURCE of COPY/REG_SEQUENCE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">// PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">// SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">// PHI-------True-Dep------> USEOfPhi</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">// The mutation creates</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">// USEOfPHI -------Artificial-Dep---> SRCOfCopy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">// This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">// (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">// late  to avoid additional copies across iterations. The possible scheduling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">// order would be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">// USEOfPHI --- SRCOfCopy---  COPY/REG_SEQUENCE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::CopyToPhiMutation::apply(ScheduleDAGInstrs *DAG) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">  for (SUnit &SU : DAG->SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">    // Find the COPY/REG_SEQUENCE instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="uncoveredLine">    if (!SU.getInstr()->isCopy() && !SU.getInstr()->isRegSequence())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">    // Record the loop carried PHIs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="uncoveredLine">    SmallVector<SUnit *, 4> PHISUs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">    // Record the SrcSUs that feed the COPY/REG_SEQUENCE instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="uncoveredLine">    SmallVector<SUnit *, 4> SrcSUs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="uncoveredLine">    for (auto &Dep : SU.Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">      SUnit *TmpSU = Dep.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">      MachineInstr *TmpMI = TmpSU->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">      SDep::Kind DepKind = Dep.getKind();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">      // Save the loop carried PHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">      if (DepKind == SDep::Anti && TmpMI->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">        PHISUs.push_back(TmpSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">      // Save the source of COPY/REG_SEQUENCE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">      // If the source has no pre-decessors, we will end up creating cycles.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">      else if (DepKind == SDep::Data && !TmpMI->isPHI() && TmpSU->NumPreds > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="uncoveredLine">        SrcSUs.push_back(TmpSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">    if (PHISUs.size() == 0 || SrcSUs.size() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">    // Find the USEs of PHI. If the use is a PHI or REG_SEQUENCE, push back this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">    // SUnit to the container.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">    SmallVector<SUnit *, 8> UseSUs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">    // Do not use iterator based loop here as we are updating the container.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">    for (size_t Index = 0; Index < PHISUs.size(); ++Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">      for (auto &Dep : PHISUs[Index]->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">        if (Dep.getKind() != SDep::Data)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">        SUnit *TmpSU = Dep.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">        MachineInstr *TmpMI = TmpSU->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">        if (TmpMI->isPHI() || TmpMI->isRegSequence()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">          PHISUs.push_back(TmpSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">        UseSUs.push_back(TmpSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">    if (UseSUs.size() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="uncoveredLine">    SwingSchedulerDAG *SDAG = cast<SwingSchedulerDAG>(DAG);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">    // Add the artificial dependencies if it does not form a cycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">    for (auto *I : UseSUs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">      for (auto *Src : SrcSUs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">        if (!SDAG->Topo.IsReachable(I, Src) && Src != I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">          Src->addPred(SDep(I, SDep::Artificial));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">          SDAG->Topo.AddPred(Src, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">/// Return true for DAG nodes that we ignore when computing the cost functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">/// We ignore the back-edge recurrence in order to avoid unbounded recursion</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">/// in the calculation of the ASAP, ALAP, etc functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="uncoveredLine">static bool ignoreDependence(const SDep &D, bool isPred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">  if (D.isArtificial() || D.getSUnit()->isBoundaryNode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="uncoveredLine">  return D.getKind() == SDep::Anti && isPred;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">/// Compute several functions need to order the nodes for scheduling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">///  ASAP - Earliest time to schedule a node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">///  ALAP - Latest time to schedule a node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">///  MOV - Mobility function, difference between ALAP and ASAP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">///  D - Depth of each node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">///  H - Height of each node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::computeNodeFunctions(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">  ScheduleInfo.resize(SUnits.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">    for (int I : Topo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">      const SUnit &SU = SUnits[I];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">      dumpNode(SU);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">  int maxASAP = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">  // Compute ASAP and ZeroLatencyDepth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">  for (int I : Topo) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">    int asap = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">    int zeroLatencyDepth = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">    SUnit *SU = &SUnits[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="uncoveredLine">    for (const SDep &P : SU->Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="uncoveredLine">      SUnit *pred = P.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">      if (P.getLatency() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="uncoveredLine">        zeroLatencyDepth =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="uncoveredLine">            std::max(zeroLatencyDepth, getZeroLatencyDepth(pred) + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="uncoveredLine">      if (ignoreDependence(P, true))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">      asap = std::max(asap, (int)(getASAP(pred) + P.getLatency() -</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">                                  getDistance(pred, SU, P) * MII));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">    maxASAP = std::max(maxASAP, asap);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="uncoveredLine">    ScheduleInfo[I].ASAP = asap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="uncoveredLine">    ScheduleInfo[I].ZeroLatencyDepth = zeroLatencyDepth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">  // Compute ALAP, ZeroLatencyHeight, and MOV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">  for (int I : llvm::reverse(Topo)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="uncoveredLine">    int alap = maxASAP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">    int zeroLatencyHeight = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">    SUnit *SU = &SUnits[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="uncoveredLine">    for (const SDep &S : SU->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="uncoveredLine">      SUnit *succ = S.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="uncoveredLine">      if (succ->isBoundaryNode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="uncoveredLine">      if (S.getLatency() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">        zeroLatencyHeight =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">            std::max(zeroLatencyHeight, getZeroLatencyHeight(succ) + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="uncoveredLine">      if (ignoreDependence(S, true))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">      alap = std::min(alap, (int)(getALAP(succ) - S.getLatency() +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">                                  getDistance(SU, succ, S) * MII));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">    ScheduleInfo[I].ALAP = alap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="uncoveredLine">    ScheduleInfo[I].ZeroLatencyHeight = zeroLatencyHeight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">  // After computing the node functions, compute the summary for each node set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="uncoveredLine">  for (NodeSet &I : NodeSets)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">    I.computeNodeSetInfo(this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">    for (unsigned i = 0; i < SUnits.size(); i++) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">      dbgs() << "\tNode " << i << ":\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">      dbgs() << "\t   ASAP = " << getASAP(&SUnits[i]) << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">      dbgs() << "\t   ALAP = " << getALAP(&SUnits[i]) << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">      dbgs() << "\t   MOV  = " << getMOV(&SUnits[i]) << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">      dbgs() << "\t   D    = " << getDepth(&SUnits[i]) << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">      dbgs() << "\t   H    = " << getHeight(&SUnits[i]) << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="">      dbgs() << "\t   ZLD  = " << getZeroLatencyDepth(&SUnits[i]) << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">      dbgs() << "\t   ZLH  = " << getZeroLatencyHeight(&SUnits[i]) << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">/// Compute the Pred_L(O) set, as defined in the paper. The set is defined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">/// as the predecessors of the elements of NodeOrder that are not also in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">/// NodeOrder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">static bool pred_L(SetVector<SUnit *> &NodeOrder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">                   SmallSetVector<SUnit *, 8> &Preds,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">                   const NodeSet *S = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">  Preds.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="uncoveredLine">  for (const SUnit *SU : NodeOrder) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">    for (const SDep &Pred : SU->Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">      if (S && S->count(Pred.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">      if (ignoreDependence(Pred, true))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="uncoveredLine">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="uncoveredLine">        Preds.insert(Pred.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">    // Back-edges are predecessors with an anti-dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">    for (const SDep &Succ : SU->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">      if (Succ.getKind() != SDep::Anti)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">      if (S && S->count(Succ.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="uncoveredLine">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">        Preds.insert(Succ.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="uncoveredLine">  return !Preds.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">/// Compute the Succ_L(O) set, as defined in the paper. The set is defined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">/// as the successors of the elements of NodeOrder that are not also in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">/// NodeOrder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">static bool succ_L(SetVector<SUnit *> &NodeOrder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">                   SmallSetVector<SUnit *, 8> &Succs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">                   const NodeSet *S = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">  Succs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">  for (const SUnit *SU : NodeOrder) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">    for (const SDep &Succ : SU->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">      if (S && S->count(Succ.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">      if (ignoreDependence(Succ, false))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">        Succs.insert(Succ.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">    for (const SDep &Pred : SU->Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="uncoveredLine">      if (Pred.getKind() != SDep::Anti)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">      if (S && S->count(Pred.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">        Succs.insert(Pred.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">  return !Succs.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">/// Return true if there is a path from the specified node to any of the nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">/// in DestNodes. Keep track and return the nodes in any path.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">static bool computePath(SUnit *Cur, SetVector<SUnit *> &Path,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">                        SetVector<SUnit *> &DestNodes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="">                        SetVector<SUnit *> &Exclude,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="">                        SmallPtrSet<SUnit *, 8> &Visited) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">  if (Cur->isBoundaryNode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="uncoveredLine">  if (Exclude.contains(Cur))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="uncoveredLine">  if (DestNodes.contains(Cur))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">  if (!Visited.insert(Cur).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="uncoveredLine">    return Path.contains(Cur);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">  bool FoundPath = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">  for (auto &SI : Cur->Succs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="uncoveredLine">    if (!ignoreDependence(SI, false))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="uncoveredLine">      FoundPath |=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">          computePath(SI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="uncoveredLine">  for (auto &PI : Cur->Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">    if (PI.getKind() == SDep::Anti)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">      FoundPath |=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">          computePath(PI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">  if (FoundPath)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">    Path.insert(Cur);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">  return FoundPath;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">/// Compute the live-out registers for the instructions in a node-set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="">/// The live-out registers are those that are defined in the node-set,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="">/// but not used. Except for use operands of Phis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">static void computeLiveOuts(MachineFunction &MF, RegPressureTracker &RPTracker,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">                            NodeSet &NS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="uncoveredLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">  SmallVector<RegisterMaskPair, 8> LiveOutRegs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">  SmallSet<unsigned, 4> Uses;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="uncoveredLine">  for (SUnit *SU : NS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="uncoveredLine">    const MachineInstr *MI = SU->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="uncoveredLine">    if (MI->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">    for (const MachineOperand &MO : MI->all_uses()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">      Register Reg = MO.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="uncoveredLine">      if (Reg.isVirtual())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">        Uses.insert(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="uncoveredLine">      else if (MRI.isAllocatable(Reg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">        for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="uncoveredLine">          Uses.insert(Unit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="uncoveredLine">  for (SUnit *SU : NS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="uncoveredLine">    for (const MachineOperand &MO : SU->getInstr()->all_defs())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="uncoveredLine">      if (!MO.isDead()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="uncoveredLine">        Register Reg = MO.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="uncoveredLine">        if (Reg.isVirtual()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="uncoveredLine">          if (!Uses.count(Reg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">            LiveOutRegs.push_back(RegisterMaskPair(Reg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">                                                   LaneBitmask::getNone()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="uncoveredLine">        } else if (MRI.isAllocatable(Reg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="uncoveredLine">          for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">            if (!Uses.count(Unit))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">              LiveOutRegs.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">                  RegisterMaskPair(Unit, LaneBitmask::getNone()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="uncoveredLine">  RPTracker.addLiveRegs(LiveOutRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="">/// A heuristic to filter nodes in recurrent node-sets if the register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">/// pressure of a set is too high.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::registerPressureFilter(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">  for (auto &NS : NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">    // Skip small node-sets since they won't cause register pressure problems.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="uncoveredLine">    if (NS.size() <= 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">    IntervalPressure RecRegPressure;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">    RegPressureTracker RecRPTracker(RecRegPressure);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="uncoveredLine">    RecRPTracker.init(&MF, &RegClassInfo, &LIS, BB, BB->end(), false, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="uncoveredLine">    computeLiveOuts(MF, RecRPTracker, NS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">    RecRPTracker.closeBottom();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="uncoveredLine">    std::vector<SUnit *> SUnits(NS.begin(), NS.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="uncoveredLine">    llvm::sort(SUnits, [](const SUnit *A, const SUnit *B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="uncoveredLine">      return A->NodeNum > B->NodeNum;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">    for (auto &SU : SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="">      // Since we're computing the register pressure for a subset of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">      // instructions in a block, we need to set the tracker for each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">      // instruction in the node-set. The tracker is set to the instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">      // just after the one we're interested in.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">      MachineBasicBlock::const_iterator CurInstI = SU->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">      RecRPTracker.setPos(std::next(CurInstI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">      RegPressureDelta RPDelta;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">      ArrayRef<PressureChange> CriticalPSets;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">      RecRPTracker.getMaxUpwardPressureDelta(SU->getInstr(), nullptr, RPDelta,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="">                                             CriticalPSets,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">                                             RecRegPressure.MaxSetPressure);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">      if (RPDelta.Excess.isValid()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">        LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">            dbgs() << "Excess register pressure: SU(" << SU->NodeNum << ") "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="">                   << TRI->getRegPressureSetName(RPDelta.Excess.getPSet())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">                   << ":" << RPDelta.Excess.getUnitInc() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="uncoveredLine">        NS.setExceedPressure(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="uncoveredLine">      RecRPTracker.recede();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="">/// A heuristic to colocate node sets that have the same set of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="">/// successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::colocateNodeSets(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">  unsigned Colocate = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">  for (int i = 0, e = NodeSets.size(); i < e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="uncoveredLine">    NodeSet &N1 = NodeSets[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">    SmallSetVector<SUnit *, 8> S1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="uncoveredLine">    if (N1.empty() || !succ_L(N1, S1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">    for (int j = i + 1; j < e; ++j) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="uncoveredLine">      NodeSet &N2 = NodeSets[j];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">      if (N1.compareRecMII(N2) != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="uncoveredLine">      SmallSetVector<SUnit *, 8> S2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">      if (N2.empty() || !succ_L(N2, S2))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="uncoveredLine">      if (llvm::set_is_subset(S1, S2) && S1.size() == S2.size()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="uncoveredLine">        N1.setColocate(++Colocate);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="uncoveredLine">        N2.setColocate(Colocate);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">/// Check if the existing node-sets are profitable. If not, then ignore the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">/// recurrent node-sets, and attempt to schedule all nodes together. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">/// a heuristic. If the MII is large and all the recurrent node-sets are small,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">/// then it's best to try to schedule all instructions together instead of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">/// starting with the recurrent node-sets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::checkNodeSets(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">  // Look for loops with a large MII.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">  if (MII < 17)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">  // Check if the node-set contains only a simple add recurrence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">  for (auto &NS : NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="uncoveredLine">    if (NS.getRecMII() > 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">    if (NS.getMaxDepth() > MII)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="uncoveredLine">  NodeSets.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Clear recurrence node-sets\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="">/// Add the nodes that do not belong to a recurrence set into groups</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">/// based upon connected components.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::groupRemainingNodes(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">  SetVector<SUnit *> NodesAdded;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">  // Add the nodes that are on a path between the previous node sets and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">  // the current node set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="uncoveredLine">  for (NodeSet &I : NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">    SmallSetVector<SUnit *, 8> N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="">    // Add the nodes from the current node set to the previous node set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="uncoveredLine">    if (succ_L(I, N)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">      SetVector<SUnit *> Path;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">      for (SUnit *NI : N) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="uncoveredLine">        Visited.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">        computePath(NI, Path, NodesAdded, I, Visited);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="uncoveredLine">      if (!Path.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">        I.insert(Path.begin(), Path.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">    // Add the nodes from the previous node set to the current node set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="uncoveredLine">    N.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">    if (succ_L(NodesAdded, N)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">      SetVector<SUnit *> Path;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">      for (SUnit *NI : N) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">        Visited.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">        computePath(NI, Path, I, NodesAdded, Visited);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">      if (!Path.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">        I.insert(Path.begin(), Path.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">    NodesAdded.insert(I.begin(), I.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">  // Create a new node set with the connected nodes of any successor of a node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">  // in a recurrent set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">  NodeSet NewSet;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="uncoveredLine">  SmallSetVector<SUnit *, 8> N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">  if (succ_L(NodesAdded, N))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">    for (SUnit *I : N)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="uncoveredLine">      addConnectedNodes(I, NewSet, NodesAdded);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="uncoveredLine">  if (!NewSet.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">    NodeSets.push_back(NewSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">  // Create a new node set with the connected nodes of any predecessor of a node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">  // in a recurrent set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">  NewSet.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">  if (pred_L(NodesAdded, N))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="uncoveredLine">    for (SUnit *I : N)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="uncoveredLine">      addConnectedNodes(I, NewSet, NodesAdded);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">  if (!NewSet.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="uncoveredLine">    NodeSets.push_back(NewSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">  // Create new nodes sets with the connected nodes any remaining node that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="">  // has no predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">  for (SUnit &SU : SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">    if (NodesAdded.count(&SU) == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="uncoveredLine">      NewSet.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="uncoveredLine">      addConnectedNodes(&SU, NewSet, NodesAdded);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="uncoveredLine">      if (!NewSet.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="uncoveredLine">        NodeSets.push_back(NewSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="">/// Add the node to the set, and add all of its connected nodes to the set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::addConnectedNodes(SUnit *SU, NodeSet &NewSet,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">                                          SetVector<SUnit *> &NodesAdded) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">  NewSet.insert(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">  NodesAdded.insert(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">  for (auto &SI : SU->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">    SUnit *Successor = SI.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="uncoveredLine">    if (!SI.isArtificial() && !Successor->isBoundaryNode() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">        NodesAdded.count(Successor) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="uncoveredLine">      addConnectedNodes(Successor, NewSet, NodesAdded);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">  for (auto &PI : SU->Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">    SUnit *Predecessor = PI.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">    if (!PI.isArtificial() && NodesAdded.count(Predecessor) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">      addConnectedNodes(Predecessor, NewSet, NodesAdded);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">/// Return true if Set1 contains elements in Set2. The elements in common</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">/// are returned in a different container.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="uncoveredLine">static bool isIntersect(SmallSetVector<SUnit *, 8> &Set1, const NodeSet &Set2,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">                        SmallSetVector<SUnit *, 8> &Result) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">  Result.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="uncoveredLine">  for (SUnit *SU : Set1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="uncoveredLine">    if (Set2.count(SU) != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">      Result.insert(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="uncoveredLine">  return !Result.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="">/// Merge the recurrence node sets that have the same initial node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::fuseRecs(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="">       ++I) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="uncoveredLine">    NodeSet &NI = *I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="uncoveredLine">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">      NodeSet &NJ = *J;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">      if (NI.getNode(0)->NodeNum == NJ.getNode(0)->NodeNum) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="uncoveredLine">        if (NJ.compareRecMII(NI) > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="uncoveredLine">          NI.setRecMII(NJ.getRecMII());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="uncoveredLine">        for (SUnit *SU : *J)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">          I->insert(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="uncoveredLine">        NodeSets.erase(J);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="uncoveredLine">        E = NodeSets.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="uncoveredLine">        ++J;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">/// Remove nodes that have been scheduled in previous NodeSets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::removeDuplicateNodes(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">       ++I)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="uncoveredLine">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">      J->remove_if([&](SUnit *SUJ) { return I->count(SUJ); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">      if (J->empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">        NodeSets.erase(J);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="uncoveredLine">        E = NodeSets.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="uncoveredLine">        ++J;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">/// Compute an ordered list of the dependence graph nodes, which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">/// indicates the order that the nodes will be scheduled.  This is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">/// two-level algorithm. First, a partial order is created, which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">/// consists of a list of sets ordered from highest to lowest priority.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::computeNodeOrder(NodeSetType &NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="uncoveredLine">  SmallSetVector<SUnit *, 8> R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">  NodeOrder.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="uncoveredLine">  for (auto &Nodes : NodeSets) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "NodeSet size " << Nodes.size() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">    OrderKind Order;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">    SmallSetVector<SUnit *, 8> N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">    if (pred_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">      R.insert(N.begin(), N.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="uncoveredLine">      Order = BottomUp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Bottom up (preds) ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">    } else if (succ_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="uncoveredLine">      R.insert(N.begin(), N.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">      Order = TopDown;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Top down (succs) ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">    } else if (isIntersect(N, Nodes, R)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">      // If some of the successors are in the existing node-set, then use the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="">      // top-down ordering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">      Order = TopDown;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Top down (intersect) ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">    } else if (NodeSets.size() == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="uncoveredLine">      for (const auto &N : Nodes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="uncoveredLine">        if (N->Succs.size() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="uncoveredLine">          R.insert(N);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="uncoveredLine">      Order = BottomUp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Bottom up (all) ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">      // Find the node with the highest ASAP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="uncoveredLine">      SUnit *maxASAP = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="uncoveredLine">      for (SUnit *SU : Nodes) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="uncoveredLine">        if (maxASAP == nullptr || getASAP(SU) > getASAP(maxASAP) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">            (getASAP(SU) == getASAP(maxASAP) && SU->NodeNum > maxASAP->NodeNum))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="uncoveredLine">          maxASAP = SU;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="uncoveredLine">      R.insert(maxASAP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">      Order = BottomUp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Bottom up (default) ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="uncoveredLine">    while (!R.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">      if (Order == TopDown) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">        // Choose the node with the maximum height.  If more than one, choose</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">        // the node wiTH the maximum ZeroLatencyHeight. If still more than one,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">        // choose the node with the lowest MOV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="uncoveredLine">        while (!R.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="uncoveredLine">          SUnit *maxHeight = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">          for (SUnit *I : R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="uncoveredLine">            if (maxHeight == nullptr || getHeight(I) > getHeight(maxHeight))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="uncoveredLine">              maxHeight = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="uncoveredLine">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="uncoveredLine">                     getZeroLatencyHeight(I) > getZeroLatencyHeight(maxHeight))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">              maxHeight = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">                     getZeroLatencyHeight(I) ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">                         getZeroLatencyHeight(maxHeight) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="uncoveredLine">                     getMOV(I) < getMOV(maxHeight))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="uncoveredLine">              maxHeight = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">          NodeOrder.insert(maxHeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs() << maxHeight->NodeNum << " ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">          R.remove(maxHeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">          for (const auto &I : maxHeight->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="uncoveredLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">            if (ignoreDependence(I, false))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="uncoveredLine">            R.insert(I.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">          // Back-edges are predecessors with an anti-dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">          for (const auto &I : maxHeight->Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">            if (I.getKind() != SDep::Anti)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="uncoveredLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="uncoveredLine">            R.insert(I.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="uncoveredLine">        Order = BottomUp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "\n   Switching order to bottom up ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="uncoveredLine">        SmallSetVector<SUnit *, 8> N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="uncoveredLine">        if (pred_L(NodeOrder, N, &Nodes))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="uncoveredLine">          R.insert(N.begin(), N.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="uncoveredLine">      } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">        // Choose the node with the maximum depth.  If more than one, choose</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">        // the node with the maximum ZeroLatencyDepth. If still more than one,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">        // choose the node with the lowest MOV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">        while (!R.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="uncoveredLine">          SUnit *maxDepth = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="uncoveredLine">          for (SUnit *I : R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="uncoveredLine">            if (maxDepth == nullptr || getDepth(I) > getDepth(maxDepth))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="uncoveredLine">              maxDepth = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="uncoveredLine">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="uncoveredLine">                     getZeroLatencyDepth(I) > getZeroLatencyDepth(maxDepth))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">              maxDepth = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">                     getZeroLatencyDepth(I) == getZeroLatencyDepth(maxDepth) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">                     getMOV(I) < getMOV(maxDepth))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">              maxDepth = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">          NodeOrder.insert(maxDepth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs() << maxDepth->NodeNum << " ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">          R.remove(maxDepth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">          if (Nodes.isExceedSU(maxDepth)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="uncoveredLine">            Order = TopDown;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">            R.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">            R.insert(Nodes.getNode(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">            break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">          for (const auto &I : maxDepth->Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="uncoveredLine">            R.insert(I.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">          // Back-edges are predecessors with an anti-dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="uncoveredLine">          for (const auto &I : maxDepth->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">            if (I.getKind() != SDep::Anti)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="uncoveredLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">            R.insert(I.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="uncoveredLine">        Order = TopDown;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "\n   Switching order to top down ");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">        SmallSetVector<SUnit *, 8> N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="uncoveredLine">        if (succ_L(NodeOrder, N, &Nodes))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">          R.insert(N.begin(), N.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "\nDone with Nodeset\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="">    dbgs() << "Node order: ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">    for (SUnit *I : NodeOrder)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">      dbgs() << " " << I->NodeNum << " ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">    dbgs() << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">/// Process the nodes in the computed order and create the pipelined schedule</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">/// of the instructions, if possible. Return true if a schedule is found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">bool SwingSchedulerDAG::schedulePipeline(SMSchedule &Schedule) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="uncoveredLine">  if (NodeOrder.empty()){</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "NodeOrder is empty! abort scheduling\n" );</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="uncoveredLine">  bool scheduleFound = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">  // Keep increasing II until a valid schedule is found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">  for (unsigned II = MII; II <= MAX_II && !scheduleFound; ++II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">    Schedule.reset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="uncoveredLine">    Schedule.setInitiationInterval(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Try to schedule with " << II << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="uncoveredLine">    SetVector<SUnit *>::iterator NI = NodeOrder.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">    SetVector<SUnit *>::iterator NE = NodeOrder.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="uncoveredLine">      SUnit *SU = *NI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">      // Compute the schedule time for the instruction, which is based</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="">      // upon the scheduled time for any predecessors/successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="uncoveredLine">      int EarlyStart = INT_MIN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">      int LateStart = INT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">      // These values are set when the size of the schedule window is limited</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">      // due to chain dependences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">      int SchedEnd = INT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">      int SchedStart = INT_MIN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="uncoveredLine">      Schedule.computeStart(SU, &EarlyStart, &LateStart, &SchedEnd, &SchedStart,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="">                            II, this);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="uncoveredLine">      LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">        dbgs() << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">        dbgs() << "Inst (" << SU->NodeNum << ") ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">        SU->getInstr()->dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">        dbgs() << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="uncoveredLine">      LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">        dbgs() << format("\tes: %8x ls: %8x me: %8x ms: %8x\n", EarlyStart,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">                         LateStart, SchedEnd, SchedStart);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="uncoveredLine">      if (EarlyStart > LateStart || SchedEnd < EarlyStart ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="uncoveredLine">          SchedStart > LateStart)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="uncoveredLine">        scheduleFound = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="uncoveredLine">      else if (EarlyStart != INT_MIN && LateStart == INT_MAX) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="uncoveredLine">        SchedEnd = std::min(SchedEnd, EarlyStart + (int)II - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">        scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="uncoveredLine">      } else if (EarlyStart == INT_MIN && LateStart != INT_MAX) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="uncoveredLine">        SchedStart = std::max(SchedStart, LateStart - (int)II + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="uncoveredLine">        scheduleFound = Schedule.insert(SU, LateStart, SchedStart, II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">      } else if (EarlyStart != INT_MIN && LateStart != INT_MAX) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">        SchedEnd =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="uncoveredLine">            std::min(SchedEnd, std::min(LateStart, EarlyStart + (int)II - 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">        // When scheduling a Phi it is better to start at the late cycle and go</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">        // backwards. The default order may insert the Phi too far away from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="">        // its first dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">        if (SU->getInstr()->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">          scheduleFound = Schedule.insert(SU, SchedEnd, EarlyStart, II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="">        else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="uncoveredLine">          scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="uncoveredLine">        int FirstCycle = Schedule.getFirstCycle();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="uncoveredLine">        scheduleFound = Schedule.insert(SU, FirstCycle + getASAP(SU),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">                                        FirstCycle + getASAP(SU) + II - 1, II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">      // Even if we find a schedule, make sure the schedule doesn't exceed the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">      // allowable number of stages. We keep trying if this happens.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">      if (scheduleFound)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="uncoveredLine">        if (SwpMaxStages > -1 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">            Schedule.getMaxStageCount() > (unsigned)SwpMaxStages)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">          scheduleFound = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">      LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">        if (!scheduleFound)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">          dbgs() << "\tCan't schedule\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="uncoveredLine">    } while (++NI != NE && scheduleFound);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="">    // If a schedule is found, ensure non-pipelined instructions are in stage 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="uncoveredLine">    if (scheduleFound)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">      scheduleFound =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="uncoveredLine">          Schedule.normalizeNonPipelinedInstructions(this, LoopPipelinerInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">    // If a schedule is found, check if it is a valid schedule too.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="uncoveredLine">    if (scheduleFound)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">      scheduleFound = Schedule.isValidSchedule(this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Schedule Found? " << scheduleFound</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">                    << " (II=" << Schedule.getInitiationInterval()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">                    << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="uncoveredLine">  if (scheduleFound) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="uncoveredLine">    scheduleFound = LoopPipelinerInfo->shouldUseSchedule(*this, Schedule);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="uncoveredLine">    if (!scheduleFound)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Target rejected schedule\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="uncoveredLine">  if (scheduleFound) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">    Schedule.finalizeSchedule(this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">    Pass.ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">             << "Schedule found with Initiation Interval: "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">             << ore::NV("II", Schedule.getInitiationInterval())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">             << ", MaxStageCount: "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">             << ore::NV("MaxStageCount", Schedule.getMaxStageCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">  } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="uncoveredLine">    Schedule.reset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">  return scheduleFound && Schedule.getMaxStageCount() > 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="">/// Return true if we can compute the amount the instruction changes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">/// during each iteration. Set Delta to the amount of the change.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="uncoveredLine">bool SwingSchedulerDAG::computeDelta(MachineInstr &MI, unsigned &Delta) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="uncoveredLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="">  const MachineOperand *BaseOp;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">  int64_t Offset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">  bool OffsetIsScalable;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="uncoveredLine">  if (!TII->getMemOperandWithOffset(MI, BaseOp, Offset, OffsetIsScalable, TRI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">  // FIXME: This algorithm assumes instructions have fixed-size offsets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="uncoveredLine">  if (OffsetIsScalable)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="uncoveredLine">  if (!BaseOp->isReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">  Register BaseReg = BaseOp->getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">  // Check if there is a Phi. If so, get the definition in the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="uncoveredLine">  MachineInstr *BaseDef = MRI.getVRegDef(BaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">  if (BaseDef && BaseDef->isPHI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">    BaseReg = getLoopPhiReg(*BaseDef, MI.getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="uncoveredLine">    BaseDef = MRI.getVRegDef(BaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">  if (!BaseDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="uncoveredLine">  int D = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">  if (!TII->getIncrementValue(*BaseDef, D) && D >= 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="uncoveredLine">  Delta = D;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">/// Check if we can change the instruction to use an offset value from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">/// previous iteration. If so, return true and set the base and offset values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">/// so that we can rewrite the load, if necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="">///   v1 = Phi(v0, v3)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">///   v2 = load v1, 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">///   v3 = post_store v1, 4, x</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">/// This function enables the load to be rewritten as v2 = load v3, 4.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="uncoveredLine">bool SwingSchedulerDAG::canUseLastOffsetValue(MachineInstr *MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="">                                              unsigned &BasePos,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">                                              unsigned &OffsetPos,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">                                              unsigned &NewBase,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">                                              int64_t &Offset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">  // Get the load instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="uncoveredLine">  if (TII->isPostIncrement(*MI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">  unsigned BasePosLd, OffsetPosLd;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">  if (!TII->getBaseAndOffsetPosition(*MI, BasePosLd, OffsetPosLd))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="uncoveredLine">  Register BaseReg = MI->getOperand(BasePosLd).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">  // Look for the Phi instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="uncoveredLine">  MachineRegisterInfo &MRI = MI->getMF()->getRegInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="uncoveredLine">  MachineInstr *Phi = MRI.getVRegDef(BaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="uncoveredLine">  if (!Phi || !Phi->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">  // Get the register defined in the loop block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="uncoveredLine">  unsigned PrevReg = getLoopPhiReg(*Phi, MI->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="uncoveredLine">  if (!PrevReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">  // Check for the post-increment load/store instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="uncoveredLine">  MachineInstr *PrevDef = MRI.getVRegDef(PrevReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="uncoveredLine">  if (!PrevDef || PrevDef == MI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="uncoveredLine">  if (!TII->isPostIncrement(*PrevDef))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">  unsigned BasePos1 = 0, OffsetPos1 = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="uncoveredLine">  if (!TII->getBaseAndOffsetPosition(*PrevDef, BasePos1, OffsetPos1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="">  // Make sure that the instructions do not access the same memory location in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">  // the next iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="uncoveredLine">  int64_t LoadOffset = MI->getOperand(OffsetPosLd).getImm();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="uncoveredLine">  int64_t StoreOffset = PrevDef->getOperand(OffsetPos1).getImm();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="uncoveredLine">  MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="uncoveredLine">  NewMI->getOperand(OffsetPosLd).setImm(LoadOffset + StoreOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="uncoveredLine">  bool Disjoint = TII->areMemAccessesTriviallyDisjoint(*NewMI, *PrevDef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="uncoveredLine">  MF.deleteMachineInstr(NewMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="uncoveredLine">  if (!Disjoint)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">  // Set the return value once we determine that we return true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="uncoveredLine">  BasePos = BasePosLd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="uncoveredLine">  OffsetPos = OffsetPosLd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="uncoveredLine">  NewBase = PrevReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">  Offset = StoreOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">/// Apply changes to the instruction if needed. The changes are need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">/// to improve the scheduling and depend up on the final schedule.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::applyInstrChange(MachineInstr *MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">                                         SMSchedule &Schedule) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">  SUnit *SU = getSUnit(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="">  DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">      InstrChanges.find(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">  if (It != InstrChanges.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="uncoveredLine">    std::pair<unsigned, int64_t> RegAndOffset = It->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">    unsigned BasePos, OffsetPos;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="uncoveredLine">    if (!TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">    Register BaseReg = MI->getOperand(BasePos).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="uncoveredLine">    MachineInstr *LoopDef = findDefInLoop(BaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="uncoveredLine">    int DefStageNum = Schedule.stageScheduled(getSUnit(LoopDef));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">    int DefCycleNum = Schedule.cycleScheduled(getSUnit(LoopDef));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="uncoveredLine">    int BaseStageNum = Schedule.stageScheduled(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="uncoveredLine">    int BaseCycleNum = Schedule.cycleScheduled(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">    if (BaseStageNum < DefStageNum) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">      MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">      int OffsetDiff = DefStageNum - BaseStageNum;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="uncoveredLine">      if (DefCycleNum < BaseCycleNum) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="uncoveredLine">        NewMI->getOperand(BasePos).setReg(RegAndOffset.first);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">        if (OffsetDiff > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">          --OffsetDiff;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="">      int64_t NewOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="uncoveredLine">          MI->getOperand(OffsetPos).getImm() + RegAndOffset.second * OffsetDiff;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">      NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">      SU->setInstr(NewMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">      MISUnitMap[NewMI] = SU;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="uncoveredLine">      NewMIs[MI] = NewMI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="">/// Return the instruction in the loop that defines the register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">/// If the definition is a Phi, then follow the Phi operand to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">/// the instruction in the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">MachineInstr *SwingSchedulerDAG::findDefInLoop(Register Reg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="uncoveredLine">  SmallPtrSet<MachineInstr *, 8> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">  MachineInstr *Def = MRI.getVRegDef(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="uncoveredLine">  while (Def->isPHI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="uncoveredLine">    if (!Visited.insert(Def).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="uncoveredLine">    for (unsigned i = 1, e = Def->getNumOperands(); i < e; i += 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="uncoveredLine">      if (Def->getOperand(i + 1).getMBB() == BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="uncoveredLine">        Def = MRI.getVRegDef(Def->getOperand(i).getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="uncoveredLine">  return Def;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">/// Return true for an order or output dependence that is loop carried</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="">/// potentially. A dependence is loop carried if the destination defines a valu</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="">/// that may be used or defined by the source in a subsequent iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">bool SwingSchedulerDAG::isLoopCarriedDep(SUnit *Source, const SDep &Dep,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="">                                         bool isSucc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="uncoveredLine">  if ((Dep.getKind() != SDep::Order && Dep.getKind() != SDep::Output) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="uncoveredLine">      Dep.isArtificial() || Dep.getSUnit()->isBoundaryNode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">  if (!SwpPruneLoopCarried)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="uncoveredLine">  if (Dep.getKind() == SDep::Output)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="uncoveredLine">  MachineInstr *SI = Source->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="uncoveredLine">  MachineInstr *DI = Dep.getSUnit()->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="uncoveredLine">  if (!isSucc)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="uncoveredLine">    std::swap(SI, DI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">  assert(SI != nullptr && DI != nullptr && "Expecting SUnit with an MI.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="">  // Assume ordered loads and stores may have a loop carried dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="uncoveredLine">  if (SI->hasUnmodeledSideEffects() || DI->hasUnmodeledSideEffects() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="uncoveredLine">      SI->mayRaiseFPException() || DI->mayRaiseFPException() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="uncoveredLine">      SI->hasOrderedMemoryRef() || DI->hasOrderedMemoryRef())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">  // Only chain dependences between a load and store can be loop carried.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="uncoveredLine">  if (!DI->mayStore() || !SI->mayLoad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="">  unsigned DeltaS, DeltaD;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="uncoveredLine">  if (!computeDelta(*SI, DeltaS) || !computeDelta(*DI, DeltaD))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">  const MachineOperand *BaseOpS, *BaseOpD;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="">  int64_t OffsetS, OffsetD;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">  bool OffsetSIsScalable, OffsetDIsScalable;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="uncoveredLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="uncoveredLine">  if (!TII->getMemOperandWithOffset(*SI, BaseOpS, OffsetS, OffsetSIsScalable,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="uncoveredLine">                                    TRI) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">      !TII->getMemOperandWithOffset(*DI, BaseOpD, OffsetD, OffsetDIsScalable,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="">                                    TRI))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="uncoveredLine">  assert(!OffsetSIsScalable && !OffsetDIsScalable &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">         "Expected offsets to be byte offsets");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="uncoveredLine">  MachineInstr *DefS = MRI.getVRegDef(BaseOpS->getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="uncoveredLine">  MachineInstr *DefD = MRI.getVRegDef(BaseOpD->getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="uncoveredLine">  if (!DefS || !DefD || !DefS->isPHI() || !DefD->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="uncoveredLine">  unsigned InitValS = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="uncoveredLine">  unsigned LoopValS = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">  unsigned InitValD = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="uncoveredLine">  unsigned LoopValD = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="uncoveredLine">  getPhiRegs(*DefS, BB, InitValS, LoopValS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">  getPhiRegs(*DefD, BB, InitValD, LoopValD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="uncoveredLine">  MachineInstr *InitDefS = MRI.getVRegDef(InitValS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="uncoveredLine">  MachineInstr *InitDefD = MRI.getVRegDef(InitValD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="uncoveredLine">  if (!InitDefS->isIdenticalTo(*InitDefD))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">  // Check that the base register is incremented by a constant value for each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="">  // iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="uncoveredLine">  MachineInstr *LoopDefS = MRI.getVRegDef(LoopValS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="uncoveredLine">  int D = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="uncoveredLine">  if (!LoopDefS || !TII->getIncrementValue(*LoopDefS, D))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="uncoveredLine">  uint64_t AccessSizeS = (*SI->memoperands_begin())->getSize();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">  uint64_t AccessSizeD = (*DI->memoperands_begin())->getSize();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">  // This is the main test, which checks the offset values and the loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="">  // increment value to determine if the accesses may be loop carried.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="uncoveredLine">  if (AccessSizeS == MemoryLocation::UnknownSize ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">      AccessSizeD == MemoryLocation::UnknownSize)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="uncoveredLine">  if (DeltaS != DeltaD || DeltaS < AccessSizeS || DeltaD < AccessSizeD)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="uncoveredLine">  return (OffsetS + (int64_t)AccessSizeS < OffsetD + (int64_t)AccessSizeD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::postProcessDAG() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="uncoveredLine">  for (auto &M : Mutations)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="uncoveredLine">    M->apply(this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="">/// Try to schedule the node at the specified StartCycle and continue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="">/// until the node is schedule or the EndCycle is reached.  This function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="">/// returns true if the node is scheduled.  This routine may search either</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="">/// forward or backward for a place to insert the instruction based upon</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="">/// the relative values of StartCycle and EndCycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="uncoveredLine">bool SMSchedule::insert(SUnit *SU, int StartCycle, int EndCycle, int II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="uncoveredLine">  bool forward = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">    dbgs() << "Trying to insert node between " << StartCycle << " and "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="">           << EndCycle << " II: " << II << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="uncoveredLine">  if (StartCycle > EndCycle)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="uncoveredLine">    forward = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">  // The terminating condition depends on the direction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="uncoveredLine">  int termCycle = forward ? EndCycle + 1 : EndCycle - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="uncoveredLine">  for (int curCycle = StartCycle; curCycle != termCycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="uncoveredLine">       forward ? ++curCycle : --curCycle) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="uncoveredLine">    if (ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="uncoveredLine">        ProcItinResources.canReserveResources(*SU, curCycle)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="uncoveredLine">      LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">        dbgs() << "\tinsert at cycle " << curCycle << " ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="">        SU->getInstr()->dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">      if (!ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="uncoveredLine">        ProcItinResources.reserveResources(*SU, curCycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="uncoveredLine">      ScheduledInstrs[curCycle].push_back(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="uncoveredLine">      InstrToCycle.insert(std::make_pair(SU, curCycle));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="uncoveredLine">      if (curCycle > LastCycle)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="uncoveredLine">        LastCycle = curCycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="uncoveredLine">      if (curCycle < FirstCycle)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="uncoveredLine">        FirstCycle = curCycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="uncoveredLine">    LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">      dbgs() << "\tfailed to insert at cycle " << curCycle << " ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="">      SU->getInstr()->dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">// Return the cycle of the earliest scheduled instruction in the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="uncoveredLine">int SMSchedule::earliestCycleInChain(const SDep &Dep) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="uncoveredLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="uncoveredLine">  SmallVector<SDep, 8> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="uncoveredLine">  Worklist.push_back(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">  int EarlyCycle = INT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="uncoveredLine">    const SDep &Cur = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">    SUnit *PrevSU = Cur.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="uncoveredLine">    if (Visited.count(PrevSU))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="uncoveredLine">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(PrevSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">    if (it == InstrToCycle.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">    EarlyCycle = std::min(EarlyCycle, it->second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="uncoveredLine">    for (const auto &PI : PrevSU->Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="uncoveredLine">      if (PI.getKind() == SDep::Order || PI.getKind() == SDep::Output)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">        Worklist.push_back(PI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="uncoveredLine">    Visited.insert(PrevSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">  return EarlyCycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">// Return the cycle of the latest scheduled instruction in the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="uncoveredLine">int SMSchedule::latestCycleInChain(const SDep &Dep) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="uncoveredLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="uncoveredLine">  SmallVector<SDep, 8> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="uncoveredLine">  Worklist.push_back(Dep);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="uncoveredLine">  int LateCycle = INT_MIN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">    const SDep &Cur = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">    SUnit *SuccSU = Cur.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">    if (Visited.count(SuccSU) || SuccSU->isBoundaryNode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="uncoveredLine">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(SuccSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="uncoveredLine">    if (it == InstrToCycle.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="uncoveredLine">    LateCycle = std::max(LateCycle, it->second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="uncoveredLine">    for (const auto &SI : SuccSU->Succs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="uncoveredLine">      if (SI.getKind() == SDep::Order || SI.getKind() == SDep::Output)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="uncoveredLine">        Worklist.push_back(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="uncoveredLine">    Visited.insert(SuccSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="uncoveredLine">  return LateCycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="">/// If an instruction has a use that spans multiple iterations, then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="">/// return true. These instructions are characterized by having a back-ege</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="">/// to a Phi, which contains a reference to another Phi.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">static SUnit *multipleIterations(SUnit *SU, SwingSchedulerDAG *DAG) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="uncoveredLine">  for (auto &P : SU->Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="uncoveredLine">    if (DAG->isBackedge(SU, P) && P.getSUnit()->getInstr()->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="uncoveredLine">      for (auto &S : P.getSUnit()->Succs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="uncoveredLine">        if (S.getKind() == SDep::Data && S.getSUnit()->getInstr()->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="uncoveredLine">          return P.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="">/// Compute the scheduling start slot for the instruction.  The start slot</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="">/// depends on any predecessor or successor nodes scheduled already.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">void SMSchedule::computeStart(SUnit *SU, int *MaxEarlyStart, int *MinLateStart,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">                              int *MinEnd, int *MaxStart, int II,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="">                              SwingSchedulerDAG *DAG) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">  // Iterate over each instruction that has been scheduled already.  The start</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="">  // slot computation depends on whether the previously scheduled instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="">  // is a predecessor or successor of the specified instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="uncoveredLine">  for (int cycle = getFirstCycle(); cycle <= LastCycle; ++cycle) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="">    // Iterate over each instruction in the current cycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="uncoveredLine">    for (SUnit *I : getInstructions(cycle)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="">      // Because we're processing a DAG for the dependences, we recognize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="">      // the back-edge in recurrences by anti dependences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="uncoveredLine">      for (unsigned i = 0, e = (unsigned)SU->Preds.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="uncoveredLine">        const SDep &Dep = SU->Preds[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="uncoveredLine">        if (Dep.getSUnit() == I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="uncoveredLine">          if (!DAG->isBackedge(SU, Dep)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="uncoveredLine">            int EarlyStart = cycle + Dep.getLatency() -</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="uncoveredLine">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="uncoveredLine">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="uncoveredLine">            if (DAG->isLoopCarriedDep(SU, Dep, false)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="uncoveredLine">              int End = earliestCycleInChain(Dep) + (II - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="uncoveredLine">              *MinEnd = std::min(*MinEnd, End);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="">          } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="uncoveredLine">            int LateStart = cycle - Dep.getLatency() +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="uncoveredLine">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="uncoveredLine">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="">        // For instruction that requires multiple iterations, make sure that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="">        // the dependent instruction is not scheduled past the definition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="uncoveredLine">        SUnit *BE = multipleIterations(I, DAG);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="uncoveredLine">        if (BE && Dep.getSUnit() == BE && !SU->getInstr()->isPHI() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="uncoveredLine">            !SU->isPred(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="uncoveredLine">          *MinLateStart = std::min(*MinLateStart, cycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="uncoveredLine">      for (unsigned i = 0, e = (unsigned)SU->Succs.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="uncoveredLine">        if (SU->Succs[i].getSUnit() == I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="uncoveredLine">          const SDep &Dep = SU->Succs[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="uncoveredLine">          if (!DAG->isBackedge(SU, Dep)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="uncoveredLine">            int LateStart = cycle - Dep.getLatency() +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="uncoveredLine">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="uncoveredLine">            if (DAG->isLoopCarriedDep(SU, Dep)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="uncoveredLine">              int Start = latestCycleInChain(Dep) + 1 - II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="uncoveredLine">              *MaxStart = std::max(*MaxStart, Start);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="">          } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="uncoveredLine">            int EarlyStart = cycle + Dep.getLatency() -</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="uncoveredLine">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="uncoveredLine">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="">/// Order the instructions within a cycle so that the definitions occur</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="">/// before the uses. Returns true if the instruction is added to the start</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="">/// of the list, or false if added to the end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="uncoveredLine">void SMSchedule::orderDependence(SwingSchedulerDAG *SSD, SUnit *SU,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="">                                 std::deque<SUnit *> &Insts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="uncoveredLine">  MachineInstr *MI = SU->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="uncoveredLine">  bool OrderBeforeUse = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="uncoveredLine">  bool OrderAfterDef = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="uncoveredLine">  bool OrderBeforeDef = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="uncoveredLine">  unsigned MoveDef = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="uncoveredLine">  unsigned MoveUse = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="uncoveredLine">  int StageInst1 = stageScheduled(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="uncoveredLine">  unsigned Pos = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="uncoveredLine">  for (std::deque<SUnit *>::iterator I = Insts.begin(), E = Insts.end(); I != E;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="uncoveredLine">       ++I, ++Pos) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="uncoveredLine">    for (MachineOperand &MO : MI->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="uncoveredLine">      if (!MO.isReg() || !MO.getReg().isVirtual())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="uncoveredLine">      Register Reg = MO.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="">      unsigned BasePos, OffsetPos;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="uncoveredLine">      if (ST.getInstrInfo()->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="uncoveredLine">        if (MI->getOperand(BasePos).getReg() == Reg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="uncoveredLine">          if (unsigned NewReg = SSD->getInstrBaseReg(SU))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="uncoveredLine">            Reg = NewReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="">      bool Reads, Writes;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="uncoveredLine">      std::tie(Reads, Writes) =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="uncoveredLine">          (*I)->getInstr()->readsWritesVirtualRegister(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="uncoveredLine">      if (MO.isDef() && Reads && stageScheduled(*I) <= StageInst1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="uncoveredLine">        OrderBeforeUse = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="uncoveredLine">        if (MoveUse == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="uncoveredLine">          MoveUse = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="uncoveredLine">      } else if (MO.isDef() && Reads && stageScheduled(*I) > StageInst1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="">        // Add the instruction after the scheduled instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="uncoveredLine">        OrderAfterDef = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="uncoveredLine">        MoveDef = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="uncoveredLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) == StageInst1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="uncoveredLine">        if (cycleScheduled(*I) == cycleScheduled(SU) && !(*I)->isSucc(SU)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="uncoveredLine">          OrderBeforeUse = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="uncoveredLine">          if (MoveUse == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="uncoveredLine">            MoveUse = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="uncoveredLine">          OrderAfterDef = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="uncoveredLine">          MoveDef = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="uncoveredLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) > StageInst1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">        OrderBeforeUse = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">        if (MoveUse == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="uncoveredLine">          MoveUse = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="uncoveredLine">        if (MoveUse != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="uncoveredLine">          OrderAfterDef = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="uncoveredLine">          MoveDef = Pos - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="uncoveredLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) < StageInst1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="">        // Add the instruction before the scheduled instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="uncoveredLine">        OrderBeforeUse = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="uncoveredLine">        if (MoveUse == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="uncoveredLine">          MoveUse = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="uncoveredLine">      } else if (MO.isUse() && stageScheduled(*I) == StageInst1 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="uncoveredLine">                 isLoopCarriedDefOfUse(SSD, (*I)->getInstr(), MO)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="uncoveredLine">        if (MoveUse == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="uncoveredLine">          OrderBeforeDef = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="uncoveredLine">          MoveUse = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="">    // Check for order dependences between instructions. Make sure the source</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="">    // is ordered before the destination.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="uncoveredLine">    for (auto &S : SU->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="uncoveredLine">      if (S.getSUnit() != *I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="uncoveredLine">      if (S.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="uncoveredLine">        OrderBeforeUse = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="uncoveredLine">        if (Pos < MoveUse)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="uncoveredLine">          MoveUse = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="">      // We did not handle HW dependences in previous for loop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="">      // and we normally set Latency = 0 for Anti deps,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="">      // so may have nodes in same cycle with Anti denpendent on HW regs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="uncoveredLine">      else if (S.getKind() == SDep::Anti && stageScheduled(*I) == StageInst1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="uncoveredLine">        OrderBeforeUse = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="uncoveredLine">        if ((MoveUse == 0) || (Pos < MoveUse))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">          MoveUse = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="uncoveredLine">    for (auto &P : SU->Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="uncoveredLine">      if (P.getSUnit() != *I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="uncoveredLine">      if (P.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="uncoveredLine">        OrderAfterDef = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="uncoveredLine">        MoveDef = Pos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="">  // A circular dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="uncoveredLine">  if (OrderAfterDef && OrderBeforeUse && MoveUse == MoveDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="uncoveredLine">    OrderBeforeUse = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="">  // OrderAfterDef takes precedences over OrderBeforeDef. The latter is due</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="">  // to a loop-carried dependence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="uncoveredLine">  if (OrderBeforeDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="uncoveredLine">    OrderBeforeUse = !OrderAfterDef || (MoveUse > MoveDef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="">  // The uncommon case when the instruction order needs to be updated because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="">  // there is both a use and def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="uncoveredLine">  if (OrderBeforeUse && OrderAfterDef) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="uncoveredLine">    SUnit *UseSU = Insts.at(MoveUse);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="uncoveredLine">    SUnit *DefSU = Insts.at(MoveDef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="uncoveredLine">    if (MoveUse > MoveDef) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="uncoveredLine">      Insts.erase(Insts.begin() + MoveUse);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="uncoveredLine">      Insts.erase(Insts.begin() + MoveDef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="uncoveredLine">      Insts.erase(Insts.begin() + MoveDef);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="uncoveredLine">      Insts.erase(Insts.begin() + MoveUse);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="uncoveredLine">    orderDependence(SSD, UseSU, Insts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="uncoveredLine">    orderDependence(SSD, SU, Insts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="uncoveredLine">    orderDependence(SSD, DefSU, Insts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="">  // Put the new instruction first if there is a use in the list. Otherwise,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="">  // put it at the end of the list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="uncoveredLine">  if (OrderBeforeUse)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="uncoveredLine">    Insts.push_front(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="uncoveredLine">    Insts.push_back(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="">/// Return true if the scheduled Phi has a loop carried operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="uncoveredLine">bool SMSchedule::isLoopCarried(SwingSchedulerDAG *SSD, MachineInstr &Phi) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="uncoveredLine">  if (!Phi.isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="uncoveredLine">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="uncoveredLine">  SUnit *DefSU = SSD->getSUnit(&Phi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="uncoveredLine">  unsigned DefCycle = cycleScheduled(DefSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="uncoveredLine">  int DefStage = stageScheduled(DefSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="uncoveredLine">  unsigned InitVal = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="uncoveredLine">  unsigned LoopVal = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="uncoveredLine">  getPhiRegs(Phi, Phi.getParent(), InitVal, LoopVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="uncoveredLine">  SUnit *UseSU = SSD->getSUnit(MRI.getVRegDef(LoopVal));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="uncoveredLine">  if (!UseSU)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="uncoveredLine">  if (UseSU->getInstr()->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="uncoveredLine">  unsigned LoopCycle = cycleScheduled(UseSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="uncoveredLine">  int LoopStage = stageScheduled(UseSU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="uncoveredLine">  return (LoopCycle > DefCycle) || (LoopStage <= DefStage);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="">/// Return true if the instruction is a definition that is loop carried</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="">/// and defines the use on the next iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="">///        v1 = phi(v2, v3)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="">///  (Def) v3 = op v1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="">///  (MO)   = v1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="">/// If MO appears before Def, then then v1 and v3 may get assigned to the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="">/// register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="uncoveredLine">bool SMSchedule::isLoopCarriedDefOfUse(SwingSchedulerDAG *SSD,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="">                                       MachineInstr *Def, MachineOperand &MO) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="uncoveredLine">  if (!MO.isReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="uncoveredLine">  if (Def->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="uncoveredLine">  MachineInstr *Phi = MRI.getVRegDef(MO.getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="uncoveredLine">  if (!Phi || !Phi->isPHI() || Phi->getParent() != Def->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="uncoveredLine">  if (!isLoopCarried(SSD, *Phi))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="uncoveredLine">  unsigned LoopReg = getLoopPhiReg(*Phi, Phi->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="uncoveredLine">  for (MachineOperand &DMO : Def->all_defs()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="uncoveredLine">    if (DMO.getReg() == LoopReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="">/// Determine transitive dependences of unpipelineable instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="uncoveredLine">SmallSet<SUnit *, 8> SMSchedule::computeUnpipelineableNodes(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="uncoveredLine">  SmallSet<SUnit *, 8> DoNotPipeline;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="uncoveredLine">  SmallVector<SUnit *, 8> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="uncoveredLine">  for (auto &SU : SSD->SUnits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="uncoveredLine">    if (SU.isInstr() && PLI->shouldIgnoreForPipelining(SU.getInstr()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="uncoveredLine">      Worklist.push_back(&SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="uncoveredLine">    auto SU = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="uncoveredLine">    if (DoNotPipeline.count(SU))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Do not pipeline SU(" << SU->NodeNum << ")\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="uncoveredLine">    DoNotPipeline.insert(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="uncoveredLine">    for (auto &Dep : SU->Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="uncoveredLine">      Worklist.push_back(Dep.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="uncoveredLine">    if (SU->getInstr()->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="uncoveredLine">      for (auto &Dep : SU->Succs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="uncoveredLine">        if (Dep.getKind() == SDep::Anti)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="uncoveredLine">          Worklist.push_back(Dep.getSUnit());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="uncoveredLine">  return DoNotPipeline;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="">// Determine all instructions upon which any unpipelineable instruction depends</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="">// and ensure that they are in stage 0.  If unable to do so, return false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="uncoveredLine">bool SMSchedule::normalizeNonPipelinedInstructions(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="uncoveredLine">  SmallSet<SUnit *, 8> DNP = computeUnpipelineableNodes(SSD, PLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="uncoveredLine">  int NewLastCycle = INT_MIN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="uncoveredLine">  for (SUnit &SU : SSD->SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="uncoveredLine">    if (!SU.isInstr())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="uncoveredLine">    if (!DNP.contains(&SU) || stageScheduled(&SU) == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="uncoveredLine">      NewLastCycle = std::max(NewLastCycle, InstrToCycle[&SU]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="">    // Put the non-pipelined instruction as early as possible in the schedule</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="uncoveredLine">    int NewCycle = getFirstCycle();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="uncoveredLine">    for (auto &Dep : SU.Preds)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="uncoveredLine">      NewCycle = std::max(InstrToCycle[Dep.getSUnit()], NewCycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="uncoveredLine">    int OldCycle = InstrToCycle[&SU];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="uncoveredLine">    if (OldCycle != NewCycle) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="uncoveredLine">      InstrToCycle[&SU] = NewCycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="uncoveredLine">      auto &OldS = getInstructions(OldCycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="uncoveredLine">      llvm::erase_value(OldS, &SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="uncoveredLine">      getInstructions(NewCycle).emplace_back(&SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "SU(" << SU.NodeNum</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="">                        << ") is not pipelined; moving from cycle " << OldCycle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="">                        << " to " << NewCycle << " Instr:" << *SU.getInstr());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="uncoveredLine">    NewLastCycle = std::max(NewLastCycle, NewCycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="uncoveredLine">  LastCycle = NewLastCycle;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="">// Check if the generated schedule is valid. This function checks if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="">// an instruction that uses a physical register is scheduled in a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="">// different stage than the definition. The pipeliner does not handle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="">// physical register values that may cross a basic block boundary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="">// Furthermore, if a physical def/use pair is assigned to the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="">// cycle, orderDependence does not guarantee def/use ordering, so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="">// case should be considered invalid.  (The test checks for both</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="">// earlier and same-cycle use to be more robust.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="uncoveredLine">bool SMSchedule::isValidSchedule(SwingSchedulerDAG *SSD) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="uncoveredLine">  for (SUnit &SU : SSD->SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="uncoveredLine">    if (!SU.hasPhysRegDefs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="uncoveredLine">    int StageDef = stageScheduled(&SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="uncoveredLine">    int CycleDef = InstrToCycle[&SU];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="uncoveredLine">    assert(StageDef != -1 && "Instruction should have been scheduled.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="uncoveredLine">    for (auto &SI : SU.Succs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="uncoveredLine">      if (SI.isAssignedRegDep() && !SI.getSUnit()->isBoundaryNode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="uncoveredLine">        if (Register::isPhysicalRegister(SI.getReg())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="uncoveredLine">          if (stageScheduled(SI.getSUnit()) != StageDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="uncoveredLine">            return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="uncoveredLine">          if (InstrToCycle[SI.getSUnit()] <= CycleDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="uncoveredLine">            return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="">/// A property of the node order in swing-modulo-scheduling is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="">/// that for nodes outside circuits the following holds:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="">/// none of them is scheduled after both a successor and a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="">/// predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="">/// The method below checks whether the property is met.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="">/// If not, debug information is printed and statistics information updated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="">/// Note that we do not use an assert statement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="">/// The reason is that although an invalid node oder may prevent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="">/// the pipeliner from finding a pipelined schedule for arbitrary II,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="">/// it does not lead to the generation of incorrect code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::checkValidNodeOrder(const NodeSetType &Circuits) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="">  // a sorted vector that maps each SUnit to its index in the NodeOrder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="">  typedef std::pair<SUnit *, unsigned> UnitIndex;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="uncoveredLine">  std::vector<UnitIndex> Indices(NodeOrder.size(), std::make_pair(nullptr, 0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="uncoveredLine">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="uncoveredLine">    Indices.push_back(std::make_pair(NodeOrder[i], i));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="uncoveredLine">  auto CompareKey = [](UnitIndex i1, UnitIndex i2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="uncoveredLine">    return std::get<0>(i1) < std::get<0>(i2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="">  // sort, so that we can perform a binary search</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="uncoveredLine">  llvm::sort(Indices, CompareKey);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="uncoveredLine">  bool Valid = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="">  (void)Valid;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="">  // for each SUnit in the NodeOrder, check whether</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="">  // it appears after both a successor and a predecessor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="">  // of the SUnit. If this is the case, and the SUnit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="">  // is not part of circuit, then the NodeOrder is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="">  // valid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="uncoveredLine">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="uncoveredLine">    SUnit *SU = NodeOrder[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="uncoveredLine">    unsigned Index = i;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="uncoveredLine">    bool PredBefore = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="uncoveredLine">    bool SuccBefore = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="">    SUnit *Succ;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="">    SUnit *Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="">    (void)Succ;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="">    (void)Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="uncoveredLine">    for (SDep &PredEdge : SU->Preds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="uncoveredLine">      SUnit *PredSU = PredEdge.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="uncoveredLine">      unsigned PredIndex = std::get<1>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="uncoveredLine">          *llvm::lower_bound(Indices, std::make_pair(PredSU, 0), CompareKey));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="uncoveredLine">      if (!PredSU->getInstr()->isPHI() && PredIndex < Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="uncoveredLine">        PredBefore = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="uncoveredLine">        Pred = PredSU;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="uncoveredLine">    for (SDep &SuccEdge : SU->Succs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="uncoveredLine">      SUnit *SuccSU = SuccEdge.getSUnit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="">      // Do not process a boundary node, it was not included in NodeOrder,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="">      // hence not in Indices either, call to std::lower_bound() below will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="">      // return Indices.end().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="uncoveredLine">      if (SuccSU->isBoundaryNode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="uncoveredLine">      unsigned SuccIndex = std::get<1>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="uncoveredLine">          *llvm::lower_bound(Indices, std::make_pair(SuccSU, 0), CompareKey));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="uncoveredLine">      if (!SuccSU->getInstr()->isPHI() && SuccIndex < Index) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="uncoveredLine">        SuccBefore = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="uncoveredLine">        Succ = SuccSU;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="uncoveredLine">    if (PredBefore && SuccBefore && !SU->getInstr()->isPHI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="">      // instructions in circuits are allowed to be scheduled</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="">      // after both a successor and predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="uncoveredLine">      bool InCircuit = llvm::any_of(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="uncoveredLine">          Circuits, [SU](const NodeSet &Circuit) { return Circuit.count(SU); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="uncoveredLine">      if (InCircuit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "In a circuit, predecessor ";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="">      else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="uncoveredLine">        Valid = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="uncoveredLine">        NumNodeOrderIssues++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "Predecessor ";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << Pred->NodeNum << " and successor " << Succ->NodeNum</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="">                        << " are scheduled before node " << SU->NodeNum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="">                        << "\n";);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="">    if (!Valid)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="">      dbgs() << "Invalid node order found!\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="">/// Attempt to fix the degenerate cases when the instruction serialization</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="">/// causes the register lifetimes to overlap. For example,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="">///   p' = store_pi(p, b)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="">///      = load p, offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="">/// In this case p and p' overlap, which means that two registers are needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="">/// Instead, this function changes the load to use p' and updates the offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="uncoveredLine">void SwingSchedulerDAG::fixupRegisterOverlaps(std::deque<SUnit *> &Instrs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="uncoveredLine">  unsigned OverlapReg = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="uncoveredLine">  unsigned NewBaseReg = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="uncoveredLine">  for (SUnit *SU : Instrs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="uncoveredLine">    MachineInstr *MI = SU->getInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="uncoveredLine">    for (unsigned i = 0, e = MI->getNumOperands(); i < e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="uncoveredLine">      const MachineOperand &MO = MI->getOperand(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="">      // Look for an instruction that uses p. The instruction occurs in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="">      // same cycle but occurs later in the serialized order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="uncoveredLine">      if (MO.isReg() && MO.isUse() && MO.getReg() == OverlapReg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="">        // Check that the instruction appears in the InstrChanges structure,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="">        // which contains instructions that can have the offset updated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="">        DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="uncoveredLine">          InstrChanges.find(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="uncoveredLine">        if (It != InstrChanges.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="">          unsigned BasePos, OffsetPos;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="">          // Update the base register and adjust the offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="uncoveredLine">          if (TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="uncoveredLine">            MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="uncoveredLine">            NewMI->getOperand(BasePos).setReg(NewBaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="">            int64_t NewOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="uncoveredLine">                MI->getOperand(OffsetPos).getImm() - It->second.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="uncoveredLine">            NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="uncoveredLine">            SU->setInstr(NewMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="uncoveredLine">            MISUnitMap[NewMI] = SU;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="uncoveredLine">            NewMIs[MI] = NewMI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="uncoveredLine">        OverlapReg = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="uncoveredLine">        NewBaseReg = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="">      // Look for an instruction of the form p' = op(p), which uses and defines</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="">      // two virtual registers that get allocated to the same physical register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="uncoveredLine">      unsigned TiedUseIdx = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="uncoveredLine">      if (MI->isRegTiedToUseOperand(i, &TiedUseIdx)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="">        // OverlapReg is p in the example above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="uncoveredLine">        OverlapReg = MI->getOperand(TiedUseIdx).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="">        // NewBaseReg is p' in the example above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="uncoveredLine">        NewBaseReg = MI->getOperand(i).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="">/// After the schedule has been formed, call this function to combine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="">/// the instructions from the different stages/cycles.  That is, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="">/// function creates a schedule that represents a single iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="uncoveredLine">void SMSchedule::finalizeSchedule(SwingSchedulerDAG *SSD) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="">  // Move all instructions to the first stage from later stages.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="uncoveredLine">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="uncoveredLine">    for (int stage = 1, lastStage = getMaxStageCount(); stage <= lastStage;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="">         ++stage) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="">      std::deque<SUnit *> &cycleInstrs =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="uncoveredLine">          ScheduledInstrs[cycle + (stage * InitiationInterval)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="uncoveredLine">      for (SUnit *SU : llvm::reverse(cycleInstrs))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="uncoveredLine">        ScheduledInstrs[cycle].push_front(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="">  // Erase all the elements in the later stages. Only one iteration should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="">  // remain in the scheduled list, and it contains all the instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="uncoveredLine">  for (int cycle = getFinalCycle() + 1; cycle <= LastCycle; ++cycle)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="uncoveredLine">    ScheduledInstrs.erase(cycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="">  // Change the registers in instruction as specified in the InstrChanges</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="">  // map. We need to use the new registers to create the correct order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="uncoveredLine">  for (const SUnit &SU : SSD->SUnits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="uncoveredLine">    SSD->applyInstrChange(SU.getInstr(), *this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="">  // Reorder the instructions in each cycle to fix and improve the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="">  // generated code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="uncoveredLine">  for (int Cycle = getFirstCycle(), E = getFinalCycle(); Cycle <= E; ++Cycle) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="uncoveredLine">    std::deque<SUnit *> &cycleInstrs = ScheduledInstrs[Cycle];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="uncoveredLine">    std::deque<SUnit *> newOrderPhi;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="uncoveredLine">    for (SUnit *SU : cycleInstrs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="uncoveredLine">      if (SU->getInstr()->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="uncoveredLine">        newOrderPhi.push_back(SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="uncoveredLine">    std::deque<SUnit *> newOrderI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="uncoveredLine">    for (SUnit *SU : cycleInstrs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="uncoveredLine">      if (!SU->getInstr()->isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="uncoveredLine">        orderDependence(SSD, SU, newOrderI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="">    // Replace the old order with the new order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="uncoveredLine">    cycleInstrs.swap(newOrderPhi);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="uncoveredLine">    llvm::append_range(cycleInstrs, newOrderI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="uncoveredLine">    SSD->fixupRegisterOverlaps(cycleInstrs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dump(););</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="uncoveredLine">void NodeSet::print(raw_ostream &os) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="uncoveredLine">  os << "Num nodes " << size() << " rec " << RecMII << " mov " << MaxMOV</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="uncoveredLine">     << " depth " << MaxDepth << " col " << Colocate << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="uncoveredLine">  for (const auto &I : Nodes)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="uncoveredLine">    os << "   SU(" << I->NodeNum << ") " << *(I->getInstr());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="uncoveredLine">  os << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="">/// Print the schedule information to the given output.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="uncoveredLine">void SMSchedule::print(raw_ostream &os) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="">  // Iterate over each cycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="uncoveredLine">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="">    // Iterate over each instruction in the cycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="uncoveredLine">    const_sched_iterator cycleInstrs = ScheduledInstrs.find(cycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="uncoveredLine">    for (SUnit *CI : cycleInstrs->second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="uncoveredLine">      os << "cycle " << cycle << " (" << stageScheduled(CI) << ") ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="uncoveredLine">      os << "(" << CI->NodeNum << ") ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="uncoveredLine">      CI->getInstr()->print(os);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="uncoveredLine">      os << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="">/// Utility function used for debugging to print the schedule.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="uncoveredLine">LLVM_DUMP_METHOD void SMSchedule::dump() const { print(dbgs()); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="uncoveredLine">LLVM_DUMP_METHOD void NodeSet::dump() const { print(dbgs()); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="uncoveredLine">void ResourceManager::dumpMRT() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="">    if (UseDFA)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="">      return;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="">    std::stringstream SS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="">    SS << "MRT:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="">    SS << std::setw(4) << "Slot";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="">      SS << std::setw(3) << I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="">    SS << std::setw(7) << "#Mops"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="">       << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="">    for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="">      SS << std::setw(4) << Slot;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="">        SS << std::setw(3) << MRT[Slot][I];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="">      SS << std::setw(7) << NumScheduledMops[Slot] << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="">    dbgs() << SS.str();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="uncoveredLine">void ResourceManager::initProcResourceVectors(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="">    const MCSchedModel &SM, SmallVectorImpl<uint64_t> &Masks) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="uncoveredLine">  unsigned ProcResourceID = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="">  // We currently limit the resource kinds to 64 and below so that we can use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="">  // uint64_t for Masks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="uncoveredLine">  assert(SM.getNumProcResourceKinds() < 64 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="">         "Too many kinds of resources, unsupported");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="">  // Create a unique bitmask for every processor resource unit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="">  // Skip resource at index 0, since it always references 'InvalidUnit'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="uncoveredLine">  Masks.resize(SM.getNumProcResourceKinds());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="uncoveredLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="uncoveredLine">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="uncoveredLine">    if (Desc.SubUnitsIdxBegin)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="uncoveredLine">    Masks[I] = 1ULL << ProcResourceID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="uncoveredLine">    ProcResourceID++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="">  // Create a unique bitmask for every processor resource group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="uncoveredLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="uncoveredLine">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="uncoveredLine">    if (!Desc.SubUnitsIdxBegin)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="uncoveredLine">    Masks[I] = 1ULL << ProcResourceID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="uncoveredLine">    for (unsigned U = 0; U < Desc.NumUnits; ++U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="uncoveredLine">      Masks[I] |= Masks[Desc.SubUnitsIdxBegin[U]];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="uncoveredLine">    ProcResourceID++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="">    if (SwpShowResMask) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="">      dbgs() << "ProcResourceDesc:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="">        const MCProcResourceDesc *ProcResource = SM.getProcResource(I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="">        dbgs() << format(" %16s(%2d): Mask: 0x%08x, NumUnits:%2d\n",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="">                         ProcResource->Name, I, Masks[I],</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="">                         ProcResource->NumUnits);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="">      dbgs() << " -----------------\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="uncoveredLine">bool ResourceManager::canReserveResources(SUnit &SU, int Cycle) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="">    if (SwpDebugResource)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="">      dbgs() << "canReserveResources:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="uncoveredLine">  if (UseDFA)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="uncoveredLine">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="uncoveredLine">        ->canReserveResources(&SU.getInstr()->getDesc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="uncoveredLine">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="uncoveredLine">  if (!SCDesc->isValid()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="uncoveredLine">    LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="uncoveredLine">  reserveResources(SCDesc, Cycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="uncoveredLine">  bool Result = !isOverbooked();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="uncoveredLine">  unreserveResources(SCDesc, Cycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="uncoveredLine">  LLVM_DEBUG(if (SwpDebugResource) dbgs() << "return " << Result << "\n\n";);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="uncoveredLine">void ResourceManager::reserveResources(SUnit &SU, int Cycle) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="">    if (SwpDebugResource)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="">      dbgs() << "reserveResources:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="uncoveredLine">  if (UseDFA)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="uncoveredLine">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="uncoveredLine">        ->reserveResources(&SU.getInstr()->getDesc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="uncoveredLine">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="uncoveredLine">  if (!SCDesc->isValid()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="uncoveredLine">    LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="uncoveredLine">  reserveResources(SCDesc, Cycle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="">    if (SwpDebugResource) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="">      dumpMRT();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="">      dbgs() << "reserveResources: done!\n\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="uncoveredLine">void ResourceManager::reserveResources(const MCSchedClassDesc *SCDesc,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="">                                       int Cycle) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="uncoveredLine">  assert(!UseDFA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="uncoveredLine">  for (const MCWriteProcResEntry &PRE : make_range(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="uncoveredLine">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="uncoveredLine">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="uncoveredLine">      ++MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="uncoveredLine">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="uncoveredLine">    ++NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="uncoveredLine">void ResourceManager::unreserveResources(const MCSchedClassDesc *SCDesc,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="">                                         int Cycle) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="uncoveredLine">  assert(!UseDFA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="uncoveredLine">  for (const MCWriteProcResEntry &PRE : make_range(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="uncoveredLine">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="uncoveredLine">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="uncoveredLine">      --MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="uncoveredLine">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="uncoveredLine">    --NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="uncoveredLine">bool ResourceManager::isOverbooked() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="uncoveredLine">  assert(!UseDFA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="uncoveredLine">  for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="uncoveredLine">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="uncoveredLine">      const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="uncoveredLine">      if (MRT[Slot][I] > Desc->NumUnits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="uncoveredLine">    if (NumScheduledMops[Slot] > IssueWidth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="uncoveredLine">int ResourceManager::calculateResMIIDFA() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="uncoveredLine">  assert(UseDFA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="">  // Sort the instructions by the number of available choices for scheduling,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="">  // least to most. Use the number of critical resources as the tie breaker.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="uncoveredLine">  FuncUnitSorter FUS = FuncUnitSorter(*ST);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="uncoveredLine">  for (SUnit &SU : DAG->SUnits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="uncoveredLine">    FUS.calcCriticalResources(*SU.getInstr());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="">  PriorityQueue<MachineInstr *, std::vector<MachineInstr *>, FuncUnitSorter></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="uncoveredLine">      FuncUnitOrder(FUS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="uncoveredLine">  for (SUnit &SU : DAG->SUnits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="uncoveredLine">    FuncUnitOrder.push(SU.getInstr());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="uncoveredLine">  SmallVector<std::unique_ptr<DFAPacketizer>, 8> Resources;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="uncoveredLine">  Resources.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="uncoveredLine">      std::unique_ptr<DFAPacketizer>(TII->CreateTargetScheduleState(*ST)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="uncoveredLine">  while (!FuncUnitOrder.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="uncoveredLine">    MachineInstr *MI = FuncUnitOrder.top();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="uncoveredLine">    FuncUnitOrder.pop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="uncoveredLine">    if (TII->isZeroCost(MI->getOpcode()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="">    // Attempt to reserve the instruction in an existing DFA. At least one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="">    // DFA is needed for each cycle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="uncoveredLine">    unsigned NumCycles = DAG->getSUnit(MI)->Latency;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="uncoveredLine">    unsigned ReservedCycles = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="uncoveredLine">    auto *RI = Resources.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="uncoveredLine">    auto *RE = Resources.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="uncoveredLine">    LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="">      dbgs() << "Trying to reserve resource for " << NumCycles</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="">             << " cycles for \n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="">      MI->dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="uncoveredLine">    for (unsigned C = 0; C < NumCycles; ++C)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="uncoveredLine">      while (RI != RE) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="uncoveredLine">        if ((*RI)->canReserveResources(*MI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="uncoveredLine">          (*RI)->reserveResources(*MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="uncoveredLine">          ++ReservedCycles;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="uncoveredLine">        RI++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "ReservedCycles:" << ReservedCycles</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="">                      << ", NumCycles:" << NumCycles << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="">    // Add new DFAs, if needed, to reserve resources.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="uncoveredLine">    for (unsigned C = ReservedCycles; C < NumCycles; ++C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="uncoveredLine">      LLVM_DEBUG(if (SwpDebugResource) dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="">                 << "NewResource created to reserve resources"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="">                 << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="uncoveredLine">      auto *NewResource = TII->CreateTargetScheduleState(*ST);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="uncoveredLine">      assert(NewResource->canReserveResources(*MI) && "Reserve error.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="uncoveredLine">      NewResource->reserveResources(*MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="uncoveredLine">      Resources.push_back(std::unique_ptr<DFAPacketizer>(NewResource));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="uncoveredLine">  int Resmii = Resources.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Return Res MII:" << Resmii << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="uncoveredLine">  return Resmii;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="uncoveredLine">int ResourceManager::calculateResMII() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="uncoveredLine">  if (UseDFA)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="uncoveredLine">    return calculateResMIIDFA();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="">  // Count each resource consumption and divide it by the number of units.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="">  // ResMII is the max value among them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="uncoveredLine">  int NumMops = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="uncoveredLine">  SmallVector<uint64_t> ResourceCount(SM.getNumProcResourceKinds());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="uncoveredLine">  for (SUnit &SU : DAG->SUnits) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="uncoveredLine">    if (TII->isZeroCost(SU.getInstr()->getOpcode()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="uncoveredLine">    const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="uncoveredLine">    if (!SCDesc->isValid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="uncoveredLine">    LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="">      if (SwpDebugResource) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="">        DAG->dumpNode(SU);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="">        dbgs() << "  #Mops: " << SCDesc->NumMicroOps << "\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="">               << "  WriteProcRes: ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="uncoveredLine">    NumMops += SCDesc->NumMicroOps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="uncoveredLine">    for (const MCWriteProcResEntry &PRE :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="uncoveredLine">         make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="uncoveredLine">                    STI->getWriteProcResEnd(SCDesc))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="uncoveredLine">      LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="">        if (SwpDebugResource) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="">          const MCProcResourceDesc *Desc =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="">              SM.getProcResource(PRE.ProcResourceIdx);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="">          dbgs() << Desc->Name << ": " << PRE.Cycles << ", ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="uncoveredLine">      ResourceCount[PRE.ProcResourceIdx] += PRE.Cycles;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="uncoveredLine">    LLVM_DEBUG(if (SwpDebugResource) dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="uncoveredLine">  int Result = (NumMops + IssueWidth - 1) / IssueWidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="">    if (SwpDebugResource)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="">      dbgs() << "#Mops: " << NumMops << ", "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="">             << "IssueWidth: " << IssueWidth << ", "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="">             << "Cycles: " << Result << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="">    if (SwpDebugResource) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="">      std::stringstream SS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="">      SS << std::setw(2) << "ID" << std::setw(16) << "Name" << std::setw(10)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="">         << "Units" << std::setw(10) << "Consumed" << std::setw(10) << "Cycles"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="">         << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="">      dbgs() << SS.str();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="uncoveredLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="uncoveredLine">    const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="uncoveredLine">    int Cycles = (ResourceCount[I] + Desc->NumUnits - 1) / Desc->NumUnits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="uncoveredLine">    LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="">      if (SwpDebugResource) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="">        std::stringstream SS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="">        SS << std::setw(2) << I << std::setw(16) << Desc->Name << std::setw(10)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="">           << Desc->NumUnits << std::setw(10) << ResourceCount[I]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="">           << std::setw(10) << Cycles << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="">        dbgs() << SS.str();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="uncoveredLine">    if (Cycles > Result)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="uncoveredLine">      Result = Cycles;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="uncoveredLine">  return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="uncoveredLine">void ResourceManager::init(int II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="uncoveredLine">  InitiationInterval = II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="uncoveredLine">  DFAResources.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="uncoveredLine">  DFAResources.resize(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="uncoveredLine">  for (auto &I : DFAResources)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="uncoveredLine">    I.reset(ST->getInstrInfo()->CreateTargetScheduleState(*ST));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="uncoveredLine">  MRT.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="uncoveredLine">  MRT.resize(II, SmallVector<uint64_t>(SM.getNumProcResourceKinds()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="uncoveredLine">  NumScheduledMops.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="uncoveredLine">  NumScheduledMops.resize(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL34initializeMachinePipelinerPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm30initializeMachinePipelinerPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16MachinePipeliner20runOnMachineFunctionERNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16MachinePipeliner12scheduleLoopERNS_11MachineLoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16MachinePipeliner12scheduleLoopERNS_11MachineLoopEENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16MachinePipeliner24setPragmaPipelineOptionsERNS_11MachineLoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16MachinePipeliner15canPipelineLoopERNS_11MachineLoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16MachinePipeliner15canPipelineLoopERNS_11MachineLoopEENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16MachinePipeliner15canPipelineLoopERNS_11MachineLoopEENKUlvE0_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16MachinePipeliner15canPipelineLoopERNS_11MachineLoopEENKUlvE1_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16MachinePipeliner15canPipelineLoopERNS_11MachineLoopEENKUlvE2_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16MachinePipeliner15canPipelineLoopERNS_11MachineLoopEENKUlvE3_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16MachinePipeliner18preprocessPhiNodesERNS_17MachineBasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16MachinePipeliner20swingModuloSchedulerERNS_11MachineLoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16MachinePipeliner16getAnalysisUsageERNS_13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG6setMIIEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG9setMAX_IIEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG8scheduleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG8scheduleEvENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG8scheduleEvENKUlvE0_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG8scheduleEvENKUlvE1_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG8scheduleEvENKUlvE2_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG8scheduleEvENKUlvE3_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG8scheduleEvENKUlvE4_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG11finishBlockEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL10getPhiRegsRN4llvm12MachineInstrEPNS_17MachineBasicBlockERjS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13getLoopPhiRegRN4llvm12MachineInstrEPNS_17MachineBasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL11isSuccOrderPN4llvm5SUnitES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL19isDependenceBarrierRN4llvm12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL20getUnderlyingObjectsPKN4llvm12MachineInstrERNS_15SmallVectorImplIPKNS_5ValueEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG25addLoopCarriedDependencesEPNS_9AAResultsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG20updatePhiDependencesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG17changeDependencesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114FuncUnitSorterC2ERKN4llvm19TargetSubtargetInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_114FuncUnitSorter12minFuncUnitsEPKN4llvm12MachineInstrERm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114FuncUnitSorter21calcCriticalResourcesERN4llvm12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_114FuncUnitSorterclEPKN4llvm12MachineInstrES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG15calculateResMIIEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG15calculateRecMIIERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL19swapAntiDependencesRSt6vectorIN4llvm5SUnitESaIS1_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG8Circuits24createAdjacencyStructureEPS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG8Circuits7circuitEiiRNS_11SmallVectorINS_7NodeSetELj8EEEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG8Circuits7unblockEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG12findCircuitsERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG17CopyToPhiMutation5applyEPNS_17ScheduleDAGInstrsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16ignoreDependenceRKN4llvm4SDepEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG20computeNodeFunctionsERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL6pred_LRN4llvm9SetVectorIPNS_5SUnitENS_11SmallVectorIS2_Lj0EEENS_8DenseSetIS2_NS_12DenseMapInfoIS2_vEEEELj0EEERNS_14SmallSetVectorIS2_Lj8EEEPKNS_7NodeSetE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL6succ_LRN4llvm9SetVectorIPNS_5SUnitENS_11SmallVectorIS2_Lj0EEENS_8DenseSetIS2_NS_12DenseMapInfoIS2_vEEEELj0EEERNS_14SmallSetVectorIS2_Lj8EEEPKNS_7NodeSetE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL11computePathPN4llvm5SUnitERNS_9SetVectorIS1_NS_11SmallVectorIS1_Lj0EEENS_8DenseSetIS1_NS_12DenseMapInfoIS1_vEEEELj0EEESA_SA_RNS_11SmallPtrSetIS1_Lj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15computeLiveOutsRN4llvm15MachineFunctionERNS_18RegPressureTrackerERNS_7NodeSetE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG22registerPressureFilterERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG22registerPressureFilterERNS_11SmallVectorINS_7NodeSetELj8EEEENKUlPKNS_5SUnitES7_E_clES7_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG16colocateNodeSetsERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG13checkNodeSetsERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG19groupRemainingNodesERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG17addConnectedNodesEPNS_5SUnitERNS_7NodeSetERNS_9SetVectorIS2_NS_11SmallVectorIS2_Lj0EEENS_8DenseSetIS2_NS_12DenseMapInfoIS2_vEEEELj0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL11isIntersectRN4llvm14SmallSetVectorIPNS_5SUnitELj8EEERKNS_7NodeSetES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG8fuseRecsERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG20removeDuplicateNodesERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG20removeDuplicateNodesERNS_11SmallVectorINS_7NodeSetELj8EEEENKUlPNS_5SUnitEE_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG16computeNodeOrderERNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG16schedulePipelineERNS_10SMScheduleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm17SwingSchedulerDAG16schedulePipelineERNS_10SMScheduleEENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG12computeDeltaERNS_12MachineInstrERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG21canUseLastOffsetValueEPNS_12MachineInstrERjS3_S3_Rl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG16applyInstrChangeEPNS_12MachineInstrERNS_10SMScheduleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG13findDefInLoopENS_8RegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG16isLoopCarriedDepEPNS_5SUnitERKNS_4SDepEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG14postProcessDAGEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule6insertEPNS_5SUnitEiii</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule20earliestCycleInChainERKNS_4SDepE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule18latestCycleInChainERKNS_4SDepE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL18multipleIterationsPN4llvm5SUnitEPNS_17SwingSchedulerDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule12computeStartEPNS_5SUnitEPiS3_S3_S3_iPNS_17SwingSchedulerDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule15orderDependenceEPNS_17SwingSchedulerDAGEPNS_5SUnitERSt5dequeIS4_SaIS4_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule13isLoopCarriedEPNS_17SwingSchedulerDAGERNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule21isLoopCarriedDefOfUseEPNS_17SwingSchedulerDAGEPNS_12MachineInstrERNS_14MachineOperandE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule26computeUnpipelineableNodesEPNS_17SwingSchedulerDAGEPNS_15TargetInstrInfo17PipelinerLoopInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule33normalizeNonPipelinedInstructionsEPNS_17SwingSchedulerDAGEPNS_15TargetInstrInfo17PipelinerLoopInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule15isValidScheduleEPNS_17SwingSchedulerDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm17SwingSchedulerDAG19checkValidNodeOrderERKNS_11SmallVectorINS_7NodeSetELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK4llvm17SwingSchedulerDAG19checkValidNodeOrderERKNS_11SmallVectorINS_7NodeSetELj8EEEENKUlSt4pairIPNS_5SUnitEjES9_E_clES9_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK4llvm17SwingSchedulerDAG19checkValidNodeOrderERKNS_11SmallVectorINS_7NodeSetELj8EEEENKUlRKS2_E0_clES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SwingSchedulerDAG21fixupRegisterOverlapsERSt5dequeIPNS_5SUnitESaIS3_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10SMSchedule16finalizeScheduleEPNS_17SwingSchedulerDAGE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7NodeSet5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10SMSchedule5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10SMSchedule4dumpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm7NodeSet4dumpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ResourceManager7dumpMRTEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ResourceManager23initProcResourceVectorsERKNS_12MCSchedModelERNS_15SmallVectorImplImEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ResourceManager19canReserveResourcesERNS_5SUnitEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ResourceManager16reserveResourcesERNS_5SUnitEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ResourceManager16reserveResourcesEPKNS_16MCSchedClassDescEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ResourceManager18unreserveResourcesEPKNS_16MCSchedClassDescEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ResourceManager12isOverbookedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ResourceManager18calculateResMIIDFAEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ResourceManager15calculateResMIIEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ResourceManager4initEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// This SMS implementation is a target-independent back-end pass. When enabled,</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// This SMS implementation is a target-independent back-end pass. When enabled,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// the pass runs just prior to the register allocation pass, while the machine</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// the pass runs just prior to the register allocation pass, while the machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">// IR is in SSA form. If software pipelining is successful, then the original</td>
    <td class="lineNumber">13</td>
    <td class="codeline">// IR is in SSA form. If software pipelining is successful, then the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// loop is replaced by the optimized loop. The optimized loop contains one or</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// loop is replaced by the optimized loop. The optimized loop contains one or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">// more prolog blocks, the pipelined kernel, and one or more epilog blocks. If</td>
    <td class="lineNumber">15</td>
    <td class="codeline">// more prolog blocks, the pipelined kernel, and one or more epilog blocks. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">// the instructions cannot be scheduled in a given MII, we increase the MII by</td>
    <td class="lineNumber">16</td>
    <td class="codeline">// the instructions cannot be scheduled in a given MII, we increase the MII by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">// one and try again.</td>
    <td class="lineNumber">17</td>
    <td class="codeline">// one and try again.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">//</td>
    <td class="lineNumber">18</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">// The SMS implementation is an extension of the ScheduleDAGInstrs class. We</td>
    <td class="lineNumber">19</td>
    <td class="codeline">// The SMS implementation is an extension of the ScheduleDAGInstrs class. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">// represent loop carried dependences in the DAG as order edges to the Phi</td>
    <td class="lineNumber">20</td>
    <td class="codeline">// represent loop carried dependences in the DAG as order edges to the Phi</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">// nodes. We also perform several passes over the DAG to eliminate unnecessary</td>
    <td class="lineNumber">21</td>
    <td class="codeline">// nodes. We also perform several passes over the DAG to eliminate unnecessary</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">// edges that inhibit the ability to pipeline. The implementation uses the</td>
    <td class="lineNumber">22</td>
    <td class="codeline">// edges that inhibit the ability to pipeline. The implementation uses the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">// DFAPacketizer class to compute the minimum initiation interval and the check</td>
    <td class="lineNumber">23</td>
    <td class="codeline">// DFAPacketizer class to compute the minimum initiation interval and the check</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">// where an instruction may be inserted in the pipelined schedule.</td>
    <td class="lineNumber">24</td>
    <td class="codeline">// where an instruction may be inserted in the pipelined schedule.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">// In order for the SMS pass to work, several target specific hooks need to be</td>
    <td class="lineNumber">26</td>
    <td class="codeline">// In order for the SMS pass to work, several target specific hooks need to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">// implemented to get information about the loop structure and to rewrite</td>
    <td class="lineNumber">27</td>
    <td class="codeline">// implemented to get information about the loop structure and to rewrite</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">// instructions.</td>
    <td class="lineNumber">28</td>
    <td class="codeline">// instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">//</td>
    <td class="lineNumber">29</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">30</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline"></td>
    <td class="lineNumber">31</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/CodeGen/MachinePipeliner.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/CodeGen/MachinePipeliner.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/ADT/MapVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/ADT/PriorityQueue.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/ADT/PriorityQueue.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/ADT/SetOperations.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/ADT/SetOperations.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/Analysis/CycleAnalysis.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/Analysis/CycleAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Analysis/MemoryLocation.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/CodeGen/DFAPacketizer.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/CodeGen/DFAPacketizer.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/CodeGen/LiveIntervals.h"</td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/CodeGen/LiveIntervals.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/CodeGen/MachineDominators.h"</td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/CodeGen/MachineDominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/CodeGen/MachineMemOperand.h"</td>
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/CodeGen/MachineMemOperand.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOperand.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/CodeGen/ModuloSchedule.h"</td>
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/CodeGen/ModuloSchedule.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">#include "llvm/CodeGen/RegisterPressure.h"</td>
    <td class="lineNumber">63</td>
    <td class="codeline">#include "llvm/CodeGen/RegisterPressure.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">#include "llvm/CodeGen/ScheduleDAG.h"</td>
    <td class="lineNumber">64</td>
    <td class="codeline">#include "llvm/CodeGen/ScheduleDAG.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">#include "llvm/CodeGen/ScheduleDAGMutation.h"</td>
    <td class="lineNumber">65</td>
    <td class="codeline">#include "llvm/CodeGen/ScheduleDAGMutation.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">#include "llvm/CodeGen/TargetOpcodes.h"</td>
    <td class="lineNumber">66</td>
    <td class="codeline">#include "llvm/CodeGen/TargetOpcodes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">67</td>
    <td class="codeline">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">68</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">69</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">70</td>
    <td class="codeline">#include "llvm/IR/Attributes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">71</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">#include "llvm/MC/LaneBitmask.h"</td>
    <td class="lineNumber">72</td>
    <td class="codeline">#include "llvm/MC/LaneBitmask.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">#include "llvm/MC/MCInstrDesc.h"</td>
    <td class="lineNumber">73</td>
    <td class="codeline">#include "llvm/MC/MCInstrDesc.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">#include "llvm/MC/MCInstrItineraries.h"</td>
    <td class="lineNumber">74</td>
    <td class="codeline">#include "llvm/MC/MCInstrItineraries.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">#include "llvm/MC/MCRegisterInfo.h"</td>
    <td class="lineNumber">75</td>
    <td class="codeline">#include "llvm/MC/MCRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">76</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">77</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">78</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">79</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">80</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">81</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">82</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">83</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">#include <climits></td>
    <td class="lineNumber">84</td>
    <td class="codeline">#include <climits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">85</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">#include <deque></td>
    <td class="lineNumber">86</td>
    <td class="codeline">#include <deque></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">#include <functional></td>
    <td class="lineNumber">87</td>
    <td class="codeline">#include <functional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">#include <iomanip></td>
    <td class="lineNumber">88</td>
    <td class="codeline">#include <iomanip></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">89</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">#include <map></td>
    <td class="lineNumber">90</td>
    <td class="codeline">#include <map></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">#include <memory></td>
    <td class="lineNumber">91</td>
    <td class="codeline">#include <memory></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">#include <sstream></td>
    <td class="lineNumber">92</td>
    <td class="codeline">#include <sstream></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">#include <tuple></td>
    <td class="lineNumber">93</td>
    <td class="codeline">#include <tuple></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">94</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">95</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">97</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">#define DEBUG_TYPE "pipeliner"</td>
    <td class="lineNumber">99</td>
    <td class="codeline">#define DEBUG_TYPE "pipeliner"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline"></td>
    <td class="lineNumber">100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">STATISTIC(NumTrytoPipeline, "Number of loops that we attempt to pipeline");</td>
    <td class="lineNumber">101</td>
    <td class="codeline">STATISTIC(NumTrytoPipeline, "Number of loops that we attempt to pipeline");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">STATISTIC(NumPipelined, "Number of loops software pipelined");</td>
    <td class="lineNumber">102</td>
    <td class="codeline">STATISTIC(NumPipelined, "Number of loops software pipelined");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">STATISTIC(NumNodeOrderIssues, "Number of node order issues found");</td>
    <td class="lineNumber">103</td>
    <td class="codeline">STATISTIC(NumNodeOrderIssues, "Number of node order issues found");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">STATISTIC(NumFailBranch, "Pipeliner abort due to unknown branch");</td>
    <td class="lineNumber">104</td>
    <td class="codeline">STATISTIC(NumFailBranch, "Pipeliner abort due to unknown branch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">STATISTIC(NumFailLoop, "Pipeliner abort due to unsupported loop");</td>
    <td class="lineNumber">105</td>
    <td class="codeline">STATISTIC(NumFailLoop, "Pipeliner abort due to unsupported loop");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">STATISTIC(NumFailPreheader, "Pipeliner abort due to missing preheader");</td>
    <td class="lineNumber">106</td>
    <td class="codeline">STATISTIC(NumFailPreheader, "Pipeliner abort due to missing preheader");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">STATISTIC(NumFailLargeMaxMII, "Pipeliner abort due to MaxMII too large");</td>
    <td class="lineNumber">107</td>
    <td class="codeline">STATISTIC(NumFailLargeMaxMII, "Pipeliner abort due to MaxMII too large");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">STATISTIC(NumFailZeroMII, "Pipeliner abort due to zero MII");</td>
    <td class="lineNumber">108</td>
    <td class="codeline">STATISTIC(NumFailZeroMII, "Pipeliner abort due to zero MII");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">STATISTIC(NumFailNoSchedule, "Pipeliner abort due to no schedule found");</td>
    <td class="lineNumber">109</td>
    <td class="codeline">STATISTIC(NumFailNoSchedule, "Pipeliner abort due to no schedule found");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">STATISTIC(NumFailZeroStage, "Pipeliner abort due to zero stage");</td>
    <td class="lineNumber">110</td>
    <td class="codeline">STATISTIC(NumFailZeroStage, "Pipeliner abort due to zero stage");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">STATISTIC(NumFailLargeMaxStage, "Pipeliner abort due to too many stages");</td>
    <td class="lineNumber">111</td>
    <td class="codeline">STATISTIC(NumFailLargeMaxStage, "Pipeliner abort due to too many stages");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline"></td>
    <td class="lineNumber">112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">/// A command line option to turn software pipelining on or off.</td>
    <td class="lineNumber">113</td>
    <td class="codeline">/// A command line option to turn software pipelining on or off.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">static cl::opt<bool> EnableSWP("enable-pipeliner", cl::Hidden, cl::init(true),</td>
    <td class="lineNumber">114</td>
    <td class="codeline">static cl::opt<bool> EnableSWP("enable-pipeliner", cl::Hidden, cl::init(true),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">                               cl::desc("Enable Software Pipelining"));</td>
    <td class="lineNumber">115</td>
    <td class="codeline">                               cl::desc("Enable Software Pipelining"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">/// A command line option to enable SWP at -Os.</td>
    <td class="lineNumber">117</td>
    <td class="codeline">/// A command line option to enable SWP at -Os.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">static cl::opt<bool> EnableSWPOptSize("enable-pipeliner-opt-size",</td>
    <td class="lineNumber">118</td>
    <td class="codeline">static cl::opt<bool> EnableSWPOptSize("enable-pipeliner-opt-size",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">                                      cl::desc("Enable SWP at Os."), cl::Hidden,</td>
    <td class="lineNumber">119</td>
    <td class="codeline">                                      cl::desc("Enable SWP at Os."), cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">                                      cl::init(false));</td>
    <td class="lineNumber">120</td>
    <td class="codeline">                                      cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">/// A command line argument to limit minimum initial interval for pipelining.</td>
    <td class="lineNumber">122</td>
    <td class="codeline">/// A command line argument to limit minimum initial interval for pipelining.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">static cl::opt<int> SwpMaxMii("pipeliner-max-mii",</td>
    <td class="lineNumber">123</td>
    <td class="codeline">static cl::opt<int> SwpMaxMii("pipeliner-max-mii",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">                              cl::desc("Size limit for the MII."),</td>
    <td class="lineNumber">124</td>
    <td class="codeline">                              cl::desc("Size limit for the MII."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">                              cl::Hidden, cl::init(27));</td>
    <td class="lineNumber">125</td>
    <td class="codeline">                              cl::Hidden, cl::init(27));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">/// A command line argument to force pipeliner to use specified initial</td>
    <td class="lineNumber">127</td>
    <td class="codeline">/// A command line argument to force pipeliner to use specified initial</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">/// interval.</td>
    <td class="lineNumber">128</td>
    <td class="codeline">/// interval.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">static cl::opt<int> SwpForceII("pipeliner-force-ii",</td>
    <td class="lineNumber">129</td>
    <td class="codeline">static cl::opt<int> SwpForceII("pipeliner-force-ii",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">                               cl::desc("Force pipeliner to use specified II."),</td>
    <td class="lineNumber">130</td>
    <td class="codeline">                               cl::desc("Force pipeliner to use specified II."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">                               cl::Hidden, cl::init(-1));</td>
    <td class="lineNumber">131</td>
    <td class="codeline">                               cl::Hidden, cl::init(-1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline"></td>
    <td class="lineNumber">132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">/// A command line argument to limit the number of stages in the pipeline.</td>
    <td class="lineNumber">133</td>
    <td class="codeline">/// A command line argument to limit the number of stages in the pipeline.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">static cl::opt<int></td>
    <td class="lineNumber">134</td>
    <td class="codeline">static cl::opt<int></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">    SwpMaxStages("pipeliner-max-stages",</td>
    <td class="lineNumber">135</td>
    <td class="codeline">    SwpMaxStages("pipeliner-max-stages",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">                 cl::desc("Maximum stages allowed in the generated scheduled."),</td>
    <td class="lineNumber">136</td>
    <td class="codeline">                 cl::desc("Maximum stages allowed in the generated scheduled."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">                 cl::Hidden, cl::init(3));</td>
    <td class="lineNumber">137</td>
    <td class="codeline">                 cl::Hidden, cl::init(3));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">/// A command line option to disable the pruning of chain dependences due to</td>
    <td class="lineNumber">139</td>
    <td class="codeline">/// A command line option to disable the pruning of chain dependences due to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">/// an unrelated Phi.</td>
    <td class="lineNumber">140</td>
    <td class="codeline">/// an unrelated Phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">static cl::opt<bool></td>
    <td class="lineNumber">141</td>
    <td class="codeline">static cl::opt<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    SwpPruneDeps("pipeliner-prune-deps",</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    SwpPruneDeps("pipeliner-prune-deps",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">                 cl::desc("Prune dependences between unrelated Phi nodes."),</td>
    <td class="lineNumber">143</td>
    <td class="codeline">                 cl::desc("Prune dependences between unrelated Phi nodes."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">                 cl::Hidden, cl::init(true));</td>
    <td class="lineNumber">144</td>
    <td class="codeline">                 cl::Hidden, cl::init(true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">/// A command line option to disable the pruning of loop carried order</td>
    <td class="lineNumber">146</td>
    <td class="codeline">/// A command line option to disable the pruning of loop carried order</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">/// dependences.</td>
    <td class="lineNumber">147</td>
    <td class="codeline">/// dependences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">static cl::opt<bool></td>
    <td class="lineNumber">148</td>
    <td class="codeline">static cl::opt<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">    SwpPruneLoopCarried("pipeliner-prune-loop-carried",</td>
    <td class="lineNumber">149</td>
    <td class="codeline">    SwpPruneLoopCarried("pipeliner-prune-loop-carried",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">                        cl::desc("Prune loop carried order dependences."),</td>
    <td class="lineNumber">150</td>
    <td class="codeline">                        cl::desc("Prune loop carried order dependences."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">                        cl::Hidden, cl::init(true));</td>
    <td class="lineNumber">151</td>
    <td class="codeline">                        cl::Hidden, cl::init(true));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline"></td>
    <td class="lineNumber">152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">153</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">static cl::opt<int> SwpLoopLimit("pipeliner-max", cl::Hidden, cl::init(-1));</td>
    <td class="lineNumber">154</td>
    <td class="codeline">static cl::opt<int> SwpLoopLimit("pipeliner-max", cl::Hidden, cl::init(-1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">155</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline"></td>
    <td class="lineNumber">156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">static cl::opt<bool> SwpIgnoreRecMII("pipeliner-ignore-recmii",</td>
    <td class="lineNumber">157</td>
    <td class="codeline">static cl::opt<bool> SwpIgnoreRecMII("pipeliner-ignore-recmii",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">                                     cl::ReallyHidden,</td>
    <td class="lineNumber">158</td>
    <td class="codeline">                                     cl::ReallyHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">                                     cl::desc("Ignore RecMII"));</td>
    <td class="lineNumber">159</td>
    <td class="codeline">                                     cl::desc("Ignore RecMII"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">static cl::opt<bool> SwpShowResMask("pipeliner-show-mask", cl::Hidden,</td>
    <td class="lineNumber">161</td>
    <td class="codeline">static cl::opt<bool> SwpShowResMask("pipeliner-show-mask", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">                                    cl::init(false));</td>
    <td class="lineNumber">162</td>
    <td class="codeline">                                    cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">static cl::opt<bool> SwpDebugResource("pipeliner-dbg-res", cl::Hidden,</td>
    <td class="lineNumber">163</td>
    <td class="codeline">static cl::opt<bool> SwpDebugResource("pipeliner-dbg-res", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">                                      cl::init(false));</td>
    <td class="lineNumber">164</td>
    <td class="codeline">                                      cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">static cl::opt<bool> EmitTestAnnotations(</td>
    <td class="lineNumber">166</td>
    <td class="codeline">static cl::opt<bool> EmitTestAnnotations(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">    "pipeliner-annotate-for-testing", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">167</td>
    <td class="codeline">    "pipeliner-annotate-for-testing", cl::Hidden, cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">    cl::desc("Instead of emitting the pipelined code, annotate instructions "</td>
    <td class="lineNumber">168</td>
    <td class="codeline">    cl::desc("Instead of emitting the pipelined code, annotate instructions "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">             "with the generated schedule for feeding into the "</td>
    <td class="lineNumber">169</td>
    <td class="codeline">             "with the generated schedule for feeding into the "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">             "-modulo-schedule-test pass"));</td>
    <td class="lineNumber">170</td>
    <td class="codeline">             "-modulo-schedule-test pass"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline"></td>
    <td class="lineNumber">171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">static cl::opt<bool> ExperimentalCodeGen(</td>
    <td class="lineNumber">172</td>
    <td class="codeline">static cl::opt<bool> ExperimentalCodeGen(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    "pipeliner-experimental-cg", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    "pipeliner-experimental-cg", cl::Hidden, cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">    cl::desc(</td>
    <td class="lineNumber">174</td>
    <td class="codeline">    cl::desc(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">        "Use the experimental peeling code generator for software pipelining"));</td>
    <td class="lineNumber">175</td>
    <td class="codeline">        "Use the experimental peeling code generator for software pipelining"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">177</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline"></td>
    <td class="lineNumber">178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">// A command line option to enable the CopyToPhi DAG mutation.</td>
    <td class="lineNumber">179</td>
    <td class="codeline">// A command line option to enable the CopyToPhi DAG mutation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">cl::opt<bool> SwpEnableCopyToPhi("pipeliner-enable-copytophi", cl::ReallyHidden,</td>
    <td class="lineNumber">180</td>
    <td class="codeline">cl::opt<bool> SwpEnableCopyToPhi("pipeliner-enable-copytophi", cl::ReallyHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">                                 cl::init(true),</td>
    <td class="lineNumber">181</td>
    <td class="codeline">                                 cl::init(true),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">                                 cl::desc("Enable CopyToPhi DAG Mutation"));</td>
    <td class="lineNumber">182</td>
    <td class="codeline">                                 cl::desc("Enable CopyToPhi DAG Mutation"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline"></td>
    <td class="lineNumber">183</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">/// A command line argument to force pipeliner to use specified issue</td>
    <td class="lineNumber">184</td>
    <td class="codeline">/// A command line argument to force pipeliner to use specified issue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">/// width.</td>
    <td class="lineNumber">185</td>
    <td class="codeline">/// width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">cl::opt<int> SwpForceIssueWidth(</td>
    <td class="lineNumber">186</td>
    <td class="codeline">cl::opt<int> SwpForceIssueWidth(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">    "pipeliner-force-issue-width",</td>
    <td class="lineNumber">187</td>
    <td class="codeline">    "pipeliner-force-issue-width",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    cl::desc("Force pipeliner to use specified issue width."), cl::Hidden,</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    cl::desc("Force pipeliner to use specified issue width."), cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">    cl::init(-1));</td>
    <td class="lineNumber">189</td>
    <td class="codeline">    cl::init(-1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline"></td>
    <td class="lineNumber">190</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">191</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">unsigned SwingSchedulerDAG::Circuits::MaxPaths = 5;</td>
    <td class="lineNumber">193</td>
    <td class="codeline">unsigned SwingSchedulerDAG::Circuits::MaxPaths = 5;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">char MachinePipeliner::ID = 0;</td>
    <td class="lineNumber">194</td>
    <td class="codeline">char MachinePipeliner::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">195</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">int MachinePipeliner::NumTries = 0;</td>
    <td class="lineNumber">196</td>
    <td class="codeline">int MachinePipeliner::NumTries = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">197</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">char &llvm::MachinePipelinerID = MachinePipeliner::ID;</td>
    <td class="lineNumber">198</td>
    <td class="codeline">char &llvm::MachinePipelinerID = MachinePipeliner::ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline"></td>
    <td class="lineNumber">199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(MachinePipeliner, DEBUG_TYPE,</td>
    <td class="lineNumber">200</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(MachinePipeliner, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">                      "Modulo Software Pipelining", false, false)</td>
    <td class="lineNumber">201</td>
    <td class="codeline">                      "Modulo Software Pipelining", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">202</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
    <td class="lineNumber">203</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
    <td class="lineNumber">204</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
    <td class="lineNumber">205</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">INITIALIZE_PASS_END(MachinePipeliner, DEBUG_TYPE,</td>
    <td class="lineNumber">206</td>
    <td class="codeline">INITIALIZE_PASS_END(MachinePipeliner, DEBUG_TYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">                    "Modulo Software Pipelining", false, false)</td>
    <td class="lineNumber">207</td>
    <td class="codeline">                    "Modulo Software Pipelining", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline"></td>
    <td class="lineNumber">208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">/// The "main" function for implementing Swing Modulo Scheduling.</td>
    <td class="lineNumber">209</td>
    <td class="codeline">/// The "main" function for implementing Swing Modulo Scheduling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">bool MachinePipeliner::runOnMachineFunction(MachineFunction &mf) {</td>
    <td class="lineNumber">210</td>
    <td class="codeline">bool MachinePipeliner::runOnMachineFunction(MachineFunction &mf) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  if (skipFunction(mf.getFunction()))</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  if (skipFunction(mf.getFunction()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">212</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  if (!EnableSWP)</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  if (!EnableSWP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">215</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  if (mf.getFunction().getAttributes().hasFnAttr(Attribute::OptimizeForSize) &&</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  if (mf.getFunction().getAttributes().hasFnAttr(Attribute::OptimizeForSize) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">      !EnableSWPOptSize.getPosition())</td>
    <td class="lineNumber">218</td>
    <td class="codeline">      !EnableSWPOptSize.getPosition())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">219</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  if (!mf.getSubtarget().enableMachinePipeliner())</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  if (!mf.getSubtarget().enableMachinePipeliner())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">222</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline"></td>
    <td class="lineNumber">223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  // Cannot pipeline loops without instruction itineraries if we are using</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  // Cannot pipeline loops without instruction itineraries if we are using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  // DFA for the pipeliner.</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  // DFA for the pipeliner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  if (mf.getSubtarget().useDFAforSMS() &&</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  if (mf.getSubtarget().useDFAforSMS() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">      (!mf.getSubtarget().getInstrItineraryData() ||</td>
    <td class="lineNumber">227</td>
    <td class="codeline">      (!mf.getSubtarget().getInstrItineraryData() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">       mf.getSubtarget().getInstrItineraryData()->isEmpty()))</td>
    <td class="lineNumber">228</td>
    <td class="codeline">       mf.getSubtarget().getInstrItineraryData()->isEmpty()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">229</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  MF = &mf;</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  MF = &mf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  MLI = &getAnalysis<MachineLoopInfo>();</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  MLI = &getAnalysis<MachineLoopInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  MDT = &getAnalysis<MachineDominatorTree>();</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  MDT = &getAnalysis<MachineDominatorTree>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  TII = MF->getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  TII = MF->getSubtarget().getInstrInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  RegClassInfo.runOnMachineFunction(*MF);</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  RegClassInfo.runOnMachineFunction(*MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  for (const auto &L : *MLI)</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  for (const auto &L : *MLI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    scheduleLoop(*L);</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    scheduleLoop(*L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline"></td>
    <td class="lineNumber">240</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">}</td>
    <td class="lineNumber">242</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline"></td>
    <td class="lineNumber">243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">/// Attempt to perform the SMS algorithm on the specified loop. This function is</td>
    <td class="lineNumber">244</td>
    <td class="codeline">/// Attempt to perform the SMS algorithm on the specified loop. This function is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">/// the main entry point for the algorithm.  The function identifies candidate</td>
    <td class="lineNumber">245</td>
    <td class="codeline">/// the main entry point for the algorithm.  The function identifies candidate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">/// loops, calculates the minimum initiation interval, and attempts to schedule</td>
    <td class="lineNumber">246</td>
    <td class="codeline">/// loops, calculates the minimum initiation interval, and attempts to schedule</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">/// the loop.</td>
    <td class="lineNumber">247</td>
    <td class="codeline">/// the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">bool MachinePipeliner::scheduleLoop(MachineLoop &L) {</td>
    <td class="lineNumber">248</td>
    <td class="codeline">bool MachinePipeliner::scheduleLoop(MachineLoop &L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  for (const auto &InnerLoop : L)</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  for (const auto &InnerLoop : L)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">    Changed |= scheduleLoop(*InnerLoop);</td>
    <td class="lineNumber">251</td>
    <td class="codeline">    Changed |= scheduleLoop(*InnerLoop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline"></td>
    <td class="lineNumber">252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">253</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  // Stop trying after reaching the limit (if any).</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  // Stop trying after reaching the limit (if any).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  int Limit = SwpLoopLimit;</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  int Limit = SwpLoopLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  if (Limit >= 0) {</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  if (Limit >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">    if (NumTries >= SwpLoopLimit)</td>
    <td class="lineNumber">257</td>
    <td class="codeline">    if (NumTries >= SwpLoopLimit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">      return Changed;</td>
    <td class="lineNumber">258</td>
    <td class="codeline">      return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">    NumTries++;</td>
    <td class="lineNumber">259</td>
    <td class="codeline">    NumTries++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">261</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline"></td>
    <td class="lineNumber">262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  setPragmaPipelineOptions(L);</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  setPragmaPipelineOptions(L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  if (!canPipelineLoop(L)) {</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  if (!canPipelineLoop(L)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\n!!! Can not pipeline loop.\n");</td>
    <td class="lineNumber">265</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\n!!! Can not pipeline loop.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    ORE->emit([&]() {</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">      return MachineOptimizationRemarkMissed(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">267</td>
    <td class="codeline">      return MachineOptimizationRemarkMissed(DEBUG_TYPE, "canPipelineLoop",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">                                             L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">268</td>
    <td class="codeline">                                             L.getStartLoc(), L.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">             << "Failed to pipeline loop";</td>
    <td class="lineNumber">269</td>
    <td class="codeline">             << "Failed to pipeline loop";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">270</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">    LI.LoopPipelinerInfo.reset();</td>
    <td class="lineNumber">272</td>
    <td class="codeline">    LI.LoopPipelinerInfo.reset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">    return Changed;</td>
    <td class="lineNumber">273</td>
    <td class="codeline">    return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline"></td>
    <td class="lineNumber">275</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  ++NumTrytoPipeline;</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  ++NumTrytoPipeline;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  Changed = swingModuloScheduler(L);</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  Changed = swingModuloScheduler(L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  LI.LoopPipelinerInfo.reset();</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  LI.LoopPipelinerInfo.reset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">}</td>
    <td class="lineNumber">282</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">void MachinePipeliner::setPragmaPipelineOptions(MachineLoop &L) {</td>
    <td class="lineNumber">284</td>
    <td class="codeline">void MachinePipeliner::setPragmaPipelineOptions(MachineLoop &L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  // Reset the pragma for the next loop in iteration.</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  // Reset the pragma for the next loop in iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  disabledByPragma = false;</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  disabledByPragma = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  II_setByPragma = 0;</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  II_setByPragma = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  MachineBasicBlock *LBLK = L.getTopBlock();</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  MachineBasicBlock *LBLK = L.getTopBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline"></td>
    <td class="lineNumber">290</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  if (LBLK == nullptr)</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  if (LBLK == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline"></td>
    <td class="lineNumber">293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  const BasicBlock *BBLK = LBLK->getBasicBlock();</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  const BasicBlock *BBLK = LBLK->getBasicBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  if (BBLK == nullptr)</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  if (BBLK == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  const Instruction *TI = BBLK->getTerminator();</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  const Instruction *TI = BBLK->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  if (TI == nullptr)</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  if (TI == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">300</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  MDNode *LoopID = TI->getMetadata(LLVMContext::MD_loop);</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  MDNode *LoopID = TI->getMetadata(LLVMContext::MD_loop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  if (LoopID == nullptr)</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  if (LoopID == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  assert(LoopID->getNumOperands() > 0 && "requires atleast one operand");</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  assert(LoopID->getNumOperands() > 0 && "requires atleast one operand");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  assert(LoopID->getOperand(0) == LoopID && "invalid loop");</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  assert(LoopID->getOperand(0) == LoopID && "invalid loop");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  for (unsigned i = 1, e = LoopID->getNumOperands(); i < e; ++i) {</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  for (unsigned i = 1, e = LoopID->getNumOperands(); i < e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    MDNode *MD = dyn_cast<MDNode>(LoopID->getOperand(i));</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    MDNode *MD = dyn_cast<MDNode>(LoopID->getOperand(i));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    if (MD == nullptr)</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    if (MD == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">313</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline"></td>
    <td class="lineNumber">314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">    MDString *S = dyn_cast<MDString>(MD->getOperand(0));</td>
    <td class="lineNumber">315</td>
    <td class="codeline">    MDString *S = dyn_cast<MDString>(MD->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">    if (S == nullptr)</td>
    <td class="lineNumber">317</td>
    <td class="codeline">    if (S == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">318</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    if (S->getString() == "llvm.loop.pipeline.initiationinterval") {</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    if (S->getString() == "llvm.loop.pipeline.initiationinterval") {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">      assert(MD->getNumOperands() == 2 &&</td>
    <td class="lineNumber">321</td>
    <td class="codeline">      assert(MD->getNumOperands() == 2 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">             "Pipeline initiation interval hint metadata should have two operands.");</td>
    <td class="lineNumber">322</td>
    <td class="codeline">             "Pipeline initiation interval hint metadata should have two operands.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">      II_setByPragma =</td>
    <td class="lineNumber">323</td>
    <td class="codeline">      II_setByPragma =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">          mdconst::extract<ConstantInt>(MD->getOperand(1))->getZExtValue();</td>
    <td class="lineNumber">324</td>
    <td class="codeline">          mdconst::extract<ConstantInt>(MD->getOperand(1))->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">      assert(II_setByPragma >= 1 && "Pipeline initiation interval must be positive.");</td>
    <td class="lineNumber">325</td>
    <td class="codeline">      assert(II_setByPragma >= 1 && "Pipeline initiation interval must be positive.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">    } else if (S->getString() == "llvm.loop.pipeline.disable") {</td>
    <td class="lineNumber">326</td>
    <td class="codeline">    } else if (S->getString() == "llvm.loop.pipeline.disable") {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">      disabledByPragma = true;</td>
    <td class="lineNumber">327</td>
    <td class="codeline">      disabledByPragma = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">328</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">}</td>
    <td class="lineNumber">330</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline"></td>
    <td class="lineNumber">331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">/// Return true if the loop can be software pipelined.  The algorithm is</td>
    <td class="lineNumber">332</td>
    <td class="codeline">/// Return true if the loop can be software pipelined.  The algorithm is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">/// restricted to loops with a single basic block.  Make sure that the</td>
    <td class="lineNumber">333</td>
    <td class="codeline">/// restricted to loops with a single basic block.  Make sure that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">/// branch in the loop can be analyzed.</td>
    <td class="lineNumber">334</td>
    <td class="codeline">/// branch in the loop can be analyzed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {</td>
    <td class="lineNumber">335</td>
    <td class="codeline">bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  if (L.getNumBlocks() != 1) {</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  if (L.getNumBlocks() != 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">    ORE->emit([&]() {</td>
    <td class="lineNumber">337</td>
    <td class="codeline">    ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">338</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">339</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">             << "Not a single basic block: "</td>
    <td class="lineNumber">340</td>
    <td class="codeline">             << "Not a single basic block: "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">             << ore::NV("NumBlocks", L.getNumBlocks());</td>
    <td class="lineNumber">341</td>
    <td class="codeline">             << ore::NV("NumBlocks", L.getNumBlocks());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">342</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">343</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline"></td>
    <td class="lineNumber">345</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  if (disabledByPragma) {</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  if (disabledByPragma) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    ORE->emit([&]() {</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">348</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">349</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">             << "Disabled by Pragma.";</td>
    <td class="lineNumber">350</td>
    <td class="codeline">             << "Disabled by Pragma.";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">352</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  // Check if the branch can't be understood because we can't do pipelining</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  // Check if the branch can't be understood because we can't do pipelining</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  // if that's the case.</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  // if that's the case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">  LI.TBB = nullptr;</td>
    <td class="lineNumber">357</td>
    <td class="codeline">  LI.TBB = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  LI.FBB = nullptr;</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  LI.FBB = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  LI.BrCond.clear();</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  LI.BrCond.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  if (TII->analyzeBranch(*L.getHeader(), LI.TBB, LI.FBB, LI.BrCond)) {</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  if (TII->analyzeBranch(*L.getHeader(), LI.TBB, LI.FBB, LI.BrCond)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Unable to analyzeBranch, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Unable to analyzeBranch, can NOT pipeline Loop\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">    NumFailBranch++;</td>
    <td class="lineNumber">362</td>
    <td class="codeline">    NumFailBranch++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">    ORE->emit([&]() {</td>
    <td class="lineNumber">363</td>
    <td class="codeline">    ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">364</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">365</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">             << "The branch can't be understood";</td>
    <td class="lineNumber">366</td>
    <td class="codeline">             << "The branch can't be understood";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">367</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">368</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  LI.LoopInductionVar = nullptr;</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  LI.LoopInductionVar = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  LI.LoopCompare = nullptr;</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  LI.LoopCompare = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  LI.LoopPipelinerInfo = TII->analyzeLoopForPipelining(L.getTopBlock());</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  LI.LoopPipelinerInfo = TII->analyzeLoopForPipelining(L.getTopBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  if (!LI.LoopPipelinerInfo) {</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  if (!LI.LoopPipelinerInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Unable to analyzeLoop, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">375</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Unable to analyzeLoop, can NOT pipeline Loop\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">    NumFailLoop++;</td>
    <td class="lineNumber">376</td>
    <td class="codeline">    NumFailLoop++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">    ORE->emit([&]() {</td>
    <td class="lineNumber">377</td>
    <td class="codeline">    ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">378</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">379</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">             << "The loop structure is not supported";</td>
    <td class="lineNumber">380</td>
    <td class="codeline">             << "The loop structure is not supported";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">381</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">382</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  if (!L.getLoopPreheader()) {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  if (!L.getLoopPreheader()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Preheader not found, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Preheader not found, can NOT pipeline Loop\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">    NumFailPreheader++;</td>
    <td class="lineNumber">387</td>
    <td class="codeline">    NumFailPreheader++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">    ORE->emit([&]() {</td>
    <td class="lineNumber">388</td>
    <td class="codeline">    ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">389</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">390</td>
    <td class="codeline">                                               L.getStartLoc(), L.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">             << "No loop preheader found";</td>
    <td class="lineNumber">391</td>
    <td class="codeline">             << "No loop preheader found";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">392</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">393</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  // Remove any subregisters from inputs to phi nodes.</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  // Remove any subregisters from inputs to phi nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  preprocessPhiNodes(*L.getHeader());</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  preprocessPhiNodes(*L.getHeader());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">}</td>
    <td class="lineNumber">399</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline"></td>
    <td class="lineNumber">400</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">void MachinePipeliner::preprocessPhiNodes(MachineBasicBlock &B) {</td>
    <td class="lineNumber">401</td>
    <td class="codeline">void MachinePipeliner::preprocessPhiNodes(MachineBasicBlock &B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  MachineRegisterInfo &MRI = MF->getRegInfo();</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  MachineRegisterInfo &MRI = MF->getRegInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  SlotIndexes &Slots = *getAnalysis<LiveIntervals>().getSlotIndexes();</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  SlotIndexes &Slots = *getAnalysis<LiveIntervals>().getSlotIndexes();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline"></td>
    <td class="lineNumber">404</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  for (MachineInstr &PI : B.phis()) {</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  for (MachineInstr &PI : B.phis()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    MachineOperand &DefOp = PI.getOperand(0);</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    MachineOperand &DefOp = PI.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">    assert(DefOp.getSubReg() == 0);</td>
    <td class="lineNumber">407</td>
    <td class="codeline">    assert(DefOp.getSubReg() == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">    auto *RC = MRI.getRegClass(DefOp.getReg());</td>
    <td class="lineNumber">408</td>
    <td class="codeline">    auto *RC = MRI.getRegClass(DefOp.getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">    for (unsigned i = 1, n = PI.getNumOperands(); i != n; i += 2) {</td>
    <td class="lineNumber">410</td>
    <td class="codeline">    for (unsigned i = 1, n = PI.getNumOperands(); i != n; i += 2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">      MachineOperand &RegOp = PI.getOperand(i);</td>
    <td class="lineNumber">411</td>
    <td class="codeline">      MachineOperand &RegOp = PI.getOperand(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">      if (RegOp.getSubReg() == 0)</td>
    <td class="lineNumber">412</td>
    <td class="codeline">      if (RegOp.getSubReg() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">413</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline"></td>
    <td class="lineNumber">414</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">      // If the operand uses a subregister, replace it with a new register</td>
    <td class="lineNumber">415</td>
    <td class="codeline">      // If the operand uses a subregister, replace it with a new register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">      // without subregisters, and generate a copy to the new register.</td>
    <td class="lineNumber">416</td>
    <td class="codeline">      // without subregisters, and generate a copy to the new register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">      Register NewReg = MRI.createVirtualRegister(RC);</td>
    <td class="lineNumber">417</td>
    <td class="codeline">      Register NewReg = MRI.createVirtualRegister(RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">      MachineBasicBlock &PredB = *PI.getOperand(i+1).getMBB();</td>
    <td class="lineNumber">418</td>
    <td class="codeline">      MachineBasicBlock &PredB = *PI.getOperand(i+1).getMBB();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">      MachineBasicBlock::iterator At = PredB.getFirstTerminator();</td>
    <td class="lineNumber">419</td>
    <td class="codeline">      MachineBasicBlock::iterator At = PredB.getFirstTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">      const DebugLoc &DL = PredB.findDebugLoc(At);</td>
    <td class="lineNumber">420</td>
    <td class="codeline">      const DebugLoc &DL = PredB.findDebugLoc(At);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">      auto Copy = BuildMI(PredB, At, DL, TII->get(TargetOpcode::COPY), NewReg)</td>
    <td class="lineNumber">421</td>
    <td class="codeline">      auto Copy = BuildMI(PredB, At, DL, TII->get(TargetOpcode::COPY), NewReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">                    .addReg(RegOp.getReg(), getRegState(RegOp),</td>
    <td class="lineNumber">422</td>
    <td class="codeline">                    .addReg(RegOp.getReg(), getRegState(RegOp),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">                            RegOp.getSubReg());</td>
    <td class="lineNumber">423</td>
    <td class="codeline">                            RegOp.getSubReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">      Slots.insertMachineInstrInMaps(*Copy);</td>
    <td class="lineNumber">424</td>
    <td class="codeline">      Slots.insertMachineInstrInMaps(*Copy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">      RegOp.setReg(NewReg);</td>
    <td class="lineNumber">425</td>
    <td class="codeline">      RegOp.setReg(NewReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">      RegOp.setSubReg(0);</td>
    <td class="lineNumber">426</td>
    <td class="codeline">      RegOp.setSubReg(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">427</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">}</td>
    <td class="lineNumber">429</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline"></td>
    <td class="lineNumber">430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">/// The SMS algorithm consists of the following main steps:</td>
    <td class="lineNumber">431</td>
    <td class="codeline">/// The SMS algorithm consists of the following main steps:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">/// 1. Computation and analysis of the dependence graph.</td>
    <td class="lineNumber">432</td>
    <td class="codeline">/// 1. Computation and analysis of the dependence graph.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">/// 2. Ordering of the nodes (instructions).</td>
    <td class="lineNumber">433</td>
    <td class="codeline">/// 2. Ordering of the nodes (instructions).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">/// 3. Attempt to Schedule the loop.</td>
    <td class="lineNumber">434</td>
    <td class="codeline">/// 3. Attempt to Schedule the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">bool MachinePipeliner::swingModuloScheduler(MachineLoop &L) {</td>
    <td class="lineNumber">435</td>
    <td class="codeline">bool MachinePipeliner::swingModuloScheduler(MachineLoop &L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  assert(L.getBlocks().size() == 1 && "SMS works on single blocks only.");</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  assert(L.getBlocks().size() == 1 && "SMS works on single blocks only.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  SwingSchedulerDAG SMS(*this, L, getAnalysis<LiveIntervals>(), RegClassInfo,</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  SwingSchedulerDAG SMS(*this, L, getAnalysis<LiveIntervals>(), RegClassInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">                        II_setByPragma, LI.LoopPipelinerInfo.get());</td>
    <td class="lineNumber">439</td>
    <td class="codeline">                        II_setByPragma, LI.LoopPipelinerInfo.get());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  MachineBasicBlock *MBB = L.getHeader();</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  MachineBasicBlock *MBB = L.getHeader();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  // The kernel should not include any terminator instructions.  These</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  // The kernel should not include any terminator instructions.  These</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">  // will be added back later.</td>
    <td class="lineNumber">443</td>
    <td class="codeline">  // will be added back later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  SMS.startBlock(MBB);</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  SMS.startBlock(MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline"></td>
    <td class="lineNumber">445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  // Compute the number of 'real' instructions in the basic block by</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  // Compute the number of 'real' instructions in the basic block by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  // ignoring terminators.</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  // ignoring terminators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  unsigned size = MBB->size();</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  unsigned size = MBB->size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  for (MachineBasicBlock::iterator I = MBB->getFirstTerminator(),</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  for (MachineBasicBlock::iterator I = MBB->getFirstTerminator(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">                                   E = MBB->instr_end();</td>
    <td class="lineNumber">450</td>
    <td class="codeline">                                   E = MBB->instr_end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">       I != E; ++I, --size)</td>
    <td class="lineNumber">451</td>
    <td class="codeline">       I != E; ++I, --size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">    ;</td>
    <td class="lineNumber">452</td>
    <td class="codeline">    ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline"></td>
    <td class="lineNumber">453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  SMS.enterRegion(MBB, MBB->begin(), MBB->getFirstTerminator(), size);</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  SMS.enterRegion(MBB, MBB->begin(), MBB->getFirstTerminator(), size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  SMS.schedule();</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  SMS.schedule();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  SMS.exitRegion();</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  SMS.exitRegion();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">  SMS.finishBlock();</td>
    <td class="lineNumber">458</td>
    <td class="codeline">  SMS.finishBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  return SMS.hasNewSchedule();</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  return SMS.hasNewSchedule();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">}</td>
    <td class="lineNumber">460</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline"></td>
    <td class="lineNumber">461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">void MachinePipeliner::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">462</td>
    <td class="codeline">void MachinePipeliner::getAnalysisUsage(AnalysisUsage &AU) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  AU.addRequired<AAResultsWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  AU.addPreserved<AAResultsWrapperPass>();</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  AU.addPreserved<AAResultsWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  AU.addRequired<MachineLoopInfo>();</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  AU.addRequired<MachineLoopInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  AU.addRequired<MachineDominatorTree>();</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  AU.addRequired<MachineDominatorTree>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  AU.addRequired<LiveIntervals>();</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  AU.addRequired<LiveIntervals>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  MachineFunctionPass::getAnalysisUsage(AU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">}</td>
    <td class="lineNumber">470</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">void SwingSchedulerDAG::setMII(unsigned ResMII, unsigned RecMII) {</td>
    <td class="lineNumber">472</td>
    <td class="codeline">void SwingSchedulerDAG::setMII(unsigned ResMII, unsigned RecMII) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  if (SwpForceII > 0)</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  if (SwpForceII > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">    MII = SwpForceII;</td>
    <td class="lineNumber">474</td>
    <td class="codeline">    MII = SwpForceII;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  else if (II_setByPragma > 0)</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  else if (II_setByPragma > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">    MII = II_setByPragma;</td>
    <td class="lineNumber">476</td>
    <td class="codeline">    MII = II_setByPragma;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">    MII = std::max(ResMII, RecMII);</td>
    <td class="lineNumber">478</td>
    <td class="codeline">    MII = std::max(ResMII, RecMII);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">}</td>
    <td class="lineNumber">479</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">void SwingSchedulerDAG::setMAX_II() {</td>
    <td class="lineNumber">481</td>
    <td class="codeline">void SwingSchedulerDAG::setMAX_II() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  if (SwpForceII > 0)</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  if (SwpForceII > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">    MAX_II = SwpForceII;</td>
    <td class="lineNumber">483</td>
    <td class="codeline">    MAX_II = SwpForceII;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  else if (II_setByPragma > 0)</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  else if (II_setByPragma > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">    MAX_II = II_setByPragma;</td>
    <td class="lineNumber">485</td>
    <td class="codeline">    MAX_II = II_setByPragma;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">    MAX_II = MII + 10;</td>
    <td class="lineNumber">487</td>
    <td class="codeline">    MAX_II = MII + 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">}</td>
    <td class="lineNumber">488</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
    <td class="lineNumber">489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">/// We override the schedule function in ScheduleDAGInstrs to implement the</td>
    <td class="lineNumber">490</td>
    <td class="codeline">/// We override the schedule function in ScheduleDAGInstrs to implement the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">/// scheduling part of the Swing Modulo Scheduling algorithm.</td>
    <td class="lineNumber">491</td>
    <td class="codeline">/// scheduling part of the Swing Modulo Scheduling algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">void SwingSchedulerDAG::schedule() {</td>
    <td class="lineNumber">492</td>
    <td class="codeline">void SwingSchedulerDAG::schedule() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  AliasAnalysis *AA = &Pass.getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  AliasAnalysis *AA = &Pass.getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  buildSchedGraph(AA);</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  buildSchedGraph(AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  addLoopCarriedDependences(AA);</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  addLoopCarriedDependences(AA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  updatePhiDependences();</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  updatePhiDependences();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  Topo.InitDAGTopologicalSorting();</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  Topo.InitDAGTopologicalSorting();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  changeDependences();</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  changeDependences();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  postProcessDAG();</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  postProcessDAG();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  LLVM_DEBUG(dump());</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  LLVM_DEBUG(dump());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  NodeSetType NodeSets;</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  NodeSetType NodeSets;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  findCircuits(NodeSets);</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  findCircuits(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  NodeSetType Circuits = NodeSets;</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  NodeSetType Circuits = NodeSets;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  // Calculate the MII.</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  // Calculate the MII.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">  unsigned ResMII = calculateResMII();</td>
    <td class="lineNumber">507</td>
    <td class="codeline">  unsigned ResMII = calculateResMII();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  unsigned RecMII = calculateRecMII(NodeSets);</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  unsigned RecMII = calculateRecMII(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  fuseRecs(NodeSets);</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  fuseRecs(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  // This flag is used for testing and can cause correctness problems.</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  // This flag is used for testing and can cause correctness problems.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  if (SwpIgnoreRecMII)</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  if (SwpIgnoreRecMII)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">    RecMII = 0;</td>
    <td class="lineNumber">514</td>
    <td class="codeline">    RecMII = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  setMII(ResMII, RecMII);</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  setMII(ResMII, RecMII);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  setMAX_II();</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  setMAX_II();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline"></td>
    <td class="lineNumber">518</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "MII = " << MII << " MAX_II = " << MAX_II</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "MII = " << MII << " MAX_II = " << MAX_II</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">                    << " (rec=" << RecMII << ", res=" << ResMII << ")\n");</td>
    <td class="lineNumber">520</td>
    <td class="codeline">                    << " (rec=" << RecMII << ", res=" << ResMII << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline"></td>
    <td class="lineNumber">521</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  // Can't schedule a loop without a valid MII.</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  // Can't schedule a loop without a valid MII.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  if (MII == 0) {</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  if (MII == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Invalid Minimal Initiation Interval: 0\n");</td>
    <td class="lineNumber">524</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Invalid Minimal Initiation Interval: 0\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">    NumFailZeroMII++;</td>
    <td class="lineNumber">525</td>
    <td class="codeline">    NumFailZeroMII++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">526</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">527</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">528</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">             << "Invalid Minimal Initiation Interval: 0";</td>
    <td class="lineNumber">529</td>
    <td class="codeline">             << "Invalid Minimal Initiation Interval: 0";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">531</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  // Don't pipeline large loops.</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  // Don't pipeline large loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  if (SwpMaxMii != -1 && (int)MII > SwpMaxMii) {</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  if (SwpMaxMii != -1 && (int)MII > SwpMaxMii) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "MII > " << SwpMaxMii</td>
    <td class="lineNumber">536</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "MII > " << SwpMaxMii</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">                      << ", we don't pipeline large loops\n");</td>
    <td class="lineNumber">537</td>
    <td class="codeline">                      << ", we don't pipeline large loops\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">    NumFailLargeMaxMII++;</td>
    <td class="lineNumber">538</td>
    <td class="codeline">    NumFailLargeMaxMII++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">540</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">541</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">             << "Minimal Initiation Interval too large: "</td>
    <td class="lineNumber">542</td>
    <td class="codeline">             << "Minimal Initiation Interval too large: "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">             << ore::NV("MII", (int)MII) << " > "</td>
    <td class="lineNumber">543</td>
    <td class="codeline">             << ore::NV("MII", (int)MII) << " > "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">             << ore::NV("SwpMaxMii", SwpMaxMii) << "."</td>
    <td class="lineNumber">544</td>
    <td class="codeline">             << ore::NV("SwpMaxMii", SwpMaxMii) << "."</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">             << "Refer to -pipeliner-max-mii.";</td>
    <td class="lineNumber">545</td>
    <td class="codeline">             << "Refer to -pipeliner-max-mii.";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">546</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">547</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline"></td>
    <td class="lineNumber">549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  computeNodeFunctions(NodeSets);</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  computeNodeFunctions(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  registerPressureFilter(NodeSets);</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  registerPressureFilter(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline"></td>
    <td class="lineNumber">553</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  colocateNodeSets(NodeSets);</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  colocateNodeSets(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline"></td>
    <td class="lineNumber">555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  checkNodeSets(NodeSets);</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  checkNodeSets(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline"></td>
    <td class="lineNumber">557</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">558</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">    for (auto &I : NodeSets) {</td>
    <td class="lineNumber">559</td>
    <td class="codeline">    for (auto &I : NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">      dbgs() << "  Rec NodeSet ";</td>
    <td class="lineNumber">560</td>
    <td class="codeline">      dbgs() << "  Rec NodeSet ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">      I.dump();</td>
    <td class="lineNumber">561</td>
    <td class="codeline">      I.dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">562</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline"></td>
    <td class="lineNumber">564</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">  llvm::stable_sort(NodeSets, std::greater<NodeSet>());</td>
    <td class="lineNumber">565</td>
    <td class="codeline">  llvm::stable_sort(NodeSets, std::greater<NodeSet>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline"></td>
    <td class="lineNumber">566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  groupRemainingNodes(NodeSets);</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  groupRemainingNodes(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
    <td class="lineNumber">568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  removeDuplicateNodes(NodeSets);</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  removeDuplicateNodes(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">    for (auto &I : NodeSets) {</td>
    <td class="lineNumber">572</td>
    <td class="codeline">    for (auto &I : NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">      dbgs() << "  NodeSet ";</td>
    <td class="lineNumber">573</td>
    <td class="codeline">      dbgs() << "  NodeSet ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">      I.dump();</td>
    <td class="lineNumber">574</td>
    <td class="codeline">      I.dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">575</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline"></td>
    <td class="lineNumber">577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">  computeNodeOrder(NodeSets);</td>
    <td class="lineNumber">578</td>
    <td class="codeline">  computeNodeOrder(NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  // check for node order issues</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  // check for node order issues</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  checkValidNodeOrder(Circuits);</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  checkValidNodeOrder(Circuits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  SMSchedule Schedule(Pass.MF, this);</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  SMSchedule Schedule(Pass.MF, this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  Scheduled = schedulePipeline(Schedule);</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  Scheduled = schedulePipeline(Schedule);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
    <td class="lineNumber">585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  if (!Scheduled){</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  if (!Scheduled){</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "No schedule found, return\n");</td>
    <td class="lineNumber">587</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "No schedule found, return\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    NumFailNoSchedule++;</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    NumFailNoSchedule++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">589</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">590</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">591</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">             << "Unable to find schedule";</td>
    <td class="lineNumber">592</td>
    <td class="codeline">             << "Unable to find schedule";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline"></td>
    <td class="lineNumber">596</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">  unsigned numStages = Schedule.getMaxStageCount();</td>
    <td class="lineNumber">597</td>
    <td class="codeline">  unsigned numStages = Schedule.getMaxStageCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  // No need to generate pipeline if there are no overlapped iterations.</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  // No need to generate pipeline if there are no overlapped iterations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  if (numStages == 0) {</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  if (numStages == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "No overlapped iterations, skip.\n");</td>
    <td class="lineNumber">600</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "No overlapped iterations, skip.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">    NumFailZeroStage++;</td>
    <td class="lineNumber">601</td>
    <td class="codeline">    NumFailZeroStage++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">602</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">603</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">604</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">             << "No need to pipeline - no overlapped iterations in schedule.";</td>
    <td class="lineNumber">605</td>
    <td class="codeline">             << "No need to pipeline - no overlapped iterations in schedule.";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  // Check that the maximum stage count is less than user-defined limit.</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  // Check that the maximum stage count is less than user-defined limit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  if (SwpMaxStages > -1 && (int)numStages > SwpMaxStages) {</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  if (SwpMaxStages > -1 && (int)numStages > SwpMaxStages) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "numStages:" << numStages << ">" << SwpMaxStages</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "numStages:" << numStages << ">" << SwpMaxStages</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">                      << " : too many stages, abort\n");</td>
    <td class="lineNumber">612</td>
    <td class="codeline">                      << " : too many stages, abort\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">    NumFailLargeMaxStage++;</td>
    <td class="lineNumber">613</td>
    <td class="codeline">    NumFailLargeMaxStage++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">614</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">615</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">616</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">             << "Too many stages in schedule: "</td>
    <td class="lineNumber">617</td>
    <td class="codeline">             << "Too many stages in schedule: "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">             << ore::NV("numStages", (int)numStages) << " > "</td>
    <td class="lineNumber">618</td>
    <td class="codeline">             << ore::NV("numStages", (int)numStages) << " > "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">             << ore::NV("SwpMaxStages", SwpMaxStages)</td>
    <td class="lineNumber">619</td>
    <td class="codeline">             << ore::NV("SwpMaxStages", SwpMaxStages)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">             << ". Refer to -pipeliner-max-stages.";</td>
    <td class="lineNumber">620</td>
    <td class="codeline">             << ". Refer to -pipeliner-max-stages.";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">621</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">622</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  Pass.ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">    return MachineOptimizationRemark(DEBUG_TYPE, "schedule", Loop.getStartLoc(),</td>
    <td class="lineNumber">626</td>
    <td class="codeline">    return MachineOptimizationRemark(DEBUG_TYPE, "schedule", Loop.getStartLoc(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">                                     Loop.getHeader())</td>
    <td class="lineNumber">627</td>
    <td class="codeline">                                     Loop.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">           << "Pipelined succesfully!";</td>
    <td class="lineNumber">628</td>
    <td class="codeline">           << "Pipelined succesfully!";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  // Generate the schedule as a ModuloSchedule.</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  // Generate the schedule as a ModuloSchedule.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  DenseMap<MachineInstr *, int> Cycles, Stages;</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  DenseMap<MachineInstr *, int> Cycles, Stages;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  std::vector<MachineInstr *> OrderedInsts;</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  std::vector<MachineInstr *> OrderedInsts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  for (int Cycle = Schedule.getFirstCycle(); Cycle <= Schedule.getFinalCycle();</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  for (int Cycle = Schedule.getFirstCycle(); Cycle <= Schedule.getFinalCycle();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">       ++Cycle) {</td>
    <td class="lineNumber">635</td>
    <td class="codeline">       ++Cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    for (SUnit *SU : Schedule.getInstructions(Cycle)) {</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    for (SUnit *SU : Schedule.getInstructions(Cycle)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">      OrderedInsts.push_back(SU->getInstr());</td>
    <td class="lineNumber">637</td>
    <td class="codeline">      OrderedInsts.push_back(SU->getInstr());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">      Cycles[SU->getInstr()] = Cycle;</td>
    <td class="lineNumber">638</td>
    <td class="codeline">      Cycles[SU->getInstr()] = Cycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">      Stages[SU->getInstr()] = Schedule.stageScheduled(SU);</td>
    <td class="lineNumber">639</td>
    <td class="codeline">      Stages[SU->getInstr()] = Schedule.stageScheduled(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  DenseMap<MachineInstr *, std::pair<unsigned, int64_t>> NewInstrChanges;</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  DenseMap<MachineInstr *, std::pair<unsigned, int64_t>> NewInstrChanges;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  for (auto &KV : NewMIs) {</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  for (auto &KV : NewMIs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">    Cycles[KV.first] = Cycles[KV.second];</td>
    <td class="lineNumber">644</td>
    <td class="codeline">    Cycles[KV.first] = Cycles[KV.second];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">    Stages[KV.first] = Stages[KV.second];</td>
    <td class="lineNumber">645</td>
    <td class="codeline">    Stages[KV.first] = Stages[KV.second];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">    NewInstrChanges[KV.first] = InstrChanges[getSUnit(KV.first)];</td>
    <td class="lineNumber">646</td>
    <td class="codeline">    NewInstrChanges[KV.first] = InstrChanges[getSUnit(KV.first)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  ModuloSchedule MS(MF, &Loop, std::move(OrderedInsts), std::move(Cycles),</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  ModuloSchedule MS(MF, &Loop, std::move(OrderedInsts), std::move(Cycles),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">                    std::move(Stages));</td>
    <td class="lineNumber">650</td>
    <td class="codeline">                    std::move(Stages));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  if (EmitTestAnnotations) {</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  if (EmitTestAnnotations) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    assert(NewInstrChanges.empty() &&</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    assert(NewInstrChanges.empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">           "Cannot serialize a schedule with InstrChanges!");</td>
    <td class="lineNumber">653</td>
    <td class="codeline">           "Cannot serialize a schedule with InstrChanges!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    ModuloScheduleTestAnnotater MSTI(MF, MS);</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    ModuloScheduleTestAnnotater MSTI(MF, MS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">    MSTI.annotate();</td>
    <td class="lineNumber">655</td>
    <td class="codeline">    MSTI.annotate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">656</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  // The experimental code generator can't work if there are InstChanges.</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  // The experimental code generator can't work if there are InstChanges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  if (ExperimentalCodeGen && NewInstrChanges.empty()) {</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  if (ExperimentalCodeGen && NewInstrChanges.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">    PeelingModuloScheduleExpander MSE(MF, MS, &LIS);</td>
    <td class="lineNumber">660</td>
    <td class="codeline">    PeelingModuloScheduleExpander MSE(MF, MS, &LIS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">    MSE.expand();</td>
    <td class="lineNumber">661</td>
    <td class="codeline">    MSE.expand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">    ModuloScheduleExpander MSE(MF, MS, LIS, std::move(NewInstrChanges));</td>
    <td class="lineNumber">663</td>
    <td class="codeline">    ModuloScheduleExpander MSE(MF, MS, LIS, std::move(NewInstrChanges));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">    MSE.expand();</td>
    <td class="lineNumber">664</td>
    <td class="codeline">    MSE.expand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">    MSE.cleanup();</td>
    <td class="lineNumber">665</td>
    <td class="codeline">    MSE.cleanup();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  ++NumPipelined;</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  ++NumPipelined;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">}</td>
    <td class="lineNumber">668</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline"></td>
    <td class="lineNumber">669</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">/// Clean up after the software pipeliner runs.</td>
    <td class="lineNumber">670</td>
    <td class="codeline">/// Clean up after the software pipeliner runs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">void SwingSchedulerDAG::finishBlock() {</td>
    <td class="lineNumber">671</td>
    <td class="codeline">void SwingSchedulerDAG::finishBlock() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  for (auto &KV : NewMIs)</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  for (auto &KV : NewMIs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">    MF.deleteMachineInstr(KV.second);</td>
    <td class="lineNumber">673</td>
    <td class="codeline">    MF.deleteMachineInstr(KV.second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  NewMIs.clear();</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  NewMIs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  // Call the superclass.</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  // Call the superclass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  ScheduleDAGInstrs::finishBlock();</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  ScheduleDAGInstrs::finishBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">}</td>
    <td class="lineNumber">678</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline"></td>
    <td class="lineNumber">679</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">/// Return the register values for  the operands of a Phi instruction.</td>
    <td class="lineNumber">680</td>
    <td class="codeline">/// Return the register values for  the operands of a Phi instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">/// This function assume the instruction is a Phi.</td>
    <td class="lineNumber">681</td>
    <td class="codeline">/// This function assume the instruction is a Phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">static void getPhiRegs(MachineInstr &Phi, MachineBasicBlock *Loop,</td>
    <td class="lineNumber">682</td>
    <td class="codeline">static void getPhiRegs(MachineInstr &Phi, MachineBasicBlock *Loop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">                       unsigned &InitVal, unsigned &LoopVal) {</td>
    <td class="lineNumber">683</td>
    <td class="codeline">                       unsigned &InitVal, unsigned &LoopVal) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  InitVal = 0;</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  InitVal = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  LoopVal = 0;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  LoopVal = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">    if (Phi.getOperand(i + 1).getMBB() != Loop)</td>
    <td class="lineNumber">689</td>
    <td class="codeline">    if (Phi.getOperand(i + 1).getMBB() != Loop)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">      InitVal = Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">690</td>
    <td class="codeline">      InitVal = Phi.getOperand(i).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">691</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">      LoopVal = Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">692</td>
    <td class="codeline">      LoopVal = Phi.getOperand(i).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline"></td>
    <td class="lineNumber">693</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  assert(InitVal != 0 && LoopVal != 0 && "Unexpected Phi structure.");</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  assert(InitVal != 0 && LoopVal != 0 && "Unexpected Phi structure.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">}</td>
    <td class="lineNumber">695</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline"></td>
    <td class="lineNumber">696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">/// Return the Phi register value that comes the loop block.</td>
    <td class="lineNumber">697</td>
    <td class="codeline">/// Return the Phi register value that comes the loop block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">static unsigned getLoopPhiReg(MachineInstr &Phi, MachineBasicBlock *LoopBB) {</td>
    <td class="lineNumber">698</td>
    <td class="codeline">static unsigned getLoopPhiReg(MachineInstr &Phi, MachineBasicBlock *LoopBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">    if (Phi.getOperand(i + 1).getMBB() == LoopBB)</td>
    <td class="lineNumber">700</td>
    <td class="codeline">    if (Phi.getOperand(i + 1).getMBB() == LoopBB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">      return Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">701</td>
    <td class="codeline">      return Phi.getOperand(i).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">702</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">}</td>
    <td class="lineNumber">703</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">/// Return true if SUb can be reached from SUa following the chain edges.</td>
    <td class="lineNumber">705</td>
    <td class="codeline">/// Return true if SUb can be reached from SUa following the chain edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">static bool isSuccOrder(SUnit *SUa, SUnit *SUb) {</td>
    <td class="lineNumber">706</td>
    <td class="codeline">static bool isSuccOrder(SUnit *SUa, SUnit *SUb) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 8> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  SmallVector<SUnit *, 8> Worklist;</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  SmallVector<SUnit *, 8> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  Worklist.push_back(SUa);</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  Worklist.push_back(SUa);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">    const SUnit *SU = Worklist.pop_back_val();</td>
    <td class="lineNumber">711</td>
    <td class="codeline">    const SUnit *SU = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">    for (const auto &SI : SU->Succs) {</td>
    <td class="lineNumber">712</td>
    <td class="codeline">    for (const auto &SI : SU->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">      SUnit *SuccSU = SI.getSUnit();</td>
    <td class="lineNumber">713</td>
    <td class="codeline">      SUnit *SuccSU = SI.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">      if (SI.getKind() == SDep::Order) {</td>
    <td class="lineNumber">714</td>
    <td class="codeline">      if (SI.getKind() == SDep::Order) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">        if (Visited.count(SuccSU))</td>
    <td class="lineNumber">715</td>
    <td class="codeline">        if (Visited.count(SuccSU))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">        if (SuccSU == SUb)</td>
    <td class="lineNumber">717</td>
    <td class="codeline">        if (SuccSU == SUb)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">718</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">        Worklist.push_back(SuccSU);</td>
    <td class="lineNumber">719</td>
    <td class="codeline">        Worklist.push_back(SuccSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">        Visited.insert(SuccSU);</td>
    <td class="lineNumber">720</td>
    <td class="codeline">        Visited.insert(SuccSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">721</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">722</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">724</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">}</td>
    <td class="lineNumber">725</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">/// Return true if the instruction causes a chain between memory</td>
    <td class="lineNumber">727</td>
    <td class="codeline">/// Return true if the instruction causes a chain between memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">/// references before and after it.</td>
    <td class="lineNumber">728</td>
    <td class="codeline">/// references before and after it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">static bool isDependenceBarrier(MachineInstr &MI) {</td>
    <td class="lineNumber">729</td>
    <td class="codeline">static bool isDependenceBarrier(MachineInstr &MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  return MI.isCall() || MI.mayRaiseFPException() ||</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  return MI.isCall() || MI.mayRaiseFPException() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">         MI.hasUnmodeledSideEffects() ||</td>
    <td class="lineNumber">731</td>
    <td class="codeline">         MI.hasUnmodeledSideEffects() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">         (MI.hasOrderedMemoryRef() &&</td>
    <td class="lineNumber">732</td>
    <td class="codeline">         (MI.hasOrderedMemoryRef() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">          (!MI.mayLoad() || !MI.isDereferenceableInvariantLoad()));</td>
    <td class="lineNumber">733</td>
    <td class="codeline">          (!MI.mayLoad() || !MI.isDereferenceableInvariantLoad()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">}</td>
    <td class="lineNumber">734</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline"></td>
    <td class="lineNumber">735</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">/// Return the underlying objects for the memory references of an instruction.</td>
    <td class="lineNumber">736</td>
    <td class="codeline">/// Return the underlying objects for the memory references of an instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">/// This function calls the code in ValueTracking, but first checks that the</td>
    <td class="lineNumber">737</td>
    <td class="codeline">/// This function calls the code in ValueTracking, but first checks that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">/// instruction has a memory operand.</td>
    <td class="lineNumber">738</td>
    <td class="codeline">/// instruction has a memory operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">static void getUnderlyingObjects(const MachineInstr *MI,</td>
    <td class="lineNumber">739</td>
    <td class="codeline">static void getUnderlyingObjects(const MachineInstr *MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">                                 SmallVectorImpl<const Value *> &Objs) {</td>
    <td class="lineNumber">740</td>
    <td class="codeline">                                 SmallVectorImpl<const Value *> &Objs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  if (!MI->hasOneMemOperand())</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  if (!MI->hasOneMemOperand())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">  MachineMemOperand *MM = *MI->memoperands_begin();</td>
    <td class="lineNumber">743</td>
    <td class="codeline">  MachineMemOperand *MM = *MI->memoperands_begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  if (!MM->getValue())</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  if (!MM->getValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">745</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  getUnderlyingObjects(MM->getValue(), Objs);</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  getUnderlyingObjects(MM->getValue(), Objs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  for (const Value *V : Objs) {</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  for (const Value *V : Objs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">    if (!isIdentifiedObject(V)) {</td>
    <td class="lineNumber">748</td>
    <td class="codeline">    if (!isIdentifiedObject(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">      Objs.clear();</td>
    <td class="lineNumber">749</td>
    <td class="codeline">      Objs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">750</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    Objs.push_back(V);</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    Objs.push_back(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">}</td>
    <td class="lineNumber">754</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">/// Add a chain edge between a load and store if the store can be an</td>
    <td class="lineNumber">756</td>
    <td class="codeline">/// Add a chain edge between a load and store if the store can be an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">/// alias of the load on a subsequent iteration, i.e., a loop carried</td>
    <td class="lineNumber">757</td>
    <td class="codeline">/// alias of the load on a subsequent iteration, i.e., a loop carried</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">/// dependence. This code is very similar to the code in ScheduleDAGInstrs</td>
    <td class="lineNumber">758</td>
    <td class="codeline">/// dependence. This code is very similar to the code in ScheduleDAGInstrs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">/// but that code doesn't create loop carried dependences.</td>
    <td class="lineNumber">759</td>
    <td class="codeline">/// but that code doesn't create loop carried dependences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">void SwingSchedulerDAG::addLoopCarriedDependences(AliasAnalysis *AA) {</td>
    <td class="lineNumber">760</td>
    <td class="codeline">void SwingSchedulerDAG::addLoopCarriedDependences(AliasAnalysis *AA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">  MapVector<const Value *, SmallVector<SUnit *, 4>> PendingLoads;</td>
    <td class="lineNumber">761</td>
    <td class="codeline">  MapVector<const Value *, SmallVector<SUnit *, 4>> PendingLoads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">  Value *UnknownValue =</td>
    <td class="lineNumber">762</td>
    <td class="codeline">  Value *UnknownValue =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    UndefValue::get(Type::getVoidTy(MF.getFunction().getContext()));</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    UndefValue::get(Type::getVoidTy(MF.getFunction().getContext()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">  for (auto &SU : SUnits) {</td>
    <td class="lineNumber">764</td>
    <td class="codeline">  for (auto &SU : SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    MachineInstr &MI = *SU.getInstr();</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    MachineInstr &MI = *SU.getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    if (isDependenceBarrier(MI))</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    if (isDependenceBarrier(MI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">      PendingLoads.clear();</td>
    <td class="lineNumber">767</td>
    <td class="codeline">      PendingLoads.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    else if (MI.mayLoad()) {</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    else if (MI.mayLoad()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">      SmallVector<const Value *, 4> Objs;</td>
    <td class="lineNumber">769</td>
    <td class="codeline">      SmallVector<const Value *, 4> Objs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">      ::getUnderlyingObjects(&MI, Objs);</td>
    <td class="lineNumber">770</td>
    <td class="codeline">      ::getUnderlyingObjects(&MI, Objs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">      if (Objs.empty())</td>
    <td class="lineNumber">771</td>
    <td class="codeline">      if (Objs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">        Objs.push_back(UnknownValue);</td>
    <td class="lineNumber">772</td>
    <td class="codeline">        Objs.push_back(UnknownValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">      for (const auto *V : Objs) {</td>
    <td class="lineNumber">773</td>
    <td class="codeline">      for (const auto *V : Objs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">        SmallVector<SUnit *, 4> &SUs = PendingLoads[V];</td>
    <td class="lineNumber">774</td>
    <td class="codeline">        SmallVector<SUnit *, 4> &SUs = PendingLoads[V];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">        SUs.push_back(&SU);</td>
    <td class="lineNumber">775</td>
    <td class="codeline">        SUs.push_back(&SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">776</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">    } else if (MI.mayStore()) {</td>
    <td class="lineNumber">777</td>
    <td class="codeline">    } else if (MI.mayStore()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">      SmallVector<const Value *, 4> Objs;</td>
    <td class="lineNumber">778</td>
    <td class="codeline">      SmallVector<const Value *, 4> Objs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">      ::getUnderlyingObjects(&MI, Objs);</td>
    <td class="lineNumber">779</td>
    <td class="codeline">      ::getUnderlyingObjects(&MI, Objs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">      if (Objs.empty())</td>
    <td class="lineNumber">780</td>
    <td class="codeline">      if (Objs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">        Objs.push_back(UnknownValue);</td>
    <td class="lineNumber">781</td>
    <td class="codeline">        Objs.push_back(UnknownValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">      for (const auto *V : Objs) {</td>
    <td class="lineNumber">782</td>
    <td class="codeline">      for (const auto *V : Objs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">        MapVector<const Value *, SmallVector<SUnit *, 4>>::iterator I =</td>
    <td class="lineNumber">783</td>
    <td class="codeline">        MapVector<const Value *, SmallVector<SUnit *, 4>>::iterator I =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">            PendingLoads.find(V);</td>
    <td class="lineNumber">784</td>
    <td class="codeline">            PendingLoads.find(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">        if (I == PendingLoads.end())</td>
    <td class="lineNumber">785</td>
    <td class="codeline">        if (I == PendingLoads.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">786</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">        for (auto *Load : I->second) {</td>
    <td class="lineNumber">787</td>
    <td class="codeline">        for (auto *Load : I->second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">          if (isSuccOrder(Load, &SU))</td>
    <td class="lineNumber">788</td>
    <td class="codeline">          if (isSuccOrder(Load, &SU))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">789</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">          MachineInstr &LdMI = *Load->getInstr();</td>
    <td class="lineNumber">790</td>
    <td class="codeline">          MachineInstr &LdMI = *Load->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">          // First, perform the cheaper check that compares the base register.</td>
    <td class="lineNumber">791</td>
    <td class="codeline">          // First, perform the cheaper check that compares the base register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">          // If they are the same and the load offset is less than the store</td>
    <td class="lineNumber">792</td>
    <td class="codeline">          // If they are the same and the load offset is less than the store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">          // offset, then mark the dependence as loop carried potentially.</td>
    <td class="lineNumber">793</td>
    <td class="codeline">          // offset, then mark the dependence as loop carried potentially.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">          const MachineOperand *BaseOp1, *BaseOp2;</td>
    <td class="lineNumber">794</td>
    <td class="codeline">          const MachineOperand *BaseOp1, *BaseOp2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">          int64_t Offset1, Offset2;</td>
    <td class="lineNumber">795</td>
    <td class="codeline">          int64_t Offset1, Offset2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">          bool Offset1IsScalable, Offset2IsScalable;</td>
    <td class="lineNumber">796</td>
    <td class="codeline">          bool Offset1IsScalable, Offset2IsScalable;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">          if (TII->getMemOperandWithOffset(LdMI, BaseOp1, Offset1,</td>
    <td class="lineNumber">797</td>
    <td class="codeline">          if (TII->getMemOperandWithOffset(LdMI, BaseOp1, Offset1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">                                           Offset1IsScalable, TRI) &&</td>
    <td class="lineNumber">798</td>
    <td class="codeline">                                           Offset1IsScalable, TRI) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">              TII->getMemOperandWithOffset(MI, BaseOp2, Offset2,</td>
    <td class="lineNumber">799</td>
    <td class="codeline">              TII->getMemOperandWithOffset(MI, BaseOp2, Offset2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">                                           Offset2IsScalable, TRI)) {</td>
    <td class="lineNumber">800</td>
    <td class="codeline">                                           Offset2IsScalable, TRI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">            if (BaseOp1->isIdenticalTo(*BaseOp2) &&</td>
    <td class="lineNumber">801</td>
    <td class="codeline">            if (BaseOp1->isIdenticalTo(*BaseOp2) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">                Offset1IsScalable == Offset2IsScalable &&</td>
    <td class="lineNumber">802</td>
    <td class="codeline">                Offset1IsScalable == Offset2IsScalable &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">                (int)Offset1 < (int)Offset2) {</td>
    <td class="lineNumber">803</td>
    <td class="codeline">                (int)Offset1 < (int)Offset2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">              assert(TII->areMemAccessesTriviallyDisjoint(LdMI, MI) &&</td>
    <td class="lineNumber">804</td>
    <td class="codeline">              assert(TII->areMemAccessesTriviallyDisjoint(LdMI, MI) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">                     "What happened to the chain edge?");</td>
    <td class="lineNumber">805</td>
    <td class="codeline">                     "What happened to the chain edge?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">              SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">806</td>
    <td class="codeline">              SDep Dep(Load, SDep::Barrier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">              Dep.setLatency(1);</td>
    <td class="lineNumber">807</td>
    <td class="codeline">              Dep.setLatency(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">              SU.addPred(Dep);</td>
    <td class="lineNumber">808</td>
    <td class="codeline">              SU.addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">809</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">810</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">811</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">          // Second, the more expensive check that uses alias analysis on the</td>
    <td class="lineNumber">812</td>
    <td class="codeline">          // Second, the more expensive check that uses alias analysis on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">          // base registers. If they alias, and the load offset is less than</td>
    <td class="lineNumber">813</td>
    <td class="codeline">          // base registers. If they alias, and the load offset is less than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">          // the store offset, the mark the dependence as loop carried.</td>
    <td class="lineNumber">814</td>
    <td class="codeline">          // the store offset, the mark the dependence as loop carried.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">          if (!AA) {</td>
    <td class="lineNumber">815</td>
    <td class="codeline">          if (!AA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">816</td>
    <td class="codeline">            SDep Dep(Load, SDep::Barrier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">            Dep.setLatency(1);</td>
    <td class="lineNumber">817</td>
    <td class="codeline">            Dep.setLatency(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">            SU.addPred(Dep);</td>
    <td class="lineNumber">818</td>
    <td class="codeline">            SU.addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">819</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">820</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">          MachineMemOperand *MMO1 = *LdMI.memoperands_begin();</td>
    <td class="lineNumber">821</td>
    <td class="codeline">          MachineMemOperand *MMO1 = *LdMI.memoperands_begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">          MachineMemOperand *MMO2 = *MI.memoperands_begin();</td>
    <td class="lineNumber">822</td>
    <td class="codeline">          MachineMemOperand *MMO2 = *MI.memoperands_begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">          if (!MMO1->getValue() || !MMO2->getValue()) {</td>
    <td class="lineNumber">823</td>
    <td class="codeline">          if (!MMO1->getValue() || !MMO2->getValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">824</td>
    <td class="codeline">            SDep Dep(Load, SDep::Barrier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">            Dep.setLatency(1);</td>
    <td class="lineNumber">825</td>
    <td class="codeline">            Dep.setLatency(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">            SU.addPred(Dep);</td>
    <td class="lineNumber">826</td>
    <td class="codeline">            SU.addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">827</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">828</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">          if (MMO1->getValue() == MMO2->getValue() &&</td>
    <td class="lineNumber">829</td>
    <td class="codeline">          if (MMO1->getValue() == MMO2->getValue() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">              MMO1->getOffset() <= MMO2->getOffset()) {</td>
    <td class="lineNumber">830</td>
    <td class="codeline">              MMO1->getOffset() <= MMO2->getOffset()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">831</td>
    <td class="codeline">            SDep Dep(Load, SDep::Barrier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">            Dep.setLatency(1);</td>
    <td class="lineNumber">832</td>
    <td class="codeline">            Dep.setLatency(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">            SU.addPred(Dep);</td>
    <td class="lineNumber">833</td>
    <td class="codeline">            SU.addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">834</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">835</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">          if (!AA->isNoAlias(</td>
    <td class="lineNumber">836</td>
    <td class="codeline">          if (!AA->isNoAlias(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">                  MemoryLocation::getAfter(MMO1->getValue(), MMO1->getAAInfo()),</td>
    <td class="lineNumber">837</td>
    <td class="codeline">                  MemoryLocation::getAfter(MMO1->getValue(), MMO1->getAAInfo()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">                  MemoryLocation::getAfter(MMO2->getValue(),</td>
    <td class="lineNumber">838</td>
    <td class="codeline">                  MemoryLocation::getAfter(MMO2->getValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">                                           MMO2->getAAInfo()))) {</td>
    <td class="lineNumber">839</td>
    <td class="codeline">                                           MMO2->getAAInfo()))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">840</td>
    <td class="codeline">            SDep Dep(Load, SDep::Barrier);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">            Dep.setLatency(1);</td>
    <td class="lineNumber">841</td>
    <td class="codeline">            Dep.setLatency(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">            SU.addPred(Dep);</td>
    <td class="lineNumber">842</td>
    <td class="codeline">            SU.addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">843</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">844</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">845</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">846</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">}</td>
    <td class="lineNumber">848</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer</td>
    <td class="lineNumber">850</td>
    <td class="codeline">/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">/// processes dependences for PHIs. This function adds true dependences</td>
    <td class="lineNumber">851</td>
    <td class="codeline">/// processes dependences for PHIs. This function adds true dependences</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">/// from a PHI to a use, and a loop carried dependence from the use to the</td>
    <td class="lineNumber">852</td>
    <td class="codeline">/// from a PHI to a use, and a loop carried dependence from the use to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">/// PHI. The loop carried dependence is represented as an anti dependence</td>
    <td class="lineNumber">853</td>
    <td class="codeline">/// PHI. The loop carried dependence is represented as an anti dependence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">/// edge. This function also removes chain dependences between unrelated</td>
    <td class="lineNumber">854</td>
    <td class="codeline">/// edge. This function also removes chain dependences between unrelated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">/// PHIs.</td>
    <td class="lineNumber">855</td>
    <td class="codeline">/// PHIs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">void SwingSchedulerDAG::updatePhiDependences() {</td>
    <td class="lineNumber">856</td>
    <td class="codeline">void SwingSchedulerDAG::updatePhiDependences() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  SmallVector<SDep, 4> RemoveDeps;</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  SmallVector<SDep, 4> RemoveDeps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">  const TargetSubtargetInfo &ST = MF.getSubtarget<TargetSubtargetInfo>();</td>
    <td class="lineNumber">858</td>
    <td class="codeline">  const TargetSubtargetInfo &ST = MF.getSubtarget<TargetSubtargetInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  // Iterate over each DAG node.</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  // Iterate over each DAG node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  for (SUnit &I : SUnits) {</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  for (SUnit &I : SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">    RemoveDeps.clear();</td>
    <td class="lineNumber">862</td>
    <td class="codeline">    RemoveDeps.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">    // Set to true if the instruction has an operand defined by a Phi.</td>
    <td class="lineNumber">863</td>
    <td class="codeline">    // Set to true if the instruction has an operand defined by a Phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">    unsigned HasPhiUse = 0;</td>
    <td class="lineNumber">864</td>
    <td class="codeline">    unsigned HasPhiUse = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    unsigned HasPhiDef = 0;</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    unsigned HasPhiDef = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    MachineInstr *MI = I.getInstr();</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    MachineInstr *MI = I.getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    // Iterate over each operand, and we process the definitions.</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    // Iterate over each operand, and we process the definitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">    for (const MachineOperand &MO : MI->operands()) {</td>
    <td class="lineNumber">868</td>
    <td class="codeline">    for (const MachineOperand &MO : MI->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">      if (!MO.isReg())</td>
    <td class="lineNumber">869</td>
    <td class="codeline">      if (!MO.isReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">870</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">871</td>
    <td class="codeline">      Register Reg = MO.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">      if (MO.isDef()) {</td>
    <td class="lineNumber">872</td>
    <td class="codeline">      if (MO.isDef()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">        // If the register is used by a Phi, then create an anti dependence.</td>
    <td class="lineNumber">873</td>
    <td class="codeline">        // If the register is used by a Phi, then create an anti dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">        for (MachineRegisterInfo::use_instr_iterator</td>
    <td class="lineNumber">874</td>
    <td class="codeline">        for (MachineRegisterInfo::use_instr_iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">                 UI = MRI.use_instr_begin(Reg),</td>
    <td class="lineNumber">875</td>
    <td class="codeline">                 UI = MRI.use_instr_begin(Reg),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">                 UE = MRI.use_instr_end();</td>
    <td class="lineNumber">876</td>
    <td class="codeline">                 UE = MRI.use_instr_end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">             UI != UE; ++UI) {</td>
    <td class="lineNumber">877</td>
    <td class="codeline">             UI != UE; ++UI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">          MachineInstr *UseMI = &*UI;</td>
    <td class="lineNumber">878</td>
    <td class="codeline">          MachineInstr *UseMI = &*UI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">          SUnit *SU = getSUnit(UseMI);</td>
    <td class="lineNumber">879</td>
    <td class="codeline">          SUnit *SU = getSUnit(UseMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">          if (SU != nullptr && UseMI->isPHI()) {</td>
    <td class="lineNumber">880</td>
    <td class="codeline">          if (SU != nullptr && UseMI->isPHI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">            if (!MI->isPHI()) {</td>
    <td class="lineNumber">881</td>
    <td class="codeline">            if (!MI->isPHI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">              SDep Dep(SU, SDep::Anti, Reg);</td>
    <td class="lineNumber">882</td>
    <td class="codeline">              SDep Dep(SU, SDep::Anti, Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">              Dep.setLatency(1);</td>
    <td class="lineNumber">883</td>
    <td class="codeline">              Dep.setLatency(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">              I.addPred(Dep);</td>
    <td class="lineNumber">884</td>
    <td class="codeline">              I.addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">            } else {</td>
    <td class="lineNumber">885</td>
    <td class="codeline">            } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">              HasPhiDef = Reg;</td>
    <td class="lineNumber">886</td>
    <td class="codeline">              HasPhiDef = Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">              // Add a chain edge to a dependent Phi that isn't an existing</td>
    <td class="lineNumber">887</td>
    <td class="codeline">              // Add a chain edge to a dependent Phi that isn't an existing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">              // predecessor.</td>
    <td class="lineNumber">888</td>
    <td class="codeline">              // predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">              if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
    <td class="lineNumber">889</td>
    <td class="codeline">              if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">                I.addPred(SDep(SU, SDep::Barrier));</td>
    <td class="lineNumber">890</td>
    <td class="codeline">                I.addPred(SDep(SU, SDep::Barrier));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">891</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">892</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">893</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">      } else if (MO.isUse()) {</td>
    <td class="lineNumber">894</td>
    <td class="codeline">      } else if (MO.isUse()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">        // If the register is defined by a Phi, then create a true dependence.</td>
    <td class="lineNumber">895</td>
    <td class="codeline">        // If the register is defined by a Phi, then create a true dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">        MachineInstr *DefMI = MRI.getUniqueVRegDef(Reg);</td>
    <td class="lineNumber">896</td>
    <td class="codeline">        MachineInstr *DefMI = MRI.getUniqueVRegDef(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">        if (DefMI == nullptr)</td>
    <td class="lineNumber">897</td>
    <td class="codeline">        if (DefMI == nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">898</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">        SUnit *SU = getSUnit(DefMI);</td>
    <td class="lineNumber">899</td>
    <td class="codeline">        SUnit *SU = getSUnit(DefMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">        if (SU != nullptr && DefMI->isPHI()) {</td>
    <td class="lineNumber">900</td>
    <td class="codeline">        if (SU != nullptr && DefMI->isPHI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">          if (!MI->isPHI()) {</td>
    <td class="lineNumber">901</td>
    <td class="codeline">          if (!MI->isPHI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">            SDep Dep(SU, SDep::Data, Reg);</td>
    <td class="lineNumber">902</td>
    <td class="codeline">            SDep Dep(SU, SDep::Data, Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">            Dep.setLatency(0);</td>
    <td class="lineNumber">903</td>
    <td class="codeline">            Dep.setLatency(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">            ST.adjustSchedDependency(SU, 0, &I, MO.getOperandNo(), Dep);</td>
    <td class="lineNumber">904</td>
    <td class="codeline">            ST.adjustSchedDependency(SU, 0, &I, MO.getOperandNo(), Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">            I.addPred(Dep);</td>
    <td class="lineNumber">905</td>
    <td class="codeline">            I.addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">          } else {</td>
    <td class="lineNumber">906</td>
    <td class="codeline">          } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">            HasPhiUse = Reg;</td>
    <td class="lineNumber">907</td>
    <td class="codeline">            HasPhiUse = Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">            // Add a chain edge to a dependent Phi that isn't an existing</td>
    <td class="lineNumber">908</td>
    <td class="codeline">            // Add a chain edge to a dependent Phi that isn't an existing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">            // predecessor.</td>
    <td class="lineNumber">909</td>
    <td class="codeline">            // predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">            if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
    <td class="lineNumber">910</td>
    <td class="codeline">            if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">              I.addPred(SDep(SU, SDep::Barrier));</td>
    <td class="lineNumber">911</td>
    <td class="codeline">              I.addPred(SDep(SU, SDep::Barrier));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">912</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">913</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">914</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">915</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">    // Remove order dependences from an unrelated Phi.</td>
    <td class="lineNumber">916</td>
    <td class="codeline">    // Remove order dependences from an unrelated Phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">    if (!SwpPruneDeps)</td>
    <td class="lineNumber">917</td>
    <td class="codeline">    if (!SwpPruneDeps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">918</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">    for (auto &PI : I.Preds) {</td>
    <td class="lineNumber">919</td>
    <td class="codeline">    for (auto &PI : I.Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">      MachineInstr *PMI = PI.getSUnit()->getInstr();</td>
    <td class="lineNumber">920</td>
    <td class="codeline">      MachineInstr *PMI = PI.getSUnit()->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">      if (PMI->isPHI() && PI.getKind() == SDep::Order) {</td>
    <td class="lineNumber">921</td>
    <td class="codeline">      if (PMI->isPHI() && PI.getKind() == SDep::Order) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">        if (I.getInstr()->isPHI()) {</td>
    <td class="lineNumber">922</td>
    <td class="codeline">        if (I.getInstr()->isPHI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">          if (PMI->getOperand(0).getReg() == HasPhiUse)</td>
    <td class="lineNumber">923</td>
    <td class="codeline">          if (PMI->getOperand(0).getReg() == HasPhiUse)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">924</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">          if (getLoopPhiReg(*PMI, PMI->getParent()) == HasPhiDef)</td>
    <td class="lineNumber">925</td>
    <td class="codeline">          if (getLoopPhiReg(*PMI, PMI->getParent()) == HasPhiDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">926</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">927</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">        RemoveDeps.push_back(PI);</td>
    <td class="lineNumber">928</td>
    <td class="codeline">        RemoveDeps.push_back(PI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">929</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">930</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">    for (int i = 0, e = RemoveDeps.size(); i != e; ++i)</td>
    <td class="lineNumber">931</td>
    <td class="codeline">    for (int i = 0, e = RemoveDeps.size(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">      I.removePred(RemoveDeps[i]);</td>
    <td class="lineNumber">932</td>
    <td class="codeline">      I.removePred(RemoveDeps[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">933</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">}</td>
    <td class="lineNumber">934</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline"></td>
    <td class="lineNumber">935</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">/// Iterate over each DAG node and see if we can change any dependences</td>
    <td class="lineNumber">936</td>
    <td class="codeline">/// Iterate over each DAG node and see if we can change any dependences</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">/// in order to reduce the recurrence MII.</td>
    <td class="lineNumber">937</td>
    <td class="codeline">/// in order to reduce the recurrence MII.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">void SwingSchedulerDAG::changeDependences() {</td>
    <td class="lineNumber">938</td>
    <td class="codeline">void SwingSchedulerDAG::changeDependences() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  // See if an instruction can use a value from the previous iteration.</td>
    <td class="lineNumber">939</td>
    <td class="codeline">  // See if an instruction can use a value from the previous iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">  // If so, we update the base and offset of the instruction and change</td>
    <td class="lineNumber">940</td>
    <td class="codeline">  // If so, we update the base and offset of the instruction and change</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">  // the dependences.</td>
    <td class="lineNumber">941</td>
    <td class="codeline">  // the dependences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  for (SUnit &I : SUnits) {</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  for (SUnit &I : SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">    unsigned BasePos = 0, OffsetPos = 0, NewBase = 0;</td>
    <td class="lineNumber">943</td>
    <td class="codeline">    unsigned BasePos = 0, OffsetPos = 0, NewBase = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">    int64_t NewOffset = 0;</td>
    <td class="lineNumber">944</td>
    <td class="codeline">    int64_t NewOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">    if (!canUseLastOffsetValue(I.getInstr(), BasePos, OffsetPos, NewBase,</td>
    <td class="lineNumber">945</td>
    <td class="codeline">    if (!canUseLastOffsetValue(I.getInstr(), BasePos, OffsetPos, NewBase,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">                               NewOffset))</td>
    <td class="lineNumber">946</td>
    <td class="codeline">                               NewOffset))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">947</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline"></td>
    <td class="lineNumber">948</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">    // Get the MI and SUnit for the instruction that defines the original base.</td>
    <td class="lineNumber">949</td>
    <td class="codeline">    // Get the MI and SUnit for the instruction that defines the original base.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">    Register OrigBase = I.getInstr()->getOperand(BasePos).getReg();</td>
    <td class="lineNumber">950</td>
    <td class="codeline">    Register OrigBase = I.getInstr()->getOperand(BasePos).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">    MachineInstr *DefMI = MRI.getUniqueVRegDef(OrigBase);</td>
    <td class="lineNumber">951</td>
    <td class="codeline">    MachineInstr *DefMI = MRI.getUniqueVRegDef(OrigBase);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">    if (!DefMI)</td>
    <td class="lineNumber">952</td>
    <td class="codeline">    if (!DefMI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">953</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">    SUnit *DefSU = getSUnit(DefMI);</td>
    <td class="lineNumber">954</td>
    <td class="codeline">    SUnit *DefSU = getSUnit(DefMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">    if (!DefSU)</td>
    <td class="lineNumber">955</td>
    <td class="codeline">    if (!DefSU)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">956</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">    // Get the MI and SUnit for the instruction that defins the new base.</td>
    <td class="lineNumber">957</td>
    <td class="codeline">    // Get the MI and SUnit for the instruction that defins the new base.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">    MachineInstr *LastMI = MRI.getUniqueVRegDef(NewBase);</td>
    <td class="lineNumber">958</td>
    <td class="codeline">    MachineInstr *LastMI = MRI.getUniqueVRegDef(NewBase);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">    if (!LastMI)</td>
    <td class="lineNumber">959</td>
    <td class="codeline">    if (!LastMI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">960</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">    SUnit *LastSU = getSUnit(LastMI);</td>
    <td class="lineNumber">961</td>
    <td class="codeline">    SUnit *LastSU = getSUnit(LastMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">    if (!LastSU)</td>
    <td class="lineNumber">962</td>
    <td class="codeline">    if (!LastSU)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">963</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
    <td class="lineNumber">964</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">    if (Topo.IsReachable(&I, LastSU))</td>
    <td class="lineNumber">965</td>
    <td class="codeline">    if (Topo.IsReachable(&I, LastSU))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">966</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">    // Remove the dependence. The value now depends on a prior iteration.</td>
    <td class="lineNumber">968</td>
    <td class="codeline">    // Remove the dependence. The value now depends on a prior iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">    SmallVector<SDep, 4> Deps;</td>
    <td class="lineNumber">969</td>
    <td class="codeline">    SmallVector<SDep, 4> Deps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">    for (const SDep &P : I.Preds)</td>
    <td class="lineNumber">970</td>
    <td class="codeline">    for (const SDep &P : I.Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">      if (P.getSUnit() == DefSU)</td>
    <td class="lineNumber">971</td>
    <td class="codeline">      if (P.getSUnit() == DefSU)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">        Deps.push_back(P);</td>
    <td class="lineNumber">972</td>
    <td class="codeline">        Deps.push_back(P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
    <td class="lineNumber">973</td>
    <td class="codeline">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">      Topo.RemovePred(&I, Deps[i].getSUnit());</td>
    <td class="lineNumber">974</td>
    <td class="codeline">      Topo.RemovePred(&I, Deps[i].getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">      I.removePred(Deps[i]);</td>
    <td class="lineNumber">975</td>
    <td class="codeline">      I.removePred(Deps[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">976</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">    // Remove the chain dependence between the instructions.</td>
    <td class="lineNumber">977</td>
    <td class="codeline">    // Remove the chain dependence between the instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">    Deps.clear();</td>
    <td class="lineNumber">978</td>
    <td class="codeline">    Deps.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">    for (auto &P : LastSU->Preds)</td>
    <td class="lineNumber">979</td>
    <td class="codeline">    for (auto &P : LastSU->Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">      if (P.getSUnit() == &I && P.getKind() == SDep::Order)</td>
    <td class="lineNumber">980</td>
    <td class="codeline">      if (P.getSUnit() == &I && P.getKind() == SDep::Order)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">        Deps.push_back(P);</td>
    <td class="lineNumber">981</td>
    <td class="codeline">        Deps.push_back(P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
    <td class="lineNumber">982</td>
    <td class="codeline">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">      Topo.RemovePred(LastSU, Deps[i].getSUnit());</td>
    <td class="lineNumber">983</td>
    <td class="codeline">      Topo.RemovePred(LastSU, Deps[i].getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">      LastSU->removePred(Deps[i]);</td>
    <td class="lineNumber">984</td>
    <td class="codeline">      LastSU->removePred(Deps[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">985</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline"></td>
    <td class="lineNumber">986</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">    // Add a dependence between the new instruction and the instruction</td>
    <td class="lineNumber">987</td>
    <td class="codeline">    // Add a dependence between the new instruction and the instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">    // that defines the new base.</td>
    <td class="lineNumber">988</td>
    <td class="codeline">    // that defines the new base.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">    SDep Dep(&I, SDep::Anti, NewBase);</td>
    <td class="lineNumber">989</td>
    <td class="codeline">    SDep Dep(&I, SDep::Anti, NewBase);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">    Topo.AddPred(LastSU, &I);</td>
    <td class="lineNumber">990</td>
    <td class="codeline">    Topo.AddPred(LastSU, &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    LastSU->addPred(Dep);</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    LastSU->addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">    // Remember the base and offset information so that we can update the</td>
    <td class="lineNumber">993</td>
    <td class="codeline">    // Remember the base and offset information so that we can update the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">    // instruction during code generation.</td>
    <td class="lineNumber">994</td>
    <td class="codeline">    // instruction during code generation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    InstrChanges[&I] = std::make_pair(NewBase, NewOffset);</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    InstrChanges[&I] = std::make_pair(NewBase, NewOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">}</td>
    <td class="lineNumber">997</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline"></td>
    <td class="lineNumber">998</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">999</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline"></td>
    <td class="lineNumber">1000</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">// FuncUnitSorter - Comparison operator used to sort instructions by</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">// FuncUnitSorter - Comparison operator used to sort instructions by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">// the number of functional unit choices.</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">// the number of functional unit choices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">struct FuncUnitSorter {</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">struct FuncUnitSorter {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">  const InstrItineraryData *InstrItins;</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">  const InstrItineraryData *InstrItins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  const MCSubtargetInfo *STI;</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  const MCSubtargetInfo *STI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">  DenseMap<InstrStage::FuncUnits, unsigned> Resources;</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">  DenseMap<InstrStage::FuncUnits, unsigned> Resources;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline"></td>
    <td class="lineNumber">1007</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">  FuncUnitSorter(const TargetSubtargetInfo &TSI)</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">  FuncUnitSorter(const TargetSubtargetInfo &TSI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">      : InstrItins(TSI.getInstrItineraryData()), STI(&TSI) {}</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">      : InstrItins(TSI.getInstrItineraryData()), STI(&TSI) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
    <td class="lineNumber">1010</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  // Compute the number of functional unit alternatives needed</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  // Compute the number of functional unit alternatives needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  // at each stage, and take the minimum value. We prioritize the</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  // at each stage, and take the minimum value. We prioritize the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">  // instructions by the least number of choices first.</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">  // instructions by the least number of choices first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  unsigned minFuncUnits(const MachineInstr *Inst,</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  unsigned minFuncUnits(const MachineInstr *Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">                        InstrStage::FuncUnits &F) const {</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">                        InstrStage::FuncUnits &F) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">    unsigned SchedClass = Inst->getDesc().getSchedClass();</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">    unsigned SchedClass = Inst->getDesc().getSchedClass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">    unsigned min = UINT_MAX;</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">    unsigned min = UINT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">    if (InstrItins && !InstrItins->isEmpty()) {</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">    if (InstrItins && !InstrItins->isEmpty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">      for (const InstrStage &IS :</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">      for (const InstrStage &IS :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">           make_range(InstrItins->beginStage(SchedClass),</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">           make_range(InstrItins->beginStage(SchedClass),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">                      InstrItins->endStage(SchedClass))) {</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">                      InstrItins->endStage(SchedClass))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">        InstrStage::FuncUnits funcUnits = IS.getUnits();</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">        InstrStage::FuncUnits funcUnits = IS.getUnits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">        unsigned numAlternatives = llvm::popcount(funcUnits);</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">        unsigned numAlternatives = llvm::popcount(funcUnits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">        if (numAlternatives < min) {</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">        if (numAlternatives < min) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">          min = numAlternatives;</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">          min = numAlternatives;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">          F = funcUnits;</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">          F = funcUnits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">      return min;</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">      return min;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">      const MCSchedClassDesc *SCDesc =</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">      const MCSchedClassDesc *SCDesc =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">      if (!SCDesc->isValid())</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">      if (!SCDesc->isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">        // No valid Schedule Class Desc for schedClass, should be</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">        // No valid Schedule Class Desc for schedClass, should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">        // Pseudo/PostRAPseudo</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">        // Pseudo/PostRAPseudo</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">        return min;</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">        return min;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline"></td>
    <td class="lineNumber">1038</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">      for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">      for (const MCWriteProcResEntry &PRE :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">                      STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">                      STI->getWriteProcResEnd(SCDesc))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">        if (!PRE.Cycles)</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">        if (!PRE.Cycles)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">        const MCProcResourceDesc *ProcResource =</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">        const MCProcResourceDesc *ProcResource =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">            STI->getSchedModel().getProcResource(PRE.ProcResourceIdx);</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">            STI->getSchedModel().getProcResource(PRE.ProcResourceIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">        unsigned NumUnits = ProcResource->NumUnits;</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">        unsigned NumUnits = ProcResource->NumUnits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">        if (NumUnits < min) {</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">        if (NumUnits < min) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">          min = NumUnits;</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">          min = NumUnits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">          F = PRE.ProcResourceIdx;</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">          F = PRE.ProcResourceIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">      return min;</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">      return min;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline"></td>
    <td class="lineNumber">1056</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  // Compute the critical resources needed by the instruction. This</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  // Compute the critical resources needed by the instruction. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  // function records the functional units needed by instructions that</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  // function records the functional units needed by instructions that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  // must use only one functional unit. We use this as a tie breaker</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  // must use only one functional unit. We use this as a tie breaker</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  // for computing the resource MII. The instrutions that require</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  // for computing the resource MII. The instrutions that require</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  // the same, highly used, functional unit have high priority.</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  // the same, highly used, functional unit have high priority.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  void calcCriticalResources(MachineInstr &MI) {</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  void calcCriticalResources(MachineInstr &MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">    unsigned SchedClass = MI.getDesc().getSchedClass();</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">    unsigned SchedClass = MI.getDesc().getSchedClass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">    if (InstrItins && !InstrItins->isEmpty()) {</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">    if (InstrItins && !InstrItins->isEmpty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">      for (const InstrStage &IS :</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">      for (const InstrStage &IS :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">           make_range(InstrItins->beginStage(SchedClass),</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">           make_range(InstrItins->beginStage(SchedClass),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">                      InstrItins->endStage(SchedClass))) {</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">                      InstrItins->endStage(SchedClass))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">        InstrStage::FuncUnits FuncUnits = IS.getUnits();</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">        InstrStage::FuncUnits FuncUnits = IS.getUnits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">        if (llvm::popcount(FuncUnits) == 1)</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">        if (llvm::popcount(FuncUnits) == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">          Resources[FuncUnits]++;</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">          Resources[FuncUnits]++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">      const MCSchedClassDesc *SCDesc =</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">      const MCSchedClassDesc *SCDesc =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">      if (!SCDesc->isValid())</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">      if (!SCDesc->isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">        // No valid Schedule Class Desc for schedClass, should be</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">        // No valid Schedule Class Desc for schedClass, should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">        // Pseudo/PostRAPseudo</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">        // Pseudo/PostRAPseudo</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">        return;</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">        return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">      for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">      for (const MCWriteProcResEntry &PRE :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">                      STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">                      STI->getWriteProcResEnd(SCDesc))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">        if (!PRE.Cycles)</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">        if (!PRE.Cycles)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">        Resources[PRE.ProcResourceIdx]++;</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">        Resources[PRE.ProcResourceIdx]++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline"></td>
    <td class="lineNumber">1093</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">  /// Return true if IS1 has less priority than IS2.</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">  /// Return true if IS1 has less priority than IS2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">  bool operator()(const MachineInstr *IS1, const MachineInstr *IS2) const {</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">  bool operator()(const MachineInstr *IS1, const MachineInstr *IS2) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">    InstrStage::FuncUnits F1 = 0, F2 = 0;</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">    InstrStage::FuncUnits F1 = 0, F2 = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">    unsigned MFUs1 = minFuncUnits(IS1, F1);</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">    unsigned MFUs1 = minFuncUnits(IS1, F1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">    unsigned MFUs2 = minFuncUnits(IS2, F2);</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">    unsigned MFUs2 = minFuncUnits(IS2, F2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">    if (MFUs1 == MFUs2)</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">    if (MFUs1 == MFUs2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">      return Resources.lookup(F1) < Resources.lookup(F2);</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">      return Resources.lookup(F1) < Resources.lookup(F2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    return MFUs1 > MFUs2;</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    return MFUs1 > MFUs2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline"></td>
    <td class="lineNumber">1106</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">/// Calculate the resource constrained minimum initiation interval for the</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">/// Calculate the resource constrained minimum initiation interval for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">/// specified loop. We use the DFA to model the resources needed for</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">/// specified loop. We use the DFA to model the resources needed for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">/// each instruction, and we ignore dependences. A different DFA is created</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">/// each instruction, and we ignore dependences. A different DFA is created</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">/// for each cycle that is required. When adding a new instruction, we attempt</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">/// for each cycle that is required. When adding a new instruction, we attempt</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">/// to add it to each existing DFA, until a legal space is found. If the</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">/// to add it to each existing DFA, until a legal space is found. If the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">/// instruction cannot be reserved in an existing DFA, we create a new one.</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">/// instruction cannot be reserved in an existing DFA, we create a new one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">unsigned SwingSchedulerDAG::calculateResMII() {</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">unsigned SwingSchedulerDAG::calculateResMII() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "calculateResMII:\n");</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "calculateResMII:\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  ResourceManager RM(&MF.getSubtarget(), this);</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  ResourceManager RM(&MF.getSubtarget(), this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  return RM.calculateResMII();</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  return RM.calculateResMII();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline"></td>
    <td class="lineNumber">1118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">/// Calculate the recurrence-constrainted minimum initiation interval.</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">/// Calculate the recurrence-constrainted minimum initiation interval.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">/// Iterate over each circuit.  Compute the delay(c) and distance(c)</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">/// Iterate over each circuit.  Compute the delay(c) and distance(c)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">/// for each circuit. The II needs to satisfy the inequality</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">/// for each circuit. The II needs to satisfy the inequality</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">/// delay(c) - II*distance(c) <= 0. For each circuit, choose the smallest</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">/// delay(c) - II*distance(c) <= 0. For each circuit, choose the smallest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">/// II that satisfies the inequality, and the RecMII is the maximum</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">/// II that satisfies the inequality, and the RecMII is the maximum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">/// of those values.</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">/// of those values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">unsigned SwingSchedulerDAG::calculateRecMII(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">unsigned SwingSchedulerDAG::calculateRecMII(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  unsigned RecMII = 0;</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  unsigned RecMII = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline"></td>
    <td class="lineNumber">1127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  for (NodeSet &Nodes : NodeSets) {</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  for (NodeSet &Nodes : NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">    if (Nodes.empty())</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">    if (Nodes.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline"></td>
    <td class="lineNumber">1131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">    unsigned Delay = Nodes.getLatency();</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">    unsigned Delay = Nodes.getLatency();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">    unsigned Distance = 1;</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">    unsigned Distance = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline"></td>
    <td class="lineNumber">1134</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    // ii = ceil(delay / distance)</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    // ii = ceil(delay / distance)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">    unsigned CurMII = (Delay + Distance - 1) / Distance;</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">    unsigned CurMII = (Delay + Distance - 1) / Distance;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">    Nodes.setRecMII(CurMII);</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">    Nodes.setRecMII(CurMII);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">    if (CurMII > RecMII)</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">    if (CurMII > RecMII)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">      RecMII = CurMII;</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">      RecMII = CurMII;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  return RecMII;</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  return RecMII;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">/// Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">/// Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">/// but we do this to find the circuits, and then change them back.</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">/// but we do this to find the circuits, and then change them back.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">static void swapAntiDependences(std::vector<SUnit> &SUnits) {</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">static void swapAntiDependences(std::vector<SUnit> &SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">  SmallVector<std::pair<SUnit *, SDep>, 8> DepsAdded;</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">  SmallVector<std::pair<SUnit *, SDep>, 8> DepsAdded;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  for (SUnit &SU : SUnits) {</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  for (SUnit &SU : SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">    for (SDep &Pred : SU.Preds)</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">    for (SDep &Pred : SU.Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">      if (Pred.getKind() == SDep::Anti)</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">      if (Pred.getKind() == SDep::Anti)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">        DepsAdded.push_back(std::make_pair(&SU, Pred));</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">        DepsAdded.push_back(std::make_pair(&SU, Pred));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  for (std::pair<SUnit *, SDep> &P : DepsAdded) {</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  for (std::pair<SUnit *, SDep> &P : DepsAdded) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">    // Remove this anti dependency and add one in the reverse direction.</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">    // Remove this anti dependency and add one in the reverse direction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">    SUnit *SU = P.first;</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">    SUnit *SU = P.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">    SDep &D = P.second;</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">    SDep &D = P.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">    SUnit *TargetSU = D.getSUnit();</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">    SUnit *TargetSU = D.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">    unsigned Reg = D.getReg();</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">    unsigned Reg = D.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">    unsigned Lat = D.getLatency();</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">    unsigned Lat = D.getLatency();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">    SU->removePred(D);</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">    SU->removePred(D);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">    SDep Dep(SU, SDep::Anti, Reg);</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">    SDep Dep(SU, SDep::Anti, Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">    Dep.setLatency(Lat);</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">    Dep.setLatency(Lat);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">    TargetSU->addPred(Dep);</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">    TargetSU->addPred(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline"></td>
    <td class="lineNumber">1167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">/// Create the adjacency structure of the nodes in the graph.</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">/// Create the adjacency structure of the nodes in the graph.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">void SwingSchedulerDAG::Circuits::createAdjacencyStructure(</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">void SwingSchedulerDAG::Circuits::createAdjacencyStructure(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">    SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">    SwingSchedulerDAG *DAG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  BitVector Added(SUnits.size());</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  BitVector Added(SUnits.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  DenseMap<int, int> OutputDeps;</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  DenseMap<int, int> OutputDeps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">    Added.reset();</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">    Added.reset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">    // Add any successor to the adjacency matrix and exclude duplicates.</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">    // Add any successor to the adjacency matrix and exclude duplicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">    for (auto &SI : SUnits[i].Succs) {</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">    for (auto &SI : SUnits[i].Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">      // Only create a back-edge on the first and last nodes of a dependence</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">      // Only create a back-edge on the first and last nodes of a dependence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">      // chain. This records any chains and adds them later.</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">      // chain. This records any chains and adds them later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">      if (SI.getKind() == SDep::Output) {</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">      if (SI.getKind() == SDep::Output) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">        int N = SI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">        int N = SI.getSUnit()->NodeNum;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">        int BackEdge = i;</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">        int BackEdge = i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">        auto Dep = OutputDeps.find(BackEdge);</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">        auto Dep = OutputDeps.find(BackEdge);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">        if (Dep != OutputDeps.end()) {</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">        if (Dep != OutputDeps.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">          BackEdge = Dep->second;</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">          BackEdge = Dep->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">          OutputDeps.erase(Dep);</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">          OutputDeps.erase(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">        OutputDeps[N] = BackEdge;</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">        OutputDeps[N] = BackEdge;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">      // Do not process a boundary node, an artificial node.</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">      // Do not process a boundary node, an artificial node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">      // A back-edge is processed only if it goes to a Phi.</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">      // A back-edge is processed only if it goes to a Phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">      if (SI.getSUnit()->isBoundaryNode() || SI.isArtificial() ||</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">      if (SI.getSUnit()->isBoundaryNode() || SI.isArtificial() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">          (SI.getKind() == SDep::Anti && !SI.getSUnit()->getInstr()->isPHI()))</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">          (SI.getKind() == SDep::Anti && !SI.getSUnit()->getInstr()->isPHI()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">      int N = SI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">      int N = SI.getSUnit()->NodeNum;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">      if (!Added.test(N)) {</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">      if (!Added.test(N)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">        AdjK[i].push_back(N);</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">        AdjK[i].push_back(N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">        Added.set(N);</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">        Added.set(N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">    // A chain edge between a store and a load is treated as a back-edge in the</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">    // A chain edge between a store and a load is treated as a back-edge in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">    // adjacency matrix.</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">    // adjacency matrix.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">    for (auto &PI : SUnits[i].Preds) {</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">    for (auto &PI : SUnits[i].Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">      if (!SUnits[i].getInstr()->mayStore() ||</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">      if (!SUnits[i].getInstr()->mayStore() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">          !DAG->isLoopCarriedDep(&SUnits[i], PI, false))</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">          !DAG->isLoopCarriedDep(&SUnits[i], PI, false))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">      if (PI.getKind() == SDep::Order && PI.getSUnit()->getInstr()->mayLoad()) {</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">      if (PI.getKind() == SDep::Order && PI.getSUnit()->getInstr()->mayLoad()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">        int N = PI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">        int N = PI.getSUnit()->NodeNum;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">        if (!Added.test(N)) {</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">        if (!Added.test(N)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">          AdjK[i].push_back(N);</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">          AdjK[i].push_back(N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">          Added.set(N);</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">          Added.set(N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">  // Add back-edges in the adjacency matrix for the output dependences.</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">  // Add back-edges in the adjacency matrix for the output dependences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  for (auto &OD : OutputDeps)</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  for (auto &OD : OutputDeps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    if (!Added.test(OD.second)) {</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    if (!Added.test(OD.second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">      AdjK[OD.first].push_back(OD.second);</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">      AdjK[OD.first].push_back(OD.second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">      Added.set(OD.second);</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">      Added.set(OD.second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline"></td>
    <td class="lineNumber">1222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">/// Identify an elementary circuit in the dependence graph starting at the</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">/// Identify an elementary circuit in the dependence graph starting at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">/// specified node.</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">/// specified node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">bool SwingSchedulerDAG::Circuits::circuit(int V, int S, NodeSetType &NodeSets,</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">bool SwingSchedulerDAG::Circuits::circuit(int V, int S, NodeSetType &NodeSets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">                                          bool HasBackedge) {</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">                                          bool HasBackedge) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  SUnit *SV = &SUnits[V];</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  SUnit *SV = &SUnits[V];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  bool F = false;</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  bool F = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  Stack.insert(SV);</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  Stack.insert(SV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  Blocked.set(V);</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  Blocked.set(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  for (auto W : AdjK[V]) {</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  for (auto W : AdjK[V]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">    if (NumPaths > MaxPaths)</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">    if (NumPaths > MaxPaths)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">    if (W < S)</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">    if (W < S)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">    if (W == S) {</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">    if (W == S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">      if (!HasBackedge)</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">      if (!HasBackedge)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">        NodeSets.push_back(NodeSet(Stack.begin(), Stack.end()));</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">        NodeSets.push_back(NodeSet(Stack.begin(), Stack.end()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">      F = true;</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">      F = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">      ++NumPaths;</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">      ++NumPaths;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">    } else if (!Blocked.test(W)) {</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">    } else if (!Blocked.test(W)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">      if (circuit(W, S, NodeSets,</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">      if (circuit(W, S, NodeSets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">                  Node2Idx->at(W) < Node2Idx->at(V) ? true : HasBackedge))</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">                  Node2Idx->at(W) < Node2Idx->at(V) ? true : HasBackedge))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">        F = true;</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">        F = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline"></td>
    <td class="lineNumber">1249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  if (F)</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  if (F)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">    unblock(V);</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">    unblock(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  else {</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">    for (auto W : AdjK[V]) {</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">    for (auto W : AdjK[V]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">      if (W < S)</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">      if (W < S)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">      B[W].insert(SV);</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">      B[W].insert(SV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  Stack.pop_back();</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  Stack.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  return F;</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  return F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">/// Unblock a node in the circuit finding algorithm.</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">/// Unblock a node in the circuit finding algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">void SwingSchedulerDAG::Circuits::unblock(int U) {</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">void SwingSchedulerDAG::Circuits::unblock(int U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  Blocked.reset(U);</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  Blocked.reset(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 4> &BU = B[U];</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 4> &BU = B[U];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">  while (!BU.empty()) {</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">  while (!BU.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">    SmallPtrSet<SUnit *, 4>::iterator SI = BU.begin();</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">    SmallPtrSet<SUnit *, 4>::iterator SI = BU.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">    assert(SI != BU.end() && "Invalid B set.");</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">    assert(SI != BU.end() && "Invalid B set.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">    SUnit *W = *SI;</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">    SUnit *W = *SI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">    BU.erase(W);</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">    BU.erase(W);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">    if (Blocked.test(W->NodeNum))</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">    if (Blocked.test(W->NodeNum))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">      unblock(W->NodeNum);</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">      unblock(W->NodeNum);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">/// Identify all the elementary circuits in the dependence graph using</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">/// Identify all the elementary circuits in the dependence graph using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">/// Johnson's circuit algorithm.</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">/// Johnson's circuit algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">void SwingSchedulerDAG::findCircuits(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">void SwingSchedulerDAG::findCircuits(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  // Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  // Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  // but we do this to find the circuits, and then change them back.</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  // but we do this to find the circuits, and then change them back.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  swapAntiDependences(SUnits);</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  swapAntiDependences(SUnits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline"></td>
    <td class="lineNumber">1283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  Circuits Cir(SUnits, Topo);</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  Circuits Cir(SUnits, Topo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">  // Create the adjacency structure.</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">  // Create the adjacency structure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  Cir.createAdjacencyStructure(this);</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  Cir.createAdjacencyStructure(this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">    Cir.reset();</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">    Cir.reset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">    Cir.circuit(i, i, NodeSets);</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">    Cir.circuit(i, i, NodeSets);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">  // Change the dependences back so that we've created a DAG again.</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">  // Change the dependences back so that we've created a DAG again.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">  swapAntiDependences(SUnits);</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">  swapAntiDependences(SUnits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">// Create artificial dependencies between the source of COPY/REG_SEQUENCE that</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">// Create artificial dependencies between the source of COPY/REG_SEQUENCE that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">// is loop-carried to the USE in next iteration. This will help pipeliner avoid</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">// is loop-carried to the USE in next iteration. This will help pipeliner avoid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">// additional copies that are needed across iterations. An artificial dependence</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">// additional copies that are needed across iterations. An artificial dependence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">// edge is added from USE to SOURCE of COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">// edge is added from USE to SOURCE of COPY/REG_SEQUENCE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">// PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried)</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">// PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">// SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">// SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">// PHI-------True-Dep------> USEOfPhi</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">// PHI-------True-Dep------> USEOfPhi</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline"></td>
    <td class="lineNumber">1304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">// The mutation creates</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">// The mutation creates</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">// USEOfPHI -------Artificial-Dep---> SRCOfCopy</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">// USEOfPHI -------Artificial-Dep---> SRCOfCopy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline"></td>
    <td class="lineNumber">1307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">// This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">// This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">// (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">// (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">// late  to avoid additional copies across iterations. The possible scheduling</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">// late  to avoid additional copies across iterations. The possible scheduling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">// order would be</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">// order would be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">// USEOfPHI --- SRCOfCopy---  COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">// USEOfPHI --- SRCOfCopy---  COPY/REG_SEQUENCE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline"></td>
    <td class="lineNumber">1313</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">void SwingSchedulerDAG::CopyToPhiMutation::apply(ScheduleDAGInstrs *DAG) {</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">void SwingSchedulerDAG::CopyToPhiMutation::apply(ScheduleDAGInstrs *DAG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  for (SUnit &SU : DAG->SUnits) {</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  for (SUnit &SU : DAG->SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">    // Find the COPY/REG_SEQUENCE instruction.</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">    // Find the COPY/REG_SEQUENCE instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">    if (!SU.getInstr()->isCopy() && !SU.getInstr()->isRegSequence())</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">    if (!SU.getInstr()->isCopy() && !SU.getInstr()->isRegSequence())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">    // Record the loop carried PHIs.</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">    // Record the loop carried PHIs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">    SmallVector<SUnit *, 4> PHISUs;</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">    SmallVector<SUnit *, 4> PHISUs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">    // Record the SrcSUs that feed the COPY/REG_SEQUENCE instructions.</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">    // Record the SrcSUs that feed the COPY/REG_SEQUENCE instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">    SmallVector<SUnit *, 4> SrcSUs;</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">    SmallVector<SUnit *, 4> SrcSUs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">    for (auto &Dep : SU.Preds) {</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">    for (auto &Dep : SU.Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">      SUnit *TmpSU = Dep.getSUnit();</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">      SUnit *TmpSU = Dep.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">      MachineInstr *TmpMI = TmpSU->getInstr();</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">      MachineInstr *TmpMI = TmpSU->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">      SDep::Kind DepKind = Dep.getKind();</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">      SDep::Kind DepKind = Dep.getKind();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">      // Save the loop carried PHI.</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">      // Save the loop carried PHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">      if (DepKind == SDep::Anti && TmpMI->isPHI())</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">      if (DepKind == SDep::Anti && TmpMI->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">        PHISUs.push_back(TmpSU);</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">        PHISUs.push_back(TmpSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">      // Save the source of COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">      // Save the source of COPY/REG_SEQUENCE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">      // If the source has no pre-decessors, we will end up creating cycles.</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">      // If the source has no pre-decessors, we will end up creating cycles.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">      else if (DepKind == SDep::Data && !TmpMI->isPHI() && TmpSU->NumPreds > 0)</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">      else if (DepKind == SDep::Data && !TmpMI->isPHI() && TmpSU->NumPreds > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">        SrcSUs.push_back(TmpSU);</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">        SrcSUs.push_back(TmpSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline"></td>
    <td class="lineNumber">1337</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">    if (PHISUs.size() == 0 || SrcSUs.size() == 0)</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">    if (PHISUs.size() == 0 || SrcSUs.size() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">    // Find the USEs of PHI. If the use is a PHI or REG_SEQUENCE, push back this</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">    // Find the USEs of PHI. If the use is a PHI or REG_SEQUENCE, push back this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">    // SUnit to the container.</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">    // SUnit to the container.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">    SmallVector<SUnit *, 8> UseSUs;</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">    SmallVector<SUnit *, 8> UseSUs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">    // Do not use iterator based loop here as we are updating the container.</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">    // Do not use iterator based loop here as we are updating the container.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">    for (size_t Index = 0; Index < PHISUs.size(); ++Index) {</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">    for (size_t Index = 0; Index < PHISUs.size(); ++Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">      for (auto &Dep : PHISUs[Index]->Succs) {</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">      for (auto &Dep : PHISUs[Index]->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">        if (Dep.getKind() != SDep::Data)</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">        if (Dep.getKind() != SDep::Data)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">        SUnit *TmpSU = Dep.getSUnit();</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">        SUnit *TmpSU = Dep.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">        MachineInstr *TmpMI = TmpSU->getInstr();</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">        MachineInstr *TmpMI = TmpSU->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">        if (TmpMI->isPHI() || TmpMI->isRegSequence()) {</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">        if (TmpMI->isPHI() || TmpMI->isRegSequence()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">          PHISUs.push_back(TmpSU);</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">          PHISUs.push_back(TmpSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">        UseSUs.push_back(TmpSU);</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">        UseSUs.push_back(TmpSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline"></td>
    <td class="lineNumber">1359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">    if (UseSUs.size() == 0)</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">    if (UseSUs.size() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">    SwingSchedulerDAG *SDAG = cast<SwingSchedulerDAG>(DAG);</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">    SwingSchedulerDAG *SDAG = cast<SwingSchedulerDAG>(DAG);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">    // Add the artificial dependencies if it does not form a cycle.</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">    // Add the artificial dependencies if it does not form a cycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">    for (auto *I : UseSUs) {</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">    for (auto *I : UseSUs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">      for (auto *Src : SrcSUs) {</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">      for (auto *Src : SrcSUs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">        if (!SDAG->Topo.IsReachable(I, Src) && Src != I) {</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">        if (!SDAG->Topo.IsReachable(I, Src) && Src != I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">          Src->addPred(SDep(I, SDep::Artificial));</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">          Src->addPred(SDep(I, SDep::Artificial));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">          SDAG->Topo.AddPred(Src, I);</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">          SDAG->Topo.AddPred(Src, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline"></td>
    <td class="lineNumber">1375</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">/// Return true for DAG nodes that we ignore when computing the cost functions.</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">/// Return true for DAG nodes that we ignore when computing the cost functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">/// We ignore the back-edge recurrence in order to avoid unbounded recursion</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">/// We ignore the back-edge recurrence in order to avoid unbounded recursion</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">/// in the calculation of the ASAP, ALAP, etc functions.</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">/// in the calculation of the ASAP, ALAP, etc functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">static bool ignoreDependence(const SDep &D, bool isPred) {</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">static bool ignoreDependence(const SDep &D, bool isPred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">  if (D.isArtificial() || D.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">  if (D.isArtificial() || D.getSUnit()->isBoundaryNode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">  return D.getKind() == SDep::Anti && isPred;</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">  return D.getKind() == SDep::Anti && isPred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline"></td>
    <td class="lineNumber">1384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">/// Compute several functions need to order the nodes for scheduling.</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">/// Compute several functions need to order the nodes for scheduling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">///  ASAP - Earliest time to schedule a node.</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">///  ASAP - Earliest time to schedule a node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">///  ALAP - Latest time to schedule a node.</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">///  ALAP - Latest time to schedule a node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">///  MOV - Mobility function, difference between ALAP and ASAP.</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">///  MOV - Mobility function, difference between ALAP and ASAP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">///  D - Depth of each node.</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">///  D - Depth of each node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">///  H - Height of each node.</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">///  H - Height of each node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">void SwingSchedulerDAG::computeNodeFunctions(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">void SwingSchedulerDAG::computeNodeFunctions(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  ScheduleInfo.resize(SUnits.size());</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  ScheduleInfo.resize(SUnits.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">    for (int I : Topo) {</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">    for (int I : Topo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">      const SUnit &SU = SUnits[I];</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">      const SUnit &SU = SUnits[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">      dumpNode(SU);</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">      dumpNode(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline"></td>
    <td class="lineNumber">1400</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  int maxASAP = 0;</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  int maxASAP = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  // Compute ASAP and ZeroLatencyDepth.</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  // Compute ASAP and ZeroLatencyDepth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">  for (int I : Topo) {</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">  for (int I : Topo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">    int asap = 0;</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">    int asap = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">    int zeroLatencyDepth = 0;</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">    int zeroLatencyDepth = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">    SUnit *SU = &SUnits[I];</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">    SUnit *SU = &SUnits[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">    for (const SDep &P : SU->Preds) {</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">    for (const SDep &P : SU->Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">      SUnit *pred = P.getSUnit();</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">      SUnit *pred = P.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">      if (P.getLatency() == 0)</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">      if (P.getLatency() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">        zeroLatencyDepth =</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">        zeroLatencyDepth =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">            std::max(zeroLatencyDepth, getZeroLatencyDepth(pred) + 1);</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">            std::max(zeroLatencyDepth, getZeroLatencyDepth(pred) + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">      if (ignoreDependence(P, true))</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">      if (ignoreDependence(P, true))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">      asap = std::max(asap, (int)(getASAP(pred) + P.getLatency() -</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">      asap = std::max(asap, (int)(getASAP(pred) + P.getLatency() -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">                                  getDistance(pred, SU, P) * MII));</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">                                  getDistance(pred, SU, P) * MII));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">    maxASAP = std::max(maxASAP, asap);</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">    maxASAP = std::max(maxASAP, asap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">    ScheduleInfo[I].ASAP = asap;</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">    ScheduleInfo[I].ASAP = asap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    ScheduleInfo[I].ZeroLatencyDepth = zeroLatencyDepth;</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    ScheduleInfo[I].ZeroLatencyDepth = zeroLatencyDepth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline"></td>
    <td class="lineNumber">1421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">  // Compute ALAP, ZeroLatencyHeight, and MOV.</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">  // Compute ALAP, ZeroLatencyHeight, and MOV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">  for (int I : llvm::reverse(Topo)) {</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">  for (int I : llvm::reverse(Topo)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">    int alap = maxASAP;</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">    int alap = maxASAP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">    int zeroLatencyHeight = 0;</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">    int zeroLatencyHeight = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">    SUnit *SU = &SUnits[I];</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">    SUnit *SU = &SUnits[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">    for (const SDep &S : SU->Succs) {</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">    for (const SDep &S : SU->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">      SUnit *succ = S.getSUnit();</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">      SUnit *succ = S.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">      if (succ->isBoundaryNode())</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">      if (succ->isBoundaryNode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">      if (S.getLatency() == 0)</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">      if (S.getLatency() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">        zeroLatencyHeight =</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">        zeroLatencyHeight =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">            std::max(zeroLatencyHeight, getZeroLatencyHeight(succ) + 1);</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">            std::max(zeroLatencyHeight, getZeroLatencyHeight(succ) + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">      if (ignoreDependence(S, true))</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">      if (ignoreDependence(S, true))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">      alap = std::min(alap, (int)(getALAP(succ) - S.getLatency() +</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">      alap = std::min(alap, (int)(getALAP(succ) - S.getLatency() +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">                                  getDistance(SU, succ, S) * MII));</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">                                  getDistance(SU, succ, S) * MII));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline"></td>
    <td class="lineNumber">1439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">    ScheduleInfo[I].ALAP = alap;</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">    ScheduleInfo[I].ALAP = alap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">    ScheduleInfo[I].ZeroLatencyHeight = zeroLatencyHeight;</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">    ScheduleInfo[I].ZeroLatencyHeight = zeroLatencyHeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
    <td class="lineNumber">1443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">  // After computing the node functions, compute the summary for each node set.</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">  // After computing the node functions, compute the summary for each node set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">  for (NodeSet &I : NodeSets)</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">  for (NodeSet &I : NodeSets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">    I.computeNodeSetInfo(this);</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">    I.computeNodeSetInfo(this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">    for (unsigned i = 0; i < SUnits.size(); i++) {</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">    for (unsigned i = 0; i < SUnits.size(); i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">      dbgs() << "\tNode " << i << ":\n";</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">      dbgs() << "\tNode " << i << ":\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">      dbgs() << "\t   ASAP = " << getASAP(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">      dbgs() << "\t   ASAP = " << getASAP(&SUnits[i]) << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">      dbgs() << "\t   ALAP = " << getALAP(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">      dbgs() << "\t   ALAP = " << getALAP(&SUnits[i]) << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">      dbgs() << "\t   MOV  = " << getMOV(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">      dbgs() << "\t   MOV  = " << getMOV(&SUnits[i]) << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">      dbgs() << "\t   D    = " << getDepth(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">      dbgs() << "\t   D    = " << getDepth(&SUnits[i]) << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">      dbgs() << "\t   H    = " << getHeight(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">      dbgs() << "\t   H    = " << getHeight(&SUnits[i]) << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">      dbgs() << "\t   ZLD  = " << getZeroLatencyDepth(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">      dbgs() << "\t   ZLD  = " << getZeroLatencyDepth(&SUnits[i]) << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">      dbgs() << "\t   ZLH  = " << getZeroLatencyHeight(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">      dbgs() << "\t   ZLH  = " << getZeroLatencyHeight(&SUnits[i]) << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline"></td>
    <td class="lineNumber">1461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">/// Compute the Pred_L(O) set, as defined in the paper. The set is defined</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">/// Compute the Pred_L(O) set, as defined in the paper. The set is defined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">/// as the predecessors of the elements of NodeOrder that are not also in</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">/// as the predecessors of the elements of NodeOrder that are not also in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">/// NodeOrder.</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">/// NodeOrder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">static bool pred_L(SetVector<SUnit *> &NodeOrder,</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">static bool pred_L(SetVector<SUnit *> &NodeOrder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">                   SmallSetVector<SUnit *, 8> &Preds,</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">                   SmallSetVector<SUnit *, 8> &Preds,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">                   const NodeSet *S = nullptr) {</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">                   const NodeSet *S = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  Preds.clear();</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  Preds.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  for (const SUnit *SU : NodeOrder) {</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  for (const SUnit *SU : NodeOrder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">    for (const SDep &Pred : SU->Preds) {</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">    for (const SDep &Pred : SU->Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">      if (S && S->count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">      if (S && S->count(Pred.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">      if (ignoreDependence(Pred, true))</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">      if (ignoreDependence(Pred, true))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">        Preds.insert(Pred.getSUnit());</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">        Preds.insert(Pred.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">    // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">    // Back-edges are predecessors with an anti-dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">    for (const SDep &Succ : SU->Succs) {</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">    for (const SDep &Succ : SU->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">      if (Succ.getKind() != SDep::Anti)</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">      if (Succ.getKind() != SDep::Anti)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">      if (S && S->count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">      if (S && S->count(Succ.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">        Preds.insert(Succ.getSUnit());</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">        Preds.insert(Succ.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">  return !Preds.empty();</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">  return !Preds.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
    <td class="lineNumber">1490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">/// Compute the Succ_L(O) set, as defined in the paper. The set is defined</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">/// Compute the Succ_L(O) set, as defined in the paper. The set is defined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">/// as the successors of the elements of NodeOrder that are not also in</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">/// as the successors of the elements of NodeOrder that are not also in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">/// NodeOrder.</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">/// NodeOrder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">static bool succ_L(SetVector<SUnit *> &NodeOrder,</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">static bool succ_L(SetVector<SUnit *> &NodeOrder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">                   SmallSetVector<SUnit *, 8> &Succs,</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">                   SmallSetVector<SUnit *, 8> &Succs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">                   const NodeSet *S = nullptr) {</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">                   const NodeSet *S = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  Succs.clear();</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  Succs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">  for (const SUnit *SU : NodeOrder) {</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">  for (const SUnit *SU : NodeOrder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">    for (const SDep &Succ : SU->Succs) {</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">    for (const SDep &Succ : SU->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">      if (S && S->count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">      if (S && S->count(Succ.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">      if (ignoreDependence(Succ, false))</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">      if (ignoreDependence(Succ, false))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">        Succs.insert(Succ.getSUnit());</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">        Succs.insert(Succ.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">    for (const SDep &Pred : SU->Preds) {</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">    for (const SDep &Pred : SU->Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">      if (Pred.getKind() != SDep::Anti)</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">      if (Pred.getKind() != SDep::Anti)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">      if (S && S->count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">      if (S && S->count(Pred.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">        Succs.insert(Pred.getSUnit());</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">        Succs.insert(Pred.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">  return !Succs.empty();</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">  return !Succs.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline"></td>
    <td class="lineNumber">1518</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">/// Return true if there is a path from the specified node to any of the nodes</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">/// Return true if there is a path from the specified node to any of the nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">/// in DestNodes. Keep track and return the nodes in any path.</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">/// in DestNodes. Keep track and return the nodes in any path.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">static bool computePath(SUnit *Cur, SetVector<SUnit *> &Path,</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">static bool computePath(SUnit *Cur, SetVector<SUnit *> &Path,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">                        SetVector<SUnit *> &DestNodes,</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">                        SetVector<SUnit *> &DestNodes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">                        SetVector<SUnit *> &Exclude,</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">                        SetVector<SUnit *> &Exclude,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">                        SmallPtrSet<SUnit *, 8> &Visited) {</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">                        SmallPtrSet<SUnit *, 8> &Visited) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">  if (Cur->isBoundaryNode())</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">  if (Cur->isBoundaryNode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">  if (Exclude.contains(Cur))</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">  if (Exclude.contains(Cur))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">  if (DestNodes.contains(Cur))</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">  if (DestNodes.contains(Cur))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">  if (!Visited.insert(Cur).second)</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">  if (!Visited.insert(Cur).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">    return Path.contains(Cur);</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">    return Path.contains(Cur);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">  bool FoundPath = false;</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">  bool FoundPath = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">  for (auto &SI : Cur->Succs)</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">  for (auto &SI : Cur->Succs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">    if (!ignoreDependence(SI, false))</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">    if (!ignoreDependence(SI, false))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">      FoundPath |=</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">      FoundPath |=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">          computePath(SI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">          computePath(SI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  for (auto &PI : Cur->Preds)</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  for (auto &PI : Cur->Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">    if (PI.getKind() == SDep::Anti)</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">    if (PI.getKind() == SDep::Anti)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">      FoundPath |=</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">      FoundPath |=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">          computePath(PI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">          computePath(PI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">  if (FoundPath)</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">  if (FoundPath)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">    Path.insert(Cur);</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">    Path.insert(Cur);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">  return FoundPath;</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">  return FoundPath;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline"></td>
    <td class="lineNumber">1546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">/// Compute the live-out registers for the instructions in a node-set.</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">/// Compute the live-out registers for the instructions in a node-set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">/// The live-out registers are those that are defined in the node-set,</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">/// The live-out registers are those that are defined in the node-set,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">/// but not used. Except for use operands of Phis.</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">/// but not used. Except for use operands of Phis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">static void computeLiveOuts(MachineFunction &MF, RegPressureTracker &RPTracker,</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">static void computeLiveOuts(MachineFunction &MF, RegPressureTracker &RPTracker,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">                            NodeSet &NS) {</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">                            NodeSet &NS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">  SmallVector<RegisterMaskPair, 8> LiveOutRegs;</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">  SmallVector<RegisterMaskPair, 8> LiveOutRegs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">  SmallSet<unsigned, 4> Uses;</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">  SmallSet<unsigned, 4> Uses;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">  for (SUnit *SU : NS) {</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">  for (SUnit *SU : NS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">    const MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">    const MachineInstr *MI = SU->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">    if (MI->isPHI())</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">    if (MI->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">    for (const MachineOperand &MO : MI->all_uses()) {</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">    for (const MachineOperand &MO : MI->all_uses()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">      Register Reg = MO.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">      if (Reg.isVirtual())</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">      if (Reg.isVirtual())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">        Uses.insert(Reg);</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">        Uses.insert(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">      else if (MRI.isAllocatable(Reg))</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">      else if (MRI.isAllocatable(Reg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">        for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">        for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">          Uses.insert(Unit);</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">          Uses.insert(Unit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">  for (SUnit *SU : NS)</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">  for (SUnit *SU : NS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">    for (const MachineOperand &MO : SU->getInstr()->all_defs())</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">    for (const MachineOperand &MO : SU->getInstr()->all_defs())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">      if (!MO.isDead()) {</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">      if (!MO.isDead()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">        Register Reg = MO.getReg();</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">        Register Reg = MO.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">        if (Reg.isVirtual()) {</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">        if (Reg.isVirtual()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">          if (!Uses.count(Reg))</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">          if (!Uses.count(Reg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">            LiveOutRegs.push_back(RegisterMaskPair(Reg,</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">            LiveOutRegs.push_back(RegisterMaskPair(Reg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">                                                   LaneBitmask::getNone()));</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">                                                   LaneBitmask::getNone()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">        } else if (MRI.isAllocatable(Reg)) {</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">        } else if (MRI.isAllocatable(Reg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">          for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">          for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">            if (!Uses.count(Unit))</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">            if (!Uses.count(Unit))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">              LiveOutRegs.push_back(</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">              LiveOutRegs.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">                  RegisterMaskPair(Unit, LaneBitmask::getNone()));</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">                  RegisterMaskPair(Unit, LaneBitmask::getNone()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">  RPTracker.addLiveRegs(LiveOutRegs);</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">  RPTracker.addLiveRegs(LiveOutRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline"></td>
    <td class="lineNumber">1586</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">/// A heuristic to filter nodes in recurrent node-sets if the register</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">/// A heuristic to filter nodes in recurrent node-sets if the register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">/// pressure of a set is too high.</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">/// pressure of a set is too high.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">void SwingSchedulerDAG::registerPressureFilter(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">void SwingSchedulerDAG::registerPressureFilter(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">  for (auto &NS : NodeSets) {</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">  for (auto &NS : NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">    // Skip small node-sets since they won't cause register pressure problems.</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">    // Skip small node-sets since they won't cause register pressure problems.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">    if (NS.size() <= 2)</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">    if (NS.size() <= 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">    IntervalPressure RecRegPressure;</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">    IntervalPressure RecRegPressure;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">    RegPressureTracker RecRPTracker(RecRegPressure);</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">    RegPressureTracker RecRPTracker(RecRegPressure);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">    RecRPTracker.init(&MF, &RegClassInfo, &LIS, BB, BB->end(), false, true);</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">    RecRPTracker.init(&MF, &RegClassInfo, &LIS, BB, BB->end(), false, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">    computeLiveOuts(MF, RecRPTracker, NS);</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">    computeLiveOuts(MF, RecRPTracker, NS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">    RecRPTracker.closeBottom();</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">    RecRPTracker.closeBottom();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline"></td>
    <td class="lineNumber">1599</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">    std::vector<SUnit *> SUnits(NS.begin(), NS.end());</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">    std::vector<SUnit *> SUnits(NS.begin(), NS.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">    llvm::sort(SUnits, [](const SUnit *A, const SUnit *B) {</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">    llvm::sort(SUnits, [](const SUnit *A, const SUnit *B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">      return A->NodeNum > B->NodeNum;</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">      return A->NodeNum > B->NodeNum;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">    for (auto &SU : SUnits) {</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">    for (auto &SU : SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">      // Since we're computing the register pressure for a subset of the</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">      // Since we're computing the register pressure for a subset of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">      // instructions in a block, we need to set the tracker for each</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">      // instructions in a block, we need to set the tracker for each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">      // instruction in the node-set. The tracker is set to the instruction</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">      // instruction in the node-set. The tracker is set to the instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">      // just after the one we're interested in.</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">      // just after the one we're interested in.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">      MachineBasicBlock::const_iterator CurInstI = SU->getInstr();</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">      MachineBasicBlock::const_iterator CurInstI = SU->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">      RecRPTracker.setPos(std::next(CurInstI));</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">      RecRPTracker.setPos(std::next(CurInstI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline"></td>
    <td class="lineNumber">1612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">      RegPressureDelta RPDelta;</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">      RegPressureDelta RPDelta;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">      ArrayRef<PressureChange> CriticalPSets;</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">      ArrayRef<PressureChange> CriticalPSets;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">      RecRPTracker.getMaxUpwardPressureDelta(SU->getInstr(), nullptr, RPDelta,</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">      RecRPTracker.getMaxUpwardPressureDelta(SU->getInstr(), nullptr, RPDelta,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">                                             CriticalPSets,</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">                                             CriticalPSets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">                                             RecRegPressure.MaxSetPressure);</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">                                             RecRegPressure.MaxSetPressure);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">      if (RPDelta.Excess.isValid()) {</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">      if (RPDelta.Excess.isValid()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">        LLVM_DEBUG(</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">        LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">            dbgs() << "Excess register pressure: SU(" << SU->NodeNum << ") "</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">            dbgs() << "Excess register pressure: SU(" << SU->NodeNum << ") "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">                   << TRI->getRegPressureSetName(RPDelta.Excess.getPSet())</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">                   << TRI->getRegPressureSetName(RPDelta.Excess.getPSet())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">                   << ":" << RPDelta.Excess.getUnitInc() << "\n");</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">                   << ":" << RPDelta.Excess.getUnitInc() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">        NS.setExceedPressure(SU);</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">        NS.setExceedPressure(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">      RecRPTracker.recede();</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">      RecRPTracker.recede();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline"></td>
    <td class="lineNumber">1630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">/// A heuristic to colocate node sets that have the same set of</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">/// A heuristic to colocate node sets that have the same set of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">/// successors.</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">/// successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">void SwingSchedulerDAG::colocateNodeSets(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">void SwingSchedulerDAG::colocateNodeSets(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">  unsigned Colocate = 0;</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">  unsigned Colocate = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">  for (int i = 0, e = NodeSets.size(); i < e; ++i) {</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">  for (int i = 0, e = NodeSets.size(); i < e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">    NodeSet &N1 = NodeSets[i];</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">    NodeSet &N1 = NodeSets[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">    SmallSetVector<SUnit *, 8> S1;</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">    SmallSetVector<SUnit *, 8> S1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">    if (N1.empty() || !succ_L(N1, S1))</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">    if (N1.empty() || !succ_L(N1, S1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">    for (int j = i + 1; j < e; ++j) {</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">    for (int j = i + 1; j < e; ++j) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">      NodeSet &N2 = NodeSets[j];</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">      NodeSet &N2 = NodeSets[j];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">      if (N1.compareRecMII(N2) != 0)</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">      if (N1.compareRecMII(N2) != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">      SmallSetVector<SUnit *, 8> S2;</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">      SmallSetVector<SUnit *, 8> S2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">      if (N2.empty() || !succ_L(N2, S2))</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">      if (N2.empty() || !succ_L(N2, S2))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">      if (llvm::set_is_subset(S1, S2) && S1.size() == S2.size()) {</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">      if (llvm::set_is_subset(S1, S2) && S1.size() == S2.size()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">        N1.setColocate(++Colocate);</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">        N1.setColocate(++Colocate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">        N2.setColocate(Colocate);</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">        N2.setColocate(Colocate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline"></td>
    <td class="lineNumber">1655</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">/// Check if the existing node-sets are profitable. If not, then ignore the</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">/// Check if the existing node-sets are profitable. If not, then ignore the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">/// recurrent node-sets, and attempt to schedule all nodes together. This is</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">/// recurrent node-sets, and attempt to schedule all nodes together. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">/// a heuristic. If the MII is large and all the recurrent node-sets are small,</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">/// a heuristic. If the MII is large and all the recurrent node-sets are small,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">/// then it's best to try to schedule all instructions together instead of</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">/// then it's best to try to schedule all instructions together instead of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">/// starting with the recurrent node-sets.</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">/// starting with the recurrent node-sets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">void SwingSchedulerDAG::checkNodeSets(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">void SwingSchedulerDAG::checkNodeSets(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">  // Look for loops with a large MII.</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">  // Look for loops with a large MII.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  if (MII < 17)</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  if (MII < 17)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">  // Check if the node-set contains only a simple add recurrence.</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">  // Check if the node-set contains only a simple add recurrence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">  for (auto &NS : NodeSets) {</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">  for (auto &NS : NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">    if (NS.getRecMII() > 2)</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">    if (NS.getRecMII() > 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">    if (NS.getMaxDepth() > MII)</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">    if (NS.getMaxDepth() > MII)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">  NodeSets.clear();</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">  NodeSets.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Clear recurrence node-sets\n");</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Clear recurrence node-sets\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline"></td>
    <td class="lineNumber">1675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">/// Add the nodes that do not belong to a recurrence set into groups</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">/// Add the nodes that do not belong to a recurrence set into groups</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">/// based upon connected components.</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">/// based upon connected components.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">void SwingSchedulerDAG::groupRemainingNodes(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">void SwingSchedulerDAG::groupRemainingNodes(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  SetVector<SUnit *> NodesAdded;</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  SetVector<SUnit *> NodesAdded;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 8> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">  // Add the nodes that are on a path between the previous node sets and</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">  // Add the nodes that are on a path between the previous node sets and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  // the current node set.</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  // the current node set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  for (NodeSet &I : NodeSets) {</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  for (NodeSet &I : NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">    SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">    SmallSetVector<SUnit *, 8> N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">    // Add the nodes from the current node set to the previous node set.</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">    // Add the nodes from the current node set to the previous node set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">    if (succ_L(I, N)) {</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">    if (succ_L(I, N)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">      SetVector<SUnit *> Path;</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">      SetVector<SUnit *> Path;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">      for (SUnit *NI : N) {</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">      for (SUnit *NI : N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">        Visited.clear();</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">        Visited.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">        computePath(NI, Path, NodesAdded, I, Visited);</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">        computePath(NI, Path, NodesAdded, I, Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">      if (!Path.empty())</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">      if (!Path.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">        I.insert(Path.begin(), Path.end());</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">        I.insert(Path.begin(), Path.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">    // Add the nodes from the previous node set to the current node set.</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">    // Add the nodes from the previous node set to the current node set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">    N.clear();</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">    N.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">    if (succ_L(NodesAdded, N)) {</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">    if (succ_L(NodesAdded, N)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">      SetVector<SUnit *> Path;</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">      SetVector<SUnit *> Path;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">      for (SUnit *NI : N) {</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">      for (SUnit *NI : N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">        Visited.clear();</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">        Visited.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">        computePath(NI, Path, I, NodesAdded, Visited);</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">        computePath(NI, Path, I, NodesAdded, Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">      if (!Path.empty())</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">      if (!Path.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">        I.insert(Path.begin(), Path.end());</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">        I.insert(Path.begin(), Path.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">    NodesAdded.insert(I.begin(), I.end());</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">    NodesAdded.insert(I.begin(), I.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline"></td>
    <td class="lineNumber">1708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">  // Create a new node set with the connected nodes of any successor of a node</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">  // Create a new node set with the connected nodes of any successor of a node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">  // in a recurrent set.</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">  // in a recurrent set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">  NodeSet NewSet;</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">  NodeSet NewSet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">  SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">  SmallSetVector<SUnit *, 8> N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  if (succ_L(NodesAdded, N))</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  if (succ_L(NodesAdded, N))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">    for (SUnit *I : N)</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">    for (SUnit *I : N)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">      addConnectedNodes(I, NewSet, NodesAdded);</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">      addConnectedNodes(I, NewSet, NodesAdded);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">  if (!NewSet.empty())</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">  if (!NewSet.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">    NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">    NodeSets.push_back(NewSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline"></td>
    <td class="lineNumber">1718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  // Create a new node set with the connected nodes of any predecessor of a node</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  // Create a new node set with the connected nodes of any predecessor of a node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  // in a recurrent set.</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  // in a recurrent set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">  NewSet.clear();</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">  NewSet.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  if (pred_L(NodesAdded, N))</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  if (pred_L(NodesAdded, N))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">    for (SUnit *I : N)</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">    for (SUnit *I : N)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">      addConnectedNodes(I, NewSet, NodesAdded);</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">      addConnectedNodes(I, NewSet, NodesAdded);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">  if (!NewSet.empty())</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">  if (!NewSet.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">    NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">    NodeSets.push_back(NewSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  // Create new nodes sets with the connected nodes any remaining node that</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  // Create new nodes sets with the connected nodes any remaining node that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  // has no predecessor.</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  // has no predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">  for (SUnit &SU : SUnits) {</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">  for (SUnit &SU : SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">    if (NodesAdded.count(&SU) == 0) {</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">    if (NodesAdded.count(&SU) == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">      NewSet.clear();</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">      NewSet.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">      addConnectedNodes(&SU, NewSet, NodesAdded);</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">      addConnectedNodes(&SU, NewSet, NodesAdded);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">      if (!NewSet.empty())</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">      if (!NewSet.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">        NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">        NodeSets.push_back(NewSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline"></td>
    <td class="lineNumber">1739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">/// Add the node to the set, and add all of its connected nodes to the set.</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">/// Add the node to the set, and add all of its connected nodes to the set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">void SwingSchedulerDAG::addConnectedNodes(SUnit *SU, NodeSet &NewSet,</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">void SwingSchedulerDAG::addConnectedNodes(SUnit *SU, NodeSet &NewSet,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">                                          SetVector<SUnit *> &NodesAdded) {</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">                                          SetVector<SUnit *> &NodesAdded) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">  NewSet.insert(SU);</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">  NewSet.insert(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">  NodesAdded.insert(SU);</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">  NodesAdded.insert(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">  for (auto &SI : SU->Succs) {</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">  for (auto &SI : SU->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">    SUnit *Successor = SI.getSUnit();</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">    SUnit *Successor = SI.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">    if (!SI.isArtificial() && !Successor->isBoundaryNode() &&</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">    if (!SI.isArtificial() && !Successor->isBoundaryNode() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">        NodesAdded.count(Successor) == 0)</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">        NodesAdded.count(Successor) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">      addConnectedNodes(Successor, NewSet, NodesAdded);</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">      addConnectedNodes(Successor, NewSet, NodesAdded);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">  for (auto &PI : SU->Preds) {</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">  for (auto &PI : SU->Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">    SUnit *Predecessor = PI.getSUnit();</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">    SUnit *Predecessor = PI.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">    if (!PI.isArtificial() && NodesAdded.count(Predecessor) == 0)</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">    if (!PI.isArtificial() && NodesAdded.count(Predecessor) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">      addConnectedNodes(Predecessor, NewSet, NodesAdded);</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">      addConnectedNodes(Predecessor, NewSet, NodesAdded);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline"></td>
    <td class="lineNumber">1757</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">/// Return true if Set1 contains elements in Set2. The elements in common</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">/// Return true if Set1 contains elements in Set2. The elements in common</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">/// are returned in a different container.</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">/// are returned in a different container.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">static bool isIntersect(SmallSetVector<SUnit *, 8> &Set1, const NodeSet &Set2,</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">static bool isIntersect(SmallSetVector<SUnit *, 8> &Set1, const NodeSet &Set2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">                        SmallSetVector<SUnit *, 8> &Result) {</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">                        SmallSetVector<SUnit *, 8> &Result) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">  Result.clear();</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">  Result.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">  for (SUnit *SU : Set1) {</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">  for (SUnit *SU : Set1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">    if (Set2.count(SU) != 0)</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">    if (Set2.count(SU) != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">      Result.insert(SU);</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">      Result.insert(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">  return !Result.empty();</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">  return !Result.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline"></td>
    <td class="lineNumber">1769</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">/// Merge the recurrence node sets that have the same initial node.</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">/// Merge the recurrence node sets that have the same initial node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">void SwingSchedulerDAG::fuseRecs(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">void SwingSchedulerDAG::fuseRecs(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">       ++I) {</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">       ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">    NodeSet &NI = *I;</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">    NodeSet &NI = *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">      NodeSet &NJ = *J;</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">      NodeSet &NJ = *J;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">      if (NI.getNode(0)->NodeNum == NJ.getNode(0)->NodeNum) {</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">      if (NI.getNode(0)->NodeNum == NJ.getNode(0)->NodeNum) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">        if (NJ.compareRecMII(NI) > 0)</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">        if (NJ.compareRecMII(NI) > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">          NI.setRecMII(NJ.getRecMII());</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">          NI.setRecMII(NJ.getRecMII());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">        for (SUnit *SU : *J)</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">        for (SUnit *SU : *J)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">          I->insert(SU);</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">          I->insert(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">        NodeSets.erase(J);</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">        NodeSets.erase(J);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">        E = NodeSets.end();</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">        E = NodeSets.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">        ++J;</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">        ++J;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline"></td>
    <td class="lineNumber">1790</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">/// Remove nodes that have been scheduled in previous NodeSets.</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">/// Remove nodes that have been scheduled in previous NodeSets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">void SwingSchedulerDAG::removeDuplicateNodes(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">void SwingSchedulerDAG::removeDuplicateNodes(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">       ++I)</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">       ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">      J->remove_if([&](SUnit *SUJ) { return I->count(SUJ); });</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">      J->remove_if([&](SUnit *SUJ) { return I->count(SUJ); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline"></td>
    <td class="lineNumber">1797</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">      if (J->empty()) {</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">      if (J->empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">        NodeSets.erase(J);</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">        NodeSets.erase(J);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">        E = NodeSets.end();</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">        E = NodeSets.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">        ++J;</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">        ++J;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline"></td>
    <td class="lineNumber">1806</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">/// Compute an ordered list of the dependence graph nodes, which</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">/// Compute an ordered list of the dependence graph nodes, which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">/// indicates the order that the nodes will be scheduled.  This is a</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">/// indicates the order that the nodes will be scheduled.  This is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">/// two-level algorithm. First, a partial order is created, which</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">/// two-level algorithm. First, a partial order is created, which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">/// consists of a list of sets ordered from highest to lowest priority.</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">/// consists of a list of sets ordered from highest to lowest priority.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">void SwingSchedulerDAG::computeNodeOrder(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">void SwingSchedulerDAG::computeNodeOrder(NodeSetType &NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">  SmallSetVector<SUnit *, 8> R;</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">  SmallSetVector<SUnit *, 8> R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  NodeOrder.clear();</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  NodeOrder.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline"></td>
    <td class="lineNumber">1814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">  for (auto &Nodes : NodeSets) {</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">  for (auto &Nodes : NodeSets) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "NodeSet size " << Nodes.size() << "\n");</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "NodeSet size " << Nodes.size() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">    OrderKind Order;</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">    OrderKind Order;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">    SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">    SmallSetVector<SUnit *, 8> N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">    if (pred_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">    if (pred_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">      R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">      R.insert(N.begin(), N.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">      Order = BottomUp;</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">      Order = BottomUp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Bottom up (preds) ");</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Bottom up (preds) ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">    } else if (succ_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">    } else if (succ_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">      R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">      R.insert(N.begin(), N.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">      Order = TopDown;</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">      Order = TopDown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Top down (succs) ");</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Top down (succs) ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">    } else if (isIntersect(N, Nodes, R)) {</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">    } else if (isIntersect(N, Nodes, R)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">      // If some of the successors are in the existing node-set, then use the</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">      // If some of the successors are in the existing node-set, then use the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">      // top-down ordering.</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">      // top-down ordering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">      Order = TopDown;</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">      Order = TopDown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Top down (intersect) ");</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Top down (intersect) ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">    } else if (NodeSets.size() == 1) {</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">    } else if (NodeSets.size() == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">      for (const auto &N : Nodes)</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">      for (const auto &N : Nodes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">        if (N->Succs.size() == 0)</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">        if (N->Succs.size() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">          R.insert(N);</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">          R.insert(N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">      Order = BottomUp;</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">      Order = BottomUp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Bottom up (all) ");</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Bottom up (all) ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">      // Find the node with the highest ASAP.</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">      // Find the node with the highest ASAP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">      SUnit *maxASAP = nullptr;</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">      SUnit *maxASAP = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">      for (SUnit *SU : Nodes) {</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">      for (SUnit *SU : Nodes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">        if (maxASAP == nullptr || getASAP(SU) > getASAP(maxASAP) ||</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">        if (maxASAP == nullptr || getASAP(SU) > getASAP(maxASAP) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">            (getASAP(SU) == getASAP(maxASAP) && SU->NodeNum > maxASAP->NodeNum))</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">            (getASAP(SU) == getASAP(maxASAP) && SU->NodeNum > maxASAP->NodeNum))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">          maxASAP = SU;</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">          maxASAP = SU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">      R.insert(maxASAP);</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">      R.insert(maxASAP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">      Order = BottomUp;</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">      Order = BottomUp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Bottom up (default) ");</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Bottom up (default) ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline"></td>
    <td class="lineNumber">1850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">    while (!R.empty()) {</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">    while (!R.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">      if (Order == TopDown) {</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">      if (Order == TopDown) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">        // Choose the node with the maximum height.  If more than one, choose</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">        // Choose the node with the maximum height.  If more than one, choose</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">        // the node wiTH the maximum ZeroLatencyHeight. If still more than one,</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">        // the node wiTH the maximum ZeroLatencyHeight. If still more than one,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">        // choose the node with the lowest MOV.</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">        // choose the node with the lowest MOV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">        while (!R.empty()) {</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">        while (!R.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">          SUnit *maxHeight = nullptr;</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">          SUnit *maxHeight = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">          for (SUnit *I : R) {</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">          for (SUnit *I : R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">            if (maxHeight == nullptr || getHeight(I) > getHeight(maxHeight))</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">            if (maxHeight == nullptr || getHeight(I) > getHeight(maxHeight))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">              maxHeight = I;</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">              maxHeight = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">                     getZeroLatencyHeight(I) > getZeroLatencyHeight(maxHeight))</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">                     getZeroLatencyHeight(I) > getZeroLatencyHeight(maxHeight))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">              maxHeight = I;</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">              maxHeight = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">                     getZeroLatencyHeight(I) ==</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">                     getZeroLatencyHeight(I) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">                         getZeroLatencyHeight(maxHeight) &&</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">                         getZeroLatencyHeight(maxHeight) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">                     getMOV(I) < getMOV(maxHeight))</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">                     getMOV(I) < getMOV(maxHeight))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">              maxHeight = I;</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">              maxHeight = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">          NodeOrder.insert(maxHeight);</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">          NodeOrder.insert(maxHeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << maxHeight->NodeNum << " ");</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << maxHeight->NodeNum << " ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">          R.remove(maxHeight);</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">          R.remove(maxHeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">          for (const auto &I : maxHeight->Succs) {</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">          for (const auto &I : maxHeight->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">            if (Nodes.count(I.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">            if (NodeOrder.contains(I.getSUnit()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">            if (ignoreDependence(I, false))</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">            if (ignoreDependence(I, false))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">            R.insert(I.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">          // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">          // Back-edges are predecessors with an anti-dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">          for (const auto &I : maxHeight->Preds) {</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">          for (const auto &I : maxHeight->Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">            if (I.getKind() != SDep::Anti)</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">            if (I.getKind() != SDep::Anti)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">            if (Nodes.count(I.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">            if (NodeOrder.contains(I.getSUnit()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">            R.insert(I.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">        Order = BottomUp;</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">        Order = BottomUp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "\n   Switching order to bottom up ");</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "\n   Switching order to bottom up ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">        SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">        SmallSetVector<SUnit *, 8> N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">        if (pred_L(NodeOrder, N, &Nodes))</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">        if (pred_L(NodeOrder, N, &Nodes))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">          R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">          R.insert(N.begin(), N.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">        // Choose the node with the maximum depth.  If more than one, choose</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">        // Choose the node with the maximum depth.  If more than one, choose</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">        // the node with the maximum ZeroLatencyDepth. If still more than one,</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">        // the node with the maximum ZeroLatencyDepth. If still more than one,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">        // choose the node with the lowest MOV.</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">        // choose the node with the lowest MOV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">        while (!R.empty()) {</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">        while (!R.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">          SUnit *maxDepth = nullptr;</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">          SUnit *maxDepth = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">          for (SUnit *I : R) {</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">          for (SUnit *I : R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">            if (maxDepth == nullptr || getDepth(I) > getDepth(maxDepth))</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">            if (maxDepth == nullptr || getDepth(I) > getDepth(maxDepth))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">              maxDepth = I;</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">              maxDepth = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">                     getZeroLatencyDepth(I) > getZeroLatencyDepth(maxDepth))</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">                     getZeroLatencyDepth(I) > getZeroLatencyDepth(maxDepth))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">              maxDepth = I;</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">              maxDepth = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">                     getZeroLatencyDepth(I) == getZeroLatencyDepth(maxDepth) &&</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">                     getZeroLatencyDepth(I) == getZeroLatencyDepth(maxDepth) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">                     getMOV(I) < getMOV(maxDepth))</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">                     getMOV(I) < getMOV(maxDepth))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">              maxDepth = I;</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">              maxDepth = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">          NodeOrder.insert(maxDepth);</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">          NodeOrder.insert(maxDepth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << maxDepth->NodeNum << " ");</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << maxDepth->NodeNum << " ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">          R.remove(maxDepth);</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">          R.remove(maxDepth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">          if (Nodes.isExceedSU(maxDepth)) {</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">          if (Nodes.isExceedSU(maxDepth)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">            Order = TopDown;</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">            Order = TopDown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">            R.clear();</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">            R.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">            R.insert(Nodes.getNode(0));</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">            R.insert(Nodes.getNode(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">            break;</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">            break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">          for (const auto &I : maxDepth->Preds) {</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">          for (const auto &I : maxDepth->Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">            if (Nodes.count(I.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">            if (NodeOrder.contains(I.getSUnit()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">            R.insert(I.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">          // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">          // Back-edges are predecessors with an anti-dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">          for (const auto &I : maxDepth->Succs) {</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">          for (const auto &I : maxDepth->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">            if (I.getKind() != SDep::Anti)</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">            if (I.getKind() != SDep::Anti)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">            if (Nodes.count(I.getSUnit()) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">            if (NodeOrder.contains(I.getSUnit()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">            R.insert(I.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">        Order = TopDown;</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">        Order = TopDown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "\n   Switching order to top down ");</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "\n   Switching order to top down ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">        SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">        SmallSetVector<SUnit *, 8> N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">        if (succ_L(NodeOrder, N, &Nodes))</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">        if (succ_L(NodeOrder, N, &Nodes))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">          R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">          R.insert(N.begin(), N.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\nDone with Nodeset\n");</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\nDone with Nodeset\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">    dbgs() << "Node order: ";</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">    dbgs() << "Node order: ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">    for (SUnit *I : NodeOrder)</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">    for (SUnit *I : NodeOrder)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">      dbgs() << " " << I->NodeNum << " ";</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">      dbgs() << " " << I->NodeNum << " ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">    dbgs() << "\n";</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">    dbgs() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline"></td>
    <td class="lineNumber">1959</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">/// Process the nodes in the computed order and create the pipelined schedule</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">/// Process the nodes in the computed order and create the pipelined schedule</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">/// of the instructions, if possible. Return true if a schedule is found.</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">/// of the instructions, if possible. Return true if a schedule is found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">bool SwingSchedulerDAG::schedulePipeline(SMSchedule &Schedule) {</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">bool SwingSchedulerDAG::schedulePipeline(SMSchedule &Schedule) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline"></td>
    <td class="lineNumber">1963</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  if (NodeOrder.empty()){</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  if (NodeOrder.empty()){</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "NodeOrder is empty! abort scheduling\n" );</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "NodeOrder is empty! abort scheduling\n" );</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline"></td>
    <td class="lineNumber">1968</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">  bool scheduleFound = false;</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">  bool scheduleFound = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  // Keep increasing II until a valid schedule is found.</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  // Keep increasing II until a valid schedule is found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">  for (unsigned II = MII; II <= MAX_II && !scheduleFound; ++II) {</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">  for (unsigned II = MII; II <= MAX_II && !scheduleFound; ++II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">    Schedule.reset();</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">    Schedule.reset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">    Schedule.setInitiationInterval(II);</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">    Schedule.setInitiationInterval(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Try to schedule with " << II << "\n");</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Try to schedule with " << II << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline"></td>
    <td class="lineNumber">1975</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">    SetVector<SUnit *>::iterator NI = NodeOrder.begin();</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">    SetVector<SUnit *>::iterator NI = NodeOrder.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">    SetVector<SUnit *>::iterator NE = NodeOrder.end();</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">    SetVector<SUnit *>::iterator NE = NodeOrder.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">      SUnit *SU = *NI;</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">      SUnit *SU = *NI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline"></td>
    <td class="lineNumber">1980</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">      // Compute the schedule time for the instruction, which is based</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">      // Compute the schedule time for the instruction, which is based</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">      // upon the scheduled time for any predecessors/successors.</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">      // upon the scheduled time for any predecessors/successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">      int EarlyStart = INT_MIN;</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">      int EarlyStart = INT_MIN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">      int LateStart = INT_MAX;</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">      int LateStart = INT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">      // These values are set when the size of the schedule window is limited</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">      // These values are set when the size of the schedule window is limited</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">      // due to chain dependences.</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">      // due to chain dependences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">      int SchedEnd = INT_MAX;</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">      int SchedEnd = INT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">      int SchedStart = INT_MIN;</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">      int SchedStart = INT_MIN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">      Schedule.computeStart(SU, &EarlyStart, &LateStart, &SchedEnd, &SchedStart,</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">      Schedule.computeStart(SU, &EarlyStart, &LateStart, &SchedEnd, &SchedStart,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">                            II, this);</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">                            II, this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">      LLVM_DEBUG({</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">      LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">        dbgs() << "\n";</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">        dbgs() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">        dbgs() << "Inst (" << SU->NodeNum << ") ";</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">        dbgs() << "Inst (" << SU->NodeNum << ") ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">        SU->getInstr()->dump();</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">        SU->getInstr()->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">        dbgs() << "\n";</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">        dbgs() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">      LLVM_DEBUG({</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">      LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">        dbgs() << format("\tes: %8x ls: %8x me: %8x ms: %8x\n", EarlyStart,</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">        dbgs() << format("\tes: %8x ls: %8x me: %8x ms: %8x\n", EarlyStart,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">                         LateStart, SchedEnd, SchedStart);</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">                         LateStart, SchedEnd, SchedStart);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline"></td>
    <td class="lineNumber">2001</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">      if (EarlyStart > LateStart || SchedEnd < EarlyStart ||</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">      if (EarlyStart > LateStart || SchedEnd < EarlyStart ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">          SchedStart > LateStart)</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">          SchedStart > LateStart)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">        scheduleFound = false;</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">        scheduleFound = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">      else if (EarlyStart != INT_MIN && LateStart == INT_MAX) {</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">      else if (EarlyStart != INT_MIN && LateStart == INT_MAX) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">        SchedEnd = std::min(SchedEnd, EarlyStart + (int)II - 1);</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">        SchedEnd = std::min(SchedEnd, EarlyStart + (int)II - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">        scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">        scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">      } else if (EarlyStart == INT_MIN && LateStart != INT_MAX) {</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">      } else if (EarlyStart == INT_MIN && LateStart != INT_MAX) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">        SchedStart = std::max(SchedStart, LateStart - (int)II + 1);</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">        SchedStart = std::max(SchedStart, LateStart - (int)II + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">        scheduleFound = Schedule.insert(SU, LateStart, SchedStart, II);</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">        scheduleFound = Schedule.insert(SU, LateStart, SchedStart, II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">      } else if (EarlyStart != INT_MIN && LateStart != INT_MAX) {</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">      } else if (EarlyStart != INT_MIN && LateStart != INT_MAX) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">        SchedEnd =</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">        SchedEnd =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">            std::min(SchedEnd, std::min(LateStart, EarlyStart + (int)II - 1));</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">            std::min(SchedEnd, std::min(LateStart, EarlyStart + (int)II - 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">        // When scheduling a Phi it is better to start at the late cycle and go</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">        // When scheduling a Phi it is better to start at the late cycle and go</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">        // backwards. The default order may insert the Phi too far away from</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">        // backwards. The default order may insert the Phi too far away from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">        // its first dependence.</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">        // its first dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">        if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">        if (SU->getInstr()->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">          scheduleFound = Schedule.insert(SU, SchedEnd, EarlyStart, II);</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">          scheduleFound = Schedule.insert(SU, SchedEnd, EarlyStart, II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">        else</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">        else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">          scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">          scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">        int FirstCycle = Schedule.getFirstCycle();</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">        int FirstCycle = Schedule.getFirstCycle();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">        scheduleFound = Schedule.insert(SU, FirstCycle + getASAP(SU),</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">        scheduleFound = Schedule.insert(SU, FirstCycle + getASAP(SU),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">                                        FirstCycle + getASAP(SU) + II - 1, II);</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">                                        FirstCycle + getASAP(SU) + II - 1, II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">      // Even if we find a schedule, make sure the schedule doesn't exceed the</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">      // Even if we find a schedule, make sure the schedule doesn't exceed the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">      // allowable number of stages. We keep trying if this happens.</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">      // allowable number of stages. We keep trying if this happens.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">      if (scheduleFound)</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">      if (scheduleFound)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">        if (SwpMaxStages > -1 &&</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">        if (SwpMaxStages > -1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">            Schedule.getMaxStageCount() > (unsigned)SwpMaxStages)</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">            Schedule.getMaxStageCount() > (unsigned)SwpMaxStages)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">          scheduleFound = false;</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">          scheduleFound = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline"></td>
    <td class="lineNumber">2032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">      LLVM_DEBUG({</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">      LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">        if (!scheduleFound)</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">        if (!scheduleFound)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">          dbgs() << "\tCan't schedule\n";</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">          dbgs() << "\tCan't schedule\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">    } while (++NI != NE && scheduleFound);</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">    } while (++NI != NE && scheduleFound);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline"></td>
    <td class="lineNumber">2038</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">    // If a schedule is found, ensure non-pipelined instructions are in stage 0</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">    // If a schedule is found, ensure non-pipelined instructions are in stage 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">    if (scheduleFound)</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">    if (scheduleFound)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">      scheduleFound =</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">      scheduleFound =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">          Schedule.normalizeNonPipelinedInstructions(this, LoopPipelinerInfo);</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">          Schedule.normalizeNonPipelinedInstructions(this, LoopPipelinerInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline"></td>
    <td class="lineNumber">2043</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">    // If a schedule is found, check if it is a valid schedule too.</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">    // If a schedule is found, check if it is a valid schedule too.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">    if (scheduleFound)</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">    if (scheduleFound)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">      scheduleFound = Schedule.isValidSchedule(this);</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">      scheduleFound = Schedule.isValidSchedule(this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline"></td>
    <td class="lineNumber">2048</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Schedule Found? " << scheduleFound</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Schedule Found? " << scheduleFound</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">                    << " (II=" << Schedule.getInitiationInterval()</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">                    << " (II=" << Schedule.getInitiationInterval()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">                    << ")\n");</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">                    << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline"></td>
    <td class="lineNumber">2052</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">  if (scheduleFound) {</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">  if (scheduleFound) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">    scheduleFound = LoopPipelinerInfo->shouldUseSchedule(*this, Schedule);</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">    scheduleFound = LoopPipelinerInfo->shouldUseSchedule(*this, Schedule);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">    if (!scheduleFound)</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">    if (!scheduleFound)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Target rejected schedule\n");</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Target rejected schedule\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline"></td>
    <td class="lineNumber">2058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">  if (scheduleFound) {</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">  if (scheduleFound) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">    Schedule.finalizeSchedule(this);</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">    Schedule.finalizeSchedule(this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">    Pass.ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">      return MachineOptimizationRemarkAnalysis(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">             << "Schedule found with Initiation Interval: "</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">             << "Schedule found with Initiation Interval: "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">             << ore::NV("II", Schedule.getInitiationInterval())</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">             << ore::NV("II", Schedule.getInitiationInterval())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">             << ", MaxStageCount: "</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">             << ", MaxStageCount: "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">             << ore::NV("MaxStageCount", Schedule.getMaxStageCount());</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">             << ore::NV("MaxStageCount", Schedule.getMaxStageCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">  } else</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">  } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">    Schedule.reset();</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">    Schedule.reset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline"></td>
    <td class="lineNumber">2071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">  return scheduleFound && Schedule.getMaxStageCount() > 0;</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">  return scheduleFound && Schedule.getMaxStageCount() > 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline"></td>
    <td class="lineNumber">2074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">/// Return true if we can compute the amount the instruction changes</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">/// Return true if we can compute the amount the instruction changes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">/// during each iteration. Set Delta to the amount of the change.</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">/// during each iteration. Set Delta to the amount of the change.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">bool SwingSchedulerDAG::computeDelta(MachineInstr &MI, unsigned &Delta) {</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">bool SwingSchedulerDAG::computeDelta(MachineInstr &MI, unsigned &Delta) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">  const MachineOperand *BaseOp;</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">  const MachineOperand *BaseOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">  int64_t Offset;</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">  int64_t Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  bool OffsetIsScalable;</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  bool OffsetIsScalable;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">  if (!TII->getMemOperandWithOffset(MI, BaseOp, Offset, OffsetIsScalable, TRI))</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">  if (!TII->getMemOperandWithOffset(MI, BaseOp, Offset, OffsetIsScalable, TRI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  // FIXME: This algorithm assumes instructions have fixed-size offsets.</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  // FIXME: This algorithm assumes instructions have fixed-size offsets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  if (OffsetIsScalable)</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  if (OffsetIsScalable)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">  if (!BaseOp->isReg())</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">  if (!BaseOp->isReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline"></td>
    <td class="lineNumber">2091</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">  Register BaseReg = BaseOp->getReg();</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">  Register BaseReg = BaseOp->getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline"></td>
    <td class="lineNumber">2093</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">  // Check if there is a Phi. If so, get the definition in the loop.</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">  // Check if there is a Phi. If so, get the definition in the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  MachineInstr *BaseDef = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  MachineInstr *BaseDef = MRI.getVRegDef(BaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">  if (BaseDef && BaseDef->isPHI()) {</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">  if (BaseDef && BaseDef->isPHI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">    BaseReg = getLoopPhiReg(*BaseDef, MI.getParent());</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">    BaseReg = getLoopPhiReg(*BaseDef, MI.getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">    BaseDef = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">    BaseDef = MRI.getVRegDef(BaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">  if (!BaseDef)</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">  if (!BaseDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline"></td>
    <td class="lineNumber">2103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  int D = 0;</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  int D = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  if (!TII->getIncrementValue(*BaseDef, D) && D >= 0)</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  if (!TII->getIncrementValue(*BaseDef, D) && D >= 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline"></td>
    <td class="lineNumber">2107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">  Delta = D;</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">  Delta = D;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline"></td>
    <td class="lineNumber">2111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">/// Check if we can change the instruction to use an offset value from the</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">/// Check if we can change the instruction to use an offset value from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">/// previous iteration. If so, return true and set the base and offset values</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">/// previous iteration. If so, return true and set the base and offset values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">/// so that we can rewrite the load, if necessary.</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">/// so that we can rewrite the load, if necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">///   v1 = Phi(v0, v3)</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">///   v1 = Phi(v0, v3)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">///   v2 = load v1, 0</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">///   v2 = load v1, 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">///   v3 = post_store v1, 4, x</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">///   v3 = post_store v1, 4, x</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">/// This function enables the load to be rewritten as v2 = load v3, 4.</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">/// This function enables the load to be rewritten as v2 = load v3, 4.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">bool SwingSchedulerDAG::canUseLastOffsetValue(MachineInstr *MI,</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">bool SwingSchedulerDAG::canUseLastOffsetValue(MachineInstr *MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">                                              unsigned &BasePos,</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">                                              unsigned &BasePos,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">                                              unsigned &OffsetPos,</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">                                              unsigned &OffsetPos,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">                                              unsigned &NewBase,</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">                                              unsigned &NewBase,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">                                              int64_t &Offset) {</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">                                              int64_t &Offset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">  // Get the load instruction.</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">  // Get the load instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  if (TII->isPostIncrement(*MI))</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  if (TII->isPostIncrement(*MI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">  unsigned BasePosLd, OffsetPosLd;</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">  unsigned BasePosLd, OffsetPosLd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">  if (!TII->getBaseAndOffsetPosition(*MI, BasePosLd, OffsetPosLd))</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">  if (!TII->getBaseAndOffsetPosition(*MI, BasePosLd, OffsetPosLd))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">  Register BaseReg = MI->getOperand(BasePosLd).getReg();</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">  Register BaseReg = MI->getOperand(BasePosLd).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline"></td>
    <td class="lineNumber">2131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">  // Look for the Phi instruction.</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">  // Look for the Phi instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  MachineRegisterInfo &MRI = MI->getMF()->getRegInfo();</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  MachineRegisterInfo &MRI = MI->getMF()->getRegInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">  MachineInstr *Phi = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">  MachineInstr *Phi = MRI.getVRegDef(BaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">  if (!Phi || !Phi->isPHI())</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">  if (!Phi || !Phi->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">  // Get the register defined in the loop block.</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">  // Get the register defined in the loop block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">  unsigned PrevReg = getLoopPhiReg(*Phi, MI->getParent());</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">  unsigned PrevReg = getLoopPhiReg(*Phi, MI->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">  if (!PrevReg)</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">  if (!PrevReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline"></td>
    <td class="lineNumber">2141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">  // Check for the post-increment load/store instruction.</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">  // Check for the post-increment load/store instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  MachineInstr *PrevDef = MRI.getVRegDef(PrevReg);</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  MachineInstr *PrevDef = MRI.getVRegDef(PrevReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  if (!PrevDef || PrevDef == MI)</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  if (!PrevDef || PrevDef == MI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline"></td>
    <td class="lineNumber">2146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">  if (!TII->isPostIncrement(*PrevDef))</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">  if (!TII->isPostIncrement(*PrevDef))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline"></td>
    <td class="lineNumber">2149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">  unsigned BasePos1 = 0, OffsetPos1 = 0;</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">  unsigned BasePos1 = 0, OffsetPos1 = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">  if (!TII->getBaseAndOffsetPosition(*PrevDef, BasePos1, OffsetPos1))</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">  if (!TII->getBaseAndOffsetPosition(*PrevDef, BasePos1, OffsetPos1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline"></td>
    <td class="lineNumber">2153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">  // Make sure that the instructions do not access the same memory location in</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">  // Make sure that the instructions do not access the same memory location in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">  // the next iteration.</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">  // the next iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">  int64_t LoadOffset = MI->getOperand(OffsetPosLd).getImm();</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">  int64_t LoadOffset = MI->getOperand(OffsetPosLd).getImm();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">  int64_t StoreOffset = PrevDef->getOperand(OffsetPos1).getImm();</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">  int64_t StoreOffset = PrevDef->getOperand(OffsetPos1).getImm();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">  MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">  MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">  NewMI->getOperand(OffsetPosLd).setImm(LoadOffset + StoreOffset);</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">  NewMI->getOperand(OffsetPosLd).setImm(LoadOffset + StoreOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">  bool Disjoint = TII->areMemAccessesTriviallyDisjoint(*NewMI, *PrevDef);</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">  bool Disjoint = TII->areMemAccessesTriviallyDisjoint(*NewMI, *PrevDef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">  MF.deleteMachineInstr(NewMI);</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">  MF.deleteMachineInstr(NewMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">  if (!Disjoint)</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">  if (!Disjoint)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline"></td>
    <td class="lineNumber">2164</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  // Set the return value once we determine that we return true.</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  // Set the return value once we determine that we return true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  BasePos = BasePosLd;</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  BasePos = BasePosLd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">  OffsetPos = OffsetPosLd;</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">  OffsetPos = OffsetPosLd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  NewBase = PrevReg;</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  NewBase = PrevReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  Offset = StoreOffset;</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  Offset = StoreOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline"></td>
    <td class="lineNumber">2172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">/// Apply changes to the instruction if needed. The changes are need</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">/// Apply changes to the instruction if needed. The changes are need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">/// to improve the scheduling and depend up on the final schedule.</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">/// to improve the scheduling and depend up on the final schedule.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">void SwingSchedulerDAG::applyInstrChange(MachineInstr *MI,</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">void SwingSchedulerDAG::applyInstrChange(MachineInstr *MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">                                         SMSchedule &Schedule) {</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">                                         SMSchedule &Schedule) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">  SUnit *SU = getSUnit(MI);</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">  SUnit *SU = getSUnit(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">  DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">  DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">      InstrChanges.find(SU);</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">      InstrChanges.find(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">  if (It != InstrChanges.end()) {</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">  if (It != InstrChanges.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">    std::pair<unsigned, int64_t> RegAndOffset = It->second;</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">    std::pair<unsigned, int64_t> RegAndOffset = It->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">    unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">    unsigned BasePos, OffsetPos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">    if (!TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">    if (!TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">    Register BaseReg = MI->getOperand(BasePos).getReg();</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">    Register BaseReg = MI->getOperand(BasePos).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">    MachineInstr *LoopDef = findDefInLoop(BaseReg);</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">    MachineInstr *LoopDef = findDefInLoop(BaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">    int DefStageNum = Schedule.stageScheduled(getSUnit(LoopDef));</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">    int DefStageNum = Schedule.stageScheduled(getSUnit(LoopDef));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">    int DefCycleNum = Schedule.cycleScheduled(getSUnit(LoopDef));</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">    int DefCycleNum = Schedule.cycleScheduled(getSUnit(LoopDef));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">    int BaseStageNum = Schedule.stageScheduled(SU);</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">    int BaseStageNum = Schedule.stageScheduled(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">    int BaseCycleNum = Schedule.cycleScheduled(SU);</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">    int BaseCycleNum = Schedule.cycleScheduled(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">    if (BaseStageNum < DefStageNum) {</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">    if (BaseStageNum < DefStageNum) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">      MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">      MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">      int OffsetDiff = DefStageNum - BaseStageNum;</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">      int OffsetDiff = DefStageNum - BaseStageNum;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">      if (DefCycleNum < BaseCycleNum) {</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">      if (DefCycleNum < BaseCycleNum) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">        NewMI->getOperand(BasePos).setReg(RegAndOffset.first);</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">        NewMI->getOperand(BasePos).setReg(RegAndOffset.first);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">        if (OffsetDiff > 0)</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">        if (OffsetDiff > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">          --OffsetDiff;</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">          --OffsetDiff;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">      int64_t NewOffset =</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">      int64_t NewOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">          MI->getOperand(OffsetPos).getImm() + RegAndOffset.second * OffsetDiff;</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">          MI->getOperand(OffsetPos).getImm() + RegAndOffset.second * OffsetDiff;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">      NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">      NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">      SU->setInstr(NewMI);</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">      SU->setInstr(NewMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">      MISUnitMap[NewMI] = SU;</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">      MISUnitMap[NewMI] = SU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">      NewMIs[MI] = NewMI;</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">      NewMIs[MI] = NewMI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline"></td>
    <td class="lineNumber">2208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">/// Return the instruction in the loop that defines the register.</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">/// Return the instruction in the loop that defines the register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">/// If the definition is a Phi, then follow the Phi operand to</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">/// If the definition is a Phi, then follow the Phi operand to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">/// the instruction in the loop.</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">/// the instruction in the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">MachineInstr *SwingSchedulerDAG::findDefInLoop(Register Reg) {</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">MachineInstr *SwingSchedulerDAG::findDefInLoop(Register Reg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">  SmallPtrSet<MachineInstr *, 8> Visited;</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">  SmallPtrSet<MachineInstr *, 8> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">  MachineInstr *Def = MRI.getVRegDef(Reg);</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">  MachineInstr *Def = MRI.getVRegDef(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">  while (Def->isPHI()) {</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">  while (Def->isPHI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">    if (!Visited.insert(Def).second)</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">    if (!Visited.insert(Def).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">    for (unsigned i = 1, e = Def->getNumOperands(); i < e; i += 2)</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">    for (unsigned i = 1, e = Def->getNumOperands(); i < e; i += 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">      if (Def->getOperand(i + 1).getMBB() == BB) {</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">      if (Def->getOperand(i + 1).getMBB() == BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">        Def = MRI.getVRegDef(Def->getOperand(i).getReg());</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">        Def = MRI.getVRegDef(Def->getOperand(i).getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">  return Def;</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">  return Def;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline"></td>
    <td class="lineNumber">2226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">/// Return true for an order or output dependence that is loop carried</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">/// Return true for an order or output dependence that is loop carried</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">/// potentially. A dependence is loop carried if the destination defines a valu</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">/// potentially. A dependence is loop carried if the destination defines a valu</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">/// that may be used or defined by the source in a subsequent iteration.</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">/// that may be used or defined by the source in a subsequent iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">bool SwingSchedulerDAG::isLoopCarriedDep(SUnit *Source, const SDep &Dep,</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">bool SwingSchedulerDAG::isLoopCarriedDep(SUnit *Source, const SDep &Dep,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">                                         bool isSucc) {</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">                                         bool isSucc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">  if ((Dep.getKind() != SDep::Order && Dep.getKind() != SDep::Output) ||</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">  if ((Dep.getKind() != SDep::Order && Dep.getKind() != SDep::Output) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">      Dep.isArtificial() || Dep.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">      Dep.isArtificial() || Dep.getSUnit()->isBoundaryNode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline"></td>
    <td class="lineNumber">2235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">  if (!SwpPruneLoopCarried)</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">  if (!SwpPruneLoopCarried)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">  if (Dep.getKind() == SDep::Output)</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">  if (Dep.getKind() == SDep::Output)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline"></td>
    <td class="lineNumber">2241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">  MachineInstr *SI = Source->getInstr();</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">  MachineInstr *SI = Source->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">  MachineInstr *DI = Dep.getSUnit()->getInstr();</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">  MachineInstr *DI = Dep.getSUnit()->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">  if (!isSucc)</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">  if (!isSucc)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">    std::swap(SI, DI);</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">    std::swap(SI, DI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">  assert(SI != nullptr && DI != nullptr && "Expecting SUnit with an MI.");</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">  assert(SI != nullptr && DI != nullptr && "Expecting SUnit with an MI.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline"></td>
    <td class="lineNumber">2247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">  // Assume ordered loads and stores may have a loop carried dependence.</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">  // Assume ordered loads and stores may have a loop carried dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">  if (SI->hasUnmodeledSideEffects() || DI->hasUnmodeledSideEffects() ||</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">  if (SI->hasUnmodeledSideEffects() || DI->hasUnmodeledSideEffects() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">      SI->mayRaiseFPException() || DI->mayRaiseFPException() ||</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">      SI->mayRaiseFPException() || DI->mayRaiseFPException() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">      SI->hasOrderedMemoryRef() || DI->hasOrderedMemoryRef())</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">      SI->hasOrderedMemoryRef() || DI->hasOrderedMemoryRef())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline"></td>
    <td class="lineNumber">2253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  // Only chain dependences between a load and store can be loop carried.</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  // Only chain dependences between a load and store can be loop carried.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">  if (!DI->mayStore() || !SI->mayLoad())</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">  if (!DI->mayStore() || !SI->mayLoad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline"></td>
    <td class="lineNumber">2257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  unsigned DeltaS, DeltaD;</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  unsigned DeltaS, DeltaD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">  if (!computeDelta(*SI, DeltaS) || !computeDelta(*DI, DeltaD))</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">  if (!computeDelta(*SI, DeltaS) || !computeDelta(*DI, DeltaD))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline"></td>
    <td class="lineNumber">2261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">  const MachineOperand *BaseOpS, *BaseOpD;</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">  const MachineOperand *BaseOpS, *BaseOpD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">  int64_t OffsetS, OffsetD;</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">  int64_t OffsetS, OffsetD;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">  bool OffsetSIsScalable, OffsetDIsScalable;</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">  bool OffsetSIsScalable, OffsetDIsScalable;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">  if (!TII->getMemOperandWithOffset(*SI, BaseOpS, OffsetS, OffsetSIsScalable,</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">  if (!TII->getMemOperandWithOffset(*SI, BaseOpS, OffsetS, OffsetSIsScalable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">                                    TRI) ||</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">                                    TRI) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">      !TII->getMemOperandWithOffset(*DI, BaseOpD, OffsetD, OffsetDIsScalable,</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">      !TII->getMemOperandWithOffset(*DI, BaseOpD, OffsetD, OffsetDIsScalable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">                                    TRI))</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">                                    TRI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline"></td>
    <td class="lineNumber">2271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">  assert(!OffsetSIsScalable && !OffsetDIsScalable &&</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">  assert(!OffsetSIsScalable && !OffsetDIsScalable &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">         "Expected offsets to be byte offsets");</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">         "Expected offsets to be byte offsets");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline"></td>
    <td class="lineNumber">2274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">  MachineInstr *DefS = MRI.getVRegDef(BaseOpS->getReg());</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">  MachineInstr *DefS = MRI.getVRegDef(BaseOpS->getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">  MachineInstr *DefD = MRI.getVRegDef(BaseOpD->getReg());</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">  MachineInstr *DefD = MRI.getVRegDef(BaseOpD->getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">  if (!DefS || !DefD || !DefS->isPHI() || !DefD->isPHI())</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">  if (!DefS || !DefD || !DefS->isPHI() || !DefD->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline"></td>
    <td class="lineNumber">2279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">  unsigned InitValS = 0;</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">  unsigned InitValS = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">  unsigned LoopValS = 0;</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">  unsigned LoopValS = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">  unsigned InitValD = 0;</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">  unsigned InitValD = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">  unsigned LoopValD = 0;</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">  unsigned LoopValD = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">  getPhiRegs(*DefS, BB, InitValS, LoopValS);</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">  getPhiRegs(*DefS, BB, InitValS, LoopValS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">  getPhiRegs(*DefD, BB, InitValD, LoopValD);</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">  getPhiRegs(*DefD, BB, InitValD, LoopValD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">  MachineInstr *InitDefS = MRI.getVRegDef(InitValS);</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">  MachineInstr *InitDefS = MRI.getVRegDef(InitValS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">  MachineInstr *InitDefD = MRI.getVRegDef(InitValD);</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">  MachineInstr *InitDefD = MRI.getVRegDef(InitValD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline"></td>
    <td class="lineNumber">2288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">  if (!InitDefS->isIdenticalTo(*InitDefD))</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">  if (!InitDefS->isIdenticalTo(*InitDefD))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline"></td>
    <td class="lineNumber">2291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">  // Check that the base register is incremented by a constant value for each</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">  // Check that the base register is incremented by a constant value for each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">  // iteration.</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">  // iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">  MachineInstr *LoopDefS = MRI.getVRegDef(LoopValS);</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">  MachineInstr *LoopDefS = MRI.getVRegDef(LoopValS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">  int D = 0;</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">  int D = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">  if (!LoopDefS || !TII->getIncrementValue(*LoopDefS, D))</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">  if (!LoopDefS || !TII->getIncrementValue(*LoopDefS, D))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline"></td>
    <td class="lineNumber">2298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">  uint64_t AccessSizeS = (*SI->memoperands_begin())->getSize();</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">  uint64_t AccessSizeS = (*SI->memoperands_begin())->getSize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">  uint64_t AccessSizeD = (*DI->memoperands_begin())->getSize();</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">  uint64_t AccessSizeD = (*DI->memoperands_begin())->getSize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline"></td>
    <td class="lineNumber">2301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">  // This is the main test, which checks the offset values and the loop</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">  // This is the main test, which checks the offset values and the loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">  // increment value to determine if the accesses may be loop carried.</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">  // increment value to determine if the accesses may be loop carried.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">  if (AccessSizeS == MemoryLocation::UnknownSize ||</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">  if (AccessSizeS == MemoryLocation::UnknownSize ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">      AccessSizeD == MemoryLocation::UnknownSize)</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">      AccessSizeD == MemoryLocation::UnknownSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline"></td>
    <td class="lineNumber">2307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">  if (DeltaS != DeltaD || DeltaS < AccessSizeS || DeltaD < AccessSizeD)</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">  if (DeltaS != DeltaD || DeltaS < AccessSizeS || DeltaD < AccessSizeD)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline"></td>
    <td class="lineNumber">2310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">  return (OffsetS + (int64_t)AccessSizeS < OffsetD + (int64_t)AccessSizeD);</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">  return (OffsetS + (int64_t)AccessSizeS < OffsetD + (int64_t)AccessSizeD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline"></td>
    <td class="lineNumber">2313</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">void SwingSchedulerDAG::postProcessDAG() {</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">void SwingSchedulerDAG::postProcessDAG() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">  for (auto &M : Mutations)</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">  for (auto &M : Mutations)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">    M->apply(this);</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">    M->apply(this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">/// Try to schedule the node at the specified StartCycle and continue</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">/// Try to schedule the node at the specified StartCycle and continue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">/// until the node is schedule or the EndCycle is reached.  This function</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">/// until the node is schedule or the EndCycle is reached.  This function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">/// returns true if the node is scheduled.  This routine may search either</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">/// returns true if the node is scheduled.  This routine may search either</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">/// forward or backward for a place to insert the instruction based upon</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">/// forward or backward for a place to insert the instruction based upon</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">/// the relative values of StartCycle and EndCycle.</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">/// the relative values of StartCycle and EndCycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">bool SMSchedule::insert(SUnit *SU, int StartCycle, int EndCycle, int II) {</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">bool SMSchedule::insert(SUnit *SU, int StartCycle, int EndCycle, int II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">  bool forward = true;</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">  bool forward = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">    dbgs() << "Trying to insert node between " << StartCycle << " and "</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">    dbgs() << "Trying to insert node between " << StartCycle << " and "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">           << EndCycle << " II: " << II << "\n";</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">           << EndCycle << " II: " << II << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">  if (StartCycle > EndCycle)</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">  if (StartCycle > EndCycle)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">    forward = false;</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">    forward = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline"></td>
    <td class="lineNumber">2332</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">  // The terminating condition depends on the direction.</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">  // The terminating condition depends on the direction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">  int termCycle = forward ? EndCycle + 1 : EndCycle - 1;</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">  int termCycle = forward ? EndCycle + 1 : EndCycle - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">  for (int curCycle = StartCycle; curCycle != termCycle;</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">  for (int curCycle = StartCycle; curCycle != termCycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">       forward ? ++curCycle : --curCycle) {</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">       forward ? ++curCycle : --curCycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline"></td>
    <td class="lineNumber">2337</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">    if (ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()) ||</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">    if (ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">        ProcItinResources.canReserveResources(*SU, curCycle)) {</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">        ProcItinResources.canReserveResources(*SU, curCycle)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">      LLVM_DEBUG({</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">      LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">        dbgs() << "\tinsert at cycle " << curCycle << " ";</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">        dbgs() << "\tinsert at cycle " << curCycle << " ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">        SU->getInstr()->dump();</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">        SU->getInstr()->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline"></td>
    <td class="lineNumber">2344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">      if (!ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()))</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">      if (!ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">        ProcItinResources.reserveResources(*SU, curCycle);</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">        ProcItinResources.reserveResources(*SU, curCycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">      ScheduledInstrs[curCycle].push_back(SU);</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">      ScheduledInstrs[curCycle].push_back(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">      InstrToCycle.insert(std::make_pair(SU, curCycle));</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">      InstrToCycle.insert(std::make_pair(SU, curCycle));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">      if (curCycle > LastCycle)</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">      if (curCycle > LastCycle)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">        LastCycle = curCycle;</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">        LastCycle = curCycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">      if (curCycle < FirstCycle)</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">      if (curCycle < FirstCycle)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">        FirstCycle = curCycle;</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">        FirstCycle = curCycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">    LLVM_DEBUG({</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">    LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">      dbgs() << "\tfailed to insert at cycle " << curCycle << " ";</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">      dbgs() << "\tfailed to insert at cycle " << curCycle << " ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">      SU->getInstr()->dump();</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">      SU->getInstr()->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">// Return the cycle of the earliest scheduled instruction in the chain.</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">// Return the cycle of the earliest scheduled instruction in the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">int SMSchedule::earliestCycleInChain(const SDep &Dep) {</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">int SMSchedule::earliestCycleInChain(const SDep &Dep) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 8> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">  SmallVector<SDep, 8> Worklist;</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">  SmallVector<SDep, 8> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">  Worklist.push_back(Dep);</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">  Worklist.push_back(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">  int EarlyCycle = INT_MAX;</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">  int EarlyCycle = INT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">    const SDep &Cur = Worklist.pop_back_val();</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">    const SDep &Cur = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">    SUnit *PrevSU = Cur.getSUnit();</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">    SUnit *PrevSU = Cur.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">    if (Visited.count(PrevSU))</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">    if (Visited.count(PrevSU))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(PrevSU);</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(PrevSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">    if (it == InstrToCycle.end())</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">    if (it == InstrToCycle.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">    EarlyCycle = std::min(EarlyCycle, it->second);</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">    EarlyCycle = std::min(EarlyCycle, it->second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">    for (const auto &PI : PrevSU->Preds)</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">    for (const auto &PI : PrevSU->Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">      if (PI.getKind() == SDep::Order || PI.getKind() == SDep::Output)</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">      if (PI.getKind() == SDep::Order || PI.getKind() == SDep::Output)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">        Worklist.push_back(PI);</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">        Worklist.push_back(PI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">    Visited.insert(PrevSU);</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">    Visited.insert(PrevSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">  return EarlyCycle;</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">  return EarlyCycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">// Return the cycle of the latest scheduled instruction in the chain.</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">// Return the cycle of the latest scheduled instruction in the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">int SMSchedule::latestCycleInChain(const SDep &Dep) {</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">int SMSchedule::latestCycleInChain(const SDep &Dep) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">  SmallPtrSet<SUnit *, 8> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">  SmallVector<SDep, 8> Worklist;</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">  SmallVector<SDep, 8> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">  Worklist.push_back(Dep);</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">  Worklist.push_back(Dep);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">  int LateCycle = INT_MIN;</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">  int LateCycle = INT_MIN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">    const SDep &Cur = Worklist.pop_back_val();</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">    const SDep &Cur = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">    SUnit *SuccSU = Cur.getSUnit();</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">    SUnit *SuccSU = Cur.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">    if (Visited.count(SuccSU) || SuccSU->isBoundaryNode())</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">    if (Visited.count(SuccSU) || SuccSU->isBoundaryNode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(SuccSU);</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(SuccSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">    if (it == InstrToCycle.end())</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">    if (it == InstrToCycle.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">    LateCycle = std::max(LateCycle, it->second);</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">    LateCycle = std::max(LateCycle, it->second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">    for (const auto &SI : SuccSU->Succs)</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">    for (const auto &SI : SuccSU->Succs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">      if (SI.getKind() == SDep::Order || SI.getKind() == SDep::Output)</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">      if (SI.getKind() == SDep::Order || SI.getKind() == SDep::Output)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">        Worklist.push_back(SI);</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">        Worklist.push_back(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">    Visited.insert(SuccSU);</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">    Visited.insert(SuccSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">  return LateCycle;</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">  return LateCycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline"></td>
    <td class="lineNumber">2408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">/// If an instruction has a use that spans multiple iterations, then</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">/// If an instruction has a use that spans multiple iterations, then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">/// return true. These instructions are characterized by having a back-ege</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">/// return true. These instructions are characterized by having a back-ege</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">/// to a Phi, which contains a reference to another Phi.</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">/// to a Phi, which contains a reference to another Phi.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">static SUnit *multipleIterations(SUnit *SU, SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">static SUnit *multipleIterations(SUnit *SU, SwingSchedulerDAG *DAG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">  for (auto &P : SU->Preds)</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">  for (auto &P : SU->Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">    if (DAG->isBackedge(SU, P) && P.getSUnit()->getInstr()->isPHI())</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">    if (DAG->isBackedge(SU, P) && P.getSUnit()->getInstr()->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">      for (auto &S : P.getSUnit()->Succs)</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">      for (auto &S : P.getSUnit()->Succs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">        if (S.getKind() == SDep::Data && S.getSUnit()->getInstr()->isPHI())</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">        if (S.getKind() == SDep::Data && S.getSUnit()->getInstr()->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">          return P.getSUnit();</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">          return P.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline"></td>
    <td class="lineNumber">2420</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">/// Compute the scheduling start slot for the instruction.  The start slot</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">/// Compute the scheduling start slot for the instruction.  The start slot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">/// depends on any predecessor or successor nodes scheduled already.</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">/// depends on any predecessor or successor nodes scheduled already.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">void SMSchedule::computeStart(SUnit *SU, int *MaxEarlyStart, int *MinLateStart,</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">void SMSchedule::computeStart(SUnit *SU, int *MaxEarlyStart, int *MinLateStart,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">                              int *MinEnd, int *MaxStart, int II,</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">                              int *MinEnd, int *MaxStart, int II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">                              SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">                              SwingSchedulerDAG *DAG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">  // Iterate over each instruction that has been scheduled already.  The start</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">  // Iterate over each instruction that has been scheduled already.  The start</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">  // slot computation depends on whether the previously scheduled instruction</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">  // slot computation depends on whether the previously scheduled instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">  // is a predecessor or successor of the specified instruction.</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">  // is a predecessor or successor of the specified instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">  for (int cycle = getFirstCycle(); cycle <= LastCycle; ++cycle) {</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">  for (int cycle = getFirstCycle(); cycle <= LastCycle; ++cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline"></td>
    <td class="lineNumber">2430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">    // Iterate over each instruction in the current cycle.</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">    // Iterate over each instruction in the current cycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">    for (SUnit *I : getInstructions(cycle)) {</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">    for (SUnit *I : getInstructions(cycle)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">      // Because we're processing a DAG for the dependences, we recognize</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">      // Because we're processing a DAG for the dependences, we recognize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">      // the back-edge in recurrences by anti dependences.</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">      // the back-edge in recurrences by anti dependences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">      for (unsigned i = 0, e = (unsigned)SU->Preds.size(); i != e; ++i) {</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">      for (unsigned i = 0, e = (unsigned)SU->Preds.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">        const SDep &Dep = SU->Preds[i];</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">        const SDep &Dep = SU->Preds[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">        if (Dep.getSUnit() == I) {</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">        if (Dep.getSUnit() == I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">          if (!DAG->isBackedge(SU, Dep)) {</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">          if (!DAG->isBackedge(SU, Dep)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">            int EarlyStart = cycle + Dep.getLatency() -</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">            int EarlyStart = cycle + Dep.getLatency() -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">            if (DAG->isLoopCarriedDep(SU, Dep, false)) {</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">            if (DAG->isLoopCarriedDep(SU, Dep, false)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">              int End = earliestCycleInChain(Dep) + (II - 1);</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">              int End = earliestCycleInChain(Dep) + (II - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">              *MinEnd = std::min(*MinEnd, End);</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">              *MinEnd = std::min(*MinEnd, End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">          } else {</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">          } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">            int LateStart = cycle - Dep.getLatency() +</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">            int LateStart = cycle - Dep.getLatency() +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">        // For instruction that requires multiple iterations, make sure that</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">        // For instruction that requires multiple iterations, make sure that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">        // the dependent instruction is not scheduled past the definition.</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">        // the dependent instruction is not scheduled past the definition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">        SUnit *BE = multipleIterations(I, DAG);</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">        SUnit *BE = multipleIterations(I, DAG);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">        if (BE && Dep.getSUnit() == BE && !SU->getInstr()->isPHI() &&</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">        if (BE && Dep.getSUnit() == BE && !SU->getInstr()->isPHI() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">            !SU->isPred(I))</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">            !SU->isPred(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">          *MinLateStart = std::min(*MinLateStart, cycle);</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">          *MinLateStart = std::min(*MinLateStart, cycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">      for (unsigned i = 0, e = (unsigned)SU->Succs.size(); i != e; ++i) {</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">      for (unsigned i = 0, e = (unsigned)SU->Succs.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">        if (SU->Succs[i].getSUnit() == I) {</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">        if (SU->Succs[i].getSUnit() == I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">          const SDep &Dep = SU->Succs[i];</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">          const SDep &Dep = SU->Succs[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">          if (!DAG->isBackedge(SU, Dep)) {</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">          if (!DAG->isBackedge(SU, Dep)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">            int LateStart = cycle - Dep.getLatency() +</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">            int LateStart = cycle - Dep.getLatency() +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">            if (DAG->isLoopCarriedDep(SU, Dep)) {</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">            if (DAG->isLoopCarriedDep(SU, Dep)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">              int Start = latestCycleInChain(Dep) + 1 - II;</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">              int Start = latestCycleInChain(Dep) + 1 - II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">              *MaxStart = std::max(*MaxStart, Start);</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">              *MaxStart = std::max(*MaxStart, Start);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">          } else {</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">          } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">            int EarlyStart = cycle + Dep.getLatency() -</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">            int EarlyStart = cycle + Dep.getLatency() -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
    <td class="lineNumber">2472</td>
    <td class="codeline">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline"></td>
    <td class="lineNumber">2480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">/// Order the instructions within a cycle so that the definitions occur</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">/// Order the instructions within a cycle so that the definitions occur</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">/// before the uses. Returns true if the instruction is added to the start</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">/// before the uses. Returns true if the instruction is added to the start</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">/// of the list, or false if added to the end.</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">/// of the list, or false if added to the end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">void SMSchedule::orderDependence(SwingSchedulerDAG *SSD, SUnit *SU,</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">void SMSchedule::orderDependence(SwingSchedulerDAG *SSD, SUnit *SU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">                                 std::deque<SUnit *> &Insts) {</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">                                 std::deque<SUnit *> &Insts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">  MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">  MachineInstr *MI = SU->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">  bool OrderBeforeUse = false;</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">  bool OrderBeforeUse = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">  bool OrderAfterDef = false;</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">  bool OrderAfterDef = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">  bool OrderBeforeDef = false;</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">  bool OrderBeforeDef = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">  unsigned MoveDef = 0;</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">  unsigned MoveDef = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">  unsigned MoveUse = 0;</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">  unsigned MoveUse = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">  int StageInst1 = stageScheduled(SU);</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">  int StageInst1 = stageScheduled(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline"></td>
    <td class="lineNumber">2493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">  unsigned Pos = 0;</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">  unsigned Pos = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">  for (std::deque<SUnit *>::iterator I = Insts.begin(), E = Insts.end(); I != E;</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">  for (std::deque<SUnit *>::iterator I = Insts.begin(), E = Insts.end(); I != E;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">       ++I, ++Pos) {</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">       ++I, ++Pos) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">    for (MachineOperand &MO : MI->operands()) {</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">    for (MachineOperand &MO : MI->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">      if (!MO.isReg() || !MO.getReg().isVirtual())</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">      if (!MO.isReg() || !MO.getReg().isVirtual())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline"></td>
    <td class="lineNumber">2500</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">      Register Reg = MO.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">      unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">      unsigned BasePos, OffsetPos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">      if (ST.getInstrInfo()->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">      if (ST.getInstrInfo()->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">        if (MI->getOperand(BasePos).getReg() == Reg)</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">        if (MI->getOperand(BasePos).getReg() == Reg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">          if (unsigned NewReg = SSD->getInstrBaseReg(SU))</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">          if (unsigned NewReg = SSD->getInstrBaseReg(SU))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">            Reg = NewReg;</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">            Reg = NewReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">      bool Reads, Writes;</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">      bool Reads, Writes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">      std::tie(Reads, Writes) =</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">      std::tie(Reads, Writes) =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">          (*I)->getInstr()->readsWritesVirtualRegister(Reg);</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">          (*I)->getInstr()->readsWritesVirtualRegister(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">      if (MO.isDef() && Reads && stageScheduled(*I) <= StageInst1) {</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">      if (MO.isDef() && Reads && stageScheduled(*I) <= StageInst1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline">        if (MoveUse == 0)</td>
    <td class="lineNumber">2512</td>
    <td class="codeline">        if (MoveUse == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">          MoveUse = Pos;</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">          MoveUse = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">      } else if (MO.isDef() && Reads && stageScheduled(*I) > StageInst1) {</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">      } else if (MO.isDef() && Reads && stageScheduled(*I) > StageInst1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">        // Add the instruction after the scheduled instruction.</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">        // Add the instruction after the scheduled instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">        OrderAfterDef = true;</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">        OrderAfterDef = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">        MoveDef = Pos;</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">        MoveDef = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">      } else if (MO.isUse() && Writes && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">      } else if (MO.isUse() && Writes && stageScheduled(*I) == StageInst1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">        if (cycleScheduled(*I) == cycleScheduled(SU) && !(*I)->isSucc(SU)) {</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">        if (cycleScheduled(*I) == cycleScheduled(SU) && !(*I)->isSucc(SU)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">          OrderBeforeUse = true;</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">          OrderBeforeUse = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">          if (MoveUse == 0)</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">          if (MoveUse == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">            MoveUse = Pos;</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">            MoveUse = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">          OrderAfterDef = true;</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">          OrderAfterDef = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">          MoveDef = Pos;</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">          MoveDef = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">      } else if (MO.isUse() && Writes && stageScheduled(*I) > StageInst1) {</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">      } else if (MO.isUse() && Writes && stageScheduled(*I) > StageInst1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">        if (MoveUse == 0)</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">        if (MoveUse == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">          MoveUse = Pos;</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">          MoveUse = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline">        if (MoveUse != 0) {</td>
    <td class="lineNumber">2531</td>
    <td class="codeline">        if (MoveUse != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">          OrderAfterDef = true;</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">          OrderAfterDef = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">          MoveDef = Pos - 1;</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">          MoveDef = Pos - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">      } else if (MO.isUse() && Writes && stageScheduled(*I) < StageInst1) {</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">      } else if (MO.isUse() && Writes && stageScheduled(*I) < StageInst1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">        // Add the instruction before the scheduled instruction.</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">        // Add the instruction before the scheduled instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">        if (MoveUse == 0)</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">        if (MoveUse == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">          MoveUse = Pos;</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">          MoveUse = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">      } else if (MO.isUse() && stageScheduled(*I) == StageInst1 &&</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">      } else if (MO.isUse() && stageScheduled(*I) == StageInst1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">                 isLoopCarriedDefOfUse(SSD, (*I)->getInstr(), MO)) {</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">                 isLoopCarriedDefOfUse(SSD, (*I)->getInstr(), MO)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">        if (MoveUse == 0) {</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">        if (MoveUse == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">          OrderBeforeDef = true;</td>
    <td class="lineNumber">2543</td>
    <td class="codeline">          OrderBeforeDef = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">          MoveUse = Pos;</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">          MoveUse = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">    // Check for order dependences between instructions. Make sure the source</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">    // Check for order dependences between instructions. Make sure the source</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline">    // is ordered before the destination.</td>
    <td class="lineNumber">2549</td>
    <td class="codeline">    // is ordered before the destination.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">    for (auto &S : SU->Succs) {</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">    for (auto &S : SU->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">      if (S.getSUnit() != *I)</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">      if (S.getSUnit() != *I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">      if (S.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">      if (S.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
    <td class="lineNumber">2554</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">        if (Pos < MoveUse)</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">        if (Pos < MoveUse)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">          MoveUse = Pos;</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">          MoveUse = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">      // We did not handle HW dependences in previous for loop,</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">      // We did not handle HW dependences in previous for loop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">      // and we normally set Latency = 0 for Anti deps,</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">      // and we normally set Latency = 0 for Anti deps,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">      // so may have nodes in same cycle with Anti denpendent on HW regs.</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">      // so may have nodes in same cycle with Anti denpendent on HW regs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">      else if (S.getKind() == SDep::Anti && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">      else if (S.getKind() == SDep::Anti && stageScheduled(*I) == StageInst1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">        OrderBeforeUse = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">        if ((MoveUse == 0) || (Pos < MoveUse))</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">        if ((MoveUse == 0) || (Pos < MoveUse))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">          MoveUse = Pos;</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">          MoveUse = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2566</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">    for (auto &P : SU->Preds) {</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">    for (auto &P : SU->Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">      if (P.getSUnit() != *I)</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">      if (P.getSUnit() != *I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">      if (P.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">      if (P.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">        OrderAfterDef = true;</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">        OrderAfterDef = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">        MoveDef = Pos;</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">        MoveDef = Pos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline"></td>
    <td class="lineNumber">2576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">  // A circular dependence.</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">  // A circular dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">  if (OrderAfterDef && OrderBeforeUse && MoveUse == MoveDef)</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">  if (OrderAfterDef && OrderBeforeUse && MoveUse == MoveDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">    OrderBeforeUse = false;</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">    OrderBeforeUse = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline"></td>
    <td class="lineNumber">2580</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">  // OrderAfterDef takes precedences over OrderBeforeDef. The latter is due</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">  // OrderAfterDef takes precedences over OrderBeforeDef. The latter is due</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">  // to a loop-carried dependence.</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">  // to a loop-carried dependence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">  if (OrderBeforeDef)</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">  if (OrderBeforeDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">    OrderBeforeUse = !OrderAfterDef || (MoveUse > MoveDef);</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">    OrderBeforeUse = !OrderAfterDef || (MoveUse > MoveDef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline"></td>
    <td class="lineNumber">2585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">  // The uncommon case when the instruction order needs to be updated because</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">  // The uncommon case when the instruction order needs to be updated because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">  // there is both a use and def.</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">  // there is both a use and def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">  if (OrderBeforeUse && OrderAfterDef) {</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">  if (OrderBeforeUse && OrderAfterDef) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">    SUnit *UseSU = Insts.at(MoveUse);</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">    SUnit *UseSU = Insts.at(MoveUse);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">    SUnit *DefSU = Insts.at(MoveDef);</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">    SUnit *DefSU = Insts.at(MoveDef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">    if (MoveUse > MoveDef) {</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">    if (MoveUse > MoveDef) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">      Insts.erase(Insts.begin() + MoveUse);</td>
    <td class="lineNumber">2592</td>
    <td class="codeline">      Insts.erase(Insts.begin() + MoveUse);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">      Insts.erase(Insts.begin() + MoveDef);</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">      Insts.erase(Insts.begin() + MoveDef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">      Insts.erase(Insts.begin() + MoveDef);</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">      Insts.erase(Insts.begin() + MoveDef);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">      Insts.erase(Insts.begin() + MoveUse);</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">      Insts.erase(Insts.begin() + MoveUse);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2597</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">    orderDependence(SSD, UseSU, Insts);</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">    orderDependence(SSD, UseSU, Insts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">    orderDependence(SSD, SU, Insts);</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">    orderDependence(SSD, SU, Insts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline">    orderDependence(SSD, DefSU, Insts);</td>
    <td class="lineNumber">2600</td>
    <td class="codeline">    orderDependence(SSD, DefSU, Insts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">  // Put the new instruction first if there is a use in the list. Otherwise,</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">  // Put the new instruction first if there is a use in the list. Otherwise,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline">  // put it at the end of the list.</td>
    <td class="lineNumber">2604</td>
    <td class="codeline">  // put it at the end of the list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">  if (OrderBeforeUse)</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">  if (OrderBeforeUse)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">    Insts.push_front(SU);</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">    Insts.push_front(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">2607</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">    Insts.push_back(SU);</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">    Insts.push_back(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline"></td>
    <td class="lineNumber">2610</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">/// Return true if the scheduled Phi has a loop carried operand.</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">/// Return true if the scheduled Phi has a loop carried operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">bool SMSchedule::isLoopCarried(SwingSchedulerDAG *SSD, MachineInstr &Phi) {</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">bool SMSchedule::isLoopCarried(SwingSchedulerDAG *SSD, MachineInstr &Phi) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  if (!Phi.isPHI())</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  if (!Phi.isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline">  SUnit *DefSU = SSD->getSUnit(&Phi);</td>
    <td class="lineNumber">2616</td>
    <td class="codeline">  SUnit *DefSU = SSD->getSUnit(&Phi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">  unsigned DefCycle = cycleScheduled(DefSU);</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">  unsigned DefCycle = cycleScheduled(DefSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline">  int DefStage = stageScheduled(DefSU);</td>
    <td class="lineNumber">2618</td>
    <td class="codeline">  int DefStage = stageScheduled(DefSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline"></td>
    <td class="lineNumber">2619</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">  unsigned InitVal = 0;</td>
    <td class="lineNumber">2620</td>
    <td class="codeline">  unsigned InitVal = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">  unsigned LoopVal = 0;</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">  unsigned LoopVal = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">  getPhiRegs(Phi, Phi.getParent(), InitVal, LoopVal);</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">  getPhiRegs(Phi, Phi.getParent(), InitVal, LoopVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">  SUnit *UseSU = SSD->getSUnit(MRI.getVRegDef(LoopVal));</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">  SUnit *UseSU = SSD->getSUnit(MRI.getVRegDef(LoopVal));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline">  if (!UseSU)</td>
    <td class="lineNumber">2624</td>
    <td class="codeline">  if (!UseSU)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline">  if (UseSU->getInstr()->isPHI())</td>
    <td class="lineNumber">2626</td>
    <td class="codeline">  if (UseSU->getInstr()->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">  unsigned LoopCycle = cycleScheduled(UseSU);</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">  unsigned LoopCycle = cycleScheduled(UseSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">  int LoopStage = stageScheduled(UseSU);</td>
    <td class="lineNumber">2629</td>
    <td class="codeline">  int LoopStage = stageScheduled(UseSU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">  return (LoopCycle > DefCycle) || (LoopStage <= DefStage);</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">  return (LoopCycle > DefCycle) || (LoopStage <= DefStage);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline"></td>
    <td class="lineNumber">2632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">/// Return true if the instruction is a definition that is loop carried</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">/// Return true if the instruction is a definition that is loop carried</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">/// and defines the use on the next iteration.</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">/// and defines the use on the next iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">///        v1 = phi(v2, v3)</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">///        v1 = phi(v2, v3)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">///  (Def) v3 = op v1</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">///  (Def) v3 = op v1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">///  (MO)   = v1</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">///  (MO)   = v1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline">/// If MO appears before Def, then then v1 and v3 may get assigned to the same</td>
    <td class="lineNumber">2638</td>
    <td class="codeline">/// If MO appears before Def, then then v1 and v3 may get assigned to the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">/// register.</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">/// register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline">bool SMSchedule::isLoopCarriedDefOfUse(SwingSchedulerDAG *SSD,</td>
    <td class="lineNumber">2640</td>
    <td class="codeline">bool SMSchedule::isLoopCarriedDefOfUse(SwingSchedulerDAG *SSD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">                                       MachineInstr *Def, MachineOperand &MO) {</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">                                       MachineInstr *Def, MachineOperand &MO) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">  if (!MO.isReg())</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">  if (!MO.isReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline">  if (Def->isPHI())</td>
    <td class="lineNumber">2644</td>
    <td class="codeline">  if (Def->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">  MachineInstr *Phi = MRI.getVRegDef(MO.getReg());</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">  MachineInstr *Phi = MRI.getVRegDef(MO.getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline">  if (!Phi || !Phi->isPHI() || Phi->getParent() != Def->getParent())</td>
    <td class="lineNumber">2647</td>
    <td class="codeline">  if (!Phi || !Phi->isPHI() || Phi->getParent() != Def->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline">  if (!isLoopCarried(SSD, *Phi))</td>
    <td class="lineNumber">2649</td>
    <td class="codeline">  if (!isLoopCarried(SSD, *Phi))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline">  unsigned LoopReg = getLoopPhiReg(*Phi, Phi->getParent());</td>
    <td class="lineNumber">2651</td>
    <td class="codeline">  unsigned LoopReg = getLoopPhiReg(*Phi, Phi->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline">  for (MachineOperand &DMO : Def->all_defs()) {</td>
    <td class="lineNumber">2652</td>
    <td class="codeline">  for (MachineOperand &DMO : Def->all_defs()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">    if (DMO.getReg() == LoopReg)</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">    if (DMO.getReg() == LoopReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2654</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2657</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline"></td>
    <td class="lineNumber">2658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline">/// Determine transitive dependences of unpipelineable instructions</td>
    <td class="lineNumber">2659</td>
    <td class="codeline">/// Determine transitive dependences of unpipelineable instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline">SmallSet<SUnit *, 8> SMSchedule::computeUnpipelineableNodes(</td>
    <td class="lineNumber">2660</td>
    <td class="codeline">SmallSet<SUnit *, 8> SMSchedule::computeUnpipelineableNodes(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
    <td class="lineNumber">2661</td>
    <td class="codeline">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">  SmallSet<SUnit *, 8> DoNotPipeline;</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">  SmallSet<SUnit *, 8> DoNotPipeline;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline">  SmallVector<SUnit *, 8> Worklist;</td>
    <td class="lineNumber">2663</td>
    <td class="codeline">  SmallVector<SUnit *, 8> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline"></td>
    <td class="lineNumber">2664</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">  for (auto &SU : SSD->SUnits)</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">  for (auto &SU : SSD->SUnits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline">    if (SU.isInstr() && PLI->shouldIgnoreForPipelining(SU.getInstr()))</td>
    <td class="lineNumber">2666</td>
    <td class="codeline">    if (SU.isInstr() && PLI->shouldIgnoreForPipelining(SU.getInstr()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">      Worklist.push_back(&SU);</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">      Worklist.push_back(&SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline"></td>
    <td class="lineNumber">2668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline">    auto SU = Worklist.pop_back_val();</td>
    <td class="lineNumber">2670</td>
    <td class="codeline">    auto SU = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeline">    if (DoNotPipeline.count(SU))</td>
    <td class="lineNumber">2671</td>
    <td class="codeline">    if (DoNotPipeline.count(SU))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2672</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Do not pipeline SU(" << SU->NodeNum << ")\n");</td>
    <td class="lineNumber">2673</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Do not pipeline SU(" << SU->NodeNum << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeline">    DoNotPipeline.insert(SU);</td>
    <td class="lineNumber">2674</td>
    <td class="codeline">    DoNotPipeline.insert(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeline">    for (auto &Dep : SU->Preds)</td>
    <td class="lineNumber">2675</td>
    <td class="codeline">    for (auto &Dep : SU->Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeline">      Worklist.push_back(Dep.getSUnit());</td>
    <td class="lineNumber">2676</td>
    <td class="codeline">      Worklist.push_back(Dep.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeline">    if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">2677</td>
    <td class="codeline">    if (SU->getInstr()->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeline">      for (auto &Dep : SU->Succs)</td>
    <td class="lineNumber">2678</td>
    <td class="codeline">      for (auto &Dep : SU->Succs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeline">        if (Dep.getKind() == SDep::Anti)</td>
    <td class="lineNumber">2679</td>
    <td class="codeline">        if (Dep.getKind() == SDep::Anti)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeline">          Worklist.push_back(Dep.getSUnit());</td>
    <td class="lineNumber">2680</td>
    <td class="codeline">          Worklist.push_back(Dep.getSUnit());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2681</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeline">  return DoNotPipeline;</td>
    <td class="lineNumber">2682</td>
    <td class="codeline">  return DoNotPipeline;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2683</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeline"></td>
    <td class="lineNumber">2684</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeline">// Determine all instructions upon which any unpipelineable instruction depends</td>
    <td class="lineNumber">2685</td>
    <td class="codeline">// Determine all instructions upon which any unpipelineable instruction depends</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeline">// and ensure that they are in stage 0.  If unable to do so, return false.</td>
    <td class="lineNumber">2686</td>
    <td class="codeline">// and ensure that they are in stage 0.  If unable to do so, return false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeline">bool SMSchedule::normalizeNonPipelinedInstructions(</td>
    <td class="lineNumber">2687</td>
    <td class="codeline">bool SMSchedule::normalizeNonPipelinedInstructions(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeline">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
    <td class="lineNumber">2688</td>
    <td class="codeline">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeline">  SmallSet<SUnit *, 8> DNP = computeUnpipelineableNodes(SSD, PLI);</td>
    <td class="lineNumber">2689</td>
    <td class="codeline">  SmallSet<SUnit *, 8> DNP = computeUnpipelineableNodes(SSD, PLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeline"></td>
    <td class="lineNumber">2690</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeline">  int NewLastCycle = INT_MIN;</td>
    <td class="lineNumber">2691</td>
    <td class="codeline">  int NewLastCycle = INT_MIN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeline">  for (SUnit &SU : SSD->SUnits) {</td>
    <td class="lineNumber">2692</td>
    <td class="codeline">  for (SUnit &SU : SSD->SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeline">    if (!SU.isInstr())</td>
    <td class="lineNumber">2693</td>
    <td class="codeline">    if (!SU.isInstr())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2694</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeline">    if (!DNP.contains(&SU) || stageScheduled(&SU) == 0) {</td>
    <td class="lineNumber">2695</td>
    <td class="codeline">    if (!DNP.contains(&SU) || stageScheduled(&SU) == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeline">      NewLastCycle = std::max(NewLastCycle, InstrToCycle[&SU]);</td>
    <td class="lineNumber">2696</td>
    <td class="codeline">      NewLastCycle = std::max(NewLastCycle, InstrToCycle[&SU]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2697</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2698</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeline"></td>
    <td class="lineNumber">2699</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeline">    // Put the non-pipelined instruction as early as possible in the schedule</td>
    <td class="lineNumber">2700</td>
    <td class="codeline">    // Put the non-pipelined instruction as early as possible in the schedule</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeline">    int NewCycle = getFirstCycle();</td>
    <td class="lineNumber">2701</td>
    <td class="codeline">    int NewCycle = getFirstCycle();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeline">    for (auto &Dep : SU.Preds)</td>
    <td class="lineNumber">2702</td>
    <td class="codeline">    for (auto &Dep : SU.Preds)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeline">      NewCycle = std::max(InstrToCycle[Dep.getSUnit()], NewCycle);</td>
    <td class="lineNumber">2703</td>
    <td class="codeline">      NewCycle = std::max(InstrToCycle[Dep.getSUnit()], NewCycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeline"></td>
    <td class="lineNumber">2704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeline">    int OldCycle = InstrToCycle[&SU];</td>
    <td class="lineNumber">2705</td>
    <td class="codeline">    int OldCycle = InstrToCycle[&SU];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeline">    if (OldCycle != NewCycle) {</td>
    <td class="lineNumber">2706</td>
    <td class="codeline">    if (OldCycle != NewCycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeline">      InstrToCycle[&SU] = NewCycle;</td>
    <td class="lineNumber">2707</td>
    <td class="codeline">      InstrToCycle[&SU] = NewCycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeline">      auto &OldS = getInstructions(OldCycle);</td>
    <td class="lineNumber">2708</td>
    <td class="codeline">      auto &OldS = getInstructions(OldCycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeline">      llvm::erase_value(OldS, &SU);</td>
    <td class="lineNumber">2709</td>
    <td class="codeline">      llvm::erase_value(OldS, &SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeline">      getInstructions(NewCycle).emplace_back(&SU);</td>
    <td class="lineNumber">2710</td>
    <td class="codeline">      getInstructions(NewCycle).emplace_back(&SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "SU(" << SU.NodeNum</td>
    <td class="lineNumber">2711</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "SU(" << SU.NodeNum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeline">                        << ") is not pipelined; moving from cycle " << OldCycle</td>
    <td class="lineNumber">2712</td>
    <td class="codeline">                        << ") is not pipelined; moving from cycle " << OldCycle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeline">                        << " to " << NewCycle << " Instr:" << *SU.getInstr());</td>
    <td class="lineNumber">2713</td>
    <td class="codeline">                        << " to " << NewCycle << " Instr:" << *SU.getInstr());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2714</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeline">    NewLastCycle = std::max(NewLastCycle, NewCycle);</td>
    <td class="lineNumber">2715</td>
    <td class="codeline">    NewLastCycle = std::max(NewLastCycle, NewCycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2716</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeline">  LastCycle = NewLastCycle;</td>
    <td class="lineNumber">2717</td>
    <td class="codeline">  LastCycle = NewLastCycle;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2718</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2719</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeline"></td>
    <td class="lineNumber">2720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeline">// Check if the generated schedule is valid. This function checks if</td>
    <td class="lineNumber">2721</td>
    <td class="codeline">// Check if the generated schedule is valid. This function checks if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeline">// an instruction that uses a physical register is scheduled in a</td>
    <td class="lineNumber">2722</td>
    <td class="codeline">// an instruction that uses a physical register is scheduled in a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeline">// different stage than the definition. The pipeliner does not handle</td>
    <td class="lineNumber">2723</td>
    <td class="codeline">// different stage than the definition. The pipeliner does not handle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeline">// physical register values that may cross a basic block boundary.</td>
    <td class="lineNumber">2724</td>
    <td class="codeline">// physical register values that may cross a basic block boundary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeline">// Furthermore, if a physical def/use pair is assigned to the same</td>
    <td class="lineNumber">2725</td>
    <td class="codeline">// Furthermore, if a physical def/use pair is assigned to the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeline">// cycle, orderDependence does not guarantee def/use ordering, so that</td>
    <td class="lineNumber">2726</td>
    <td class="codeline">// cycle, orderDependence does not guarantee def/use ordering, so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeline">// case should be considered invalid.  (The test checks for both</td>
    <td class="lineNumber">2727</td>
    <td class="codeline">// case should be considered invalid.  (The test checks for both</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeline">// earlier and same-cycle use to be more robust.)</td>
    <td class="lineNumber">2728</td>
    <td class="codeline">// earlier and same-cycle use to be more robust.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeline">bool SMSchedule::isValidSchedule(SwingSchedulerDAG *SSD) {</td>
    <td class="lineNumber">2729</td>
    <td class="codeline">bool SMSchedule::isValidSchedule(SwingSchedulerDAG *SSD) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeline">  for (SUnit &SU : SSD->SUnits) {</td>
    <td class="lineNumber">2730</td>
    <td class="codeline">  for (SUnit &SU : SSD->SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeline">    if (!SU.hasPhysRegDefs)</td>
    <td class="lineNumber">2731</td>
    <td class="codeline">    if (!SU.hasPhysRegDefs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2732</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeline">    int StageDef = stageScheduled(&SU);</td>
    <td class="lineNumber">2733</td>
    <td class="codeline">    int StageDef = stageScheduled(&SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeline">    int CycleDef = InstrToCycle[&SU];</td>
    <td class="lineNumber">2734</td>
    <td class="codeline">    int CycleDef = InstrToCycle[&SU];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeline">    assert(StageDef != -1 && "Instruction should have been scheduled.");</td>
    <td class="lineNumber">2735</td>
    <td class="codeline">    assert(StageDef != -1 && "Instruction should have been scheduled.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeline">    for (auto &SI : SU.Succs)</td>
    <td class="lineNumber">2736</td>
    <td class="codeline">    for (auto &SI : SU.Succs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeline">      if (SI.isAssignedRegDep() && !SI.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">2737</td>
    <td class="codeline">      if (SI.isAssignedRegDep() && !SI.getSUnit()->isBoundaryNode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeline">        if (Register::isPhysicalRegister(SI.getReg())) {</td>
    <td class="lineNumber">2738</td>
    <td class="codeline">        if (Register::isPhysicalRegister(SI.getReg())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeline">          if (stageScheduled(SI.getSUnit()) != StageDef)</td>
    <td class="lineNumber">2739</td>
    <td class="codeline">          if (stageScheduled(SI.getSUnit()) != StageDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeline">            return false;</td>
    <td class="lineNumber">2740</td>
    <td class="codeline">            return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeline">          if (InstrToCycle[SI.getSUnit()] <= CycleDef)</td>
    <td class="lineNumber">2741</td>
    <td class="codeline">          if (InstrToCycle[SI.getSUnit()] <= CycleDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeline">            return false;</td>
    <td class="lineNumber">2742</td>
    <td class="codeline">            return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2743</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2744</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2745</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2746</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeline"></td>
    <td class="lineNumber">2747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeline">/// A property of the node order in swing-modulo-scheduling is</td>
    <td class="lineNumber">2748</td>
    <td class="codeline">/// A property of the node order in swing-modulo-scheduling is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeline">/// that for nodes outside circuits the following holds:</td>
    <td class="lineNumber">2749</td>
    <td class="codeline">/// that for nodes outside circuits the following holds:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeline">/// none of them is scheduled after both a successor and a</td>
    <td class="lineNumber">2750</td>
    <td class="codeline">/// none of them is scheduled after both a successor and a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeline">/// predecessor.</td>
    <td class="lineNumber">2751</td>
    <td class="codeline">/// predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeline">/// The method below checks whether the property is met.</td>
    <td class="lineNumber">2752</td>
    <td class="codeline">/// The method below checks whether the property is met.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeline">/// If not, debug information is printed and statistics information updated.</td>
    <td class="lineNumber">2753</td>
    <td class="codeline">/// If not, debug information is printed and statistics information updated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeline">/// Note that we do not use an assert statement.</td>
    <td class="lineNumber">2754</td>
    <td class="codeline">/// Note that we do not use an assert statement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeline">/// The reason is that although an invalid node oder may prevent</td>
    <td class="lineNumber">2755</td>
    <td class="codeline">/// The reason is that although an invalid node oder may prevent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeline">/// the pipeliner from finding a pipelined schedule for arbitrary II,</td>
    <td class="lineNumber">2756</td>
    <td class="codeline">/// the pipeliner from finding a pipelined schedule for arbitrary II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeline">/// it does not lead to the generation of incorrect code.</td>
    <td class="lineNumber">2757</td>
    <td class="codeline">/// it does not lead to the generation of incorrect code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeline">void SwingSchedulerDAG::checkValidNodeOrder(const NodeSetType &Circuits) const {</td>
    <td class="lineNumber">2758</td>
    <td class="codeline">void SwingSchedulerDAG::checkValidNodeOrder(const NodeSetType &Circuits) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeline"></td>
    <td class="lineNumber">2759</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeline">  // a sorted vector that maps each SUnit to its index in the NodeOrder</td>
    <td class="lineNumber">2760</td>
    <td class="codeline">  // a sorted vector that maps each SUnit to its index in the NodeOrder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeline">  typedef std::pair<SUnit *, unsigned> UnitIndex;</td>
    <td class="lineNumber">2761</td>
    <td class="codeline">  typedef std::pair<SUnit *, unsigned> UnitIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeline">  std::vector<UnitIndex> Indices(NodeOrder.size(), std::make_pair(nullptr, 0));</td>
    <td class="lineNumber">2762</td>
    <td class="codeline">  std::vector<UnitIndex> Indices(NodeOrder.size(), std::make_pair(nullptr, 0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeline"></td>
    <td class="lineNumber">2763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeline">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i)</td>
    <td class="lineNumber">2764</td>
    <td class="codeline">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeline">    Indices.push_back(std::make_pair(NodeOrder[i], i));</td>
    <td class="lineNumber">2765</td>
    <td class="codeline">    Indices.push_back(std::make_pair(NodeOrder[i], i));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeline"></td>
    <td class="lineNumber">2766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeline">  auto CompareKey = [](UnitIndex i1, UnitIndex i2) {</td>
    <td class="lineNumber">2767</td>
    <td class="codeline">  auto CompareKey = [](UnitIndex i1, UnitIndex i2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeline">    return std::get<0>(i1) < std::get<0>(i2);</td>
    <td class="lineNumber">2768</td>
    <td class="codeline">    return std::get<0>(i1) < std::get<0>(i2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2769</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeline"></td>
    <td class="lineNumber">2770</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeline">  // sort, so that we can perform a binary search</td>
    <td class="lineNumber">2771</td>
    <td class="codeline">  // sort, so that we can perform a binary search</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeline">  llvm::sort(Indices, CompareKey);</td>
    <td class="lineNumber">2772</td>
    <td class="codeline">  llvm::sort(Indices, CompareKey);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeline"></td>
    <td class="lineNumber">2773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeline">  bool Valid = true;</td>
    <td class="lineNumber">2774</td>
    <td class="codeline">  bool Valid = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeline">  (void)Valid;</td>
    <td class="lineNumber">2775</td>
    <td class="codeline">  (void)Valid;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeline">  // for each SUnit in the NodeOrder, check whether</td>
    <td class="lineNumber">2776</td>
    <td class="codeline">  // for each SUnit in the NodeOrder, check whether</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeline">  // it appears after both a successor and a predecessor</td>
    <td class="lineNumber">2777</td>
    <td class="codeline">  // it appears after both a successor and a predecessor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeline">  // of the SUnit. If this is the case, and the SUnit</td>
    <td class="lineNumber">2778</td>
    <td class="codeline">  // of the SUnit. If this is the case, and the SUnit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeline">  // is not part of circuit, then the NodeOrder is not</td>
    <td class="lineNumber">2779</td>
    <td class="codeline">  // is not part of circuit, then the NodeOrder is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeline">  // valid.</td>
    <td class="lineNumber">2780</td>
    <td class="codeline">  // valid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeline">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i) {</td>
    <td class="lineNumber">2781</td>
    <td class="codeline">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeline">    SUnit *SU = NodeOrder[i];</td>
    <td class="lineNumber">2782</td>
    <td class="codeline">    SUnit *SU = NodeOrder[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeline">    unsigned Index = i;</td>
    <td class="lineNumber">2783</td>
    <td class="codeline">    unsigned Index = i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeline"></td>
    <td class="lineNumber">2784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeline">    bool PredBefore = false;</td>
    <td class="lineNumber">2785</td>
    <td class="codeline">    bool PredBefore = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeline">    bool SuccBefore = false;</td>
    <td class="lineNumber">2786</td>
    <td class="codeline">    bool SuccBefore = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeline"></td>
    <td class="lineNumber">2787</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeline">    SUnit *Succ;</td>
    <td class="lineNumber">2788</td>
    <td class="codeline">    SUnit *Succ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeline">    SUnit *Pred;</td>
    <td class="lineNumber">2789</td>
    <td class="codeline">    SUnit *Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeline">    (void)Succ;</td>
    <td class="lineNumber">2790</td>
    <td class="codeline">    (void)Succ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeline">    (void)Pred;</td>
    <td class="lineNumber">2791</td>
    <td class="codeline">    (void)Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeline"></td>
    <td class="lineNumber">2792</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeline">    for (SDep &PredEdge : SU->Preds) {</td>
    <td class="lineNumber">2793</td>
    <td class="codeline">    for (SDep &PredEdge : SU->Preds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeline">      SUnit *PredSU = PredEdge.getSUnit();</td>
    <td class="lineNumber">2794</td>
    <td class="codeline">      SUnit *PredSU = PredEdge.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeline">      unsigned PredIndex = std::get<1>(</td>
    <td class="lineNumber">2795</td>
    <td class="codeline">      unsigned PredIndex = std::get<1>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeline">          *llvm::lower_bound(Indices, std::make_pair(PredSU, 0), CompareKey));</td>
    <td class="lineNumber">2796</td>
    <td class="codeline">          *llvm::lower_bound(Indices, std::make_pair(PredSU, 0), CompareKey));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeline">      if (!PredSU->getInstr()->isPHI() && PredIndex < Index) {</td>
    <td class="lineNumber">2797</td>
    <td class="codeline">      if (!PredSU->getInstr()->isPHI() && PredIndex < Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeline">        PredBefore = true;</td>
    <td class="lineNumber">2798</td>
    <td class="codeline">        PredBefore = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeline">        Pred = PredSU;</td>
    <td class="lineNumber">2799</td>
    <td class="codeline">        Pred = PredSU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2800</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2801</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2802</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeline"></td>
    <td class="lineNumber">2803</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeline">    for (SDep &SuccEdge : SU->Succs) {</td>
    <td class="lineNumber">2804</td>
    <td class="codeline">    for (SDep &SuccEdge : SU->Succs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeline">      SUnit *SuccSU = SuccEdge.getSUnit();</td>
    <td class="lineNumber">2805</td>
    <td class="codeline">      SUnit *SuccSU = SuccEdge.getSUnit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeline">      // Do not process a boundary node, it was not included in NodeOrder,</td>
    <td class="lineNumber">2806</td>
    <td class="codeline">      // Do not process a boundary node, it was not included in NodeOrder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeline">      // hence not in Indices either, call to std::lower_bound() below will</td>
    <td class="lineNumber">2807</td>
    <td class="codeline">      // hence not in Indices either, call to std::lower_bound() below will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeline">      // return Indices.end().</td>
    <td class="lineNumber">2808</td>
    <td class="codeline">      // return Indices.end().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeline">      if (SuccSU->isBoundaryNode())</td>
    <td class="lineNumber">2809</td>
    <td class="codeline">      if (SuccSU->isBoundaryNode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2810</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeline">      unsigned SuccIndex = std::get<1>(</td>
    <td class="lineNumber">2811</td>
    <td class="codeline">      unsigned SuccIndex = std::get<1>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeline">          *llvm::lower_bound(Indices, std::make_pair(SuccSU, 0), CompareKey));</td>
    <td class="lineNumber">2812</td>
    <td class="codeline">          *llvm::lower_bound(Indices, std::make_pair(SuccSU, 0), CompareKey));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeline">      if (!SuccSU->getInstr()->isPHI() && SuccIndex < Index) {</td>
    <td class="lineNumber">2813</td>
    <td class="codeline">      if (!SuccSU->getInstr()->isPHI() && SuccIndex < Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeline">        SuccBefore = true;</td>
    <td class="lineNumber">2814</td>
    <td class="codeline">        SuccBefore = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeline">        Succ = SuccSU;</td>
    <td class="lineNumber">2815</td>
    <td class="codeline">        Succ = SuccSU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2816</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2817</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2818</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeline"></td>
    <td class="lineNumber">2819</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeline">    if (PredBefore && SuccBefore && !SU->getInstr()->isPHI()) {</td>
    <td class="lineNumber">2820</td>
    <td class="codeline">    if (PredBefore && SuccBefore && !SU->getInstr()->isPHI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeline">      // instructions in circuits are allowed to be scheduled</td>
    <td class="lineNumber">2821</td>
    <td class="codeline">      // instructions in circuits are allowed to be scheduled</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeline">      // after both a successor and predecessor.</td>
    <td class="lineNumber">2822</td>
    <td class="codeline">      // after both a successor and predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeline">      bool InCircuit = llvm::any_of(</td>
    <td class="lineNumber">2823</td>
    <td class="codeline">      bool InCircuit = llvm::any_of(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeline">          Circuits, [SU](const NodeSet &Circuit) { return Circuit.count(SU); });</td>
    <td class="lineNumber">2824</td>
    <td class="codeline">          Circuits, [SU](const NodeSet &Circuit) { return Circuit.count(SU); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeline">      if (InCircuit)</td>
    <td class="lineNumber">2825</td>
    <td class="codeline">      if (InCircuit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "In a circuit, predecessor ";);</td>
    <td class="lineNumber">2826</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "In a circuit, predecessor ";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeline">      else {</td>
    <td class="lineNumber">2827</td>
    <td class="codeline">      else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeline">        Valid = false;</td>
    <td class="lineNumber">2828</td>
    <td class="codeline">        Valid = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeline">        NumNodeOrderIssues++;</td>
    <td class="lineNumber">2829</td>
    <td class="codeline">        NumNodeOrderIssues++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Predecessor ";);</td>
    <td class="lineNumber">2830</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Predecessor ";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2831</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << Pred->NodeNum << " and successor " << Succ->NodeNum</td>
    <td class="lineNumber">2832</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << Pred->NodeNum << " and successor " << Succ->NodeNum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeline">                        << " are scheduled before node " << SU->NodeNum</td>
    <td class="lineNumber">2833</td>
    <td class="codeline">                        << " are scheduled before node " << SU->NodeNum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeline">                        << "\n";);</td>
    <td class="lineNumber">2834</td>
    <td class="codeline">                        << "\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2835</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2836</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeline"></td>
    <td class="lineNumber">2837</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">2838</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeline">    if (!Valid)</td>
    <td class="lineNumber">2839</td>
    <td class="codeline">    if (!Valid)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeline">      dbgs() << "Invalid node order found!\n";</td>
    <td class="lineNumber">2840</td>
    <td class="codeline">      dbgs() << "Invalid node order found!\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">2841</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2842</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeline"></td>
    <td class="lineNumber">2843</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeline">/// Attempt to fix the degenerate cases when the instruction serialization</td>
    <td class="lineNumber">2844</td>
    <td class="codeline">/// Attempt to fix the degenerate cases when the instruction serialization</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeline">/// causes the register lifetimes to overlap. For example,</td>
    <td class="lineNumber">2845</td>
    <td class="codeline">/// causes the register lifetimes to overlap. For example,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeline">///   p' = store_pi(p, b)</td>
    <td class="lineNumber">2846</td>
    <td class="codeline">///   p' = store_pi(p, b)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeline">///      = load p, offset</td>
    <td class="lineNumber">2847</td>
    <td class="codeline">///      = load p, offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeline">/// In this case p and p' overlap, which means that two registers are needed.</td>
    <td class="lineNumber">2848</td>
    <td class="codeline">/// In this case p and p' overlap, which means that two registers are needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeline">/// Instead, this function changes the load to use p' and updates the offset.</td>
    <td class="lineNumber">2849</td>
    <td class="codeline">/// Instead, this function changes the load to use p' and updates the offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeline">void SwingSchedulerDAG::fixupRegisterOverlaps(std::deque<SUnit *> &Instrs) {</td>
    <td class="lineNumber">2850</td>
    <td class="codeline">void SwingSchedulerDAG::fixupRegisterOverlaps(std::deque<SUnit *> &Instrs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeline">  unsigned OverlapReg = 0;</td>
    <td class="lineNumber">2851</td>
    <td class="codeline">  unsigned OverlapReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeline">  unsigned NewBaseReg = 0;</td>
    <td class="lineNumber">2852</td>
    <td class="codeline">  unsigned NewBaseReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeline">  for (SUnit *SU : Instrs) {</td>
    <td class="lineNumber">2853</td>
    <td class="codeline">  for (SUnit *SU : Instrs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeline">    MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">2854</td>
    <td class="codeline">    MachineInstr *MI = SU->getInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeline">    for (unsigned i = 0, e = MI->getNumOperands(); i < e; ++i) {</td>
    <td class="lineNumber">2855</td>
    <td class="codeline">    for (unsigned i = 0, e = MI->getNumOperands(); i < e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeline">      const MachineOperand &MO = MI->getOperand(i);</td>
    <td class="lineNumber">2856</td>
    <td class="codeline">      const MachineOperand &MO = MI->getOperand(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeline">      // Look for an instruction that uses p. The instruction occurs in the</td>
    <td class="lineNumber">2857</td>
    <td class="codeline">      // Look for an instruction that uses p. The instruction occurs in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeline">      // same cycle but occurs later in the serialized order.</td>
    <td class="lineNumber">2858</td>
    <td class="codeline">      // same cycle but occurs later in the serialized order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeline">      if (MO.isReg() && MO.isUse() && MO.getReg() == OverlapReg) {</td>
    <td class="lineNumber">2859</td>
    <td class="codeline">      if (MO.isReg() && MO.isUse() && MO.getReg() == OverlapReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeline">        // Check that the instruction appears in the InstrChanges structure,</td>
    <td class="lineNumber">2860</td>
    <td class="codeline">        // Check that the instruction appears in the InstrChanges structure,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeline">        // which contains instructions that can have the offset updated.</td>
    <td class="lineNumber">2861</td>
    <td class="codeline">        // which contains instructions that can have the offset updated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeline">        DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
    <td class="lineNumber">2862</td>
    <td class="codeline">        DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeline">          InstrChanges.find(SU);</td>
    <td class="lineNumber">2863</td>
    <td class="codeline">          InstrChanges.find(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeline">        if (It != InstrChanges.end()) {</td>
    <td class="lineNumber">2864</td>
    <td class="codeline">        if (It != InstrChanges.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeline">          unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">2865</td>
    <td class="codeline">          unsigned BasePos, OffsetPos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeline">          // Update the base register and adjust the offset.</td>
    <td class="lineNumber">2866</td>
    <td class="codeline">          // Update the base register and adjust the offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeline">          if (TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos)) {</td>
    <td class="lineNumber">2867</td>
    <td class="codeline">          if (TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeline">            MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">2868</td>
    <td class="codeline">            MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeline">            NewMI->getOperand(BasePos).setReg(NewBaseReg);</td>
    <td class="lineNumber">2869</td>
    <td class="codeline">            NewMI->getOperand(BasePos).setReg(NewBaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeline">            int64_t NewOffset =</td>
    <td class="lineNumber">2870</td>
    <td class="codeline">            int64_t NewOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeline">                MI->getOperand(OffsetPos).getImm() - It->second.second;</td>
    <td class="lineNumber">2871</td>
    <td class="codeline">                MI->getOperand(OffsetPos).getImm() - It->second.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeline">            NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
    <td class="lineNumber">2872</td>
    <td class="codeline">            NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeline">            SU->setInstr(NewMI);</td>
    <td class="lineNumber">2873</td>
    <td class="codeline">            SU->setInstr(NewMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeline">            MISUnitMap[NewMI] = SU;</td>
    <td class="lineNumber">2874</td>
    <td class="codeline">            MISUnitMap[NewMI] = SU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeline">            NewMIs[MI] = NewMI;</td>
    <td class="lineNumber">2875</td>
    <td class="codeline">            NewMIs[MI] = NewMI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">2876</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2877</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeline">        OverlapReg = 0;</td>
    <td class="lineNumber">2878</td>
    <td class="codeline">        OverlapReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeline">        NewBaseReg = 0;</td>
    <td class="lineNumber">2879</td>
    <td class="codeline">        NewBaseReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2880</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2881</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeline">      // Look for an instruction of the form p' = op(p), which uses and defines</td>
    <td class="lineNumber">2882</td>
    <td class="codeline">      // Look for an instruction of the form p' = op(p), which uses and defines</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeline">      // two virtual registers that get allocated to the same physical register.</td>
    <td class="lineNumber">2883</td>
    <td class="codeline">      // two virtual registers that get allocated to the same physical register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeline">      unsigned TiedUseIdx = 0;</td>
    <td class="lineNumber">2884</td>
    <td class="codeline">      unsigned TiedUseIdx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeline">      if (MI->isRegTiedToUseOperand(i, &TiedUseIdx)) {</td>
    <td class="lineNumber">2885</td>
    <td class="codeline">      if (MI->isRegTiedToUseOperand(i, &TiedUseIdx)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeline">        // OverlapReg is p in the example above.</td>
    <td class="lineNumber">2886</td>
    <td class="codeline">        // OverlapReg is p in the example above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeline">        OverlapReg = MI->getOperand(TiedUseIdx).getReg();</td>
    <td class="lineNumber">2887</td>
    <td class="codeline">        OverlapReg = MI->getOperand(TiedUseIdx).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeline">        // NewBaseReg is p' in the example above.</td>
    <td class="lineNumber">2888</td>
    <td class="codeline">        // NewBaseReg is p' in the example above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeline">        NewBaseReg = MI->getOperand(i).getReg();</td>
    <td class="lineNumber">2889</td>
    <td class="codeline">        NewBaseReg = MI->getOperand(i).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2890</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2891</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2892</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2893</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2894</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeline"></td>
    <td class="lineNumber">2895</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeline">/// After the schedule has been formed, call this function to combine</td>
    <td class="lineNumber">2896</td>
    <td class="codeline">/// After the schedule has been formed, call this function to combine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeline">/// the instructions from the different stages/cycles.  That is, this</td>
    <td class="lineNumber">2897</td>
    <td class="codeline">/// the instructions from the different stages/cycles.  That is, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeline">/// function creates a schedule that represents a single iteration.</td>
    <td class="lineNumber">2898</td>
    <td class="codeline">/// function creates a schedule that represents a single iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeline">void SMSchedule::finalizeSchedule(SwingSchedulerDAG *SSD) {</td>
    <td class="lineNumber">2899</td>
    <td class="codeline">void SMSchedule::finalizeSchedule(SwingSchedulerDAG *SSD) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeline">  // Move all instructions to the first stage from later stages.</td>
    <td class="lineNumber">2900</td>
    <td class="codeline">  // Move all instructions to the first stage from later stages.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeline">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
    <td class="lineNumber">2901</td>
    <td class="codeline">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeline">    for (int stage = 1, lastStage = getMaxStageCount(); stage <= lastStage;</td>
    <td class="lineNumber">2902</td>
    <td class="codeline">    for (int stage = 1, lastStage = getMaxStageCount(); stage <= lastStage;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeline">         ++stage) {</td>
    <td class="lineNumber">2903</td>
    <td class="codeline">         ++stage) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeline">      std::deque<SUnit *> &cycleInstrs =</td>
    <td class="lineNumber">2904</td>
    <td class="codeline">      std::deque<SUnit *> &cycleInstrs =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeline">          ScheduledInstrs[cycle + (stage * InitiationInterval)];</td>
    <td class="lineNumber">2905</td>
    <td class="codeline">          ScheduledInstrs[cycle + (stage * InitiationInterval)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeline">      for (SUnit *SU : llvm::reverse(cycleInstrs))</td>
    <td class="lineNumber">2906</td>
    <td class="codeline">      for (SUnit *SU : llvm::reverse(cycleInstrs))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeline">        ScheduledInstrs[cycle].push_front(SU);</td>
    <td class="lineNumber">2907</td>
    <td class="codeline">        ScheduledInstrs[cycle].push_front(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2908</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2909</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeline"></td>
    <td class="lineNumber">2910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeline">  // Erase all the elements in the later stages. Only one iteration should</td>
    <td class="lineNumber">2911</td>
    <td class="codeline">  // Erase all the elements in the later stages. Only one iteration should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeline">  // remain in the scheduled list, and it contains all the instructions.</td>
    <td class="lineNumber">2912</td>
    <td class="codeline">  // remain in the scheduled list, and it contains all the instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeline">  for (int cycle = getFinalCycle() + 1; cycle <= LastCycle; ++cycle)</td>
    <td class="lineNumber">2913</td>
    <td class="codeline">  for (int cycle = getFinalCycle() + 1; cycle <= LastCycle; ++cycle)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeline">    ScheduledInstrs.erase(cycle);</td>
    <td class="lineNumber">2914</td>
    <td class="codeline">    ScheduledInstrs.erase(cycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeline"></td>
    <td class="lineNumber">2915</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeline">  // Change the registers in instruction as specified in the InstrChanges</td>
    <td class="lineNumber">2916</td>
    <td class="codeline">  // Change the registers in instruction as specified in the InstrChanges</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeline">  // map. We need to use the new registers to create the correct order.</td>
    <td class="lineNumber">2917</td>
    <td class="codeline">  // map. We need to use the new registers to create the correct order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeline">  for (const SUnit &SU : SSD->SUnits)</td>
    <td class="lineNumber">2918</td>
    <td class="codeline">  for (const SUnit &SU : SSD->SUnits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeline">    SSD->applyInstrChange(SU.getInstr(), *this);</td>
    <td class="lineNumber">2919</td>
    <td class="codeline">    SSD->applyInstrChange(SU.getInstr(), *this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeline"></td>
    <td class="lineNumber">2920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeline">  // Reorder the instructions in each cycle to fix and improve the</td>
    <td class="lineNumber">2921</td>
    <td class="codeline">  // Reorder the instructions in each cycle to fix and improve the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeline">  // generated code.</td>
    <td class="lineNumber">2922</td>
    <td class="codeline">  // generated code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeline">  for (int Cycle = getFirstCycle(), E = getFinalCycle(); Cycle <= E; ++Cycle) {</td>
    <td class="lineNumber">2923</td>
    <td class="codeline">  for (int Cycle = getFirstCycle(), E = getFinalCycle(); Cycle <= E; ++Cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeline">    std::deque<SUnit *> &cycleInstrs = ScheduledInstrs[Cycle];</td>
    <td class="lineNumber">2924</td>
    <td class="codeline">    std::deque<SUnit *> &cycleInstrs = ScheduledInstrs[Cycle];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeline">    std::deque<SUnit *> newOrderPhi;</td>
    <td class="lineNumber">2925</td>
    <td class="codeline">    std::deque<SUnit *> newOrderPhi;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeline">    for (SUnit *SU : cycleInstrs) {</td>
    <td class="lineNumber">2926</td>
    <td class="codeline">    for (SUnit *SU : cycleInstrs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeline">      if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">2927</td>
    <td class="codeline">      if (SU->getInstr()->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeline">        newOrderPhi.push_back(SU);</td>
    <td class="lineNumber">2928</td>
    <td class="codeline">        newOrderPhi.push_back(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2929</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeline">    std::deque<SUnit *> newOrderI;</td>
    <td class="lineNumber">2930</td>
    <td class="codeline">    std::deque<SUnit *> newOrderI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeline">    for (SUnit *SU : cycleInstrs) {</td>
    <td class="lineNumber">2931</td>
    <td class="codeline">    for (SUnit *SU : cycleInstrs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeline">      if (!SU->getInstr()->isPHI())</td>
    <td class="lineNumber">2932</td>
    <td class="codeline">      if (!SU->getInstr()->isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeline">        orderDependence(SSD, SU, newOrderI);</td>
    <td class="lineNumber">2933</td>
    <td class="codeline">        orderDependence(SSD, SU, newOrderI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2934</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeline">    // Replace the old order with the new order.</td>
    <td class="lineNumber">2935</td>
    <td class="codeline">    // Replace the old order with the new order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeline">    cycleInstrs.swap(newOrderPhi);</td>
    <td class="lineNumber">2936</td>
    <td class="codeline">    cycleInstrs.swap(newOrderPhi);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeline">    llvm::append_range(cycleInstrs, newOrderI);</td>
    <td class="lineNumber">2937</td>
    <td class="codeline">    llvm::append_range(cycleInstrs, newOrderI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeline">    SSD->fixupRegisterOverlaps(cycleInstrs);</td>
    <td class="lineNumber">2938</td>
    <td class="codeline">    SSD->fixupRegisterOverlaps(cycleInstrs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2939</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeline"></td>
    <td class="lineNumber">2940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeline">  LLVM_DEBUG(dump(););</td>
    <td class="lineNumber">2941</td>
    <td class="codeline">  LLVM_DEBUG(dump(););</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2942</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeline"></td>
    <td class="lineNumber">2943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeline">void NodeSet::print(raw_ostream &os) const {</td>
    <td class="lineNumber">2944</td>
    <td class="codeline">void NodeSet::print(raw_ostream &os) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeline">  os << "Num nodes " << size() << " rec " << RecMII << " mov " << MaxMOV</td>
    <td class="lineNumber">2945</td>
    <td class="codeline">  os << "Num nodes " << size() << " rec " << RecMII << " mov " << MaxMOV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeline">     << " depth " << MaxDepth << " col " << Colocate << "\n";</td>
    <td class="lineNumber">2946</td>
    <td class="codeline">     << " depth " << MaxDepth << " col " << Colocate << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeline">  for (const auto &I : Nodes)</td>
    <td class="lineNumber">2947</td>
    <td class="codeline">  for (const auto &I : Nodes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeline">    os << "   SU(" << I->NodeNum << ") " << *(I->getInstr());</td>
    <td class="lineNumber">2948</td>
    <td class="codeline">    os << "   SU(" << I->NodeNum << ") " << *(I->getInstr());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeline">  os << "\n";</td>
    <td class="lineNumber">2949</td>
    <td class="codeline">  os << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2950</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeline"></td>
    <td class="lineNumber">2951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">2952</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeline">/// Print the schedule information to the given output.</td>
    <td class="lineNumber">2953</td>
    <td class="codeline">/// Print the schedule information to the given output.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeline">void SMSchedule::print(raw_ostream &os) const {</td>
    <td class="lineNumber">2954</td>
    <td class="codeline">void SMSchedule::print(raw_ostream &os) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeline">  // Iterate over each cycle.</td>
    <td class="lineNumber">2955</td>
    <td class="codeline">  // Iterate over each cycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeline">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
    <td class="lineNumber">2956</td>
    <td class="codeline">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeline">    // Iterate over each instruction in the cycle.</td>
    <td class="lineNumber">2957</td>
    <td class="codeline">    // Iterate over each instruction in the cycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeline">    const_sched_iterator cycleInstrs = ScheduledInstrs.find(cycle);</td>
    <td class="lineNumber">2958</td>
    <td class="codeline">    const_sched_iterator cycleInstrs = ScheduledInstrs.find(cycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeline">    for (SUnit *CI : cycleInstrs->second) {</td>
    <td class="lineNumber">2959</td>
    <td class="codeline">    for (SUnit *CI : cycleInstrs->second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeline">      os << "cycle " << cycle << " (" << stageScheduled(CI) << ") ";</td>
    <td class="lineNumber">2960</td>
    <td class="codeline">      os << "cycle " << cycle << " (" << stageScheduled(CI) << ") ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeline">      os << "(" << CI->NodeNum << ") ";</td>
    <td class="lineNumber">2961</td>
    <td class="codeline">      os << "(" << CI->NodeNum << ") ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeline">      CI->getInstr()->print(os);</td>
    <td class="lineNumber">2962</td>
    <td class="codeline">      CI->getInstr()->print(os);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeline">      os << "\n";</td>
    <td class="lineNumber">2963</td>
    <td class="codeline">      os << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2964</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2965</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2966</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeline"></td>
    <td class="lineNumber">2967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeline">/// Utility function used for debugging to print the schedule.</td>
    <td class="lineNumber">2968</td>
    <td class="codeline">/// Utility function used for debugging to print the schedule.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeline">LLVM_DUMP_METHOD void SMSchedule::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">2969</td>
    <td class="codeline">LLVM_DUMP_METHOD void SMSchedule::dump() const { print(dbgs()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeline">LLVM_DUMP_METHOD void NodeSet::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">2970</td>
    <td class="codeline">LLVM_DUMP_METHOD void NodeSet::dump() const { print(dbgs()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeline"></td>
    <td class="lineNumber">2971</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeline">void ResourceManager::dumpMRT() const {</td>
    <td class="lineNumber">2972</td>
    <td class="codeline">void ResourceManager::dumpMRT() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">2973</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeline">    if (UseDFA)</td>
    <td class="lineNumber">2974</td>
    <td class="codeline">    if (UseDFA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">2975</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeline">    std::stringstream SS;</td>
    <td class="lineNumber">2976</td>
    <td class="codeline">    std::stringstream SS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeline">    SS << "MRT:\n";</td>
    <td class="lineNumber">2977</td>
    <td class="codeline">    SS << "MRT:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeline">    SS << std::setw(4) << "Slot";</td>
    <td class="lineNumber">2978</td>
    <td class="codeline">    SS << std::setw(4) << "Slot";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeline">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
    <td class="lineNumber">2979</td>
    <td class="codeline">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeline">      SS << std::setw(3) << I;</td>
    <td class="lineNumber">2980</td>
    <td class="codeline">      SS << std::setw(3) << I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeline">    SS << std::setw(7) << "#Mops"</td>
    <td class="lineNumber">2981</td>
    <td class="codeline">    SS << std::setw(7) << "#Mops"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeline">       << "\n";</td>
    <td class="lineNumber">2982</td>
    <td class="codeline">       << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeline">    for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
    <td class="lineNumber">2983</td>
    <td class="codeline">    for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeline">      SS << std::setw(4) << Slot;</td>
    <td class="lineNumber">2984</td>
    <td class="codeline">      SS << std::setw(4) << Slot;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeline">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
    <td class="lineNumber">2985</td>
    <td class="codeline">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeline">        SS << std::setw(3) << MRT[Slot][I];</td>
    <td class="lineNumber">2986</td>
    <td class="codeline">        SS << std::setw(3) << MRT[Slot][I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeline">      SS << std::setw(7) << NumScheduledMops[Slot] << "\n";</td>
    <td class="lineNumber">2987</td>
    <td class="codeline">      SS << std::setw(7) << NumScheduledMops[Slot] << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2988</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeline">    dbgs() << SS.str();</td>
    <td class="lineNumber">2989</td>
    <td class="codeline">    dbgs() << SS.str();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">2990</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2991</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">2992</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeline"></td>
    <td class="lineNumber">2993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeline">void ResourceManager::initProcResourceVectors(</td>
    <td class="lineNumber">2994</td>
    <td class="codeline">void ResourceManager::initProcResourceVectors(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeline">    const MCSchedModel &SM, SmallVectorImpl<uint64_t> &Masks) {</td>
    <td class="lineNumber">2995</td>
    <td class="codeline">    const MCSchedModel &SM, SmallVectorImpl<uint64_t> &Masks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeline">  unsigned ProcResourceID = 0;</td>
    <td class="lineNumber">2996</td>
    <td class="codeline">  unsigned ProcResourceID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeline"></td>
    <td class="lineNumber">2997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeline">  // We currently limit the resource kinds to 64 and below so that we can use</td>
    <td class="lineNumber">2998</td>
    <td class="codeline">  // We currently limit the resource kinds to 64 and below so that we can use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeline">  // uint64_t for Masks</td>
    <td class="lineNumber">2999</td>
    <td class="codeline">  // uint64_t for Masks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeline">  assert(SM.getNumProcResourceKinds() < 64 &&</td>
    <td class="lineNumber">3000</td>
    <td class="codeline">  assert(SM.getNumProcResourceKinds() < 64 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeline">         "Too many kinds of resources, unsupported");</td>
    <td class="lineNumber">3001</td>
    <td class="codeline">         "Too many kinds of resources, unsupported");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeline">  // Create a unique bitmask for every processor resource unit.</td>
    <td class="lineNumber">3002</td>
    <td class="codeline">  // Create a unique bitmask for every processor resource unit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeline">  // Skip resource at index 0, since it always references 'InvalidUnit'.</td>
    <td class="lineNumber">3003</td>
    <td class="codeline">  // Skip resource at index 0, since it always references 'InvalidUnit'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeline">  Masks.resize(SM.getNumProcResourceKinds());</td>
    <td class="lineNumber">3004</td>
    <td class="codeline">  Masks.resize(SM.getNumProcResourceKinds());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeline">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">3005</td>
    <td class="codeline">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeline">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
    <td class="lineNumber">3006</td>
    <td class="codeline">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeline">    if (Desc.SubUnitsIdxBegin)</td>
    <td class="lineNumber">3007</td>
    <td class="codeline">    if (Desc.SubUnitsIdxBegin)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">3008</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeline">    Masks[I] = 1ULL << ProcResourceID;</td>
    <td class="lineNumber">3009</td>
    <td class="codeline">    Masks[I] = 1ULL << ProcResourceID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeline">    ProcResourceID++;</td>
    <td class="lineNumber">3010</td>
    <td class="codeline">    ProcResourceID++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3011</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeline">  // Create a unique bitmask for every processor resource group.</td>
    <td class="lineNumber">3012</td>
    <td class="codeline">  // Create a unique bitmask for every processor resource group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeline">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">3013</td>
    <td class="codeline">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeline">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
    <td class="lineNumber">3014</td>
    <td class="codeline">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeline">    if (!Desc.SubUnitsIdxBegin)</td>
    <td class="lineNumber">3015</td>
    <td class="codeline">    if (!Desc.SubUnitsIdxBegin)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">3016</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeline">    Masks[I] = 1ULL << ProcResourceID;</td>
    <td class="lineNumber">3017</td>
    <td class="codeline">    Masks[I] = 1ULL << ProcResourceID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeline">    for (unsigned U = 0; U < Desc.NumUnits; ++U)</td>
    <td class="lineNumber">3018</td>
    <td class="codeline">    for (unsigned U = 0; U < Desc.NumUnits; ++U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeline">      Masks[I] |= Masks[Desc.SubUnitsIdxBegin[U]];</td>
    <td class="lineNumber">3019</td>
    <td class="codeline">      Masks[I] |= Masks[Desc.SubUnitsIdxBegin[U]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeline">    ProcResourceID++;</td>
    <td class="lineNumber">3020</td>
    <td class="codeline">    ProcResourceID++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3021</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">3022</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeline">    if (SwpShowResMask) {</td>
    <td class="lineNumber">3023</td>
    <td class="codeline">    if (SwpShowResMask) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeline">      dbgs() << "ProcResourceDesc:\n";</td>
    <td class="lineNumber">3024</td>
    <td class="codeline">      dbgs() << "ProcResourceDesc:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeline">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">3025</td>
    <td class="codeline">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeline">        const MCProcResourceDesc *ProcResource = SM.getProcResource(I);</td>
    <td class="lineNumber">3026</td>
    <td class="codeline">        const MCProcResourceDesc *ProcResource = SM.getProcResource(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeline">        dbgs() << format(" %16s(%2d): Mask: 0x%08x, NumUnits:%2d\n",</td>
    <td class="lineNumber">3027</td>
    <td class="codeline">        dbgs() << format(" %16s(%2d): Mask: 0x%08x, NumUnits:%2d\n",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeline">                         ProcResource->Name, I, Masks[I],</td>
    <td class="lineNumber">3028</td>
    <td class="codeline">                         ProcResource->Name, I, Masks[I],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeline">                         ProcResource->NumUnits);</td>
    <td class="lineNumber">3029</td>
    <td class="codeline">                         ProcResource->NumUnits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3030</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeline">      dbgs() << " -----------------\n";</td>
    <td class="lineNumber">3031</td>
    <td class="codeline">      dbgs() << " -----------------\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3032</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">3033</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3034</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeline"></td>
    <td class="lineNumber">3035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeline">bool ResourceManager::canReserveResources(SUnit &SU, int Cycle) {</td>
    <td class="lineNumber">3036</td>
    <td class="codeline">bool ResourceManager::canReserveResources(SUnit &SU, int Cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">3037</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeline">    if (SwpDebugResource)</td>
    <td class="lineNumber">3038</td>
    <td class="codeline">    if (SwpDebugResource)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeline">      dbgs() << "canReserveResources:\n";</td>
    <td class="lineNumber">3039</td>
    <td class="codeline">      dbgs() << "canReserveResources:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">3040</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeline">  if (UseDFA)</td>
    <td class="lineNumber">3041</td>
    <td class="codeline">  if (UseDFA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeline">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
    <td class="lineNumber">3042</td>
    <td class="codeline">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeline">        ->canReserveResources(&SU.getInstr()->getDesc());</td>
    <td class="lineNumber">3043</td>
    <td class="codeline">        ->canReserveResources(&SU.getInstr()->getDesc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeline"></td>
    <td class="lineNumber">3044</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeline">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">3045</td>
    <td class="codeline">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeline">  if (!SCDesc->isValid()) {</td>
    <td class="lineNumber">3046</td>
    <td class="codeline">  if (!SCDesc->isValid()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeline">    LLVM_DEBUG({</td>
    <td class="lineNumber">3047</td>
    <td class="codeline">    LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeline">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
    <td class="lineNumber">3048</td>
    <td class="codeline">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeline">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
    <td class="lineNumber">3049</td>
    <td class="codeline">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">3050</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3051</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3052</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeline"></td>
    <td class="lineNumber">3053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeline">  reserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">3054</td>
    <td class="codeline">  reserveResources(SCDesc, Cycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeline">  bool Result = !isOverbooked();</td>
    <td class="lineNumber">3055</td>
    <td class="codeline">  bool Result = !isOverbooked();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeline">  unreserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">3056</td>
    <td class="codeline">  unreserveResources(SCDesc, Cycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeline"></td>
    <td class="lineNumber">3057</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeline">  LLVM_DEBUG(if (SwpDebugResource) dbgs() << "return " << Result << "\n\n";);</td>
    <td class="lineNumber">3058</td>
    <td class="codeline">  LLVM_DEBUG(if (SwpDebugResource) dbgs() << "return " << Result << "\n\n";);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">3059</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3060</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeline"></td>
    <td class="lineNumber">3061</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeline">void ResourceManager::reserveResources(SUnit &SU, int Cycle) {</td>
    <td class="lineNumber">3062</td>
    <td class="codeline">void ResourceManager::reserveResources(SUnit &SU, int Cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">3063</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeline">    if (SwpDebugResource)</td>
    <td class="lineNumber">3064</td>
    <td class="codeline">    if (SwpDebugResource)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeline">      dbgs() << "reserveResources:\n";</td>
    <td class="lineNumber">3065</td>
    <td class="codeline">      dbgs() << "reserveResources:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">3066</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeline">  if (UseDFA)</td>
    <td class="lineNumber">3067</td>
    <td class="codeline">  if (UseDFA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeline">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
    <td class="lineNumber">3068</td>
    <td class="codeline">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeline">        ->reserveResources(&SU.getInstr()->getDesc());</td>
    <td class="lineNumber">3069</td>
    <td class="codeline">        ->reserveResources(&SU.getInstr()->getDesc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeline"></td>
    <td class="lineNumber">3070</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeline">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">3071</td>
    <td class="codeline">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeline">  if (!SCDesc->isValid()) {</td>
    <td class="lineNumber">3072</td>
    <td class="codeline">  if (!SCDesc->isValid()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeline">    LLVM_DEBUG({</td>
    <td class="lineNumber">3073</td>
    <td class="codeline">    LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeline">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
    <td class="lineNumber">3074</td>
    <td class="codeline">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeline">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
    <td class="lineNumber">3075</td>
    <td class="codeline">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">3076</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">3077</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3078</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeline"></td>
    <td class="lineNumber">3079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="codeline">  reserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">3080</td>
    <td class="codeline">  reserveResources(SCDesc, Cycle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="codeline"></td>
    <td class="lineNumber">3081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">3082</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="codeline">    if (SwpDebugResource) {</td>
    <td class="lineNumber">3083</td>
    <td class="codeline">    if (SwpDebugResource) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="codeline">      dumpMRT();</td>
    <td class="lineNumber">3084</td>
    <td class="codeline">      dumpMRT();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="codeline">      dbgs() << "reserveResources: done!\n\n";</td>
    <td class="lineNumber">3085</td>
    <td class="codeline">      dbgs() << "reserveResources: done!\n\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3086</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">3087</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3088</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="codeline"></td>
    <td class="lineNumber">3089</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="codeline">void ResourceManager::reserveResources(const MCSchedClassDesc *SCDesc,</td>
    <td class="lineNumber">3090</td>
    <td class="codeline">void ResourceManager::reserveResources(const MCSchedClassDesc *SCDesc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="codeline">                                       int Cycle) {</td>
    <td class="lineNumber">3091</td>
    <td class="codeline">                                       int Cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="codeline">  assert(!UseDFA);</td>
    <td class="lineNumber">3092</td>
    <td class="codeline">  assert(!UseDFA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="codeline">  for (const MCWriteProcResEntry &PRE : make_range(</td>
    <td class="lineNumber">3093</td>
    <td class="codeline">  for (const MCWriteProcResEntry &PRE : make_range(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="codeline">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
    <td class="lineNumber">3094</td>
    <td class="codeline">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="codeline">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
    <td class="lineNumber">3095</td>
    <td class="codeline">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="codeline">      ++MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
    <td class="lineNumber">3096</td>
    <td class="codeline">      ++MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="codeline"></td>
    <td class="lineNumber">3097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="codeline">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
    <td class="lineNumber">3098</td>
    <td class="codeline">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="codeline">    ++NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
    <td class="lineNumber">3099</td>
    <td class="codeline">    ++NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3100</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="codeline"></td>
    <td class="lineNumber">3101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="codeline">void ResourceManager::unreserveResources(const MCSchedClassDesc *SCDesc,</td>
    <td class="lineNumber">3102</td>
    <td class="codeline">void ResourceManager::unreserveResources(const MCSchedClassDesc *SCDesc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="codeline">                                         int Cycle) {</td>
    <td class="lineNumber">3103</td>
    <td class="codeline">                                         int Cycle) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="codeline">  assert(!UseDFA);</td>
    <td class="lineNumber">3104</td>
    <td class="codeline">  assert(!UseDFA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="codeline">  for (const MCWriteProcResEntry &PRE : make_range(</td>
    <td class="lineNumber">3105</td>
    <td class="codeline">  for (const MCWriteProcResEntry &PRE : make_range(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="codeline">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
    <td class="lineNumber">3106</td>
    <td class="codeline">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="codeline">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
    <td class="lineNumber">3107</td>
    <td class="codeline">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="codeline">      --MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
    <td class="lineNumber">3108</td>
    <td class="codeline">      --MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="codeline"></td>
    <td class="lineNumber">3109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="codeline">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
    <td class="lineNumber">3110</td>
    <td class="codeline">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="codeline">    --NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
    <td class="lineNumber">3111</td>
    <td class="codeline">    --NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3112</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="codeline"></td>
    <td class="lineNumber">3113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="codeline">bool ResourceManager::isOverbooked() const {</td>
    <td class="lineNumber">3114</td>
    <td class="codeline">bool ResourceManager::isOverbooked() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="codeline">  assert(!UseDFA);</td>
    <td class="lineNumber">3115</td>
    <td class="codeline">  assert(!UseDFA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="codeline">  for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
    <td class="lineNumber">3116</td>
    <td class="codeline">  for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="codeline">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">3117</td>
    <td class="codeline">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="codeline">      const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
    <td class="lineNumber">3118</td>
    <td class="codeline">      const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="codeline">      if (MRT[Slot][I] > Desc->NumUnits)</td>
    <td class="lineNumber">3119</td>
    <td class="codeline">      if (MRT[Slot][I] > Desc->NumUnits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">3120</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3121</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="codeline">    if (NumScheduledMops[Slot] > IssueWidth)</td>
    <td class="lineNumber">3122</td>
    <td class="codeline">    if (NumScheduledMops[Slot] > IssueWidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3123</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3124</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">3125</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3126</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="codeline"></td>
    <td class="lineNumber">3127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="codeline">int ResourceManager::calculateResMIIDFA() const {</td>
    <td class="lineNumber">3128</td>
    <td class="codeline">int ResourceManager::calculateResMIIDFA() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="codeline">  assert(UseDFA);</td>
    <td class="lineNumber">3129</td>
    <td class="codeline">  assert(UseDFA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="codeline"></td>
    <td class="lineNumber">3130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="codeline">  // Sort the instructions by the number of available choices for scheduling,</td>
    <td class="lineNumber">3131</td>
    <td class="codeline">  // Sort the instructions by the number of available choices for scheduling,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="codeline">  // least to most. Use the number of critical resources as the tie breaker.</td>
    <td class="lineNumber">3132</td>
    <td class="codeline">  // least to most. Use the number of critical resources as the tie breaker.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="codeline">  FuncUnitSorter FUS = FuncUnitSorter(*ST);</td>
    <td class="lineNumber">3133</td>
    <td class="codeline">  FuncUnitSorter FUS = FuncUnitSorter(*ST);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="codeline">  for (SUnit &SU : DAG->SUnits)</td>
    <td class="lineNumber">3134</td>
    <td class="codeline">  for (SUnit &SU : DAG->SUnits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="codeline">    FUS.calcCriticalResources(*SU.getInstr());</td>
    <td class="lineNumber">3135</td>
    <td class="codeline">    FUS.calcCriticalResources(*SU.getInstr());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="codeline">  PriorityQueue<MachineInstr *, std::vector<MachineInstr *>, FuncUnitSorter></td>
    <td class="lineNumber">3136</td>
    <td class="codeline">  PriorityQueue<MachineInstr *, std::vector<MachineInstr *>, FuncUnitSorter></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="codeline">      FuncUnitOrder(FUS);</td>
    <td class="lineNumber">3137</td>
    <td class="codeline">      FuncUnitOrder(FUS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="codeline"></td>
    <td class="lineNumber">3138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="codeline">  for (SUnit &SU : DAG->SUnits)</td>
    <td class="lineNumber">3139</td>
    <td class="codeline">  for (SUnit &SU : DAG->SUnits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="codeline">    FuncUnitOrder.push(SU.getInstr());</td>
    <td class="lineNumber">3140</td>
    <td class="codeline">    FuncUnitOrder.push(SU.getInstr());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="codeline"></td>
    <td class="lineNumber">3141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="codeline">  SmallVector<std::unique_ptr<DFAPacketizer>, 8> Resources;</td>
    <td class="lineNumber">3142</td>
    <td class="codeline">  SmallVector<std::unique_ptr<DFAPacketizer>, 8> Resources;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="codeline">  Resources.push_back(</td>
    <td class="lineNumber">3143</td>
    <td class="codeline">  Resources.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="codeline">      std::unique_ptr<DFAPacketizer>(TII->CreateTargetScheduleState(*ST)));</td>
    <td class="lineNumber">3144</td>
    <td class="codeline">      std::unique_ptr<DFAPacketizer>(TII->CreateTargetScheduleState(*ST)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="codeline"></td>
    <td class="lineNumber">3145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="codeline">  while (!FuncUnitOrder.empty()) {</td>
    <td class="lineNumber">3146</td>
    <td class="codeline">  while (!FuncUnitOrder.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="codeline">    MachineInstr *MI = FuncUnitOrder.top();</td>
    <td class="lineNumber">3147</td>
    <td class="codeline">    MachineInstr *MI = FuncUnitOrder.top();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="codeline">    FuncUnitOrder.pop();</td>
    <td class="lineNumber">3148</td>
    <td class="codeline">    FuncUnitOrder.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="codeline">    if (TII->isZeroCost(MI->getOpcode()))</td>
    <td class="lineNumber">3149</td>
    <td class="codeline">    if (TII->isZeroCost(MI->getOpcode()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">3150</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="codeline"></td>
    <td class="lineNumber">3151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="codeline">    // Attempt to reserve the instruction in an existing DFA. At least one</td>
    <td class="lineNumber">3152</td>
    <td class="codeline">    // Attempt to reserve the instruction in an existing DFA. At least one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="codeline">    // DFA is needed for each cycle.</td>
    <td class="lineNumber">3153</td>
    <td class="codeline">    // DFA is needed for each cycle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="codeline">    unsigned NumCycles = DAG->getSUnit(MI)->Latency;</td>
    <td class="lineNumber">3154</td>
    <td class="codeline">    unsigned NumCycles = DAG->getSUnit(MI)->Latency;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="codeline">    unsigned ReservedCycles = 0;</td>
    <td class="lineNumber">3155</td>
    <td class="codeline">    unsigned ReservedCycles = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="codeline">    auto *RI = Resources.begin();</td>
    <td class="lineNumber">3156</td>
    <td class="codeline">    auto *RI = Resources.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="codeline">    auto *RE = Resources.end();</td>
    <td class="lineNumber">3157</td>
    <td class="codeline">    auto *RE = Resources.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="codeline">    LLVM_DEBUG({</td>
    <td class="lineNumber">3158</td>
    <td class="codeline">    LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="codeline">      dbgs() << "Trying to reserve resource for " << NumCycles</td>
    <td class="lineNumber">3159</td>
    <td class="codeline">      dbgs() << "Trying to reserve resource for " << NumCycles</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="codeline">             << " cycles for \n";</td>
    <td class="lineNumber">3160</td>
    <td class="codeline">             << " cycles for \n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="codeline">      MI->dump();</td>
    <td class="lineNumber">3161</td>
    <td class="codeline">      MI->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">3162</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="codeline">    for (unsigned C = 0; C < NumCycles; ++C)</td>
    <td class="lineNumber">3163</td>
    <td class="codeline">    for (unsigned C = 0; C < NumCycles; ++C)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="codeline">      while (RI != RE) {</td>
    <td class="lineNumber">3164</td>
    <td class="codeline">      while (RI != RE) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="codeline">        if ((*RI)->canReserveResources(*MI)) {</td>
    <td class="lineNumber">3165</td>
    <td class="codeline">        if ((*RI)->canReserveResources(*MI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="codeline">          (*RI)->reserveResources(*MI);</td>
    <td class="lineNumber">3166</td>
    <td class="codeline">          (*RI)->reserveResources(*MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="codeline">          ++ReservedCycles;</td>
    <td class="lineNumber">3167</td>
    <td class="codeline">          ++ReservedCycles;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">3168</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">3169</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="codeline">        RI++;</td>
    <td class="lineNumber">3170</td>
    <td class="codeline">        RI++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3171</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "ReservedCycles:" << ReservedCycles</td>
    <td class="lineNumber">3172</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "ReservedCycles:" << ReservedCycles</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="codeline">                      << ", NumCycles:" << NumCycles << "\n");</td>
    <td class="lineNumber">3173</td>
    <td class="codeline">                      << ", NumCycles:" << NumCycles << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="codeline">    // Add new DFAs, if needed, to reserve resources.</td>
    <td class="lineNumber">3174</td>
    <td class="codeline">    // Add new DFAs, if needed, to reserve resources.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="codeline">    for (unsigned C = ReservedCycles; C < NumCycles; ++C) {</td>
    <td class="lineNumber">3175</td>
    <td class="codeline">    for (unsigned C = ReservedCycles; C < NumCycles; ++C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="codeline">      LLVM_DEBUG(if (SwpDebugResource) dbgs()</td>
    <td class="lineNumber">3176</td>
    <td class="codeline">      LLVM_DEBUG(if (SwpDebugResource) dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="codeline">                 << "NewResource created to reserve resources"</td>
    <td class="lineNumber">3177</td>
    <td class="codeline">                 << "NewResource created to reserve resources"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="codeline">                 << "\n");</td>
    <td class="lineNumber">3178</td>
    <td class="codeline">                 << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="codeline">      auto *NewResource = TII->CreateTargetScheduleState(*ST);</td>
    <td class="lineNumber">3179</td>
    <td class="codeline">      auto *NewResource = TII->CreateTargetScheduleState(*ST);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="codeline">      assert(NewResource->canReserveResources(*MI) && "Reserve error.");</td>
    <td class="lineNumber">3180</td>
    <td class="codeline">      assert(NewResource->canReserveResources(*MI) && "Reserve error.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="codeline">      NewResource->reserveResources(*MI);</td>
    <td class="lineNumber">3181</td>
    <td class="codeline">      NewResource->reserveResources(*MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="codeline">      Resources.push_back(std::unique_ptr<DFAPacketizer>(NewResource));</td>
    <td class="lineNumber">3182</td>
    <td class="codeline">      Resources.push_back(std::unique_ptr<DFAPacketizer>(NewResource));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3183</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3184</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="codeline"></td>
    <td class="lineNumber">3185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="codeline">  int Resmii = Resources.size();</td>
    <td class="lineNumber">3186</td>
    <td class="codeline">  int Resmii = Resources.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Return Res MII:" << Resmii << "\n");</td>
    <td class="lineNumber">3187</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Return Res MII:" << Resmii << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="codeline">  return Resmii;</td>
    <td class="lineNumber">3188</td>
    <td class="codeline">  return Resmii;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3189</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="codeline"></td>
    <td class="lineNumber">3190</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="codeline">int ResourceManager::calculateResMII() const {</td>
    <td class="lineNumber">3191</td>
    <td class="codeline">int ResourceManager::calculateResMII() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="codeline">  if (UseDFA)</td>
    <td class="lineNumber">3192</td>
    <td class="codeline">  if (UseDFA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="codeline">    return calculateResMIIDFA();</td>
    <td class="lineNumber">3193</td>
    <td class="codeline">    return calculateResMIIDFA();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="codeline"></td>
    <td class="lineNumber">3194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="codeline">  // Count each resource consumption and divide it by the number of units.</td>
    <td class="lineNumber">3195</td>
    <td class="codeline">  // Count each resource consumption and divide it by the number of units.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="codeline">  // ResMII is the max value among them.</td>
    <td class="lineNumber">3196</td>
    <td class="codeline">  // ResMII is the max value among them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="codeline"></td>
    <td class="lineNumber">3197</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="codeline">  int NumMops = 0;</td>
    <td class="lineNumber">3198</td>
    <td class="codeline">  int NumMops = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="codeline">  SmallVector<uint64_t> ResourceCount(SM.getNumProcResourceKinds());</td>
    <td class="lineNumber">3199</td>
    <td class="codeline">  SmallVector<uint64_t> ResourceCount(SM.getNumProcResourceKinds());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="codeline">  for (SUnit &SU : DAG->SUnits) {</td>
    <td class="lineNumber">3200</td>
    <td class="codeline">  for (SUnit &SU : DAG->SUnits) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="codeline">    if (TII->isZeroCost(SU.getInstr()->getOpcode()))</td>
    <td class="lineNumber">3201</td>
    <td class="codeline">    if (TII->isZeroCost(SU.getInstr()->getOpcode()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">3202</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="codeline"></td>
    <td class="lineNumber">3203</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="codeline">    const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">3204</td>
    <td class="codeline">    const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="codeline">    if (!SCDesc->isValid())</td>
    <td class="lineNumber">3205</td>
    <td class="codeline">    if (!SCDesc->isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">3206</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="codeline"></td>
    <td class="lineNumber">3207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="codeline">    LLVM_DEBUG({</td>
    <td class="lineNumber">3208</td>
    <td class="codeline">    LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="codeline">      if (SwpDebugResource) {</td>
    <td class="lineNumber">3209</td>
    <td class="codeline">      if (SwpDebugResource) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="codeline">        DAG->dumpNode(SU);</td>
    <td class="lineNumber">3210</td>
    <td class="codeline">        DAG->dumpNode(SU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="codeline">        dbgs() << "  #Mops: " << SCDesc->NumMicroOps << "\n"</td>
    <td class="lineNumber">3211</td>
    <td class="codeline">        dbgs() << "  #Mops: " << SCDesc->NumMicroOps << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="codeline">               << "  WriteProcRes: ";</td>
    <td class="lineNumber">3212</td>
    <td class="codeline">               << "  WriteProcRes: ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3213</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">3214</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="codeline">    NumMops += SCDesc->NumMicroOps;</td>
    <td class="lineNumber">3215</td>
    <td class="codeline">    NumMops += SCDesc->NumMicroOps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="codeline">    for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">3216</td>
    <td class="codeline">    for (const MCWriteProcResEntry &PRE :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="codeline">         make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">3217</td>
    <td class="codeline">         make_range(STI->getWriteProcResBegin(SCDesc),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="codeline">                    STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">3218</td>
    <td class="codeline">                    STI->getWriteProcResEnd(SCDesc))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="codeline">      LLVM_DEBUG({</td>
    <td class="lineNumber">3219</td>
    <td class="codeline">      LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="codeline">        if (SwpDebugResource) {</td>
    <td class="lineNumber">3220</td>
    <td class="codeline">        if (SwpDebugResource) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="codeline">          const MCProcResourceDesc *Desc =</td>
    <td class="lineNumber">3221</td>
    <td class="codeline">          const MCProcResourceDesc *Desc =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="codeline">              SM.getProcResource(PRE.ProcResourceIdx);</td>
    <td class="lineNumber">3222</td>
    <td class="codeline">              SM.getProcResource(PRE.ProcResourceIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="codeline">          dbgs() << Desc->Name << ": " << PRE.Cycles << ", ";</td>
    <td class="lineNumber">3223</td>
    <td class="codeline">          dbgs() << Desc->Name << ": " << PRE.Cycles << ", ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">3224</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">3225</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="codeline">      ResourceCount[PRE.ProcResourceIdx] += PRE.Cycles;</td>
    <td class="lineNumber">3226</td>
    <td class="codeline">      ResourceCount[PRE.ProcResourceIdx] += PRE.Cycles;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3227</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="codeline">    LLVM_DEBUG(if (SwpDebugResource) dbgs() << "\n");</td>
    <td class="lineNumber">3228</td>
    <td class="codeline">    LLVM_DEBUG(if (SwpDebugResource) dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3229</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="codeline"></td>
    <td class="lineNumber">3230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="codeline">  int Result = (NumMops + IssueWidth - 1) / IssueWidth;</td>
    <td class="lineNumber">3231</td>
    <td class="codeline">  int Result = (NumMops + IssueWidth - 1) / IssueWidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">3232</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="codeline">    if (SwpDebugResource)</td>
    <td class="lineNumber">3233</td>
    <td class="codeline">    if (SwpDebugResource)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="codeline">      dbgs() << "#Mops: " << NumMops << ", "</td>
    <td class="lineNumber">3234</td>
    <td class="codeline">      dbgs() << "#Mops: " << NumMops << ", "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="codeline">             << "IssueWidth: " << IssueWidth << ", "</td>
    <td class="lineNumber">3235</td>
    <td class="codeline">             << "IssueWidth: " << IssueWidth << ", "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="codeline">             << "Cycles: " << Result << "\n";</td>
    <td class="lineNumber">3236</td>
    <td class="codeline">             << "Cycles: " << Result << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">3237</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="codeline"></td>
    <td class="lineNumber">3238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">3239</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="codeline">    if (SwpDebugResource) {</td>
    <td class="lineNumber">3240</td>
    <td class="codeline">    if (SwpDebugResource) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="codeline">      std::stringstream SS;</td>
    <td class="lineNumber">3241</td>
    <td class="codeline">      std::stringstream SS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="codeline">      SS << std::setw(2) << "ID" << std::setw(16) << "Name" << std::setw(10)</td>
    <td class="lineNumber">3242</td>
    <td class="codeline">      SS << std::setw(2) << "ID" << std::setw(16) << "Name" << std::setw(10)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="codeline">         << "Units" << std::setw(10) << "Consumed" << std::setw(10) << "Cycles"</td>
    <td class="lineNumber">3243</td>
    <td class="codeline">         << "Units" << std::setw(10) << "Consumed" << std::setw(10) << "Cycles"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="codeline">         << "\n";</td>
    <td class="lineNumber">3244</td>
    <td class="codeline">         << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="codeline">      dbgs() << SS.str();</td>
    <td class="lineNumber">3245</td>
    <td class="codeline">      dbgs() << SS.str();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3246</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">3247</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="codeline">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">3248</td>
    <td class="codeline">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="codeline">    const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
    <td class="lineNumber">3249</td>
    <td class="codeline">    const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="codeline">    int Cycles = (ResourceCount[I] + Desc->NumUnits - 1) / Desc->NumUnits;</td>
    <td class="lineNumber">3250</td>
    <td class="codeline">    int Cycles = (ResourceCount[I] + Desc->NumUnits - 1) / Desc->NumUnits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="codeline">    LLVM_DEBUG({</td>
    <td class="lineNumber">3251</td>
    <td class="codeline">    LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="codeline">      if (SwpDebugResource) {</td>
    <td class="lineNumber">3252</td>
    <td class="codeline">      if (SwpDebugResource) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="codeline">        std::stringstream SS;</td>
    <td class="lineNumber">3253</td>
    <td class="codeline">        std::stringstream SS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="codeline">        SS << std::setw(2) << I << std::setw(16) << Desc->Name << std::setw(10)</td>
    <td class="lineNumber">3254</td>
    <td class="codeline">        SS << std::setw(2) << I << std::setw(16) << Desc->Name << std::setw(10)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="codeline">           << Desc->NumUnits << std::setw(10) << ResourceCount[I]</td>
    <td class="lineNumber">3255</td>
    <td class="codeline">           << Desc->NumUnits << std::setw(10) << ResourceCount[I]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="codeline">           << std::setw(10) << Cycles << "\n";</td>
    <td class="lineNumber">3256</td>
    <td class="codeline">           << std::setw(10) << Cycles << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="codeline">        dbgs() << SS.str();</td>
    <td class="lineNumber">3257</td>
    <td class="codeline">        dbgs() << SS.str();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3258</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">3259</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="codeline">    if (Cycles > Result)</td>
    <td class="lineNumber">3260</td>
    <td class="codeline">    if (Cycles > Result)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="codeline">      Result = Cycles;</td>
    <td class="lineNumber">3261</td>
    <td class="codeline">      Result = Cycles;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3262</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">3263</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3264</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="codeline"></td>
    <td class="lineNumber">3265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="codeline">void ResourceManager::init(int II) {</td>
    <td class="lineNumber">3266</td>
    <td class="codeline">void ResourceManager::init(int II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="codeline">  InitiationInterval = II;</td>
    <td class="lineNumber">3267</td>
    <td class="codeline">  InitiationInterval = II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="codeline">  DFAResources.clear();</td>
    <td class="lineNumber">3268</td>
    <td class="codeline">  DFAResources.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="codeline">  DFAResources.resize(II);</td>
    <td class="lineNumber">3269</td>
    <td class="codeline">  DFAResources.resize(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="codeline">  for (auto &I : DFAResources)</td>
    <td class="lineNumber">3270</td>
    <td class="codeline">  for (auto &I : DFAResources)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="codeline">    I.reset(ST->getInstrInfo()->CreateTargetScheduleState(*ST));</td>
    <td class="lineNumber">3271</td>
    <td class="codeline">    I.reset(ST->getInstrInfo()->CreateTargetScheduleState(*ST));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="codeline">  MRT.clear();</td>
    <td class="lineNumber">3272</td>
    <td class="codeline">  MRT.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="codeline">  MRT.resize(II, SmallVector<uint64_t>(SM.getNumProcResourceKinds()));</td>
    <td class="lineNumber">3273</td>
    <td class="codeline">  MRT.resize(II, SmallVector<uint64_t>(SM.getNumProcResourceKinds()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="codeline">  NumScheduledMops.clear();</td>
    <td class="lineNumber">3274</td>
    <td class="codeline">  NumScheduledMops.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="codeline">  NumScheduledMops.resize(II);</td>
    <td class="lineNumber">3275</td>
    <td class="codeline">  NumScheduledMops.resize(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3276</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="codeline"></td>
    <td class="lineNumber">3277</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// This SMS implementation is a target-independent back-end pass. When enabled,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// This SMS implementation is a target-independent back-end pass. When enabled,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// the pass runs just prior to the register allocation pass, while the machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// the pass runs just prior to the register allocation pass, while the machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">// IR is in SSA form. If software pipelining is successful, then the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">// IR is in SSA form. If software pipelining is successful, then the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// loop is replaced by the optimized loop. The optimized loop contains one or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// loop is replaced by the optimized loop. The optimized loop contains one or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">// more prolog blocks, the pipelined kernel, and one or more epilog blocks. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">// more prolog blocks, the pipelined kernel, and one or more epilog blocks. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">// the instructions cannot be scheduled in a given MII, we increase the MII by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">// the instructions cannot be scheduled in a given MII, we increase the MII by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">// one and try again.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">// one and try again.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">// The SMS implementation is an extension of the ScheduleDAGInstrs class. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">// The SMS implementation is an extension of the ScheduleDAGInstrs class. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">// represent loop carried dependences in the DAG as order edges to the Phi</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">// represent loop carried dependences in the DAG as order edges to the Phi</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">// nodes. We also perform several passes over the DAG to eliminate unnecessary</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">// nodes. We also perform several passes over the DAG to eliminate unnecessary</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">// edges that inhibit the ability to pipeline. The implementation uses the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">// edges that inhibit the ability to pipeline. The implementation uses the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">// DFAPacketizer class to compute the minimum initiation interval and the check</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">// DFAPacketizer class to compute the minimum initiation interval and the check</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">// where an instruction may be inserted in the pipelined schedule.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">// where an instruction may be inserted in the pipelined schedule.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">// In order for the SMS pass to work, several target specific hooks need to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">// In order for the SMS pass to work, several target specific hooks need to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">// implemented to get information about the loop structure and to rewrite</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">// implemented to get information about the loop structure and to rewrite</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">// instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">// instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/CodeGen/MachinePipeliner.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/CodeGen/MachinePipeliner.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/ADT/PriorityQueue.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/ADT/PriorityQueue.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/ADT/SetOperations.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/ADT/SetOperations.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/Analysis/CycleAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/Analysis/CycleAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Analysis/MemoryLocation.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/CodeGen/DFAPacketizer.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/CodeGen/DFAPacketizer.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveIntervals.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveIntervals.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineDominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineDominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineMemOperand.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineMemOperand.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/CodeGen/ModuloSchedule.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/CodeGen/ModuloSchedule.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">#include "llvm/CodeGen/RegisterPressure.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">#include "llvm/CodeGen/RegisterPressure.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">#include "llvm/CodeGen/ScheduleDAG.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">#include "llvm/CodeGen/ScheduleDAG.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">#include "llvm/CodeGen/ScheduleDAGMutation.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">#include "llvm/CodeGen/ScheduleDAGMutation.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetOpcodes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetOpcodes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">#include "llvm/IR/Attributes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">#include "llvm/MC/LaneBitmask.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">#include "llvm/MC/LaneBitmask.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">#include "llvm/MC/MCInstrDesc.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">#include "llvm/MC/MCInstrDesc.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">#include "llvm/MC/MCInstrItineraries.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">#include "llvm/MC/MCInstrItineraries.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">#include "llvm/MC/MCRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">#include "llvm/MC/MCRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">#include <climits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">#include <climits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">#include <deque></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">#include <deque></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">#include <functional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">#include <functional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">#include <iomanip></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">#include <iomanip></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">#include <map></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">#include <map></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">#include <sstream></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">#include <sstream></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">#define DEBUG_TYPE "pipeliner"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">#define DEBUG_TYPE "pipeliner"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">STATISTIC(NumTrytoPipeline, "Number of loops that we attempt to pipeline");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">STATISTIC(NumTrytoPipeline, "Number of loops that we attempt to pipeline");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">STATISTIC(NumPipelined, "Number of loops software pipelined");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">STATISTIC(NumPipelined, "Number of loops software pipelined");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">STATISTIC(NumNodeOrderIssues, "Number of node order issues found");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">STATISTIC(NumNodeOrderIssues, "Number of node order issues found");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">STATISTIC(NumFailBranch, "Pipeliner abort due to unknown branch");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">STATISTIC(NumFailBranch, "Pipeliner abort due to unknown branch");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">STATISTIC(NumFailLoop, "Pipeliner abort due to unsupported loop");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">STATISTIC(NumFailLoop, "Pipeliner abort due to unsupported loop");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">STATISTIC(NumFailPreheader, "Pipeliner abort due to missing preheader");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">STATISTIC(NumFailPreheader, "Pipeliner abort due to missing preheader");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">STATISTIC(NumFailLargeMaxMII, "Pipeliner abort due to MaxMII too large");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">STATISTIC(NumFailLargeMaxMII, "Pipeliner abort due to MaxMII too large");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">STATISTIC(NumFailZeroMII, "Pipeliner abort due to zero MII");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">STATISTIC(NumFailZeroMII, "Pipeliner abort due to zero MII");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">STATISTIC(NumFailNoSchedule, "Pipeliner abort due to no schedule found");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">STATISTIC(NumFailNoSchedule, "Pipeliner abort due to no schedule found");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">STATISTIC(NumFailZeroStage, "Pipeliner abort due to zero stage");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">STATISTIC(NumFailZeroStage, "Pipeliner abort due to zero stage");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">STATISTIC(NumFailLargeMaxStage, "Pipeliner abort due to too many stages");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">STATISTIC(NumFailLargeMaxStage, "Pipeliner abort due to too many stages");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">/// A command line option to turn software pipelining on or off.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">/// A command line option to turn software pipelining on or off.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">static cl::opt<bool> EnableSWP("enable-pipeliner", cl::Hidden, cl::init(true),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">static cl::opt<bool> EnableSWP("enable-pipeliner", cl::Hidden, cl::init(true),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">                               cl::desc("Enable Software Pipelining"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">                               cl::desc("Enable Software Pipelining"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">/// A command line option to enable SWP at -Os.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">/// A command line option to enable SWP at -Os.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">static cl::opt<bool> EnableSWPOptSize("enable-pipeliner-opt-size",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">static cl::opt<bool> EnableSWPOptSize("enable-pipeliner-opt-size",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">                                      cl::desc("Enable SWP at Os."), cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">                                      cl::desc("Enable SWP at Os."), cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">                                      cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">                                      cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">/// A command line argument to limit minimum initial interval for pipelining.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">/// A command line argument to limit minimum initial interval for pipelining.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">static cl::opt<int> SwpMaxMii("pipeliner-max-mii",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">static cl::opt<int> SwpMaxMii("pipeliner-max-mii",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">                              cl::desc("Size limit for the MII."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">                              cl::desc("Size limit for the MII."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">                              cl::Hidden, cl::init(27));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">                              cl::Hidden, cl::init(27));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">/// A command line argument to force pipeliner to use specified initial</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">/// A command line argument to force pipeliner to use specified initial</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">/// interval.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">/// interval.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">static cl::opt<int> SwpForceII("pipeliner-force-ii",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">static cl::opt<int> SwpForceII("pipeliner-force-ii",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">                               cl::desc("Force pipeliner to use specified II."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">                               cl::desc("Force pipeliner to use specified II."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">                               cl::Hidden, cl::init(-1));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">                               cl::Hidden, cl::init(-1));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">/// A command line argument to limit the number of stages in the pipeline.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">/// A command line argument to limit the number of stages in the pipeline.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">static cl::opt<int></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">static cl::opt<int></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">    SwpMaxStages("pipeliner-max-stages",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">    SwpMaxStages("pipeliner-max-stages",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">                 cl::desc("Maximum stages allowed in the generated scheduled."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">                 cl::desc("Maximum stages allowed in the generated scheduled."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">                 cl::Hidden, cl::init(3));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">                 cl::Hidden, cl::init(3));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">/// A command line option to disable the pruning of chain dependences due to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">/// A command line option to disable the pruning of chain dependences due to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">/// an unrelated Phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">/// an unrelated Phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    SwpPruneDeps("pipeliner-prune-deps",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    SwpPruneDeps("pipeliner-prune-deps",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">                 cl::desc("Prune dependences between unrelated Phi nodes."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">                 cl::desc("Prune dependences between unrelated Phi nodes."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">                 cl::Hidden, cl::init(true));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">                 cl::Hidden, cl::init(true));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">/// A command line option to disable the pruning of loop carried order</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">/// A command line option to disable the pruning of loop carried order</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">/// dependences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">/// dependences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">    SwpPruneLoopCarried("pipeliner-prune-loop-carried",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">    SwpPruneLoopCarried("pipeliner-prune-loop-carried",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">                        cl::desc("Prune loop carried order dependences."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">                        cl::desc("Prune loop carried order dependences."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">                        cl::Hidden, cl::init(true));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">                        cl::Hidden, cl::init(true));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">static cl::opt<int> SwpLoopLimit("pipeliner-max", cl::Hidden, cl::init(-1));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">static cl::opt<int> SwpLoopLimit("pipeliner-max", cl::Hidden, cl::init(-1));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">static cl::opt<bool> SwpIgnoreRecMII("pipeliner-ignore-recmii",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">static cl::opt<bool> SwpIgnoreRecMII("pipeliner-ignore-recmii",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">                                     cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">                                     cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">                                     cl::desc("Ignore RecMII"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">                                     cl::desc("Ignore RecMII"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">static cl::opt<bool> SwpShowResMask("pipeliner-show-mask", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">static cl::opt<bool> SwpShowResMask("pipeliner-show-mask", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">                                    cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">                                    cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">static cl::opt<bool> SwpDebugResource("pipeliner-dbg-res", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">static cl::opt<bool> SwpDebugResource("pipeliner-dbg-res", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">                                      cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">                                      cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">static cl::opt<bool> EmitTestAnnotations(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">static cl::opt<bool> EmitTestAnnotations(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">    "pipeliner-annotate-for-testing", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">    "pipeliner-annotate-for-testing", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">    cl::desc("Instead of emitting the pipelined code, annotate instructions "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">    cl::desc("Instead of emitting the pipelined code, annotate instructions "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">             "with the generated schedule for feeding into the "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">             "with the generated schedule for feeding into the "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">             "-modulo-schedule-test pass"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">             "-modulo-schedule-test pass"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">static cl::opt<bool> ExperimentalCodeGen(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">static cl::opt<bool> ExperimentalCodeGen(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    "pipeliner-experimental-cg", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    "pipeliner-experimental-cg", cl::Hidden, cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">    cl::desc(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">    cl::desc(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">        "Use the experimental peeling code generator for software pipelining"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">        "Use the experimental peeling code generator for software pipelining"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">// A command line option to enable the CopyToPhi DAG mutation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">// A command line option to enable the CopyToPhi DAG mutation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">cl::opt<bool> SwpEnableCopyToPhi("pipeliner-enable-copytophi", cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">cl::opt<bool> SwpEnableCopyToPhi("pipeliner-enable-copytophi", cl::ReallyHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">                                 cl::init(true),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">                                 cl::init(true),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">                                 cl::desc("Enable CopyToPhi DAG Mutation"));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">                                 cl::desc("Enable CopyToPhi DAG Mutation"));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">/// A command line argument to force pipeliner to use specified issue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">/// A command line argument to force pipeliner to use specified issue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">/// width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">/// width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">cl::opt<int> SwpForceIssueWidth(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">cl::opt<int> SwpForceIssueWidth(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">    "pipeliner-force-issue-width",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">    "pipeliner-force-issue-width",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    cl::desc("Force pipeliner to use specified issue width."), cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    cl::desc("Force pipeliner to use specified issue width."), cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">    cl::init(-1));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">    cl::init(-1));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">unsigned SwingSchedulerDAG::Circuits::MaxPaths = 5;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">unsigned SwingSchedulerDAG::Circuits::MaxPaths = 5;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">char MachinePipeliner::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">char MachinePipeliner::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">int MachinePipeliner::NumTries = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">int MachinePipeliner::NumTries = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">char &llvm::MachinePipelinerID = MachinePipeliner::ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">char &llvm::MachinePipelinerID = MachinePipeliner::ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(MachinePipeliner, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">200</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(MachinePipeliner, DEBUG_TYPE,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">                      "Modulo Software Pipelining", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">                      "Modulo Software Pipelining", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">202</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">203</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">204</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">205</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(MachinePipeliner, DEBUG_TYPE,</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(MachinePipeliner, DEBUG_TYPE,</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">                    "Modulo Software Pipelining", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">                    "Modulo Software Pipelining", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">/// The "main" function for implementing Swing Modulo Scheduling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">/// The "main" function for implementing Swing Modulo Scheduling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">bool MachinePipeliner::runOnMachineFunction(MachineFunction &mf) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">bool MachinePipeliner::runOnMachineFunction(MachineFunction &mf) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  if (skipFunction(mf.getFunction()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  if (skipFunction(mf.getFunction()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  if (!EnableSWP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  if (!EnableSWP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  if (mf.getFunction().getAttributes().hasFnAttr(Attribute::OptimizeForSize) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  if (mf.getFunction().getAttributes().hasFnAttr(Attribute::OptimizeForSize) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">      !EnableSWPOptSize.getPosition())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">      !EnableSWPOptSize.getPosition())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  if (!mf.getSubtarget().enableMachinePipeliner())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  if (!mf.getSubtarget().enableMachinePipeliner())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  // Cannot pipeline loops without instruction itineraries if we are using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  // Cannot pipeline loops without instruction itineraries if we are using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  // DFA for the pipeliner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  // DFA for the pipeliner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  if (mf.getSubtarget().useDFAforSMS() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  if (mf.getSubtarget().useDFAforSMS() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">      (!mf.getSubtarget().getInstrItineraryData() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">      (!mf.getSubtarget().getInstrItineraryData() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">       mf.getSubtarget().getInstrItineraryData()->isEmpty()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">       mf.getSubtarget().getInstrItineraryData()->isEmpty()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  MF = &mf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  MF = &mf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  MLI = &getAnalysis<MachineLoopInfo>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  MLI = &getAnalysis<MachineLoopInfo>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  MDT = &getAnalysis<MachineDominatorTree>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  MDT = &getAnalysis<MachineDominatorTree>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  TII = MF->getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  TII = MF->getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  RegClassInfo.runOnMachineFunction(*MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  RegClassInfo.runOnMachineFunction(*MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  for (const auto &L : *MLI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  for (const auto &L : *MLI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    scheduleLoop(*L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    scheduleLoop(*L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">/// Attempt to perform the SMS algorithm on the specified loop. This function is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">/// Attempt to perform the SMS algorithm on the specified loop. This function is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">/// the main entry point for the algorithm.  The function identifies candidate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">/// the main entry point for the algorithm.  The function identifies candidate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">/// loops, calculates the minimum initiation interval, and attempts to schedule</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">/// loops, calculates the minimum initiation interval, and attempts to schedule</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">/// the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">/// the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">bool MachinePipeliner::scheduleLoop(MachineLoop &L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">bool MachinePipeliner::scheduleLoop(MachineLoop &L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  for (const auto &InnerLoop : L)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  for (const auto &InnerLoop : L)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">    Changed |= scheduleLoop(*InnerLoop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">    Changed |= scheduleLoop(*InnerLoop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  // Stop trying after reaching the limit (if any).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  // Stop trying after reaching the limit (if any).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  int Limit = SwpLoopLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  int Limit = SwpLoopLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  if (Limit >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  if (Limit >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">    if (NumTries >= SwpLoopLimit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">    if (NumTries >= SwpLoopLimit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">      return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">      return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">    NumTries++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">    NumTries++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  setPragmaPipelineOptions(L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  setPragmaPipelineOptions(L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  if (!canPipelineLoop(L)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  if (!canPipelineLoop(L)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\n!!! Can not pipeline loop.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\n!!! Can not pipeline loop.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">      return MachineOptimizationRemarkMissed(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">      return MachineOptimizationRemarkMissed(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">                                             L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">                                             L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">             << "Failed to pipeline loop";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">             << "Failed to pipeline loop";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">    LI.LoopPipelinerInfo.reset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">    LI.LoopPipelinerInfo.reset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  ++NumTrytoPipeline;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  ++NumTrytoPipeline;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  Changed = swingModuloScheduler(L);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  Changed = swingModuloScheduler(L);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  LI.LoopPipelinerInfo.reset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  LI.LoopPipelinerInfo.reset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">void MachinePipeliner::setPragmaPipelineOptions(MachineLoop &L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">void MachinePipeliner::setPragmaPipelineOptions(MachineLoop &L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  // Reset the pragma for the next loop in iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  // Reset the pragma for the next loop in iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  disabledByPragma = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  disabledByPragma = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  II_setByPragma = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  II_setByPragma = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  MachineBasicBlock *LBLK = L.getTopBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  MachineBasicBlock *LBLK = L.getTopBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  if (LBLK == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  if (LBLK == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  const BasicBlock *BBLK = LBLK->getBasicBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  const BasicBlock *BBLK = LBLK->getBasicBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  if (BBLK == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  if (BBLK == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  const Instruction *TI = BBLK->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  const Instruction *TI = BBLK->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  if (TI == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  if (TI == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  MDNode *LoopID = TI->getMetadata(LLVMContext::MD_loop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  MDNode *LoopID = TI->getMetadata(LLVMContext::MD_loop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  if (LoopID == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  if (LoopID == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  assert(LoopID->getNumOperands() > 0 && "requires atleast one operand");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  assert(LoopID->getNumOperands() > 0 && "requires atleast one operand");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  assert(LoopID->getOperand(0) == LoopID && "invalid loop");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  assert(LoopID->getOperand(0) == LoopID && "invalid loop");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  for (unsigned i = 1, e = LoopID->getNumOperands(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  for (unsigned i = 1, e = LoopID->getNumOperands(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    MDNode *MD = dyn_cast<MDNode>(LoopID->getOperand(i));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    MDNode *MD = dyn_cast<MDNode>(LoopID->getOperand(i));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    if (MD == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    if (MD == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">    MDString *S = dyn_cast<MDString>(MD->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">    MDString *S = dyn_cast<MDString>(MD->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">    if (S == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">    if (S == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">    if (S->getString() == "llvm.loop.pipeline.initiationinterval") {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">    if (S->getString() == "llvm.loop.pipeline.initiationinterval") {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">      assert(MD->getNumOperands() == 2 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">      assert(MD->getNumOperands() == 2 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">             "Pipeline initiation interval hint metadata should have two operands.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">             "Pipeline initiation interval hint metadata should have two operands.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">      II_setByPragma =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">      II_setByPragma =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">          mdconst::extract<ConstantInt>(MD->getOperand(1))->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">          mdconst::extract<ConstantInt>(MD->getOperand(1))->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">      assert(II_setByPragma >= 1 && "Pipeline initiation interval must be positive.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">      assert(II_setByPragma >= 1 && "Pipeline initiation interval must be positive.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">    } else if (S->getString() == "llvm.loop.pipeline.disable") {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">    } else if (S->getString() == "llvm.loop.pipeline.disable") {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">      disabledByPragma = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">      disabledByPragma = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">/// Return true if the loop can be software pipelined.  The algorithm is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">/// Return true if the loop can be software pipelined.  The algorithm is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">/// restricted to loops with a single basic block.  Make sure that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">/// restricted to loops with a single basic block.  Make sure that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">/// branch in the loop can be analyzed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">/// branch in the loop can be analyzed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  if (L.getNumBlocks() != 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  if (L.getNumBlocks() != 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">             << "Not a single basic block: "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">             << "Not a single basic block: "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">             << ore::NV("NumBlocks", L.getNumBlocks());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">             << ore::NV("NumBlocks", L.getNumBlocks());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  if (disabledByPragma) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  if (disabledByPragma) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">             << "Disabled by Pragma.";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">             << "Disabled by Pragma.";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  // Check if the branch can't be understood because we can't do pipelining</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  // Check if the branch can't be understood because we can't do pipelining</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  // if that's the case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  // if that's the case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">  LI.TBB = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">  LI.TBB = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  LI.FBB = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  LI.FBB = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  LI.BrCond.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  LI.BrCond.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  if (TII->analyzeBranch(*L.getHeader(), LI.TBB, LI.FBB, LI.BrCond)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  if (TII->analyzeBranch(*L.getHeader(), LI.TBB, LI.FBB, LI.BrCond)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Unable to analyzeBranch, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Unable to analyzeBranch, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">    NumFailBranch++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">    NumFailBranch++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">             << "The branch can't be understood";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">             << "The branch can't be understood";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  LI.LoopInductionVar = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  LI.LoopInductionVar = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  LI.LoopCompare = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  LI.LoopCompare = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  LI.LoopPipelinerInfo = TII->analyzeLoopForPipelining(L.getTopBlock());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  LI.LoopPipelinerInfo = TII->analyzeLoopForPipelining(L.getTopBlock());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  if (!LI.LoopPipelinerInfo) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  if (!LI.LoopPipelinerInfo) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Unable to analyzeLoop, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Unable to analyzeLoop, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">    NumFailLoop++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">    NumFailLoop++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">             << "The loop structure is not supported";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">             << "The loop structure is not supported";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  if (!L.getLoopPreheader()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  if (!L.getLoopPreheader()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Preheader not found, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Preheader not found, can NOT pipeline Loop\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">    NumFailPreheader++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">    NumFailPreheader++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">                                               L.getStartLoc(), L.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">             << "No loop preheader found";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">             << "No loop preheader found";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  // Remove any subregisters from inputs to phi nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  // Remove any subregisters from inputs to phi nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  preprocessPhiNodes(*L.getHeader());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  preprocessPhiNodes(*L.getHeader());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">void MachinePipeliner::preprocessPhiNodes(MachineBasicBlock &B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">void MachinePipeliner::preprocessPhiNodes(MachineBasicBlock &B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  MachineRegisterInfo &MRI = MF->getRegInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  MachineRegisterInfo &MRI = MF->getRegInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  SlotIndexes &Slots = *getAnalysis<LiveIntervals>().getSlotIndexes();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  SlotIndexes &Slots = *getAnalysis<LiveIntervals>().getSlotIndexes();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  for (MachineInstr &PI : B.phis()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  for (MachineInstr &PI : B.phis()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    MachineOperand &DefOp = PI.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    MachineOperand &DefOp = PI.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">    assert(DefOp.getSubReg() == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">    assert(DefOp.getSubReg() == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">    auto *RC = MRI.getRegClass(DefOp.getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">    auto *RC = MRI.getRegClass(DefOp.getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">    for (unsigned i = 1, n = PI.getNumOperands(); i != n; i += 2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">    for (unsigned i = 1, n = PI.getNumOperands(); i != n; i += 2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">      MachineOperand &RegOp = PI.getOperand(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">      MachineOperand &RegOp = PI.getOperand(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">      if (RegOp.getSubReg() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">      if (RegOp.getSubReg() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">      // If the operand uses a subregister, replace it with a new register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">      // If the operand uses a subregister, replace it with a new register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">      // without subregisters, and generate a copy to the new register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">      // without subregisters, and generate a copy to the new register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">      Register NewReg = MRI.createVirtualRegister(RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">      Register NewReg = MRI.createVirtualRegister(RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">      MachineBasicBlock &PredB = *PI.getOperand(i+1).getMBB();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">      MachineBasicBlock &PredB = *PI.getOperand(i+1).getMBB();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">      MachineBasicBlock::iterator At = PredB.getFirstTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">      MachineBasicBlock::iterator At = PredB.getFirstTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">      const DebugLoc &DL = PredB.findDebugLoc(At);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">      const DebugLoc &DL = PredB.findDebugLoc(At);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">      auto Copy = BuildMI(PredB, At, DL, TII->get(TargetOpcode::COPY), NewReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">      auto Copy = BuildMI(PredB, At, DL, TII->get(TargetOpcode::COPY), NewReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">                    .addReg(RegOp.getReg(), getRegState(RegOp),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">                    .addReg(RegOp.getReg(), getRegState(RegOp),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">                            RegOp.getSubReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">                            RegOp.getSubReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">      Slots.insertMachineInstrInMaps(*Copy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">      Slots.insertMachineInstrInMaps(*Copy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">      RegOp.setReg(NewReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">      RegOp.setReg(NewReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">      RegOp.setSubReg(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">      RegOp.setSubReg(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">/// The SMS algorithm consists of the following main steps:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">/// The SMS algorithm consists of the following main steps:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">/// 1. Computation and analysis of the dependence graph.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">/// 1. Computation and analysis of the dependence graph.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">/// 2. Ordering of the nodes (instructions).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">/// 2. Ordering of the nodes (instructions).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">/// 3. Attempt to Schedule the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">/// 3. Attempt to Schedule the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">bool MachinePipeliner::swingModuloScheduler(MachineLoop &L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">bool MachinePipeliner::swingModuloScheduler(MachineLoop &L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  assert(L.getBlocks().size() == 1 && "SMS works on single blocks only.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  assert(L.getBlocks().size() == 1 && "SMS works on single blocks only.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  SwingSchedulerDAG SMS(*this, L, getAnalysis<LiveIntervals>(), RegClassInfo,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  SwingSchedulerDAG SMS(*this, L, getAnalysis<LiveIntervals>(), RegClassInfo,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">                        II_setByPragma, LI.LoopPipelinerInfo.get());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">                        II_setByPragma, LI.LoopPipelinerInfo.get());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  MachineBasicBlock *MBB = L.getHeader();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  MachineBasicBlock *MBB = L.getHeader();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  // The kernel should not include any terminator instructions.  These</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  // The kernel should not include any terminator instructions.  These</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">  // will be added back later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">  // will be added back later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  SMS.startBlock(MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  SMS.startBlock(MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  // Compute the number of 'real' instructions in the basic block by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  // Compute the number of 'real' instructions in the basic block by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  // ignoring terminators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  // ignoring terminators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  unsigned size = MBB->size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  unsigned size = MBB->size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  for (MachineBasicBlock::iterator I = MBB->getFirstTerminator(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  for (MachineBasicBlock::iterator I = MBB->getFirstTerminator(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">                                   E = MBB->instr_end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">                                   E = MBB->instr_end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">       I != E; ++I, --size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">       I != E; ++I, --size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">    ;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">    ;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  SMS.enterRegion(MBB, MBB->begin(), MBB->getFirstTerminator(), size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  SMS.enterRegion(MBB, MBB->begin(), MBB->getFirstTerminator(), size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  SMS.schedule();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  SMS.schedule();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">  SMS.exitRegion();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">  SMS.exitRegion();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">  SMS.finishBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">  SMS.finishBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  return SMS.hasNewSchedule();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  return SMS.hasNewSchedule();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">void MachinePipeliner::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">void MachinePipeliner::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  AU.addRequired<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  AU.addPreserved<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  AU.addPreserved<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  AU.addRequired<MachineLoopInfo>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  AU.addRequired<MachineLoopInfo>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  AU.addRequired<MachineDominatorTree>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  AU.addRequired<MachineDominatorTree>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  AU.addRequired<LiveIntervals>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  AU.addRequired<LiveIntervals>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">void SwingSchedulerDAG::setMII(unsigned ResMII, unsigned RecMII) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">void SwingSchedulerDAG::setMII(unsigned ResMII, unsigned RecMII) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  if (SwpForceII > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  if (SwpForceII > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">    MII = SwpForceII;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">    MII = SwpForceII;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  else if (II_setByPragma > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  else if (II_setByPragma > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">    MII = II_setByPragma;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">    MII = II_setByPragma;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">    MII = std::max(ResMII, RecMII);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">    MII = std::max(ResMII, RecMII);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">void SwingSchedulerDAG::setMAX_II() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">void SwingSchedulerDAG::setMAX_II() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  if (SwpForceII > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  if (SwpForceII > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">    MAX_II = SwpForceII;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">    MAX_II = SwpForceII;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  else if (II_setByPragma > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  else if (II_setByPragma > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">    MAX_II = II_setByPragma;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">    MAX_II = II_setByPragma;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">    MAX_II = MII + 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">    MAX_II = MII + 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">/// We override the schedule function in ScheduleDAGInstrs to implement the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">/// We override the schedule function in ScheduleDAGInstrs to implement the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">/// scheduling part of the Swing Modulo Scheduling algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">/// scheduling part of the Swing Modulo Scheduling algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">void SwingSchedulerDAG::schedule() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">void SwingSchedulerDAG::schedule() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  AliasAnalysis *AA = &Pass.getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  AliasAnalysis *AA = &Pass.getAnalysis<AAResultsWrapperPass>().getAAResults();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  buildSchedGraph(AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  buildSchedGraph(AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  addLoopCarriedDependences(AA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  addLoopCarriedDependences(AA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  updatePhiDependences();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  updatePhiDependences();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  Topo.InitDAGTopologicalSorting();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  Topo.InitDAGTopologicalSorting();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  changeDependences();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  changeDependences();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  postProcessDAG();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  postProcessDAG();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  LLVM_DEBUG(dump());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  LLVM_DEBUG(dump());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  NodeSetType NodeSets;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  NodeSetType NodeSets;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  findCircuits(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  findCircuits(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  NodeSetType Circuits = NodeSets;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  NodeSetType Circuits = NodeSets;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  // Calculate the MII.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  // Calculate the MII.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">  unsigned ResMII = calculateResMII();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">  unsigned ResMII = calculateResMII();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  unsigned RecMII = calculateRecMII(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  unsigned RecMII = calculateRecMII(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  fuseRecs(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  fuseRecs(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  // This flag is used for testing and can cause correctness problems.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  // This flag is used for testing and can cause correctness problems.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  if (SwpIgnoreRecMII)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  if (SwpIgnoreRecMII)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">    RecMII = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">    RecMII = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  setMII(ResMII, RecMII);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  setMII(ResMII, RecMII);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  setMAX_II();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  setMAX_II();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "MII = " << MII << " MAX_II = " << MAX_II</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "MII = " << MII << " MAX_II = " << MAX_II</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">                    << " (rec=" << RecMII << ", res=" << ResMII << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">                    << " (rec=" << RecMII << ", res=" << ResMII << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  // Can't schedule a loop without a valid MII.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  // Can't schedule a loop without a valid MII.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  if (MII == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  if (MII == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Invalid Minimal Initiation Interval: 0\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Invalid Minimal Initiation Interval: 0\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">    NumFailZeroMII++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">    NumFailZeroMII++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">             << "Invalid Minimal Initiation Interval: 0";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">             << "Invalid Minimal Initiation Interval: 0";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  // Don't pipeline large loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  // Don't pipeline large loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  if (SwpMaxMii != -1 && (int)MII > SwpMaxMii) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  if (SwpMaxMii != -1 && (int)MII > SwpMaxMii) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "MII > " << SwpMaxMii</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "MII > " << SwpMaxMii</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">                      << ", we don't pipeline large loops\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">                      << ", we don't pipeline large loops\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">    NumFailLargeMaxMII++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">    NumFailLargeMaxMII++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">             << "Minimal Initiation Interval too large: "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">             << "Minimal Initiation Interval too large: "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">             << ore::NV("MII", (int)MII) << " > "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">             << ore::NV("MII", (int)MII) << " > "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">             << ore::NV("SwpMaxMii", SwpMaxMii) << "."</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">             << ore::NV("SwpMaxMii", SwpMaxMii) << "."</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">             << "Refer to -pipeliner-max-mii.";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">             << "Refer to -pipeliner-max-mii.";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  computeNodeFunctions(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  computeNodeFunctions(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  registerPressureFilter(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  registerPressureFilter(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  colocateNodeSets(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  colocateNodeSets(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  checkNodeSets(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  checkNodeSets(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">    for (auto &I : NodeSets) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">    for (auto &I : NodeSets) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">      dbgs() << "  Rec NodeSet ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">      dbgs() << "  Rec NodeSet ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">      I.dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">      I.dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">  llvm::stable_sort(NodeSets, std::greater<NodeSet>());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">  llvm::stable_sort(NodeSets, std::greater<NodeSet>());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">  groupRemainingNodes(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">  groupRemainingNodes(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  removeDuplicateNodes(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  removeDuplicateNodes(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">    for (auto &I : NodeSets) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">    for (auto &I : NodeSets) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">      dbgs() << "  NodeSet ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">      dbgs() << "  NodeSet ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">      I.dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">      I.dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">  computeNodeOrder(NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">  computeNodeOrder(NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  // check for node order issues</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  // check for node order issues</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  checkValidNodeOrder(Circuits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  checkValidNodeOrder(Circuits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  SMSchedule Schedule(Pass.MF, this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  SMSchedule Schedule(Pass.MF, this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  Scheduled = schedulePipeline(Schedule);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  Scheduled = schedulePipeline(Schedule);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">  if (!Scheduled){</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">  if (!Scheduled){</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "No schedule found, return\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "No schedule found, return\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    NumFailNoSchedule++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    NumFailNoSchedule++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">             << "Unable to find schedule";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">             << "Unable to find schedule";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">  unsigned numStages = Schedule.getMaxStageCount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">  unsigned numStages = Schedule.getMaxStageCount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  // No need to generate pipeline if there are no overlapped iterations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  // No need to generate pipeline if there are no overlapped iterations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  if (numStages == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  if (numStages == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "No overlapped iterations, skip.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "No overlapped iterations, skip.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">    NumFailZeroStage++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">    NumFailZeroStage++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">             << "No need to pipeline - no overlapped iterations in schedule.";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">             << "No need to pipeline - no overlapped iterations in schedule.";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  // Check that the maximum stage count is less than user-defined limit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  // Check that the maximum stage count is less than user-defined limit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  if (SwpMaxStages > -1 && (int)numStages > SwpMaxStages) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  if (SwpMaxStages > -1 && (int)numStages > SwpMaxStages) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "numStages:" << numStages << ">" << SwpMaxStages</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "numStages:" << numStages << ">" << SwpMaxStages</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">                      << " : too many stages, abort\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">                      << " : too many stages, abort\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">    NumFailLargeMaxStage++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">    NumFailLargeMaxStage++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">             << "Too many stages in schedule: "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">             << "Too many stages in schedule: "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">             << ore::NV("numStages", (int)numStages) << " > "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">             << ore::NV("numStages", (int)numStages) << " > "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">             << ore::NV("SwpMaxStages", SwpMaxStages)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">             << ore::NV("SwpMaxStages", SwpMaxStages)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">             << ". Refer to -pipeliner-max-stages.";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">             << ". Refer to -pipeliner-max-stages.";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">    return MachineOptimizationRemark(DEBUG_TYPE, "schedule", Loop.getStartLoc(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">    return MachineOptimizationRemark(DEBUG_TYPE, "schedule", Loop.getStartLoc(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">                                     Loop.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">                                     Loop.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">           << "Pipelined succesfully!";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">           << "Pipelined succesfully!";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  // Generate the schedule as a ModuloSchedule.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  // Generate the schedule as a ModuloSchedule.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  DenseMap<MachineInstr *, int> Cycles, Stages;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  DenseMap<MachineInstr *, int> Cycles, Stages;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  std::vector<MachineInstr *> OrderedInsts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  std::vector<MachineInstr *> OrderedInsts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  for (int Cycle = Schedule.getFirstCycle(); Cycle <= Schedule.getFinalCycle();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  for (int Cycle = Schedule.getFirstCycle(); Cycle <= Schedule.getFinalCycle();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">       ++Cycle) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">       ++Cycle) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    for (SUnit *SU : Schedule.getInstructions(Cycle)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    for (SUnit *SU : Schedule.getInstructions(Cycle)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">      OrderedInsts.push_back(SU->getInstr());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">      OrderedInsts.push_back(SU->getInstr());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">      Cycles[SU->getInstr()] = Cycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">      Cycles[SU->getInstr()] = Cycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">      Stages[SU->getInstr()] = Schedule.stageScheduled(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">      Stages[SU->getInstr()] = Schedule.stageScheduled(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  DenseMap<MachineInstr *, std::pair<unsigned, int64_t>> NewInstrChanges;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  DenseMap<MachineInstr *, std::pair<unsigned, int64_t>> NewInstrChanges;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  for (auto &KV : NewMIs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  for (auto &KV : NewMIs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">    Cycles[KV.first] = Cycles[KV.second];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">    Cycles[KV.first] = Cycles[KV.second];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">    Stages[KV.first] = Stages[KV.second];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">    Stages[KV.first] = Stages[KV.second];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">    NewInstrChanges[KV.first] = InstrChanges[getSUnit(KV.first)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">    NewInstrChanges[KV.first] = InstrChanges[getSUnit(KV.first)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  ModuloSchedule MS(MF, &Loop, std::move(OrderedInsts), std::move(Cycles),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  ModuloSchedule MS(MF, &Loop, std::move(OrderedInsts), std::move(Cycles),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">                    std::move(Stages));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">                    std::move(Stages));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  if (EmitTestAnnotations) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  if (EmitTestAnnotations) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    assert(NewInstrChanges.empty() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    assert(NewInstrChanges.empty() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">           "Cannot serialize a schedule with InstrChanges!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">           "Cannot serialize a schedule with InstrChanges!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    ModuloScheduleTestAnnotater MSTI(MF, MS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    ModuloScheduleTestAnnotater MSTI(MF, MS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">    MSTI.annotate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">    MSTI.annotate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  // The experimental code generator can't work if there are InstChanges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  // The experimental code generator can't work if there are InstChanges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  if (ExperimentalCodeGen && NewInstrChanges.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  if (ExperimentalCodeGen && NewInstrChanges.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">    PeelingModuloScheduleExpander MSE(MF, MS, &LIS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">    PeelingModuloScheduleExpander MSE(MF, MS, &LIS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">    MSE.expand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">    MSE.expand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">    ModuloScheduleExpander MSE(MF, MS, LIS, std::move(NewInstrChanges));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">    ModuloScheduleExpander MSE(MF, MS, LIS, std::move(NewInstrChanges));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">    MSE.expand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">    MSE.expand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">    MSE.cleanup();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">    MSE.cleanup();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  ++NumPipelined;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  ++NumPipelined;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">/// Clean up after the software pipeliner runs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">/// Clean up after the software pipeliner runs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">void SwingSchedulerDAG::finishBlock() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">void SwingSchedulerDAG::finishBlock() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  for (auto &KV : NewMIs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  for (auto &KV : NewMIs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">    MF.deleteMachineInstr(KV.second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">    MF.deleteMachineInstr(KV.second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  NewMIs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  NewMIs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  // Call the superclass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  // Call the superclass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  ScheduleDAGInstrs::finishBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  ScheduleDAGInstrs::finishBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">/// Return the register values for  the operands of a Phi instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">/// Return the register values for  the operands of a Phi instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">/// This function assume the instruction is a Phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">/// This function assume the instruction is a Phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">static void getPhiRegs(MachineInstr &Phi, MachineBasicBlock *Loop,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">static void getPhiRegs(MachineInstr &Phi, MachineBasicBlock *Loop,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">                       unsigned &InitVal, unsigned &LoopVal) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">                       unsigned &InitVal, unsigned &LoopVal) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  InitVal = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  InitVal = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  LoopVal = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  LoopVal = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">    if (Phi.getOperand(i + 1).getMBB() != Loop)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">    if (Phi.getOperand(i + 1).getMBB() != Loop)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">      InitVal = Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">      InitVal = Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">      LoopVal = Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">      LoopVal = Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  assert(InitVal != 0 && LoopVal != 0 && "Unexpected Phi structure.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  assert(InitVal != 0 && LoopVal != 0 && "Unexpected Phi structure.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">/// Return the Phi register value that comes the loop block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">/// Return the Phi register value that comes the loop block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">static unsigned getLoopPhiReg(MachineInstr &Phi, MachineBasicBlock *LoopBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">static unsigned getLoopPhiReg(MachineInstr &Phi, MachineBasicBlock *LoopBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  for (unsigned i = 1, e = Phi.getNumOperands(); i != e; i += 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">    if (Phi.getOperand(i + 1).getMBB() == LoopBB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">    if (Phi.getOperand(i + 1).getMBB() == LoopBB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">      return Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">      return Phi.getOperand(i).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">/// Return true if SUb can be reached from SUa following the chain edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">/// Return true if SUb can be reached from SUa following the chain edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">static bool isSuccOrder(SUnit *SUa, SUnit *SUb) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">static bool isSuccOrder(SUnit *SUa, SUnit *SUb) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  SmallVector<SUnit *, 8> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  SmallVector<SUnit *, 8> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  Worklist.push_back(SUa);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  Worklist.push_back(SUa);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">    const SUnit *SU = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">    const SUnit *SU = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">    for (const auto &SI : SU->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">    for (const auto &SI : SU->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">      SUnit *SuccSU = SI.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">      SUnit *SuccSU = SI.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">      if (SI.getKind() == SDep::Order) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">      if (SI.getKind() == SDep::Order) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">        if (Visited.count(SuccSU))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">        if (Visited.count(SuccSU))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">        if (SuccSU == SUb)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">        if (SuccSU == SUb)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">        Worklist.push_back(SuccSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">        Worklist.push_back(SuccSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">        Visited.insert(SuccSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">        Visited.insert(SuccSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">/// Return true if the instruction causes a chain between memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">/// Return true if the instruction causes a chain between memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">/// references before and after it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">/// references before and after it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">static bool isDependenceBarrier(MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">static bool isDependenceBarrier(MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  return MI.isCall() || MI.mayRaiseFPException() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  return MI.isCall() || MI.mayRaiseFPException() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">         MI.hasUnmodeledSideEffects() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">         MI.hasUnmodeledSideEffects() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">         (MI.hasOrderedMemoryRef() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">         (MI.hasOrderedMemoryRef() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">          (!MI.mayLoad() || !MI.isDereferenceableInvariantLoad()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">          (!MI.mayLoad() || !MI.isDereferenceableInvariantLoad()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">/// Return the underlying objects for the memory references of an instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">/// Return the underlying objects for the memory references of an instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">/// This function calls the code in ValueTracking, but first checks that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">/// This function calls the code in ValueTracking, but first checks that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">/// instruction has a memory operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">/// instruction has a memory operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">static void getUnderlyingObjects(const MachineInstr *MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">static void getUnderlyingObjects(const MachineInstr *MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">                                 SmallVectorImpl<const Value *> &Objs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">                                 SmallVectorImpl<const Value *> &Objs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  if (!MI->hasOneMemOperand())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  if (!MI->hasOneMemOperand())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">  MachineMemOperand *MM = *MI->memoperands_begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">  MachineMemOperand *MM = *MI->memoperands_begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  if (!MM->getValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  if (!MM->getValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  getUnderlyingObjects(MM->getValue(), Objs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  getUnderlyingObjects(MM->getValue(), Objs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  for (const Value *V : Objs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  for (const Value *V : Objs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">    if (!isIdentifiedObject(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">    if (!isIdentifiedObject(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">      Objs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">      Objs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">    Objs.push_back(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">    Objs.push_back(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">/// Add a chain edge between a load and store if the store can be an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">/// Add a chain edge between a load and store if the store can be an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">/// alias of the load on a subsequent iteration, i.e., a loop carried</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">/// alias of the load on a subsequent iteration, i.e., a loop carried</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">/// dependence. This code is very similar to the code in ScheduleDAGInstrs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">/// dependence. This code is very similar to the code in ScheduleDAGInstrs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">/// but that code doesn't create loop carried dependences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">/// but that code doesn't create loop carried dependences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">void SwingSchedulerDAG::addLoopCarriedDependences(AliasAnalysis *AA) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">void SwingSchedulerDAG::addLoopCarriedDependences(AliasAnalysis *AA) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">  MapVector<const Value *, SmallVector<SUnit *, 4>> PendingLoads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">  MapVector<const Value *, SmallVector<SUnit *, 4>> PendingLoads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">  Value *UnknownValue =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">  Value *UnknownValue =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    UndefValue::get(Type::getVoidTy(MF.getFunction().getContext()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    UndefValue::get(Type::getVoidTy(MF.getFunction().getContext()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">  for (auto &SU : SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">  for (auto &SU : SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    MachineInstr &MI = *SU.getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    MachineInstr &MI = *SU.getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    if (isDependenceBarrier(MI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    if (isDependenceBarrier(MI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">      PendingLoads.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">      PendingLoads.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    else if (MI.mayLoad()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    else if (MI.mayLoad()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">      SmallVector<const Value *, 4> Objs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">      SmallVector<const Value *, 4> Objs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">      ::getUnderlyingObjects(&MI, Objs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">      ::getUnderlyingObjects(&MI, Objs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">      if (Objs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">      if (Objs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">        Objs.push_back(UnknownValue);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">        Objs.push_back(UnknownValue);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">      for (const auto *V : Objs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">      for (const auto *V : Objs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">        SmallVector<SUnit *, 4> &SUs = PendingLoads[V];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">        SmallVector<SUnit *, 4> &SUs = PendingLoads[V];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">        SUs.push_back(&SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">        SUs.push_back(&SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">    } else if (MI.mayStore()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">    } else if (MI.mayStore()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">      SmallVector<const Value *, 4> Objs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">      SmallVector<const Value *, 4> Objs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">      ::getUnderlyingObjects(&MI, Objs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">      ::getUnderlyingObjects(&MI, Objs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">      if (Objs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">      if (Objs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">        Objs.push_back(UnknownValue);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">        Objs.push_back(UnknownValue);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">      for (const auto *V : Objs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">      for (const auto *V : Objs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">        MapVector<const Value *, SmallVector<SUnit *, 4>>::iterator I =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">        MapVector<const Value *, SmallVector<SUnit *, 4>>::iterator I =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">            PendingLoads.find(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">            PendingLoads.find(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">        if (I == PendingLoads.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">        if (I == PendingLoads.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">        for (auto *Load : I->second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">        for (auto *Load : I->second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">          if (isSuccOrder(Load, &SU))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">          if (isSuccOrder(Load, &SU))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">          MachineInstr &LdMI = *Load->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">          MachineInstr &LdMI = *Load->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">          // First, perform the cheaper check that compares the base register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">          // First, perform the cheaper check that compares the base register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">          // If they are the same and the load offset is less than the store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">          // If they are the same and the load offset is less than the store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">          // offset, then mark the dependence as loop carried potentially.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">          // offset, then mark the dependence as loop carried potentially.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">          const MachineOperand *BaseOp1, *BaseOp2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">          const MachineOperand *BaseOp1, *BaseOp2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">          int64_t Offset1, Offset2;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">          int64_t Offset1, Offset2;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">          bool Offset1IsScalable, Offset2IsScalable;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">          bool Offset1IsScalable, Offset2IsScalable;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">          if (TII->getMemOperandWithOffset(LdMI, BaseOp1, Offset1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">          if (TII->getMemOperandWithOffset(LdMI, BaseOp1, Offset1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">                                           Offset1IsScalable, TRI) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">                                           Offset1IsScalable, TRI) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">              TII->getMemOperandWithOffset(MI, BaseOp2, Offset2,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">              TII->getMemOperandWithOffset(MI, BaseOp2, Offset2,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">                                           Offset2IsScalable, TRI)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">                                           Offset2IsScalable, TRI)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">            if (BaseOp1->isIdenticalTo(*BaseOp2) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">            if (BaseOp1->isIdenticalTo(*BaseOp2) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">                Offset1IsScalable == Offset2IsScalable &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">                Offset1IsScalable == Offset2IsScalable &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">                (int)Offset1 < (int)Offset2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">                (int)Offset1 < (int)Offset2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">              assert(TII->areMemAccessesTriviallyDisjoint(LdMI, MI) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">              assert(TII->areMemAccessesTriviallyDisjoint(LdMI, MI) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">                     "What happened to the chain edge?");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">                     "What happened to the chain edge?");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">              SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">              SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">              Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">              Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">              SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">              SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">          // Second, the more expensive check that uses alias analysis on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">          // Second, the more expensive check that uses alias analysis on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">          // base registers. If they alias, and the load offset is less than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">          // base registers. If they alias, and the load offset is less than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">          // the store offset, the mark the dependence as loop carried.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">          // the store offset, the mark the dependence as loop carried.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">          if (!AA) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">          if (!AA) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">            Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">            Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">            SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">            SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">          MachineMemOperand *MMO1 = *LdMI.memoperands_begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">          MachineMemOperand *MMO1 = *LdMI.memoperands_begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">          MachineMemOperand *MMO2 = *MI.memoperands_begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">          MachineMemOperand *MMO2 = *MI.memoperands_begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">          if (!MMO1->getValue() || !MMO2->getValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">          if (!MMO1->getValue() || !MMO2->getValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">            Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">            Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">            SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">            SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">          if (MMO1->getValue() == MMO2->getValue() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">          if (MMO1->getValue() == MMO2->getValue() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">              MMO1->getOffset() <= MMO2->getOffset()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">              MMO1->getOffset() <= MMO2->getOffset()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">            Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">            Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">            SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">            SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">          if (!AA->isNoAlias(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">          if (!AA->isNoAlias(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">                  MemoryLocation::getAfter(MMO1->getValue(), MMO1->getAAInfo()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">                  MemoryLocation::getAfter(MMO1->getValue(), MMO1->getAAInfo()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">                  MemoryLocation::getAfter(MMO2->getValue(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">                  MemoryLocation::getAfter(MMO2->getValue(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">                                           MMO2->getAAInfo()))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">                                           MMO2->getAAInfo()))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">            SDep Dep(Load, SDep::Barrier);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">            Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">            Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">            SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">            SU.addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">/// processes dependences for PHIs. This function adds true dependences</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">/// processes dependences for PHIs. This function adds true dependences</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">/// from a PHI to a use, and a loop carried dependence from the use to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">/// from a PHI to a use, and a loop carried dependence from the use to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">/// PHI. The loop carried dependence is represented as an anti dependence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">/// PHI. The loop carried dependence is represented as an anti dependence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">/// edge. This function also removes chain dependences between unrelated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">/// edge. This function also removes chain dependences between unrelated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">/// PHIs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">/// PHIs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">void SwingSchedulerDAG::updatePhiDependences() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">void SwingSchedulerDAG::updatePhiDependences() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  SmallVector<SDep, 4> RemoveDeps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  SmallVector<SDep, 4> RemoveDeps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">  const TargetSubtargetInfo &ST = MF.getSubtarget<TargetSubtargetInfo>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">  const TargetSubtargetInfo &ST = MF.getSubtarget<TargetSubtargetInfo>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  // Iterate over each DAG node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  // Iterate over each DAG node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  for (SUnit &I : SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  for (SUnit &I : SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">    RemoveDeps.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">    RemoveDeps.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">    // Set to true if the instruction has an operand defined by a Phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">    // Set to true if the instruction has an operand defined by a Phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">    unsigned HasPhiUse = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">    unsigned HasPhiUse = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    unsigned HasPhiDef = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    unsigned HasPhiDef = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    MachineInstr *MI = I.getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    MachineInstr *MI = I.getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    // Iterate over each operand, and we process the definitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    // Iterate over each operand, and we process the definitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">    for (const MachineOperand &MO : MI->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">    for (const MachineOperand &MO : MI->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">      if (!MO.isReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">      if (!MO.isReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">      if (MO.isDef()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">      if (MO.isDef()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">        // If the register is used by a Phi, then create an anti dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">        // If the register is used by a Phi, then create an anti dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">        for (MachineRegisterInfo::use_instr_iterator</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">        for (MachineRegisterInfo::use_instr_iterator</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">                 UI = MRI.use_instr_begin(Reg),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">                 UI = MRI.use_instr_begin(Reg),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">                 UE = MRI.use_instr_end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">                 UE = MRI.use_instr_end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">             UI != UE; ++UI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">             UI != UE; ++UI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">          MachineInstr *UseMI = &*UI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">          MachineInstr *UseMI = &*UI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">          SUnit *SU = getSUnit(UseMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">          SUnit *SU = getSUnit(UseMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">          if (SU != nullptr && UseMI->isPHI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">          if (SU != nullptr && UseMI->isPHI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">            if (!MI->isPHI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">            if (!MI->isPHI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">              SDep Dep(SU, SDep::Anti, Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">              SDep Dep(SU, SDep::Anti, Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">              Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">              Dep.setLatency(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">              I.addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">              I.addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">            } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">            } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">              HasPhiDef = Reg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">              HasPhiDef = Reg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">              // Add a chain edge to a dependent Phi that isn't an existing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">              // Add a chain edge to a dependent Phi that isn't an existing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">              // predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">              // predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">              if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">              if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">                I.addPred(SDep(SU, SDep::Barrier));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">                I.addPred(SDep(SU, SDep::Barrier));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">      } else if (MO.isUse()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">      } else if (MO.isUse()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">        // If the register is defined by a Phi, then create a true dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">        // If the register is defined by a Phi, then create a true dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">        MachineInstr *DefMI = MRI.getUniqueVRegDef(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">        MachineInstr *DefMI = MRI.getUniqueVRegDef(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">        if (DefMI == nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">        if (DefMI == nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">        SUnit *SU = getSUnit(DefMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">        SUnit *SU = getSUnit(DefMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">        if (SU != nullptr && DefMI->isPHI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">        if (SU != nullptr && DefMI->isPHI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">          if (!MI->isPHI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">          if (!MI->isPHI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">            SDep Dep(SU, SDep::Data, Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">            SDep Dep(SU, SDep::Data, Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">            Dep.setLatency(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">            Dep.setLatency(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">            ST.adjustSchedDependency(SU, 0, &I, MO.getOperandNo(), Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">            ST.adjustSchedDependency(SU, 0, &I, MO.getOperandNo(), Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">            I.addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">            I.addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">          } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">          } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">            HasPhiUse = Reg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">            HasPhiUse = Reg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">            // Add a chain edge to a dependent Phi that isn't an existing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">            // Add a chain edge to a dependent Phi that isn't an existing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">            // predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">            // predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">            if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">            if (SU->NodeNum < I.NodeNum && !I.isPred(SU))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">              I.addPred(SDep(SU, SDep::Barrier));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">              I.addPred(SDep(SU, SDep::Barrier));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">    // Remove order dependences from an unrelated Phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">    // Remove order dependences from an unrelated Phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">    if (!SwpPruneDeps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">    if (!SwpPruneDeps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">    for (auto &PI : I.Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">    for (auto &PI : I.Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">      MachineInstr *PMI = PI.getSUnit()->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">      MachineInstr *PMI = PI.getSUnit()->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">      if (PMI->isPHI() && PI.getKind() == SDep::Order) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">      if (PMI->isPHI() && PI.getKind() == SDep::Order) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">        if (I.getInstr()->isPHI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">        if (I.getInstr()->isPHI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">          if (PMI->getOperand(0).getReg() == HasPhiUse)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">          if (PMI->getOperand(0).getReg() == HasPhiUse)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">          if (getLoopPhiReg(*PMI, PMI->getParent()) == HasPhiDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">          if (getLoopPhiReg(*PMI, PMI->getParent()) == HasPhiDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">        RemoveDeps.push_back(PI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">        RemoveDeps.push_back(PI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">    for (int i = 0, e = RemoveDeps.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">    for (int i = 0, e = RemoveDeps.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">      I.removePred(RemoveDeps[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">      I.removePred(RemoveDeps[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">/// Iterate over each DAG node and see if we can change any dependences</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">/// Iterate over each DAG node and see if we can change any dependences</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">/// in order to reduce the recurrence MII.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">/// in order to reduce the recurrence MII.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">void SwingSchedulerDAG::changeDependences() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">void SwingSchedulerDAG::changeDependences() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  // See if an instruction can use a value from the previous iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  // See if an instruction can use a value from the previous iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">  // If so, we update the base and offset of the instruction and change</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">  // If so, we update the base and offset of the instruction and change</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">  // the dependences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">  // the dependences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  for (SUnit &I : SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  for (SUnit &I : SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">    unsigned BasePos = 0, OffsetPos = 0, NewBase = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">    unsigned BasePos = 0, OffsetPos = 0, NewBase = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">    int64_t NewOffset = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">    int64_t NewOffset = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">    if (!canUseLastOffsetValue(I.getInstr(), BasePos, OffsetPos, NewBase,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">    if (!canUseLastOffsetValue(I.getInstr(), BasePos, OffsetPos, NewBase,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">                               NewOffset))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">                               NewOffset))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">    // Get the MI and SUnit for the instruction that defines the original base.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">    // Get the MI and SUnit for the instruction that defines the original base.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">    Register OrigBase = I.getInstr()->getOperand(BasePos).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">    Register OrigBase = I.getInstr()->getOperand(BasePos).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">    MachineInstr *DefMI = MRI.getUniqueVRegDef(OrigBase);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">    MachineInstr *DefMI = MRI.getUniqueVRegDef(OrigBase);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">    if (!DefMI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">    if (!DefMI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">    SUnit *DefSU = getSUnit(DefMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">    SUnit *DefSU = getSUnit(DefMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">    if (!DefSU)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">    if (!DefSU)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">    // Get the MI and SUnit for the instruction that defins the new base.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">    // Get the MI and SUnit for the instruction that defins the new base.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">    MachineInstr *LastMI = MRI.getUniqueVRegDef(NewBase);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">    MachineInstr *LastMI = MRI.getUniqueVRegDef(NewBase);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">    if (!LastMI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">    if (!LastMI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">    SUnit *LastSU = getSUnit(LastMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">    SUnit *LastSU = getSUnit(LastMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">    if (!LastSU)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">    if (!LastSU)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">    if (Topo.IsReachable(&I, LastSU))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">    if (Topo.IsReachable(&I, LastSU))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">    // Remove the dependence. The value now depends on a prior iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">    // Remove the dependence. The value now depends on a prior iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">    SmallVector<SDep, 4> Deps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">    SmallVector<SDep, 4> Deps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">    for (const SDep &P : I.Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">    for (const SDep &P : I.Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">      if (P.getSUnit() == DefSU)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">      if (P.getSUnit() == DefSU)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">        Deps.push_back(P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">        Deps.push_back(P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">      Topo.RemovePred(&I, Deps[i].getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">      Topo.RemovePred(&I, Deps[i].getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">      I.removePred(Deps[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">      I.removePred(Deps[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">    // Remove the chain dependence between the instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">    // Remove the chain dependence between the instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">    Deps.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">    Deps.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">    for (auto &P : LastSU->Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">    for (auto &P : LastSU->Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">      if (P.getSUnit() == &I && P.getKind() == SDep::Order)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">      if (P.getSUnit() == &I && P.getKind() == SDep::Order)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">        Deps.push_back(P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">        Deps.push_back(P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">    for (int i = 0, e = Deps.size(); i != e; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">      Topo.RemovePred(LastSU, Deps[i].getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">      Topo.RemovePred(LastSU, Deps[i].getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">      LastSU->removePred(Deps[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">      LastSU->removePred(Deps[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">    // Add a dependence between the new instruction and the instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">    // Add a dependence between the new instruction and the instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">    // that defines the new base.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">    // that defines the new base.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">    SDep Dep(&I, SDep::Anti, NewBase);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">    SDep Dep(&I, SDep::Anti, NewBase);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">    Topo.AddPred(LastSU, &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">    Topo.AddPred(LastSU, &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">    LastSU->addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">    LastSU->addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">    // Remember the base and offset information so that we can update the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">    // Remember the base and offset information so that we can update the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">    // instruction during code generation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">    // instruction during code generation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">    InstrChanges[&I] = std::make_pair(NewBase, NewOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">    InstrChanges[&I] = std::make_pair(NewBase, NewOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">// FuncUnitSorter - Comparison operator used to sort instructions by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">// FuncUnitSorter - Comparison operator used to sort instructions by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">// the number of functional unit choices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">// the number of functional unit choices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">struct FuncUnitSorter {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">struct FuncUnitSorter {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">  const InstrItineraryData *InstrItins;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">  const InstrItineraryData *InstrItins;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  const MCSubtargetInfo *STI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  const MCSubtargetInfo *STI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">  DenseMap<InstrStage::FuncUnits, unsigned> Resources;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">  DenseMap<InstrStage::FuncUnits, unsigned> Resources;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">  FuncUnitSorter(const TargetSubtargetInfo &TSI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">  FuncUnitSorter(const TargetSubtargetInfo &TSI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">      : InstrItins(TSI.getInstrItineraryData()), STI(&TSI) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">      : InstrItins(TSI.getInstrItineraryData()), STI(&TSI) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  // Compute the number of functional unit alternatives needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  // Compute the number of functional unit alternatives needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  // at each stage, and take the minimum value. We prioritize the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  // at each stage, and take the minimum value. We prioritize the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">  // instructions by the least number of choices first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">  // instructions by the least number of choices first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  unsigned minFuncUnits(const MachineInstr *Inst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  unsigned minFuncUnits(const MachineInstr *Inst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">                        InstrStage::FuncUnits &F) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">                        InstrStage::FuncUnits &F) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">    unsigned SchedClass = Inst->getDesc().getSchedClass();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">    unsigned SchedClass = Inst->getDesc().getSchedClass();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">    unsigned min = UINT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">    unsigned min = UINT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">    if (InstrItins && !InstrItins->isEmpty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">    if (InstrItins && !InstrItins->isEmpty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">      for (const InstrStage &IS :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">      for (const InstrStage &IS :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">           make_range(InstrItins->beginStage(SchedClass),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">           make_range(InstrItins->beginStage(SchedClass),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">                      InstrItins->endStage(SchedClass))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">                      InstrItins->endStage(SchedClass))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">        InstrStage::FuncUnits funcUnits = IS.getUnits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">        InstrStage::FuncUnits funcUnits = IS.getUnits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">        unsigned numAlternatives = llvm::popcount(funcUnits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">        unsigned numAlternatives = llvm::popcount(funcUnits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">        if (numAlternatives < min) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">        if (numAlternatives < min) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">          min = numAlternatives;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">          min = numAlternatives;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">          F = funcUnits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">          F = funcUnits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">      return min;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">      return min;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">      const MCSchedClassDesc *SCDesc =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">      const MCSchedClassDesc *SCDesc =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">      if (!SCDesc->isValid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">      if (!SCDesc->isValid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">        // No valid Schedule Class Desc for schedClass, should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">        // No valid Schedule Class Desc for schedClass, should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">        // Pseudo/PostRAPseudo</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">        // Pseudo/PostRAPseudo</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">        return min;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">        return min;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">      for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">      for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">                      STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">                      STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">        if (!PRE.Cycles)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">        if (!PRE.Cycles)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">        const MCProcResourceDesc *ProcResource =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">        const MCProcResourceDesc *ProcResource =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">            STI->getSchedModel().getProcResource(PRE.ProcResourceIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">            STI->getSchedModel().getProcResource(PRE.ProcResourceIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">        unsigned NumUnits = ProcResource->NumUnits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">        unsigned NumUnits = ProcResource->NumUnits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">        if (NumUnits < min) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">        if (NumUnits < min) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">          min = NumUnits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">          min = NumUnits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">          F = PRE.ProcResourceIdx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">          F = PRE.ProcResourceIdx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">      return min;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">      return min;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  // Compute the critical resources needed by the instruction. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  // Compute the critical resources needed by the instruction. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  // function records the functional units needed by instructions that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  // function records the functional units needed by instructions that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  // must use only one functional unit. We use this as a tie breaker</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  // must use only one functional unit. We use this as a tie breaker</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // for computing the resource MII. The instrutions that require</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // for computing the resource MII. The instrutions that require</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  // the same, highly used, functional unit have high priority.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  // the same, highly used, functional unit have high priority.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  void calcCriticalResources(MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  void calcCriticalResources(MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">    unsigned SchedClass = MI.getDesc().getSchedClass();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">    unsigned SchedClass = MI.getDesc().getSchedClass();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">    if (InstrItins && !InstrItins->isEmpty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">    if (InstrItins && !InstrItins->isEmpty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">      for (const InstrStage &IS :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">      for (const InstrStage &IS :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">           make_range(InstrItins->beginStage(SchedClass),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">           make_range(InstrItins->beginStage(SchedClass),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">                      InstrItins->endStage(SchedClass))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">                      InstrItins->endStage(SchedClass))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">        InstrStage::FuncUnits FuncUnits = IS.getUnits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">        InstrStage::FuncUnits FuncUnits = IS.getUnits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">        if (llvm::popcount(FuncUnits) == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">        if (llvm::popcount(FuncUnits) == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">          Resources[FuncUnits]++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">          Resources[FuncUnits]++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    if (STI && STI->getSchedModel().hasInstrSchedModel()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">      const MCSchedClassDesc *SCDesc =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">      const MCSchedClassDesc *SCDesc =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">          STI->getSchedModel().getSchedClassDesc(SchedClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">      if (!SCDesc->isValid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">      if (!SCDesc->isValid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">        // No valid Schedule Class Desc for schedClass, should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">        // No valid Schedule Class Desc for schedClass, should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">        // Pseudo/PostRAPseudo</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">        // Pseudo/PostRAPseudo</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">      for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">      for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">           make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">                      STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">                      STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">        if (!PRE.Cycles)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">        if (!PRE.Cycles)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">        Resources[PRE.ProcResourceIdx]++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">        Resources[PRE.ProcResourceIdx]++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">    llvm_unreachable("Should have non-empty InstrItins or hasInstrSchedModel!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">  /// Return true if IS1 has less priority than IS2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">  /// Return true if IS1 has less priority than IS2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">  bool operator()(const MachineInstr *IS1, const MachineInstr *IS2) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">  bool operator()(const MachineInstr *IS1, const MachineInstr *IS2) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">    InstrStage::FuncUnits F1 = 0, F2 = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">    InstrStage::FuncUnits F1 = 0, F2 = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">    unsigned MFUs1 = minFuncUnits(IS1, F1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">    unsigned MFUs1 = minFuncUnits(IS1, F1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">    unsigned MFUs2 = minFuncUnits(IS2, F2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">    unsigned MFUs2 = minFuncUnits(IS2, F2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">    if (MFUs1 == MFUs2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">    if (MFUs1 == MFUs2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">      return Resources.lookup(F1) < Resources.lookup(F2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">      return Resources.lookup(F1) < Resources.lookup(F2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    return MFUs1 > MFUs2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    return MFUs1 > MFUs2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">/// Calculate the resource constrained minimum initiation interval for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">/// Calculate the resource constrained minimum initiation interval for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">/// specified loop. We use the DFA to model the resources needed for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">/// specified loop. We use the DFA to model the resources needed for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">/// each instruction, and we ignore dependences. A different DFA is created</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">/// each instruction, and we ignore dependences. A different DFA is created</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">/// for each cycle that is required. When adding a new instruction, we attempt</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">/// for each cycle that is required. When adding a new instruction, we attempt</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">/// to add it to each existing DFA, until a legal space is found. If the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">/// to add it to each existing DFA, until a legal space is found. If the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">/// instruction cannot be reserved in an existing DFA, we create a new one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">/// instruction cannot be reserved in an existing DFA, we create a new one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">unsigned SwingSchedulerDAG::calculateResMII() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">unsigned SwingSchedulerDAG::calculateResMII() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "calculateResMII:\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "calculateResMII:\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  ResourceManager RM(&MF.getSubtarget(), this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  ResourceManager RM(&MF.getSubtarget(), this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  return RM.calculateResMII();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  return RM.calculateResMII();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">/// Calculate the recurrence-constrainted minimum initiation interval.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">/// Calculate the recurrence-constrainted minimum initiation interval.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">/// Iterate over each circuit.  Compute the delay(c) and distance(c)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">/// Iterate over each circuit.  Compute the delay(c) and distance(c)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">/// for each circuit. The II needs to satisfy the inequality</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">/// for each circuit. The II needs to satisfy the inequality</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">/// delay(c) - II*distance(c) <= 0. For each circuit, choose the smallest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">/// delay(c) - II*distance(c) <= 0. For each circuit, choose the smallest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">/// II that satisfies the inequality, and the RecMII is the maximum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">/// II that satisfies the inequality, and the RecMII is the maximum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">/// of those values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">/// of those values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">unsigned SwingSchedulerDAG::calculateRecMII(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">unsigned SwingSchedulerDAG::calculateRecMII(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  unsigned RecMII = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  unsigned RecMII = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  for (NodeSet &Nodes : NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  for (NodeSet &Nodes : NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">    if (Nodes.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">    if (Nodes.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">    unsigned Delay = Nodes.getLatency();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">    unsigned Delay = Nodes.getLatency();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">    unsigned Distance = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">    unsigned Distance = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    // ii = ceil(delay / distance)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    // ii = ceil(delay / distance)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">    unsigned CurMII = (Delay + Distance - 1) / Distance;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">    unsigned CurMII = (Delay + Distance - 1) / Distance;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">    Nodes.setRecMII(CurMII);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">    Nodes.setRecMII(CurMII);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">    if (CurMII > RecMII)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">    if (CurMII > RecMII)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">      RecMII = CurMII;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">      RecMII = CurMII;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  return RecMII;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  return RecMII;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">/// Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">/// Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">/// but we do this to find the circuits, and then change them back.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">/// but we do this to find the circuits, and then change them back.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">static void swapAntiDependences(std::vector<SUnit> &SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">static void swapAntiDependences(std::vector<SUnit> &SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">  SmallVector<std::pair<SUnit *, SDep>, 8> DepsAdded;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">  SmallVector<std::pair<SUnit *, SDep>, 8> DepsAdded;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  for (SUnit &SU : SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  for (SUnit &SU : SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">    for (SDep &Pred : SU.Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">    for (SDep &Pred : SU.Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">      if (Pred.getKind() == SDep::Anti)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">      if (Pred.getKind() == SDep::Anti)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">        DepsAdded.push_back(std::make_pair(&SU, Pred));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">        DepsAdded.push_back(std::make_pair(&SU, Pred));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  for (std::pair<SUnit *, SDep> &P : DepsAdded) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  for (std::pair<SUnit *, SDep> &P : DepsAdded) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">    // Remove this anti dependency and add one in the reverse direction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">    // Remove this anti dependency and add one in the reverse direction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">    SUnit *SU = P.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">    SUnit *SU = P.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">    SDep &D = P.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">    SDep &D = P.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">    SUnit *TargetSU = D.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">    SUnit *TargetSU = D.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">    unsigned Reg = D.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">    unsigned Reg = D.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">    unsigned Lat = D.getLatency();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">    unsigned Lat = D.getLatency();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">    SU->removePred(D);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">    SU->removePred(D);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">    SDep Dep(SU, SDep::Anti, Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">    SDep Dep(SU, SDep::Anti, Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">    Dep.setLatency(Lat);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">    Dep.setLatency(Lat);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">    TargetSU->addPred(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">    TargetSU->addPred(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">/// Create the adjacency structure of the nodes in the graph.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">/// Create the adjacency structure of the nodes in the graph.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">void SwingSchedulerDAG::Circuits::createAdjacencyStructure(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">void SwingSchedulerDAG::Circuits::createAdjacencyStructure(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">    SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">    SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  BitVector Added(SUnits.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  BitVector Added(SUnits.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  DenseMap<int, int> OutputDeps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  DenseMap<int, int> OutputDeps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">    Added.reset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">    Added.reset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">    // Add any successor to the adjacency matrix and exclude duplicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">    // Add any successor to the adjacency matrix and exclude duplicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">    for (auto &SI : SUnits[i].Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">    for (auto &SI : SUnits[i].Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">      // Only create a back-edge on the first and last nodes of a dependence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">      // Only create a back-edge on the first and last nodes of a dependence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">      // chain. This records any chains and adds them later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">      // chain. This records any chains and adds them later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">      if (SI.getKind() == SDep::Output) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">      if (SI.getKind() == SDep::Output) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">        int N = SI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">        int N = SI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">        int BackEdge = i;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">        int BackEdge = i;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">        auto Dep = OutputDeps.find(BackEdge);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">        auto Dep = OutputDeps.find(BackEdge);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">        if (Dep != OutputDeps.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">        if (Dep != OutputDeps.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">          BackEdge = Dep->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">          BackEdge = Dep->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">          OutputDeps.erase(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">          OutputDeps.erase(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">        OutputDeps[N] = BackEdge;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">        OutputDeps[N] = BackEdge;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">      // Do not process a boundary node, an artificial node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">      // Do not process a boundary node, an artificial node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">      // A back-edge is processed only if it goes to a Phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">      // A back-edge is processed only if it goes to a Phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">      if (SI.getSUnit()->isBoundaryNode() || SI.isArtificial() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">      if (SI.getSUnit()->isBoundaryNode() || SI.isArtificial() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">          (SI.getKind() == SDep::Anti && !SI.getSUnit()->getInstr()->isPHI()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">          (SI.getKind() == SDep::Anti && !SI.getSUnit()->getInstr()->isPHI()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">      int N = SI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">      int N = SI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">      if (!Added.test(N)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">      if (!Added.test(N)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">        AdjK[i].push_back(N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">        AdjK[i].push_back(N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">        Added.set(N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">        Added.set(N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">    // A chain edge between a store and a load is treated as a back-edge in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">    // A chain edge between a store and a load is treated as a back-edge in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">    // adjacency matrix.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">    // adjacency matrix.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">    for (auto &PI : SUnits[i].Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">    for (auto &PI : SUnits[i].Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">      if (!SUnits[i].getInstr()->mayStore() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">      if (!SUnits[i].getInstr()->mayStore() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">          !DAG->isLoopCarriedDep(&SUnits[i], PI, false))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">          !DAG->isLoopCarriedDep(&SUnits[i], PI, false))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">      if (PI.getKind() == SDep::Order && PI.getSUnit()->getInstr()->mayLoad()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">      if (PI.getKind() == SDep::Order && PI.getSUnit()->getInstr()->mayLoad()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">        int N = PI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">        int N = PI.getSUnit()->NodeNum;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">        if (!Added.test(N)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">        if (!Added.test(N)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">          AdjK[i].push_back(N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">          AdjK[i].push_back(N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">          Added.set(N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">          Added.set(N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">  // Add back-edges in the adjacency matrix for the output dependences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">  // Add back-edges in the adjacency matrix for the output dependences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  for (auto &OD : OutputDeps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  for (auto &OD : OutputDeps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    if (!Added.test(OD.second)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    if (!Added.test(OD.second)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">      AdjK[OD.first].push_back(OD.second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">      AdjK[OD.first].push_back(OD.second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">      Added.set(OD.second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">      Added.set(OD.second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">/// Identify an elementary circuit in the dependence graph starting at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">/// Identify an elementary circuit in the dependence graph starting at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">/// specified node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">/// specified node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">bool SwingSchedulerDAG::Circuits::circuit(int V, int S, NodeSetType &NodeSets,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">bool SwingSchedulerDAG::Circuits::circuit(int V, int S, NodeSetType &NodeSets,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">                                          bool HasBackedge) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">                                          bool HasBackedge) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  SUnit *SV = &SUnits[V];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  SUnit *SV = &SUnits[V];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  bool F = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  bool F = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  Stack.insert(SV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  Stack.insert(SV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  Blocked.set(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  Blocked.set(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  for (auto W : AdjK[V]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  for (auto W : AdjK[V]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">    if (NumPaths > MaxPaths)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">    if (NumPaths > MaxPaths)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">    if (W < S)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">    if (W < S)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">    if (W == S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">    if (W == S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">      if (!HasBackedge)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">      if (!HasBackedge)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">        NodeSets.push_back(NodeSet(Stack.begin(), Stack.end()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">        NodeSets.push_back(NodeSet(Stack.begin(), Stack.end()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">      F = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">      F = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">      ++NumPaths;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">      ++NumPaths;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">    } else if (!Blocked.test(W)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">    } else if (!Blocked.test(W)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">      if (circuit(W, S, NodeSets,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">      if (circuit(W, S, NodeSets,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">                  Node2Idx->at(W) < Node2Idx->at(V) ? true : HasBackedge))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">                  Node2Idx->at(W) < Node2Idx->at(V) ? true : HasBackedge))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">        F = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">        F = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  if (F)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  if (F)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">    unblock(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">    unblock(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">    for (auto W : AdjK[V]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">    for (auto W : AdjK[V]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">      if (W < S)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">      if (W < S)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">      B[W].insert(SV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">      B[W].insert(SV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  Stack.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  Stack.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  return F;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  return F;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">/// Unblock a node in the circuit finding algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">/// Unblock a node in the circuit finding algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">void SwingSchedulerDAG::Circuits::unblock(int U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">void SwingSchedulerDAG::Circuits::unblock(int U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  Blocked.reset(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  Blocked.reset(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 4> &BU = B[U];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 4> &BU = B[U];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">  while (!BU.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">  while (!BU.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">    SmallPtrSet<SUnit *, 4>::iterator SI = BU.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">    SmallPtrSet<SUnit *, 4>::iterator SI = BU.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">    assert(SI != BU.end() && "Invalid B set.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">    assert(SI != BU.end() && "Invalid B set.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">    SUnit *W = *SI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">    SUnit *W = *SI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">    BU.erase(W);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">    BU.erase(W);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">    if (Blocked.test(W->NodeNum))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">    if (Blocked.test(W->NodeNum))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">      unblock(W->NodeNum);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">      unblock(W->NodeNum);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">/// Identify all the elementary circuits in the dependence graph using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">/// Identify all the elementary circuits in the dependence graph using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">/// Johnson's circuit algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">/// Johnson's circuit algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">void SwingSchedulerDAG::findCircuits(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">void SwingSchedulerDAG::findCircuits(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  // Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  // Swap all the anti dependences in the DAG. That means it is no longer a DAG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  // but we do this to find the circuits, and then change them back.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  // but we do this to find the circuits, and then change them back.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  swapAntiDependences(SUnits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  swapAntiDependences(SUnits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  Circuits Cir(SUnits, Topo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  Circuits Cir(SUnits, Topo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">  // Create the adjacency structure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">  // Create the adjacency structure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  Cir.createAdjacencyStructure(this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  Cir.createAdjacencyStructure(this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  for (int i = 0, e = SUnits.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">    Cir.reset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">    Cir.reset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">    Cir.circuit(i, i, NodeSets);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">    Cir.circuit(i, i, NodeSets);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">  // Change the dependences back so that we've created a DAG again.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">  // Change the dependences back so that we've created a DAG again.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">  swapAntiDependences(SUnits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">  swapAntiDependences(SUnits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">// Create artificial dependencies between the source of COPY/REG_SEQUENCE that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">// Create artificial dependencies between the source of COPY/REG_SEQUENCE that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">// is loop-carried to the USE in next iteration. This will help pipeliner avoid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">// is loop-carried to the USE in next iteration. This will help pipeliner avoid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">// additional copies that are needed across iterations. An artificial dependence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">// additional copies that are needed across iterations. An artificial dependence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">// edge is added from USE to SOURCE of COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">// edge is added from USE to SOURCE of COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">// PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">// PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">// SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">// SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">// PHI-------True-Dep------> USEOfPhi</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">// PHI-------True-Dep------> USEOfPhi</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">// The mutation creates</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">// The mutation creates</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">// USEOfPHI -------Artificial-Dep---> SRCOfCopy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">// USEOfPHI -------Artificial-Dep---> SRCOfCopy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">// This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">// This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">// (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">// (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">// late  to avoid additional copies across iterations. The possible scheduling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">// late  to avoid additional copies across iterations. The possible scheduling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">// order would be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">// order would be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">// USEOfPHI --- SRCOfCopy---  COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">// USEOfPHI --- SRCOfCopy---  COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">void SwingSchedulerDAG::CopyToPhiMutation::apply(ScheduleDAGInstrs *DAG) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">void SwingSchedulerDAG::CopyToPhiMutation::apply(ScheduleDAGInstrs *DAG) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  for (SUnit &SU : DAG->SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  for (SUnit &SU : DAG->SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">    // Find the COPY/REG_SEQUENCE instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">    // Find the COPY/REG_SEQUENCE instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">    if (!SU.getInstr()->isCopy() && !SU.getInstr()->isRegSequence())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">    if (!SU.getInstr()->isCopy() && !SU.getInstr()->isRegSequence())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">    // Record the loop carried PHIs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">    // Record the loop carried PHIs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">    SmallVector<SUnit *, 4> PHISUs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">    SmallVector<SUnit *, 4> PHISUs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">    // Record the SrcSUs that feed the COPY/REG_SEQUENCE instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">    // Record the SrcSUs that feed the COPY/REG_SEQUENCE instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">    SmallVector<SUnit *, 4> SrcSUs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">    SmallVector<SUnit *, 4> SrcSUs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">    for (auto &Dep : SU.Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">    for (auto &Dep : SU.Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">      SUnit *TmpSU = Dep.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">      SUnit *TmpSU = Dep.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">      MachineInstr *TmpMI = TmpSU->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">      MachineInstr *TmpMI = TmpSU->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">      SDep::Kind DepKind = Dep.getKind();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">      SDep::Kind DepKind = Dep.getKind();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">      // Save the loop carried PHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">      // Save the loop carried PHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">      if (DepKind == SDep::Anti && TmpMI->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">      if (DepKind == SDep::Anti && TmpMI->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">        PHISUs.push_back(TmpSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">        PHISUs.push_back(TmpSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">      // Save the source of COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">      // Save the source of COPY/REG_SEQUENCE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">      // If the source has no pre-decessors, we will end up creating cycles.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">      // If the source has no pre-decessors, we will end up creating cycles.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">      else if (DepKind == SDep::Data && !TmpMI->isPHI() && TmpSU->NumPreds > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">      else if (DepKind == SDep::Data && !TmpMI->isPHI() && TmpSU->NumPreds > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">        SrcSUs.push_back(TmpSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">        SrcSUs.push_back(TmpSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">    if (PHISUs.size() == 0 || SrcSUs.size() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">    if (PHISUs.size() == 0 || SrcSUs.size() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">    // Find the USEs of PHI. If the use is a PHI or REG_SEQUENCE, push back this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">    // Find the USEs of PHI. If the use is a PHI or REG_SEQUENCE, push back this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">    // SUnit to the container.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">    // SUnit to the container.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">    SmallVector<SUnit *, 8> UseSUs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">    SmallVector<SUnit *, 8> UseSUs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">    // Do not use iterator based loop here as we are updating the container.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">    // Do not use iterator based loop here as we are updating the container.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">    for (size_t Index = 0; Index < PHISUs.size(); ++Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">    for (size_t Index = 0; Index < PHISUs.size(); ++Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">      for (auto &Dep : PHISUs[Index]->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">      for (auto &Dep : PHISUs[Index]->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">        if (Dep.getKind() != SDep::Data)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">        if (Dep.getKind() != SDep::Data)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">        SUnit *TmpSU = Dep.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">        SUnit *TmpSU = Dep.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">        MachineInstr *TmpMI = TmpSU->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">        MachineInstr *TmpMI = TmpSU->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">        if (TmpMI->isPHI() || TmpMI->isRegSequence()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">        if (TmpMI->isPHI() || TmpMI->isRegSequence()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">          PHISUs.push_back(TmpSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">          PHISUs.push_back(TmpSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">        UseSUs.push_back(TmpSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">        UseSUs.push_back(TmpSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">    if (UseSUs.size() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">    if (UseSUs.size() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">    SwingSchedulerDAG *SDAG = cast<SwingSchedulerDAG>(DAG);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">    SwingSchedulerDAG *SDAG = cast<SwingSchedulerDAG>(DAG);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">    // Add the artificial dependencies if it does not form a cycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">    // Add the artificial dependencies if it does not form a cycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">    for (auto *I : UseSUs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">    for (auto *I : UseSUs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">      for (auto *Src : SrcSUs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">      for (auto *Src : SrcSUs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">        if (!SDAG->Topo.IsReachable(I, Src) && Src != I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">        if (!SDAG->Topo.IsReachable(I, Src) && Src != I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">          Src->addPred(SDep(I, SDep::Artificial));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">          Src->addPred(SDep(I, SDep::Artificial));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">          SDAG->Topo.AddPred(Src, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">          SDAG->Topo.AddPred(Src, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">/// Return true for DAG nodes that we ignore when computing the cost functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">/// Return true for DAG nodes that we ignore when computing the cost functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">/// We ignore the back-edge recurrence in order to avoid unbounded recursion</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">/// We ignore the back-edge recurrence in order to avoid unbounded recursion</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">/// in the calculation of the ASAP, ALAP, etc functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">/// in the calculation of the ASAP, ALAP, etc functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">static bool ignoreDependence(const SDep &D, bool isPred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">static bool ignoreDependence(const SDep &D, bool isPred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">  if (D.isArtificial() || D.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">  if (D.isArtificial() || D.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">  return D.getKind() == SDep::Anti && isPred;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">  return D.getKind() == SDep::Anti && isPred;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">/// Compute several functions need to order the nodes for scheduling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">/// Compute several functions need to order the nodes for scheduling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">///  ASAP - Earliest time to schedule a node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">///  ASAP - Earliest time to schedule a node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">///  ALAP - Latest time to schedule a node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">///  ALAP - Latest time to schedule a node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">///  MOV - Mobility function, difference between ALAP and ASAP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">///  MOV - Mobility function, difference between ALAP and ASAP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">///  D - Depth of each node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">///  D - Depth of each node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">///  H - Height of each node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">///  H - Height of each node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">void SwingSchedulerDAG::computeNodeFunctions(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">void SwingSchedulerDAG::computeNodeFunctions(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  ScheduleInfo.resize(SUnits.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  ScheduleInfo.resize(SUnits.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">    for (int I : Topo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">    for (int I : Topo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">      const SUnit &SU = SUnits[I];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">      const SUnit &SU = SUnits[I];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">      dumpNode(SU);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">      dumpNode(SU);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  int maxASAP = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  int maxASAP = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  // Compute ASAP and ZeroLatencyDepth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  // Compute ASAP and ZeroLatencyDepth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">  for (int I : Topo) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">  for (int I : Topo) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">    int asap = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">    int asap = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">    int zeroLatencyDepth = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">    int zeroLatencyDepth = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">    SUnit *SU = &SUnits[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">    SUnit *SU = &SUnits[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">    for (const SDep &P : SU->Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">    for (const SDep &P : SU->Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">      SUnit *pred = P.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">      SUnit *pred = P.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">      if (P.getLatency() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">      if (P.getLatency() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">        zeroLatencyDepth =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">        zeroLatencyDepth =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">            std::max(zeroLatencyDepth, getZeroLatencyDepth(pred) + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">            std::max(zeroLatencyDepth, getZeroLatencyDepth(pred) + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">      if (ignoreDependence(P, true))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">      if (ignoreDependence(P, true))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">      asap = std::max(asap, (int)(getASAP(pred) + P.getLatency() -</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">      asap = std::max(asap, (int)(getASAP(pred) + P.getLatency() -</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">                                  getDistance(pred, SU, P) * MII));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">                                  getDistance(pred, SU, P) * MII));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">    maxASAP = std::max(maxASAP, asap);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">    maxASAP = std::max(maxASAP, asap);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">    ScheduleInfo[I].ASAP = asap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">    ScheduleInfo[I].ASAP = asap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    ScheduleInfo[I].ZeroLatencyDepth = zeroLatencyDepth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    ScheduleInfo[I].ZeroLatencyDepth = zeroLatencyDepth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">  // Compute ALAP, ZeroLatencyHeight, and MOV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">  // Compute ALAP, ZeroLatencyHeight, and MOV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">  for (int I : llvm::reverse(Topo)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">  for (int I : llvm::reverse(Topo)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">    int alap = maxASAP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">    int alap = maxASAP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">    int zeroLatencyHeight = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">    int zeroLatencyHeight = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">    SUnit *SU = &SUnits[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">    SUnit *SU = &SUnits[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">    for (const SDep &S : SU->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">    for (const SDep &S : SU->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">      SUnit *succ = S.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">      SUnit *succ = S.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">      if (succ->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">      if (succ->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">      if (S.getLatency() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">      if (S.getLatency() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">        zeroLatencyHeight =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">        zeroLatencyHeight =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">            std::max(zeroLatencyHeight, getZeroLatencyHeight(succ) + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">            std::max(zeroLatencyHeight, getZeroLatencyHeight(succ) + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">      if (ignoreDependence(S, true))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">      if (ignoreDependence(S, true))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">      alap = std::min(alap, (int)(getALAP(succ) - S.getLatency() +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">      alap = std::min(alap, (int)(getALAP(succ) - S.getLatency() +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">                                  getDistance(SU, succ, S) * MII));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">                                  getDistance(SU, succ, S) * MII));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">    ScheduleInfo[I].ALAP = alap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">    ScheduleInfo[I].ALAP = alap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">    ScheduleInfo[I].ZeroLatencyHeight = zeroLatencyHeight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">    ScheduleInfo[I].ZeroLatencyHeight = zeroLatencyHeight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">  // After computing the node functions, compute the summary for each node set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">  // After computing the node functions, compute the summary for each node set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">  for (NodeSet &I : NodeSets)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">  for (NodeSet &I : NodeSets)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">    I.computeNodeSetInfo(this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">    I.computeNodeSetInfo(this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">    for (unsigned i = 0; i < SUnits.size(); i++) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">    for (unsigned i = 0; i < SUnits.size(); i++) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">      dbgs() << "\tNode " << i << ":\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">      dbgs() << "\tNode " << i << ":\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">      dbgs() << "\t   ASAP = " << getASAP(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">      dbgs() << "\t   ASAP = " << getASAP(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">      dbgs() << "\t   ALAP = " << getALAP(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">      dbgs() << "\t   ALAP = " << getALAP(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">      dbgs() << "\t   MOV  = " << getMOV(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">      dbgs() << "\t   MOV  = " << getMOV(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">      dbgs() << "\t   D    = " << getDepth(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">      dbgs() << "\t   D    = " << getDepth(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">      dbgs() << "\t   H    = " << getHeight(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">      dbgs() << "\t   H    = " << getHeight(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">      dbgs() << "\t   ZLD  = " << getZeroLatencyDepth(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">      dbgs() << "\t   ZLD  = " << getZeroLatencyDepth(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">      dbgs() << "\t   ZLH  = " << getZeroLatencyHeight(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">      dbgs() << "\t   ZLH  = " << getZeroLatencyHeight(&SUnits[i]) << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">/// Compute the Pred_L(O) set, as defined in the paper. The set is defined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">/// Compute the Pred_L(O) set, as defined in the paper. The set is defined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">/// as the predecessors of the elements of NodeOrder that are not also in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">/// as the predecessors of the elements of NodeOrder that are not also in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">/// NodeOrder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">/// NodeOrder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">static bool pred_L(SetVector<SUnit *> &NodeOrder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">static bool pred_L(SetVector<SUnit *> &NodeOrder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">                   SmallSetVector<SUnit *, 8> &Preds,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">                   SmallSetVector<SUnit *, 8> &Preds,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">                   const NodeSet *S = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">                   const NodeSet *S = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  Preds.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  Preds.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  for (const SUnit *SU : NodeOrder) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  for (const SUnit *SU : NodeOrder) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">    for (const SDep &Pred : SU->Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">    for (const SDep &Pred : SU->Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">      if (S && S->count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">      if (S && S->count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">      if (ignoreDependence(Pred, true))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">      if (ignoreDependence(Pred, true))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">        Preds.insert(Pred.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">        Preds.insert(Pred.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">    // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">    // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">    for (const SDep &Succ : SU->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">    for (const SDep &Succ : SU->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">      if (Succ.getKind() != SDep::Anti)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">      if (Succ.getKind() != SDep::Anti)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">      if (S && S->count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">      if (S && S->count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">        Preds.insert(Succ.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">        Preds.insert(Succ.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">  return !Preds.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">  return !Preds.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">/// Compute the Succ_L(O) set, as defined in the paper. The set is defined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">/// Compute the Succ_L(O) set, as defined in the paper. The set is defined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">/// as the successors of the elements of NodeOrder that are not also in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">/// as the successors of the elements of NodeOrder that are not also in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">/// NodeOrder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">/// NodeOrder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">static bool succ_L(SetVector<SUnit *> &NodeOrder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">static bool succ_L(SetVector<SUnit *> &NodeOrder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">                   SmallSetVector<SUnit *, 8> &Succs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">                   SmallSetVector<SUnit *, 8> &Succs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">                   const NodeSet *S = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">                   const NodeSet *S = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  Succs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  Succs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">  for (const SUnit *SU : NodeOrder) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">  for (const SUnit *SU : NodeOrder) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">    for (const SDep &Succ : SU->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">    for (const SDep &Succ : SU->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">      if (S && S->count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">      if (S && S->count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">      if (ignoreDependence(Succ, false))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">      if (ignoreDependence(Succ, false))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">      if (NodeOrder.count(Succ.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">        Succs.insert(Succ.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">        Succs.insert(Succ.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">    for (const SDep &Pred : SU->Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">    for (const SDep &Pred : SU->Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">      if (Pred.getKind() != SDep::Anti)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">      if (Pred.getKind() != SDep::Anti)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">      if (S && S->count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">      if (S && S->count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">      if (NodeOrder.count(Pred.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">        Succs.insert(Pred.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">        Succs.insert(Pred.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">  return !Succs.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">  return !Succs.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">/// Return true if there is a path from the specified node to any of the nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">/// Return true if there is a path from the specified node to any of the nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">/// in DestNodes. Keep track and return the nodes in any path.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">/// in DestNodes. Keep track and return the nodes in any path.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">static bool computePath(SUnit *Cur, SetVector<SUnit *> &Path,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">static bool computePath(SUnit *Cur, SetVector<SUnit *> &Path,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">                        SetVector<SUnit *> &DestNodes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">                        SetVector<SUnit *> &DestNodes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">                        SetVector<SUnit *> &Exclude,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">                        SetVector<SUnit *> &Exclude,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">                        SmallPtrSet<SUnit *, 8> &Visited) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">                        SmallPtrSet<SUnit *, 8> &Visited) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">  if (Cur->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">  if (Cur->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">  if (Exclude.contains(Cur))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">  if (Exclude.contains(Cur))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">  if (DestNodes.contains(Cur))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">  if (DestNodes.contains(Cur))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">  if (!Visited.insert(Cur).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">  if (!Visited.insert(Cur).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">    return Path.contains(Cur);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">    return Path.contains(Cur);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">  bool FoundPath = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">  bool FoundPath = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">  for (auto &SI : Cur->Succs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">  for (auto &SI : Cur->Succs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">    if (!ignoreDependence(SI, false))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">    if (!ignoreDependence(SI, false))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">      FoundPath |=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">      FoundPath |=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">          computePath(SI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">          computePath(SI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  for (auto &PI : Cur->Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  for (auto &PI : Cur->Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">    if (PI.getKind() == SDep::Anti)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">    if (PI.getKind() == SDep::Anti)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">      FoundPath |=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">      FoundPath |=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">          computePath(PI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">          computePath(PI.getSUnit(), Path, DestNodes, Exclude, Visited);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">  if (FoundPath)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">  if (FoundPath)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">    Path.insert(Cur);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">    Path.insert(Cur);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">  return FoundPath;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">  return FoundPath;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">/// Compute the live-out registers for the instructions in a node-set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">/// Compute the live-out registers for the instructions in a node-set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">/// The live-out registers are those that are defined in the node-set,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">/// The live-out registers are those that are defined in the node-set,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">/// but not used. Except for use operands of Phis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">/// but not used. Except for use operands of Phis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">static void computeLiveOuts(MachineFunction &MF, RegPressureTracker &RPTracker,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">static void computeLiveOuts(MachineFunction &MF, RegPressureTracker &RPTracker,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">                            NodeSet &NS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">                            NodeSet &NS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">  SmallVector<RegisterMaskPair, 8> LiveOutRegs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">  SmallVector<RegisterMaskPair, 8> LiveOutRegs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">  SmallSet<unsigned, 4> Uses;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">  SmallSet<unsigned, 4> Uses;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">  for (SUnit *SU : NS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">  for (SUnit *SU : NS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">    const MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">    const MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">    if (MI->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">    if (MI->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">    for (const MachineOperand &MO : MI->all_uses()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">    for (const MachineOperand &MO : MI->all_uses()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">      if (Reg.isVirtual())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">      if (Reg.isVirtual())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">        Uses.insert(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">        Uses.insert(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">      else if (MRI.isAllocatable(Reg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">      else if (MRI.isAllocatable(Reg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">        for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">        for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">          Uses.insert(Unit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">          Uses.insert(Unit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">  for (SUnit *SU : NS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">  for (SUnit *SU : NS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">    for (const MachineOperand &MO : SU->getInstr()->all_defs())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">    for (const MachineOperand &MO : SU->getInstr()->all_defs())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">      if (!MO.isDead()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">      if (!MO.isDead()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">        Register Reg = MO.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">        Register Reg = MO.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">        if (Reg.isVirtual()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">        if (Reg.isVirtual()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">          if (!Uses.count(Reg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">          if (!Uses.count(Reg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">            LiveOutRegs.push_back(RegisterMaskPair(Reg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">            LiveOutRegs.push_back(RegisterMaskPair(Reg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">                                                   LaneBitmask::getNone()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">                                                   LaneBitmask::getNone()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">        } else if (MRI.isAllocatable(Reg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">        } else if (MRI.isAllocatable(Reg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">          for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">          for (MCRegUnit Unit : TRI->regunits(Reg.asMCReg()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">            if (!Uses.count(Unit))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">            if (!Uses.count(Unit))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">              LiveOutRegs.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">              LiveOutRegs.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">                  RegisterMaskPair(Unit, LaneBitmask::getNone()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">                  RegisterMaskPair(Unit, LaneBitmask::getNone()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">  RPTracker.addLiveRegs(LiveOutRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">  RPTracker.addLiveRegs(LiveOutRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">/// A heuristic to filter nodes in recurrent node-sets if the register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">/// A heuristic to filter nodes in recurrent node-sets if the register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">/// pressure of a set is too high.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">/// pressure of a set is too high.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">void SwingSchedulerDAG::registerPressureFilter(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">void SwingSchedulerDAG::registerPressureFilter(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">  for (auto &NS : NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">  for (auto &NS : NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">    // Skip small node-sets since they won't cause register pressure problems.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">    // Skip small node-sets since they won't cause register pressure problems.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">    if (NS.size() <= 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">    if (NS.size() <= 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">    IntervalPressure RecRegPressure;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">    IntervalPressure RecRegPressure;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">    RegPressureTracker RecRPTracker(RecRegPressure);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">    RegPressureTracker RecRPTracker(RecRegPressure);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">    RecRPTracker.init(&MF, &RegClassInfo, &LIS, BB, BB->end(), false, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">    RecRPTracker.init(&MF, &RegClassInfo, &LIS, BB, BB->end(), false, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">    computeLiveOuts(MF, RecRPTracker, NS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">    computeLiveOuts(MF, RecRPTracker, NS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">    RecRPTracker.closeBottom();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">    RecRPTracker.closeBottom();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">    std::vector<SUnit *> SUnits(NS.begin(), NS.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">    std::vector<SUnit *> SUnits(NS.begin(), NS.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">    llvm::sort(SUnits, [](const SUnit *A, const SUnit *B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">    llvm::sort(SUnits, [](const SUnit *A, const SUnit *B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">      return A->NodeNum > B->NodeNum;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">      return A->NodeNum > B->NodeNum;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">    for (auto &SU : SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">    for (auto &SU : SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">      // Since we're computing the register pressure for a subset of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">      // Since we're computing the register pressure for a subset of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">      // instructions in a block, we need to set the tracker for each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">      // instructions in a block, we need to set the tracker for each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">      // instruction in the node-set. The tracker is set to the instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">      // instruction in the node-set. The tracker is set to the instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">      // just after the one we're interested in.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">      // just after the one we're interested in.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">      MachineBasicBlock::const_iterator CurInstI = SU->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">      MachineBasicBlock::const_iterator CurInstI = SU->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">      RecRPTracker.setPos(std::next(CurInstI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">      RecRPTracker.setPos(std::next(CurInstI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">      RegPressureDelta RPDelta;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">      RegPressureDelta RPDelta;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">      ArrayRef<PressureChange> CriticalPSets;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">      ArrayRef<PressureChange> CriticalPSets;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">      RecRPTracker.getMaxUpwardPressureDelta(SU->getInstr(), nullptr, RPDelta,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">      RecRPTracker.getMaxUpwardPressureDelta(SU->getInstr(), nullptr, RPDelta,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">                                             CriticalPSets,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">                                             CriticalPSets,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">                                             RecRegPressure.MaxSetPressure);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">                                             RecRegPressure.MaxSetPressure);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">      if (RPDelta.Excess.isValid()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">      if (RPDelta.Excess.isValid()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">            dbgs() << "Excess register pressure: SU(" << SU->NodeNum << ") "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">            dbgs() << "Excess register pressure: SU(" << SU->NodeNum << ") "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">                   << TRI->getRegPressureSetName(RPDelta.Excess.getPSet())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">                   << TRI->getRegPressureSetName(RPDelta.Excess.getPSet())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">                   << ":" << RPDelta.Excess.getUnitInc() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">                   << ":" << RPDelta.Excess.getUnitInc() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">        NS.setExceedPressure(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">        NS.setExceedPressure(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">      RecRPTracker.recede();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">      RecRPTracker.recede();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">/// A heuristic to colocate node sets that have the same set of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">/// A heuristic to colocate node sets that have the same set of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">/// successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">/// successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">void SwingSchedulerDAG::colocateNodeSets(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">void SwingSchedulerDAG::colocateNodeSets(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">  unsigned Colocate = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">  unsigned Colocate = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">  for (int i = 0, e = NodeSets.size(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">  for (int i = 0, e = NodeSets.size(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">    NodeSet &N1 = NodeSets[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">    NodeSet &N1 = NodeSets[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">    SmallSetVector<SUnit *, 8> S1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">    SmallSetVector<SUnit *, 8> S1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">    if (N1.empty() || !succ_L(N1, S1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">    if (N1.empty() || !succ_L(N1, S1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">    for (int j = i + 1; j < e; ++j) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">    for (int j = i + 1; j < e; ++j) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">      NodeSet &N2 = NodeSets[j];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">      NodeSet &N2 = NodeSets[j];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">      if (N1.compareRecMII(N2) != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">      if (N1.compareRecMII(N2) != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">      SmallSetVector<SUnit *, 8> S2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">      SmallSetVector<SUnit *, 8> S2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">      if (N2.empty() || !succ_L(N2, S2))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">      if (N2.empty() || !succ_L(N2, S2))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">      if (llvm::set_is_subset(S1, S2) && S1.size() == S2.size()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">      if (llvm::set_is_subset(S1, S2) && S1.size() == S2.size()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">        N1.setColocate(++Colocate);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">        N1.setColocate(++Colocate);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">        N2.setColocate(Colocate);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">        N2.setColocate(Colocate);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">/// Check if the existing node-sets are profitable. If not, then ignore the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">/// Check if the existing node-sets are profitable. If not, then ignore the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">/// recurrent node-sets, and attempt to schedule all nodes together. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">/// recurrent node-sets, and attempt to schedule all nodes together. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">/// a heuristic. If the MII is large and all the recurrent node-sets are small,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">/// a heuristic. If the MII is large and all the recurrent node-sets are small,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">/// then it's best to try to schedule all instructions together instead of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">/// then it's best to try to schedule all instructions together instead of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">/// starting with the recurrent node-sets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">/// starting with the recurrent node-sets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">void SwingSchedulerDAG::checkNodeSets(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">void SwingSchedulerDAG::checkNodeSets(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">  // Look for loops with a large MII.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">  // Look for loops with a large MII.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  if (MII < 17)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  if (MII < 17)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">  // Check if the node-set contains only a simple add recurrence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">  // Check if the node-set contains only a simple add recurrence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">  for (auto &NS : NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">  for (auto &NS : NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">    if (NS.getRecMII() > 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">    if (NS.getRecMII() > 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">    if (NS.getMaxDepth() > MII)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">    if (NS.getMaxDepth() > MII)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">  NodeSets.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">  NodeSets.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Clear recurrence node-sets\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Clear recurrence node-sets\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">/// Add the nodes that do not belong to a recurrence set into groups</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">/// Add the nodes that do not belong to a recurrence set into groups</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">/// based upon connected components.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">/// based upon connected components.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">void SwingSchedulerDAG::groupRemainingNodes(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">void SwingSchedulerDAG::groupRemainingNodes(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  SetVector<SUnit *> NodesAdded;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  SetVector<SUnit *> NodesAdded;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">  // Add the nodes that are on a path between the previous node sets and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">  // Add the nodes that are on a path between the previous node sets and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  // the current node set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  // the current node set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  for (NodeSet &I : NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  for (NodeSet &I : NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">    SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">    SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">    // Add the nodes from the current node set to the previous node set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">    // Add the nodes from the current node set to the previous node set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">    if (succ_L(I, N)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">    if (succ_L(I, N)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">      SetVector<SUnit *> Path;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">      SetVector<SUnit *> Path;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">      for (SUnit *NI : N) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">      for (SUnit *NI : N) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">        Visited.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">        Visited.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">        computePath(NI, Path, NodesAdded, I, Visited);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">        computePath(NI, Path, NodesAdded, I, Visited);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">      if (!Path.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">      if (!Path.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">        I.insert(Path.begin(), Path.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">        I.insert(Path.begin(), Path.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">    // Add the nodes from the previous node set to the current node set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">    // Add the nodes from the previous node set to the current node set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">    N.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">    N.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">    if (succ_L(NodesAdded, N)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">    if (succ_L(NodesAdded, N)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">      SetVector<SUnit *> Path;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">      SetVector<SUnit *> Path;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">      for (SUnit *NI : N) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">      for (SUnit *NI : N) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">        Visited.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">        Visited.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">        computePath(NI, Path, I, NodesAdded, Visited);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">        computePath(NI, Path, I, NodesAdded, Visited);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">      if (!Path.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">      if (!Path.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">        I.insert(Path.begin(), Path.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">        I.insert(Path.begin(), Path.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">    NodesAdded.insert(I.begin(), I.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">    NodesAdded.insert(I.begin(), I.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">  // Create a new node set with the connected nodes of any successor of a node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">  // Create a new node set with the connected nodes of any successor of a node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">  // in a recurrent set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">  // in a recurrent set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">  NodeSet NewSet;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">  NodeSet NewSet;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">  SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">  SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  if (succ_L(NodesAdded, N))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  if (succ_L(NodesAdded, N))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">    for (SUnit *I : N)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">    for (SUnit *I : N)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">      addConnectedNodes(I, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">      addConnectedNodes(I, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">  if (!NewSet.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">  if (!NewSet.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">    NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">    NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  // Create a new node set with the connected nodes of any predecessor of a node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  // Create a new node set with the connected nodes of any predecessor of a node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  // in a recurrent set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  // in a recurrent set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">  NewSet.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">  NewSet.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  if (pred_L(NodesAdded, N))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  if (pred_L(NodesAdded, N))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">    for (SUnit *I : N)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">    for (SUnit *I : N)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">      addConnectedNodes(I, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">      addConnectedNodes(I, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">  if (!NewSet.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">  if (!NewSet.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">    NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">    NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  // Create new nodes sets with the connected nodes any remaining node that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  // Create new nodes sets with the connected nodes any remaining node that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  // has no predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  // has no predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">  for (SUnit &SU : SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">  for (SUnit &SU : SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">    if (NodesAdded.count(&SU) == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">    if (NodesAdded.count(&SU) == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">      NewSet.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">      NewSet.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">      addConnectedNodes(&SU, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">      addConnectedNodes(&SU, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">      if (!NewSet.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">      if (!NewSet.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">        NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">        NodeSets.push_back(NewSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">/// Add the node to the set, and add all of its connected nodes to the set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">/// Add the node to the set, and add all of its connected nodes to the set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">void SwingSchedulerDAG::addConnectedNodes(SUnit *SU, NodeSet &NewSet,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">void SwingSchedulerDAG::addConnectedNodes(SUnit *SU, NodeSet &NewSet,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">                                          SetVector<SUnit *> &NodesAdded) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">                                          SetVector<SUnit *> &NodesAdded) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">  NewSet.insert(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">  NewSet.insert(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">  NodesAdded.insert(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">  NodesAdded.insert(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">  for (auto &SI : SU->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">  for (auto &SI : SU->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">    SUnit *Successor = SI.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">    SUnit *Successor = SI.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">    if (!SI.isArtificial() && !Successor->isBoundaryNode() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">    if (!SI.isArtificial() && !Successor->isBoundaryNode() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">        NodesAdded.count(Successor) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">        NodesAdded.count(Successor) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">      addConnectedNodes(Successor, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">      addConnectedNodes(Successor, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">  for (auto &PI : SU->Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">  for (auto &PI : SU->Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">    SUnit *Predecessor = PI.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">    SUnit *Predecessor = PI.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">    if (!PI.isArtificial() && NodesAdded.count(Predecessor) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">    if (!PI.isArtificial() && NodesAdded.count(Predecessor) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">      addConnectedNodes(Predecessor, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">      addConnectedNodes(Predecessor, NewSet, NodesAdded);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">/// Return true if Set1 contains elements in Set2. The elements in common</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">/// Return true if Set1 contains elements in Set2. The elements in common</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">/// are returned in a different container.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">/// are returned in a different container.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">static bool isIntersect(SmallSetVector<SUnit *, 8> &Set1, const NodeSet &Set2,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">static bool isIntersect(SmallSetVector<SUnit *, 8> &Set1, const NodeSet &Set2,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">                        SmallSetVector<SUnit *, 8> &Result) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">                        SmallSetVector<SUnit *, 8> &Result) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">  Result.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">  Result.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">  for (SUnit *SU : Set1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">  for (SUnit *SU : Set1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">    if (Set2.count(SU) != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">    if (Set2.count(SU) != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">      Result.insert(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">      Result.insert(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">  return !Result.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">  return !Result.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">/// Merge the recurrence node sets that have the same initial node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">/// Merge the recurrence node sets that have the same initial node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">void SwingSchedulerDAG::fuseRecs(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">void SwingSchedulerDAG::fuseRecs(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">       ++I) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">       ++I) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">    NodeSet &NI = *I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">    NodeSet &NI = *I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">      NodeSet &NJ = *J;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">      NodeSet &NJ = *J;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">      if (NI.getNode(0)->NodeNum == NJ.getNode(0)->NodeNum) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">      if (NI.getNode(0)->NodeNum == NJ.getNode(0)->NodeNum) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">        if (NJ.compareRecMII(NI) > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">        if (NJ.compareRecMII(NI) > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">          NI.setRecMII(NJ.getRecMII());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">          NI.setRecMII(NJ.getRecMII());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">        for (SUnit *SU : *J)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">        for (SUnit *SU : *J)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">          I->insert(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">          I->insert(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">        NodeSets.erase(J);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">        NodeSets.erase(J);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">        E = NodeSets.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">        E = NodeSets.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">        ++J;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">        ++J;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">/// Remove nodes that have been scheduled in previous NodeSets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">/// Remove nodes that have been scheduled in previous NodeSets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">void SwingSchedulerDAG::removeDuplicateNodes(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">void SwingSchedulerDAG::removeDuplicateNodes(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">  for (NodeSetType::iterator I = NodeSets.begin(), E = NodeSets.end(); I != E;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">       ++I)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">       ++I)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">    for (NodeSetType::iterator J = I + 1; J != E;) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">      J->remove_if([&](SUnit *SUJ) { return I->count(SUJ); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">      J->remove_if([&](SUnit *SUJ) { return I->count(SUJ); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">      if (J->empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">      if (J->empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">        NodeSets.erase(J);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">        NodeSets.erase(J);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">        E = NodeSets.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">        E = NodeSets.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">        ++J;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">        ++J;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">/// Compute an ordered list of the dependence graph nodes, which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">/// Compute an ordered list of the dependence graph nodes, which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">/// indicates the order that the nodes will be scheduled.  This is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">/// indicates the order that the nodes will be scheduled.  This is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">/// two-level algorithm. First, a partial order is created, which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">/// two-level algorithm. First, a partial order is created, which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">/// consists of a list of sets ordered from highest to lowest priority.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">/// consists of a list of sets ordered from highest to lowest priority.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">void SwingSchedulerDAG::computeNodeOrder(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">void SwingSchedulerDAG::computeNodeOrder(NodeSetType &NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">  SmallSetVector<SUnit *, 8> R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">  SmallSetVector<SUnit *, 8> R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  NodeOrder.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  NodeOrder.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">  for (auto &Nodes : NodeSets) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">  for (auto &Nodes : NodeSets) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "NodeSet size " << Nodes.size() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "NodeSet size " << Nodes.size() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">    OrderKind Order;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">    OrderKind Order;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">    SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">    SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">    if (pred_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">    if (pred_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">      R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">      R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">      Order = BottomUp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">      Order = BottomUp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Bottom up (preds) ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Bottom up (preds) ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">    } else if (succ_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">    } else if (succ_L(NodeOrder, N) && llvm::set_is_subset(N, Nodes)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">      R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">      R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">      Order = TopDown;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">      Order = TopDown;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Top down (succs) ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Top down (succs) ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">    } else if (isIntersect(N, Nodes, R)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">    } else if (isIntersect(N, Nodes, R)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">      // If some of the successors are in the existing node-set, then use the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">      // If some of the successors are in the existing node-set, then use the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">      // top-down ordering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">      // top-down ordering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">      Order = TopDown;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">      Order = TopDown;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Top down (intersect) ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Top down (intersect) ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">    } else if (NodeSets.size() == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">    } else if (NodeSets.size() == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">      for (const auto &N : Nodes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">      for (const auto &N : Nodes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">        if (N->Succs.size() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">        if (N->Succs.size() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">          R.insert(N);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">          R.insert(N);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">      Order = BottomUp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">      Order = BottomUp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Bottom up (all) ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Bottom up (all) ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">      // Find the node with the highest ASAP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">      // Find the node with the highest ASAP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">      SUnit *maxASAP = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">      SUnit *maxASAP = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">      for (SUnit *SU : Nodes) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">      for (SUnit *SU : Nodes) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">        if (maxASAP == nullptr || getASAP(SU) > getASAP(maxASAP) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">        if (maxASAP == nullptr || getASAP(SU) > getASAP(maxASAP) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">            (getASAP(SU) == getASAP(maxASAP) && SU->NodeNum > maxASAP->NodeNum))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">            (getASAP(SU) == getASAP(maxASAP) && SU->NodeNum > maxASAP->NodeNum))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">          maxASAP = SU;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">          maxASAP = SU;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">      R.insert(maxASAP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">      R.insert(maxASAP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">      Order = BottomUp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">      Order = BottomUp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Bottom up (default) ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Bottom up (default) ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">    while (!R.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">    while (!R.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">      if (Order == TopDown) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">      if (Order == TopDown) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">        // Choose the node with the maximum height.  If more than one, choose</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">        // Choose the node with the maximum height.  If more than one, choose</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">        // the node wiTH the maximum ZeroLatencyHeight. If still more than one,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">        // the node wiTH the maximum ZeroLatencyHeight. If still more than one,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">        // choose the node with the lowest MOV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">        // choose the node with the lowest MOV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">        while (!R.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">        while (!R.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">          SUnit *maxHeight = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">          SUnit *maxHeight = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">          for (SUnit *I : R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">          for (SUnit *I : R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">            if (maxHeight == nullptr || getHeight(I) > getHeight(maxHeight))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">            if (maxHeight == nullptr || getHeight(I) > getHeight(maxHeight))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">              maxHeight = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">              maxHeight = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">                     getZeroLatencyHeight(I) > getZeroLatencyHeight(maxHeight))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">                     getZeroLatencyHeight(I) > getZeroLatencyHeight(maxHeight))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">              maxHeight = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">              maxHeight = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">            else if (getHeight(I) == getHeight(maxHeight) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">                     getZeroLatencyHeight(I) ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">                     getZeroLatencyHeight(I) ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">                         getZeroLatencyHeight(maxHeight) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">                         getZeroLatencyHeight(maxHeight) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">                     getMOV(I) < getMOV(maxHeight))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">                     getMOV(I) < getMOV(maxHeight))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">              maxHeight = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">              maxHeight = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">          NodeOrder.insert(maxHeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">          NodeOrder.insert(maxHeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << maxHeight->NodeNum << " ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << maxHeight->NodeNum << " ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">          R.remove(maxHeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">          R.remove(maxHeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">          for (const auto &I : maxHeight->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">          for (const auto &I : maxHeight->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">            if (ignoreDependence(I, false))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">            if (ignoreDependence(I, false))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">          // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">          // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">          for (const auto &I : maxHeight->Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">          for (const auto &I : maxHeight->Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">            if (I.getKind() != SDep::Anti)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">            if (I.getKind() != SDep::Anti)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">        Order = BottomUp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">        Order = BottomUp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "\n   Switching order to bottom up ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "\n   Switching order to bottom up ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">        SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">        SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">        if (pred_L(NodeOrder, N, &Nodes))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">        if (pred_L(NodeOrder, N, &Nodes))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">          R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">          R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">        // Choose the node with the maximum depth.  If more than one, choose</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">        // Choose the node with the maximum depth.  If more than one, choose</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">        // the node with the maximum ZeroLatencyDepth. If still more than one,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">        // the node with the maximum ZeroLatencyDepth. If still more than one,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">        // choose the node with the lowest MOV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">        // choose the node with the lowest MOV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">        while (!R.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">        while (!R.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">          SUnit *maxDepth = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">          SUnit *maxDepth = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">          for (SUnit *I : R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">          for (SUnit *I : R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">            if (maxDepth == nullptr || getDepth(I) > getDepth(maxDepth))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">            if (maxDepth == nullptr || getDepth(I) > getDepth(maxDepth))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">              maxDepth = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">              maxDepth = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">                     getZeroLatencyDepth(I) > getZeroLatencyDepth(maxDepth))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">                     getZeroLatencyDepth(I) > getZeroLatencyDepth(maxDepth))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">              maxDepth = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">              maxDepth = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">            else if (getDepth(I) == getDepth(maxDepth) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">                     getZeroLatencyDepth(I) == getZeroLatencyDepth(maxDepth) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">                     getZeroLatencyDepth(I) == getZeroLatencyDepth(maxDepth) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">                     getMOV(I) < getMOV(maxDepth))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">                     getMOV(I) < getMOV(maxDepth))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">              maxDepth = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">              maxDepth = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">          NodeOrder.insert(maxDepth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">          NodeOrder.insert(maxDepth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << maxDepth->NodeNum << " ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << maxDepth->NodeNum << " ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">          R.remove(maxDepth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">          R.remove(maxDepth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">          if (Nodes.isExceedSU(maxDepth)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">          if (Nodes.isExceedSU(maxDepth)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">            Order = TopDown;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">            Order = TopDown;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">            R.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">            R.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">            R.insert(Nodes.getNode(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">            R.insert(Nodes.getNode(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">            break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">            break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">          for (const auto &I : maxDepth->Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">          for (const auto &I : maxDepth->Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">          // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">          // Back-edges are predecessors with an anti-dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">          for (const auto &I : maxDepth->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">          for (const auto &I : maxDepth->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">            if (I.getKind() != SDep::Anti)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">            if (I.getKind() != SDep::Anti)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">            if (Nodes.count(I.getSUnit()) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">            if (NodeOrder.contains(I.getSUnit()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">            R.insert(I.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">        Order = TopDown;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">        Order = TopDown;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "\n   Switching order to top down ");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "\n   Switching order to top down ");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">        SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">        SmallSetVector<SUnit *, 8> N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">        if (succ_L(NodeOrder, N, &Nodes))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">        if (succ_L(NodeOrder, N, &Nodes))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">          R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">          R.insert(N.begin(), N.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\nDone with Nodeset\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\nDone with Nodeset\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">    dbgs() << "Node order: ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">    dbgs() << "Node order: ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">    for (SUnit *I : NodeOrder)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">    for (SUnit *I : NodeOrder)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">      dbgs() << " " << I->NodeNum << " ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">      dbgs() << " " << I->NodeNum << " ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">    dbgs() << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">    dbgs() << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">/// Process the nodes in the computed order and create the pipelined schedule</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">/// Process the nodes in the computed order and create the pipelined schedule</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">/// of the instructions, if possible. Return true if a schedule is found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">/// of the instructions, if possible. Return true if a schedule is found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">bool SwingSchedulerDAG::schedulePipeline(SMSchedule &Schedule) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">bool SwingSchedulerDAG::schedulePipeline(SMSchedule &Schedule) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  if (NodeOrder.empty()){</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  if (NodeOrder.empty()){</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "NodeOrder is empty! abort scheduling\n" );</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "NodeOrder is empty! abort scheduling\n" );</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">  bool scheduleFound = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">  bool scheduleFound = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">  // Keep increasing II until a valid schedule is found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">  // Keep increasing II until a valid schedule is found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">  for (unsigned II = MII; II <= MAX_II && !scheduleFound; ++II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">  for (unsigned II = MII; II <= MAX_II && !scheduleFound; ++II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">    Schedule.reset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">    Schedule.reset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">    Schedule.setInitiationInterval(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">    Schedule.setInitiationInterval(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Try to schedule with " << II << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Try to schedule with " << II << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">    SetVector<SUnit *>::iterator NI = NodeOrder.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">    SetVector<SUnit *>::iterator NI = NodeOrder.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">    SetVector<SUnit *>::iterator NE = NodeOrder.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">    SetVector<SUnit *>::iterator NE = NodeOrder.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">      SUnit *SU = *NI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">      SUnit *SU = *NI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">      // Compute the schedule time for the instruction, which is based</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">      // Compute the schedule time for the instruction, which is based</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">      // upon the scheduled time for any predecessors/successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">      // upon the scheduled time for any predecessors/successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">      int EarlyStart = INT_MIN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">      int EarlyStart = INT_MIN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">      int LateStart = INT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">      int LateStart = INT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">      // These values are set when the size of the schedule window is limited</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">      // These values are set when the size of the schedule window is limited</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">      // due to chain dependences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">      // due to chain dependences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">      int SchedEnd = INT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">      int SchedEnd = INT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">      int SchedStart = INT_MIN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">      int SchedStart = INT_MIN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">      Schedule.computeStart(SU, &EarlyStart, &LateStart, &SchedEnd, &SchedStart,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">      Schedule.computeStart(SU, &EarlyStart, &LateStart, &SchedEnd, &SchedStart,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">                            II, this);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">                            II, this);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">        dbgs() << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">        dbgs() << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">        dbgs() << "Inst (" << SU->NodeNum << ") ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">        dbgs() << "Inst (" << SU->NodeNum << ") ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">        SU->getInstr()->dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">        SU->getInstr()->dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">        dbgs() << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">        dbgs() << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">        dbgs() << format("\tes: %8x ls: %8x me: %8x ms: %8x\n", EarlyStart,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">        dbgs() << format("\tes: %8x ls: %8x me: %8x ms: %8x\n", EarlyStart,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">                         LateStart, SchedEnd, SchedStart);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">                         LateStart, SchedEnd, SchedStart);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">      if (EarlyStart > LateStart || SchedEnd < EarlyStart ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">      if (EarlyStart > LateStart || SchedEnd < EarlyStart ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">          SchedStart > LateStart)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">          SchedStart > LateStart)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">        scheduleFound = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">        scheduleFound = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">      else if (EarlyStart != INT_MIN && LateStart == INT_MAX) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">      else if (EarlyStart != INT_MIN && LateStart == INT_MAX) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">        SchedEnd = std::min(SchedEnd, EarlyStart + (int)II - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">        SchedEnd = std::min(SchedEnd, EarlyStart + (int)II - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">        scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">        scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">      } else if (EarlyStart == INT_MIN && LateStart != INT_MAX) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">      } else if (EarlyStart == INT_MIN && LateStart != INT_MAX) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">        SchedStart = std::max(SchedStart, LateStart - (int)II + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">        SchedStart = std::max(SchedStart, LateStart - (int)II + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">        scheduleFound = Schedule.insert(SU, LateStart, SchedStart, II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">        scheduleFound = Schedule.insert(SU, LateStart, SchedStart, II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">      } else if (EarlyStart != INT_MIN && LateStart != INT_MAX) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">      } else if (EarlyStart != INT_MIN && LateStart != INT_MAX) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">        SchedEnd =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">        SchedEnd =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">            std::min(SchedEnd, std::min(LateStart, EarlyStart + (int)II - 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">            std::min(SchedEnd, std::min(LateStart, EarlyStart + (int)II - 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">        // When scheduling a Phi it is better to start at the late cycle and go</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">        // When scheduling a Phi it is better to start at the late cycle and go</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">        // backwards. The default order may insert the Phi too far away from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">        // backwards. The default order may insert the Phi too far away from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">        // its first dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">        // its first dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">        if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">        if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">          scheduleFound = Schedule.insert(SU, SchedEnd, EarlyStart, II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">          scheduleFound = Schedule.insert(SU, SchedEnd, EarlyStart, II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">          scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">          scheduleFound = Schedule.insert(SU, EarlyStart, SchedEnd, II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">        int FirstCycle = Schedule.getFirstCycle();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">        int FirstCycle = Schedule.getFirstCycle();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">        scheduleFound = Schedule.insert(SU, FirstCycle + getASAP(SU),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">        scheduleFound = Schedule.insert(SU, FirstCycle + getASAP(SU),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">                                        FirstCycle + getASAP(SU) + II - 1, II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">                                        FirstCycle + getASAP(SU) + II - 1, II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">      // Even if we find a schedule, make sure the schedule doesn't exceed the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">      // Even if we find a schedule, make sure the schedule doesn't exceed the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">      // allowable number of stages. We keep trying if this happens.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">      // allowable number of stages. We keep trying if this happens.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">      if (scheduleFound)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">      if (scheduleFound)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">        if (SwpMaxStages > -1 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">        if (SwpMaxStages > -1 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">            Schedule.getMaxStageCount() > (unsigned)SwpMaxStages)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">            Schedule.getMaxStageCount() > (unsigned)SwpMaxStages)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">          scheduleFound = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">          scheduleFound = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">        if (!scheduleFound)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">        if (!scheduleFound)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">          dbgs() << "\tCan't schedule\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">          dbgs() << "\tCan't schedule\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">    } while (++NI != NE && scheduleFound);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">    } while (++NI != NE && scheduleFound);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">    // If a schedule is found, ensure non-pipelined instructions are in stage 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">    // If a schedule is found, ensure non-pipelined instructions are in stage 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">    if (scheduleFound)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">    if (scheduleFound)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">      scheduleFound =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">      scheduleFound =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">          Schedule.normalizeNonPipelinedInstructions(this, LoopPipelinerInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">          Schedule.normalizeNonPipelinedInstructions(this, LoopPipelinerInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">    // If a schedule is found, check if it is a valid schedule too.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">    // If a schedule is found, check if it is a valid schedule too.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">    if (scheduleFound)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">    if (scheduleFound)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">      scheduleFound = Schedule.isValidSchedule(this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">      scheduleFound = Schedule.isValidSchedule(this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Schedule Found? " << scheduleFound</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Schedule Found? " << scheduleFound</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">                    << " (II=" << Schedule.getInitiationInterval()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">                    << " (II=" << Schedule.getInitiationInterval()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">                    << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">                    << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">  if (scheduleFound) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">  if (scheduleFound) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">    scheduleFound = LoopPipelinerInfo->shouldUseSchedule(*this, Schedule);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">    scheduleFound = LoopPipelinerInfo->shouldUseSchedule(*this, Schedule);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">    if (!scheduleFound)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">    if (!scheduleFound)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Target rejected schedule\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Target rejected schedule\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">  if (scheduleFound) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">  if (scheduleFound) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">    Schedule.finalizeSchedule(this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">    Schedule.finalizeSchedule(this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">    Pass.ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">      return MachineOptimizationRemarkAnalysis(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">             << "Schedule found with Initiation Interval: "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">             << "Schedule found with Initiation Interval: "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">             << ore::NV("II", Schedule.getInitiationInterval())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">             << ore::NV("II", Schedule.getInitiationInterval())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">             << ", MaxStageCount: "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">             << ", MaxStageCount: "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">             << ore::NV("MaxStageCount", Schedule.getMaxStageCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">             << ore::NV("MaxStageCount", Schedule.getMaxStageCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">  } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">    Schedule.reset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">    Schedule.reset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">  return scheduleFound && Schedule.getMaxStageCount() > 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">  return scheduleFound && Schedule.getMaxStageCount() > 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">/// Return true if we can compute the amount the instruction changes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">/// Return true if we can compute the amount the instruction changes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">/// during each iteration. Set Delta to the amount of the change.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">/// during each iteration. Set Delta to the amount of the change.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">bool SwingSchedulerDAG::computeDelta(MachineInstr &MI, unsigned &Delta) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">bool SwingSchedulerDAG::computeDelta(MachineInstr &MI, unsigned &Delta) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">  const MachineOperand *BaseOp;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">  const MachineOperand *BaseOp;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">  int64_t Offset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">  int64_t Offset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  bool OffsetIsScalable;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  bool OffsetIsScalable;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">  if (!TII->getMemOperandWithOffset(MI, BaseOp, Offset, OffsetIsScalable, TRI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">  if (!TII->getMemOperandWithOffset(MI, BaseOp, Offset, OffsetIsScalable, TRI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // FIXME: This algorithm assumes instructions have fixed-size offsets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // FIXME: This algorithm assumes instructions have fixed-size offsets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  if (OffsetIsScalable)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  if (OffsetIsScalable)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">  if (!BaseOp->isReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">  if (!BaseOp->isReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">  Register BaseReg = BaseOp->getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">  Register BaseReg = BaseOp->getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">  MachineRegisterInfo &MRI = MF.getRegInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">  // Check if there is a Phi. If so, get the definition in the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">  // Check if there is a Phi. If so, get the definition in the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  MachineInstr *BaseDef = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  MachineInstr *BaseDef = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">  if (BaseDef && BaseDef->isPHI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">  if (BaseDef && BaseDef->isPHI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">    BaseReg = getLoopPhiReg(*BaseDef, MI.getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">    BaseReg = getLoopPhiReg(*BaseDef, MI.getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">    BaseDef = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">    BaseDef = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">  if (!BaseDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">  if (!BaseDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  int D = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  int D = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  if (!TII->getIncrementValue(*BaseDef, D) && D >= 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  if (!TII->getIncrementValue(*BaseDef, D) && D >= 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">  Delta = D;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">  Delta = D;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">/// Check if we can change the instruction to use an offset value from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">/// Check if we can change the instruction to use an offset value from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">/// previous iteration. If so, return true and set the base and offset values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">/// previous iteration. If so, return true and set the base and offset values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">/// so that we can rewrite the load, if necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">/// so that we can rewrite the load, if necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">///   v1 = Phi(v0, v3)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">///   v1 = Phi(v0, v3)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">///   v2 = load v1, 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">///   v2 = load v1, 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">///   v3 = post_store v1, 4, x</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">///   v3 = post_store v1, 4, x</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">/// This function enables the load to be rewritten as v2 = load v3, 4.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">/// This function enables the load to be rewritten as v2 = load v3, 4.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">bool SwingSchedulerDAG::canUseLastOffsetValue(MachineInstr *MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">bool SwingSchedulerDAG::canUseLastOffsetValue(MachineInstr *MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">                                              unsigned &BasePos,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">                                              unsigned &BasePos,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">                                              unsigned &OffsetPos,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">                                              unsigned &OffsetPos,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">                                              unsigned &NewBase,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">                                              unsigned &NewBase,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">                                              int64_t &Offset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">                                              int64_t &Offset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">  // Get the load instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">  // Get the load instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  if (TII->isPostIncrement(*MI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  if (TII->isPostIncrement(*MI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">  unsigned BasePosLd, OffsetPosLd;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">  unsigned BasePosLd, OffsetPosLd;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">  if (!TII->getBaseAndOffsetPosition(*MI, BasePosLd, OffsetPosLd))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">  if (!TII->getBaseAndOffsetPosition(*MI, BasePosLd, OffsetPosLd))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">  Register BaseReg = MI->getOperand(BasePosLd).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">  Register BaseReg = MI->getOperand(BasePosLd).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">  // Look for the Phi instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">  // Look for the Phi instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  MachineRegisterInfo &MRI = MI->getMF()->getRegInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  MachineRegisterInfo &MRI = MI->getMF()->getRegInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">  MachineInstr *Phi = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">  MachineInstr *Phi = MRI.getVRegDef(BaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">  if (!Phi || !Phi->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">  if (!Phi || !Phi->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">  // Get the register defined in the loop block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">  // Get the register defined in the loop block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">  unsigned PrevReg = getLoopPhiReg(*Phi, MI->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">  unsigned PrevReg = getLoopPhiReg(*Phi, MI->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">  if (!PrevReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">  if (!PrevReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">  // Check for the post-increment load/store instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">  // Check for the post-increment load/store instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  MachineInstr *PrevDef = MRI.getVRegDef(PrevReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  MachineInstr *PrevDef = MRI.getVRegDef(PrevReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  if (!PrevDef || PrevDef == MI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  if (!PrevDef || PrevDef == MI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">  if (!TII->isPostIncrement(*PrevDef))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">  if (!TII->isPostIncrement(*PrevDef))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">  unsigned BasePos1 = 0, OffsetPos1 = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">  unsigned BasePos1 = 0, OffsetPos1 = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">  if (!TII->getBaseAndOffsetPosition(*PrevDef, BasePos1, OffsetPos1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">  if (!TII->getBaseAndOffsetPosition(*PrevDef, BasePos1, OffsetPos1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">  // Make sure that the instructions do not access the same memory location in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">  // Make sure that the instructions do not access the same memory location in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">  // the next iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">  // the next iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">  int64_t LoadOffset = MI->getOperand(OffsetPosLd).getImm();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">  int64_t LoadOffset = MI->getOperand(OffsetPosLd).getImm();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">  int64_t StoreOffset = PrevDef->getOperand(OffsetPos1).getImm();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">  int64_t StoreOffset = PrevDef->getOperand(OffsetPos1).getImm();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">  MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">  MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">  NewMI->getOperand(OffsetPosLd).setImm(LoadOffset + StoreOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">  NewMI->getOperand(OffsetPosLd).setImm(LoadOffset + StoreOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">  bool Disjoint = TII->areMemAccessesTriviallyDisjoint(*NewMI, *PrevDef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">  bool Disjoint = TII->areMemAccessesTriviallyDisjoint(*NewMI, *PrevDef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">  MF.deleteMachineInstr(NewMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">  MF.deleteMachineInstr(NewMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">  if (!Disjoint)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">  if (!Disjoint)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  // Set the return value once we determine that we return true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  // Set the return value once we determine that we return true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  BasePos = BasePosLd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  BasePos = BasePosLd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">  OffsetPos = OffsetPosLd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">  OffsetPos = OffsetPosLd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  NewBase = PrevReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  NewBase = PrevReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  Offset = StoreOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  Offset = StoreOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">/// Apply changes to the instruction if needed. The changes are need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">/// Apply changes to the instruction if needed. The changes are need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">/// to improve the scheduling and depend up on the final schedule.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">/// to improve the scheduling and depend up on the final schedule.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">void SwingSchedulerDAG::applyInstrChange(MachineInstr *MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">void SwingSchedulerDAG::applyInstrChange(MachineInstr *MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">                                         SMSchedule &Schedule) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">                                         SMSchedule &Schedule) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">  SUnit *SU = getSUnit(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">  SUnit *SU = getSUnit(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">  DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">  DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">      InstrChanges.find(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">      InstrChanges.find(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">  if (It != InstrChanges.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">  if (It != InstrChanges.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">    std::pair<unsigned, int64_t> RegAndOffset = It->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">    std::pair<unsigned, int64_t> RegAndOffset = It->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">    unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">    unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">    if (!TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">    if (!TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">    Register BaseReg = MI->getOperand(BasePos).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">    Register BaseReg = MI->getOperand(BasePos).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">    MachineInstr *LoopDef = findDefInLoop(BaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">    MachineInstr *LoopDef = findDefInLoop(BaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">    int DefStageNum = Schedule.stageScheduled(getSUnit(LoopDef));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">    int DefStageNum = Schedule.stageScheduled(getSUnit(LoopDef));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">    int DefCycleNum = Schedule.cycleScheduled(getSUnit(LoopDef));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">    int DefCycleNum = Schedule.cycleScheduled(getSUnit(LoopDef));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">    int BaseStageNum = Schedule.stageScheduled(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">    int BaseStageNum = Schedule.stageScheduled(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">    int BaseCycleNum = Schedule.cycleScheduled(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">    int BaseCycleNum = Schedule.cycleScheduled(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">    if (BaseStageNum < DefStageNum) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">    if (BaseStageNum < DefStageNum) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">      MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">      MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">      int OffsetDiff = DefStageNum - BaseStageNum;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">      int OffsetDiff = DefStageNum - BaseStageNum;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">      if (DefCycleNum < BaseCycleNum) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">      if (DefCycleNum < BaseCycleNum) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">        NewMI->getOperand(BasePos).setReg(RegAndOffset.first);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">        NewMI->getOperand(BasePos).setReg(RegAndOffset.first);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">        if (OffsetDiff > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">        if (OffsetDiff > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">          --OffsetDiff;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">          --OffsetDiff;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">      int64_t NewOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">      int64_t NewOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">          MI->getOperand(OffsetPos).getImm() + RegAndOffset.second * OffsetDiff;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">          MI->getOperand(OffsetPos).getImm() + RegAndOffset.second * OffsetDiff;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">      NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">      NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">      SU->setInstr(NewMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">      SU->setInstr(NewMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">      MISUnitMap[NewMI] = SU;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">      MISUnitMap[NewMI] = SU;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">      NewMIs[MI] = NewMI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">      NewMIs[MI] = NewMI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">/// Return the instruction in the loop that defines the register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">/// Return the instruction in the loop that defines the register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">/// If the definition is a Phi, then follow the Phi operand to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">/// If the definition is a Phi, then follow the Phi operand to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">/// the instruction in the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">/// the instruction in the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">MachineInstr *SwingSchedulerDAG::findDefInLoop(Register Reg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">MachineInstr *SwingSchedulerDAG::findDefInLoop(Register Reg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">  SmallPtrSet<MachineInstr *, 8> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">  SmallPtrSet<MachineInstr *, 8> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">  MachineInstr *Def = MRI.getVRegDef(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">  MachineInstr *Def = MRI.getVRegDef(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">  while (Def->isPHI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">  while (Def->isPHI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">    if (!Visited.insert(Def).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">    if (!Visited.insert(Def).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">    for (unsigned i = 1, e = Def->getNumOperands(); i < e; i += 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">    for (unsigned i = 1, e = Def->getNumOperands(); i < e; i += 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">      if (Def->getOperand(i + 1).getMBB() == BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">      if (Def->getOperand(i + 1).getMBB() == BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">        Def = MRI.getVRegDef(Def->getOperand(i).getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">        Def = MRI.getVRegDef(Def->getOperand(i).getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">  return Def;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">  return Def;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">/// Return true for an order or output dependence that is loop carried</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">/// Return true for an order or output dependence that is loop carried</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">/// potentially. A dependence is loop carried if the destination defines a valu</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">/// potentially. A dependence is loop carried if the destination defines a valu</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">/// that may be used or defined by the source in a subsequent iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">/// that may be used or defined by the source in a subsequent iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">bool SwingSchedulerDAG::isLoopCarriedDep(SUnit *Source, const SDep &Dep,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">bool SwingSchedulerDAG::isLoopCarriedDep(SUnit *Source, const SDep &Dep,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">                                         bool isSucc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">                                         bool isSucc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">  if ((Dep.getKind() != SDep::Order && Dep.getKind() != SDep::Output) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">  if ((Dep.getKind() != SDep::Order && Dep.getKind() != SDep::Output) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">      Dep.isArtificial() || Dep.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">      Dep.isArtificial() || Dep.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">  if (!SwpPruneLoopCarried)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">  if (!SwpPruneLoopCarried)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">  if (Dep.getKind() == SDep::Output)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">  if (Dep.getKind() == SDep::Output)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">  MachineInstr *SI = Source->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">  MachineInstr *SI = Source->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">  MachineInstr *DI = Dep.getSUnit()->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">  MachineInstr *DI = Dep.getSUnit()->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">  if (!isSucc)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">  if (!isSucc)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">    std::swap(SI, DI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">    std::swap(SI, DI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">  assert(SI != nullptr && DI != nullptr && "Expecting SUnit with an MI.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">  assert(SI != nullptr && DI != nullptr && "Expecting SUnit with an MI.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">  // Assume ordered loads and stores may have a loop carried dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">  // Assume ordered loads and stores may have a loop carried dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">  if (SI->hasUnmodeledSideEffects() || DI->hasUnmodeledSideEffects() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">  if (SI->hasUnmodeledSideEffects() || DI->hasUnmodeledSideEffects() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">      SI->mayRaiseFPException() || DI->mayRaiseFPException() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">      SI->mayRaiseFPException() || DI->mayRaiseFPException() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">      SI->hasOrderedMemoryRef() || DI->hasOrderedMemoryRef())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">      SI->hasOrderedMemoryRef() || DI->hasOrderedMemoryRef())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  // Only chain dependences between a load and store can be loop carried.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  // Only chain dependences between a load and store can be loop carried.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">  if (!DI->mayStore() || !SI->mayLoad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">  if (!DI->mayStore() || !SI->mayLoad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  unsigned DeltaS, DeltaD;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  unsigned DeltaS, DeltaD;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">  if (!computeDelta(*SI, DeltaS) || !computeDelta(*DI, DeltaD))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">  if (!computeDelta(*SI, DeltaS) || !computeDelta(*DI, DeltaD))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">  const MachineOperand *BaseOpS, *BaseOpD;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">  const MachineOperand *BaseOpS, *BaseOpD;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">  int64_t OffsetS, OffsetD;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">  int64_t OffsetS, OffsetD;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">  bool OffsetSIsScalable, OffsetDIsScalable;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">  bool OffsetSIsScalable, OffsetDIsScalable;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">  if (!TII->getMemOperandWithOffset(*SI, BaseOpS, OffsetS, OffsetSIsScalable,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">  if (!TII->getMemOperandWithOffset(*SI, BaseOpS, OffsetS, OffsetSIsScalable,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">                                    TRI) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">                                    TRI) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">      !TII->getMemOperandWithOffset(*DI, BaseOpD, OffsetD, OffsetDIsScalable,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">      !TII->getMemOperandWithOffset(*DI, BaseOpD, OffsetD, OffsetDIsScalable,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">                                    TRI))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">                                    TRI))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">  assert(!OffsetSIsScalable && !OffsetDIsScalable &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">  assert(!OffsetSIsScalable && !OffsetDIsScalable &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">         "Expected offsets to be byte offsets");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">         "Expected offsets to be byte offsets");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">  MachineInstr *DefS = MRI.getVRegDef(BaseOpS->getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">  MachineInstr *DefS = MRI.getVRegDef(BaseOpS->getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">  MachineInstr *DefD = MRI.getVRegDef(BaseOpD->getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">  MachineInstr *DefD = MRI.getVRegDef(BaseOpD->getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">  if (!DefS || !DefD || !DefS->isPHI() || !DefD->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">  if (!DefS || !DefD || !DefS->isPHI() || !DefD->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">  unsigned InitValS = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">  unsigned InitValS = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">  unsigned LoopValS = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">  unsigned LoopValS = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">  unsigned InitValD = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">  unsigned InitValD = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">  unsigned LoopValD = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">  unsigned LoopValD = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">  getPhiRegs(*DefS, BB, InitValS, LoopValS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">  getPhiRegs(*DefS, BB, InitValS, LoopValS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">  getPhiRegs(*DefD, BB, InitValD, LoopValD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">  getPhiRegs(*DefD, BB, InitValD, LoopValD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">  MachineInstr *InitDefS = MRI.getVRegDef(InitValS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">  MachineInstr *InitDefS = MRI.getVRegDef(InitValS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">  MachineInstr *InitDefD = MRI.getVRegDef(InitValD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">  MachineInstr *InitDefD = MRI.getVRegDef(InitValD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">  if (!InitDefS->isIdenticalTo(*InitDefD))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">  if (!InitDefS->isIdenticalTo(*InitDefD))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">  // Check that the base register is incremented by a constant value for each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">  // Check that the base register is incremented by a constant value for each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">  // iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">  // iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">  MachineInstr *LoopDefS = MRI.getVRegDef(LoopValS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">  MachineInstr *LoopDefS = MRI.getVRegDef(LoopValS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">  int D = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">  int D = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">  if (!LoopDefS || !TII->getIncrementValue(*LoopDefS, D))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">  if (!LoopDefS || !TII->getIncrementValue(*LoopDefS, D))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">  uint64_t AccessSizeS = (*SI->memoperands_begin())->getSize();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">  uint64_t AccessSizeS = (*SI->memoperands_begin())->getSize();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">  uint64_t AccessSizeD = (*DI->memoperands_begin())->getSize();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">  uint64_t AccessSizeD = (*DI->memoperands_begin())->getSize();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">  // This is the main test, which checks the offset values and the loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">  // This is the main test, which checks the offset values and the loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">  // increment value to determine if the accesses may be loop carried.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">  // increment value to determine if the accesses may be loop carried.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">  if (AccessSizeS == MemoryLocation::UnknownSize ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">  if (AccessSizeS == MemoryLocation::UnknownSize ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">      AccessSizeD == MemoryLocation::UnknownSize)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">      AccessSizeD == MemoryLocation::UnknownSize)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">  if (DeltaS != DeltaD || DeltaS < AccessSizeS || DeltaD < AccessSizeD)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">  if (DeltaS != DeltaD || DeltaS < AccessSizeS || DeltaD < AccessSizeD)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">  return (OffsetS + (int64_t)AccessSizeS < OffsetD + (int64_t)AccessSizeD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">  return (OffsetS + (int64_t)AccessSizeS < OffsetD + (int64_t)AccessSizeD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">void SwingSchedulerDAG::postProcessDAG() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">void SwingSchedulerDAG::postProcessDAG() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">  for (auto &M : Mutations)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">  for (auto &M : Mutations)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">    M->apply(this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">    M->apply(this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">/// Try to schedule the node at the specified StartCycle and continue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">/// Try to schedule the node at the specified StartCycle and continue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">/// until the node is schedule or the EndCycle is reached.  This function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">/// until the node is schedule or the EndCycle is reached.  This function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">/// returns true if the node is scheduled.  This routine may search either</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">/// returns true if the node is scheduled.  This routine may search either</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">/// forward or backward for a place to insert the instruction based upon</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">/// forward or backward for a place to insert the instruction based upon</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">/// the relative values of StartCycle and EndCycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">/// the relative values of StartCycle and EndCycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">bool SMSchedule::insert(SUnit *SU, int StartCycle, int EndCycle, int II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">bool SMSchedule::insert(SUnit *SU, int StartCycle, int EndCycle, int II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">  bool forward = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">  bool forward = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">    dbgs() << "Trying to insert node between " << StartCycle << " and "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">    dbgs() << "Trying to insert node between " << StartCycle << " and "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">           << EndCycle << " II: " << II << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">           << EndCycle << " II: " << II << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">  if (StartCycle > EndCycle)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">  if (StartCycle > EndCycle)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">    forward = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">    forward = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">  // The terminating condition depends on the direction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">  // The terminating condition depends on the direction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">  int termCycle = forward ? EndCycle + 1 : EndCycle - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">  int termCycle = forward ? EndCycle + 1 : EndCycle - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">  for (int curCycle = StartCycle; curCycle != termCycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">  for (int curCycle = StartCycle; curCycle != termCycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">       forward ? ++curCycle : --curCycle) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">       forward ? ++curCycle : --curCycle) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">    if (ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">    if (ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">        ProcItinResources.canReserveResources(*SU, curCycle)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">        ProcItinResources.canReserveResources(*SU, curCycle)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">        dbgs() << "\tinsert at cycle " << curCycle << " ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">        dbgs() << "\tinsert at cycle " << curCycle << " ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">        SU->getInstr()->dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">        SU->getInstr()->dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">      if (!ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">      if (!ST.getInstrInfo()->isZeroCost(SU->getInstr()->getOpcode()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">        ProcItinResources.reserveResources(*SU, curCycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">        ProcItinResources.reserveResources(*SU, curCycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">      ScheduledInstrs[curCycle].push_back(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">      ScheduledInstrs[curCycle].push_back(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">      InstrToCycle.insert(std::make_pair(SU, curCycle));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">      InstrToCycle.insert(std::make_pair(SU, curCycle));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">      if (curCycle > LastCycle)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">      if (curCycle > LastCycle)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">        LastCycle = curCycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">        LastCycle = curCycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">      if (curCycle < FirstCycle)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">      if (curCycle < FirstCycle)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">        FirstCycle = curCycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">        FirstCycle = curCycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">      dbgs() << "\tfailed to insert at cycle " << curCycle << " ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">      dbgs() << "\tfailed to insert at cycle " << curCycle << " ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">      SU->getInstr()->dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">      SU->getInstr()->dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">// Return the cycle of the earliest scheduled instruction in the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">// Return the cycle of the earliest scheduled instruction in the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">int SMSchedule::earliestCycleInChain(const SDep &Dep) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">int SMSchedule::earliestCycleInChain(const SDep &Dep) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">  SmallVector<SDep, 8> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">  SmallVector<SDep, 8> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">  Worklist.push_back(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">  Worklist.push_back(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">  int EarlyCycle = INT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">  int EarlyCycle = INT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">    const SDep &Cur = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">    const SDep &Cur = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">    SUnit *PrevSU = Cur.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">    SUnit *PrevSU = Cur.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">    if (Visited.count(PrevSU))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">    if (Visited.count(PrevSU))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(PrevSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(PrevSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">    if (it == InstrToCycle.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">    if (it == InstrToCycle.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">    EarlyCycle = std::min(EarlyCycle, it->second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">    EarlyCycle = std::min(EarlyCycle, it->second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">    for (const auto &PI : PrevSU->Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">    for (const auto &PI : PrevSU->Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">      if (PI.getKind() == SDep::Order || PI.getKind() == SDep::Output)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">      if (PI.getKind() == SDep::Order || PI.getKind() == SDep::Output)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">        Worklist.push_back(PI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">        Worklist.push_back(PI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">    Visited.insert(PrevSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">    Visited.insert(PrevSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">  return EarlyCycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">  return EarlyCycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">// Return the cycle of the latest scheduled instruction in the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">// Return the cycle of the latest scheduled instruction in the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">int SMSchedule::latestCycleInChain(const SDep &Dep) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">int SMSchedule::latestCycleInChain(const SDep &Dep) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">  SmallPtrSet<SUnit *, 8> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">  SmallVector<SDep, 8> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">  SmallVector<SDep, 8> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">  Worklist.push_back(Dep);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">  Worklist.push_back(Dep);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">  int LateCycle = INT_MIN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">  int LateCycle = INT_MIN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">    const SDep &Cur = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">    const SDep &Cur = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">    SUnit *SuccSU = Cur.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">    SUnit *SuccSU = Cur.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">    if (Visited.count(SuccSU) || SuccSU->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">    if (Visited.count(SuccSU) || SuccSU->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(SuccSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">    std::map<SUnit *, int>::const_iterator it = InstrToCycle.find(SuccSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">    if (it == InstrToCycle.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">    if (it == InstrToCycle.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">    LateCycle = std::max(LateCycle, it->second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">    LateCycle = std::max(LateCycle, it->second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">    for (const auto &SI : SuccSU->Succs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">    for (const auto &SI : SuccSU->Succs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">      if (SI.getKind() == SDep::Order || SI.getKind() == SDep::Output)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">      if (SI.getKind() == SDep::Order || SI.getKind() == SDep::Output)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">        Worklist.push_back(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">        Worklist.push_back(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">    Visited.insert(SuccSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">    Visited.insert(SuccSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">  return LateCycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">  return LateCycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">/// If an instruction has a use that spans multiple iterations, then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">/// If an instruction has a use that spans multiple iterations, then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">/// return true. These instructions are characterized by having a back-ege</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">/// return true. These instructions are characterized by having a back-ege</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">/// to a Phi, which contains a reference to another Phi.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">/// to a Phi, which contains a reference to another Phi.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">static SUnit *multipleIterations(SUnit *SU, SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">static SUnit *multipleIterations(SUnit *SU, SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">  for (auto &P : SU->Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">  for (auto &P : SU->Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">    if (DAG->isBackedge(SU, P) && P.getSUnit()->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">    if (DAG->isBackedge(SU, P) && P.getSUnit()->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">      for (auto &S : P.getSUnit()->Succs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">      for (auto &S : P.getSUnit()->Succs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">        if (S.getKind() == SDep::Data && S.getSUnit()->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">        if (S.getKind() == SDep::Data && S.getSUnit()->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">          return P.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">          return P.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">/// Compute the scheduling start slot for the instruction.  The start slot</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">/// Compute the scheduling start slot for the instruction.  The start slot</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">/// depends on any predecessor or successor nodes scheduled already.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">/// depends on any predecessor or successor nodes scheduled already.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">void SMSchedule::computeStart(SUnit *SU, int *MaxEarlyStart, int *MinLateStart,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">void SMSchedule::computeStart(SUnit *SU, int *MaxEarlyStart, int *MinLateStart,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">                              int *MinEnd, int *MaxStart, int II,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">                              int *MinEnd, int *MaxStart, int II,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">                              SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">                              SwingSchedulerDAG *DAG) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">  // Iterate over each instruction that has been scheduled already.  The start</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">  // Iterate over each instruction that has been scheduled already.  The start</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">  // slot computation depends on whether the previously scheduled instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">  // slot computation depends on whether the previously scheduled instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">  // is a predecessor or successor of the specified instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">  // is a predecessor or successor of the specified instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">  for (int cycle = getFirstCycle(); cycle <= LastCycle; ++cycle) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">  for (int cycle = getFirstCycle(); cycle <= LastCycle; ++cycle) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">    // Iterate over each instruction in the current cycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">    // Iterate over each instruction in the current cycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">    for (SUnit *I : getInstructions(cycle)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">    for (SUnit *I : getInstructions(cycle)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">      // Because we're processing a DAG for the dependences, we recognize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">      // Because we're processing a DAG for the dependences, we recognize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">      // the back-edge in recurrences by anti dependences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">      // the back-edge in recurrences by anti dependences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">      for (unsigned i = 0, e = (unsigned)SU->Preds.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">      for (unsigned i = 0, e = (unsigned)SU->Preds.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">        const SDep &Dep = SU->Preds[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">        const SDep &Dep = SU->Preds[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">        if (Dep.getSUnit() == I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">        if (Dep.getSUnit() == I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">          if (!DAG->isBackedge(SU, Dep)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">          if (!DAG->isBackedge(SU, Dep)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">            int EarlyStart = cycle + Dep.getLatency() -</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">            int EarlyStart = cycle + Dep.getLatency() -</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">            if (DAG->isLoopCarriedDep(SU, Dep, false)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">            if (DAG->isLoopCarriedDep(SU, Dep, false)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">              int End = earliestCycleInChain(Dep) + (II - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">              int End = earliestCycleInChain(Dep) + (II - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">              *MinEnd = std::min(*MinEnd, End);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">              *MinEnd = std::min(*MinEnd, End);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">          } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">          } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">            int LateStart = cycle - Dep.getLatency() +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">            int LateStart = cycle - Dep.getLatency() +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">        // For instruction that requires multiple iterations, make sure that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">        // For instruction that requires multiple iterations, make sure that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">        // the dependent instruction is not scheduled past the definition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">        // the dependent instruction is not scheduled past the definition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">        SUnit *BE = multipleIterations(I, DAG);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">        SUnit *BE = multipleIterations(I, DAG);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">        if (BE && Dep.getSUnit() == BE && !SU->getInstr()->isPHI() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">        if (BE && Dep.getSUnit() == BE && !SU->getInstr()->isPHI() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">            !SU->isPred(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">            !SU->isPred(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">          *MinLateStart = std::min(*MinLateStart, cycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">          *MinLateStart = std::min(*MinLateStart, cycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">      for (unsigned i = 0, e = (unsigned)SU->Succs.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">      for (unsigned i = 0, e = (unsigned)SU->Succs.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">        if (SU->Succs[i].getSUnit() == I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">        if (SU->Succs[i].getSUnit() == I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">          const SDep &Dep = SU->Succs[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">          const SDep &Dep = SU->Succs[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">          if (!DAG->isBackedge(SU, Dep)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">          if (!DAG->isBackedge(SU, Dep)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">            int LateStart = cycle - Dep.getLatency() +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">            int LateStart = cycle - Dep.getLatency() +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">                            DAG->getDistance(SU, Dep.getSUnit(), Dep) * II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">            *MinLateStart = std::min(*MinLateStart, LateStart);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">            if (DAG->isLoopCarriedDep(SU, Dep)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">            if (DAG->isLoopCarriedDep(SU, Dep)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">              int Start = latestCycleInChain(Dep) + 1 - II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">              int Start = latestCycleInChain(Dep) + 1 - II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">              *MaxStart = std::max(*MaxStart, Start);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">              *MaxStart = std::max(*MaxStart, Start);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">          } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">          } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">            int EarlyStart = cycle + Dep.getLatency() -</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">            int EarlyStart = cycle + Dep.getLatency() -</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine">                             DAG->getDistance(Dep.getSUnit(), SU, Dep) * II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">            *MaxEarlyStart = std::max(*MaxEarlyStart, EarlyStart);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">/// Order the instructions within a cycle so that the definitions occur</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">/// Order the instructions within a cycle so that the definitions occur</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">/// before the uses. Returns true if the instruction is added to the start</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">/// before the uses. Returns true if the instruction is added to the start</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">/// of the list, or false if added to the end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">/// of the list, or false if added to the end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">void SMSchedule::orderDependence(SwingSchedulerDAG *SSD, SUnit *SU,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">void SMSchedule::orderDependence(SwingSchedulerDAG *SSD, SUnit *SU,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">                                 std::deque<SUnit *> &Insts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">                                 std::deque<SUnit *> &Insts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">  MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">  MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">  bool OrderBeforeUse = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">  bool OrderBeforeUse = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">  bool OrderAfterDef = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">  bool OrderAfterDef = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">  bool OrderBeforeDef = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">  bool OrderBeforeDef = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">  unsigned MoveDef = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">  unsigned MoveDef = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">  unsigned MoveUse = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">  unsigned MoveUse = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">  int StageInst1 = stageScheduled(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">  int StageInst1 = stageScheduled(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">  unsigned Pos = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">  unsigned Pos = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">  for (std::deque<SUnit *>::iterator I = Insts.begin(), E = Insts.end(); I != E;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">  for (std::deque<SUnit *>::iterator I = Insts.begin(), E = Insts.end(); I != E;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">       ++I, ++Pos) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">       ++I, ++Pos) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">    for (MachineOperand &MO : MI->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">    for (MachineOperand &MO : MI->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">      if (!MO.isReg() || !MO.getReg().isVirtual())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">      if (!MO.isReg() || !MO.getReg().isVirtual())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">      Register Reg = MO.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">      unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">      unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">      if (ST.getInstrInfo()->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">      if (ST.getInstrInfo()->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">        if (MI->getOperand(BasePos).getReg() == Reg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">        if (MI->getOperand(BasePos).getReg() == Reg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">          if (unsigned NewReg = SSD->getInstrBaseReg(SU))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">          if (unsigned NewReg = SSD->getInstrBaseReg(SU))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">            Reg = NewReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">            Reg = NewReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">      bool Reads, Writes;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">      bool Reads, Writes;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">      std::tie(Reads, Writes) =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">      std::tie(Reads, Writes) =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">          (*I)->getInstr()->readsWritesVirtualRegister(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">          (*I)->getInstr()->readsWritesVirtualRegister(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">      if (MO.isDef() && Reads && stageScheduled(*I) <= StageInst1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">      if (MO.isDef() && Reads && stageScheduled(*I) <= StageInst1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine">        if (MoveUse == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine">        if (MoveUse == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">      } else if (MO.isDef() && Reads && stageScheduled(*I) > StageInst1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">      } else if (MO.isDef() && Reads && stageScheduled(*I) > StageInst1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">        // Add the instruction after the scheduled instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">        // Add the instruction after the scheduled instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">        OrderAfterDef = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">        OrderAfterDef = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">        MoveDef = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">        MoveDef = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">        if (cycleScheduled(*I) == cycleScheduled(SU) && !(*I)->isSucc(SU)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">        if (cycleScheduled(*I) == cycleScheduled(SU) && !(*I)->isSucc(SU)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">          OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">          OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">          if (MoveUse == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">          if (MoveUse == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">            MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">            MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">          OrderAfterDef = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">          OrderAfterDef = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">          MoveDef = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">          MoveDef = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) > StageInst1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) > StageInst1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">        if (MoveUse == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">        if (MoveUse == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine">        if (MoveUse != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine">        if (MoveUse != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">          OrderAfterDef = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">          OrderAfterDef = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">          MoveDef = Pos - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">          MoveDef = Pos - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) < StageInst1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">      } else if (MO.isUse() && Writes && stageScheduled(*I) < StageInst1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">        // Add the instruction before the scheduled instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">        // Add the instruction before the scheduled instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">        if (MoveUse == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">        if (MoveUse == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">      } else if (MO.isUse() && stageScheduled(*I) == StageInst1 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">      } else if (MO.isUse() && stageScheduled(*I) == StageInst1 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">                 isLoopCarriedDefOfUse(SSD, (*I)->getInstr(), MO)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">                 isLoopCarriedDefOfUse(SSD, (*I)->getInstr(), MO)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">        if (MoveUse == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">        if (MoveUse == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">          OrderBeforeDef = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">          OrderBeforeDef = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">    // Check for order dependences between instructions. Make sure the source</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">    // Check for order dependences between instructions. Make sure the source</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine">    // is ordered before the destination.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine">    // is ordered before the destination.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">    for (auto &S : SU->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">    for (auto &S : SU->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">      if (S.getSUnit() != *I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">      if (S.getSUnit() != *I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">      if (S.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">      if (S.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine">        if (Pos < MoveUse)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine">        if (Pos < MoveUse)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">      // We did not handle HW dependences in previous for loop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">      // We did not handle HW dependences in previous for loop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine">      // and we normally set Latency = 0 for Anti deps,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine">      // and we normally set Latency = 0 for Anti deps,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine">      // so may have nodes in same cycle with Anti denpendent on HW regs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine">      // so may have nodes in same cycle with Anti denpendent on HW regs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">      else if (S.getKind() == SDep::Anti && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">      else if (S.getKind() == SDep::Anti && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">        OrderBeforeUse = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">        if ((MoveUse == 0) || (Pos < MoveUse))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">        if ((MoveUse == 0) || (Pos < MoveUse))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">          MoveUse = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">    for (auto &P : SU->Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">    for (auto &P : SU->Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">      if (P.getSUnit() != *I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">      if (P.getSUnit() != *I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">      if (P.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">      if (P.getKind() == SDep::Order && stageScheduled(*I) == StageInst1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine">        OrderAfterDef = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine">        OrderAfterDef = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">        MoveDef = Pos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">        MoveDef = Pos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">  // A circular dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">  // A circular dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">  if (OrderAfterDef && OrderBeforeUse && MoveUse == MoveDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">  if (OrderAfterDef && OrderBeforeUse && MoveUse == MoveDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">    OrderBeforeUse = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">    OrderBeforeUse = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">  // OrderAfterDef takes precedences over OrderBeforeDef. The latter is due</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">  // OrderAfterDef takes precedences over OrderBeforeDef. The latter is due</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine">  // to a loop-carried dependence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine">  // to a loop-carried dependence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine">  if (OrderBeforeDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine">  if (OrderBeforeDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine">    OrderBeforeUse = !OrderAfterDef || (MoveUse > MoveDef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine">    OrderBeforeUse = !OrderAfterDef || (MoveUse > MoveDef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">  // The uncommon case when the instruction order needs to be updated because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">  // The uncommon case when the instruction order needs to be updated because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">  // there is both a use and def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">  // there is both a use and def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">  if (OrderBeforeUse && OrderAfterDef) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">  if (OrderBeforeUse && OrderAfterDef) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine">    SUnit *UseSU = Insts.at(MoveUse);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine">    SUnit *UseSU = Insts.at(MoveUse);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">    SUnit *DefSU = Insts.at(MoveDef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">    SUnit *DefSU = Insts.at(MoveDef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">    if (MoveUse > MoveDef) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">    if (MoveUse > MoveDef) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine">      Insts.erase(Insts.begin() + MoveUse);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine">      Insts.erase(Insts.begin() + MoveUse);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine">      Insts.erase(Insts.begin() + MoveDef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine">      Insts.erase(Insts.begin() + MoveDef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">      Insts.erase(Insts.begin() + MoveDef);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">      Insts.erase(Insts.begin() + MoveDef);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">      Insts.erase(Insts.begin() + MoveUse);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">      Insts.erase(Insts.begin() + MoveUse);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">    orderDependence(SSD, UseSU, Insts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">    orderDependence(SSD, UseSU, Insts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">    orderDependence(SSD, SU, Insts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">    orderDependence(SSD, SU, Insts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine">    orderDependence(SSD, DefSU, Insts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine">    orderDependence(SSD, DefSU, Insts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">  // Put the new instruction first if there is a use in the list. Otherwise,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">  // Put the new instruction first if there is a use in the list. Otherwise,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine">  // put it at the end of the list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine">  // put it at the end of the list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">  if (OrderBeforeUse)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">  if (OrderBeforeUse)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">    Insts.push_front(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">    Insts.push_front(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">    Insts.push_back(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">    Insts.push_back(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">/// Return true if the scheduled Phi has a loop carried operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">/// Return true if the scheduled Phi has a loop carried operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">bool SMSchedule::isLoopCarried(SwingSchedulerDAG *SSD, MachineInstr &Phi) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">bool SMSchedule::isLoopCarried(SwingSchedulerDAG *SSD, MachineInstr &Phi) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  if (!Phi.isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  if (!Phi.isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine">  assert(Phi.isPHI() && "Expecting a Phi.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine">  SUnit *DefSU = SSD->getSUnit(&Phi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine">  SUnit *DefSU = SSD->getSUnit(&Phi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">  unsigned DefCycle = cycleScheduled(DefSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">  unsigned DefCycle = cycleScheduled(DefSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine">  int DefStage = stageScheduled(DefSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine">  int DefStage = stageScheduled(DefSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine">  unsigned InitVal = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine">  unsigned InitVal = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">  unsigned LoopVal = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">  unsigned LoopVal = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine">  getPhiRegs(Phi, Phi.getParent(), InitVal, LoopVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine">  getPhiRegs(Phi, Phi.getParent(), InitVal, LoopVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">  SUnit *UseSU = SSD->getSUnit(MRI.getVRegDef(LoopVal));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">  SUnit *UseSU = SSD->getSUnit(MRI.getVRegDef(LoopVal));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine">  if (!UseSU)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine">  if (!UseSU)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine">  if (UseSU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine">  if (UseSU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">  unsigned LoopCycle = cycleScheduled(UseSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">  unsigned LoopCycle = cycleScheduled(UseSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine">  int LoopStage = stageScheduled(UseSU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine">  int LoopStage = stageScheduled(UseSU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine">  return (LoopCycle > DefCycle) || (LoopStage <= DefStage);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine">  return (LoopCycle > DefCycle) || (LoopStage <= DefStage);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine">/// Return true if the instruction is a definition that is loop carried</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine">/// Return true if the instruction is a definition that is loop carried</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">/// and defines the use on the next iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">/// and defines the use on the next iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine">///        v1 = phi(v2, v3)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine">///        v1 = phi(v2, v3)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">///  (Def) v3 = op v1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">///  (Def) v3 = op v1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">///  (MO)   = v1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">///  (MO)   = v1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine">/// If MO appears before Def, then then v1 and v3 may get assigned to the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine">/// If MO appears before Def, then then v1 and v3 may get assigned to the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine">/// register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine">/// register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine">bool SMSchedule::isLoopCarriedDefOfUse(SwingSchedulerDAG *SSD,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine">bool SMSchedule::isLoopCarriedDefOfUse(SwingSchedulerDAG *SSD,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">                                       MachineInstr *Def, MachineOperand &MO) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">                                       MachineInstr *Def, MachineOperand &MO) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">  if (!MO.isReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">  if (!MO.isReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine">  if (Def->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine">  if (Def->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine">  MachineInstr *Phi = MRI.getVRegDef(MO.getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine">  MachineInstr *Phi = MRI.getVRegDef(MO.getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine">  if (!Phi || !Phi->isPHI() || Phi->getParent() != Def->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine">  if (!Phi || !Phi->isPHI() || Phi->getParent() != Def->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine">  if (!isLoopCarried(SSD, *Phi))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine">  if (!isLoopCarried(SSD, *Phi))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine">  unsigned LoopReg = getLoopPhiReg(*Phi, Phi->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine">  unsigned LoopReg = getLoopPhiReg(*Phi, Phi->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine">  for (MachineOperand &DMO : Def->all_defs()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine">  for (MachineOperand &DMO : Def->all_defs()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine">    if (DMO.getReg() == LoopReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine">    if (DMO.getReg() == LoopReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine">/// Determine transitive dependences of unpipelineable instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine">/// Determine transitive dependences of unpipelineable instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine">SmallSet<SUnit *, 8> SMSchedule::computeUnpipelineableNodes(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine">SmallSet<SUnit *, 8> SMSchedule::computeUnpipelineableNodes(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine">  SmallSet<SUnit *, 8> DoNotPipeline;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine">  SmallSet<SUnit *, 8> DoNotPipeline;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine">  SmallVector<SUnit *, 8> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine">  SmallVector<SUnit *, 8> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine">  for (auto &SU : SSD->SUnits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine">  for (auto &SU : SSD->SUnits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine">    if (SU.isInstr() && PLI->shouldIgnoreForPipelining(SU.getInstr()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine">    if (SU.isInstr() && PLI->shouldIgnoreForPipelining(SU.getInstr()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine">      Worklist.push_back(&SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine">      Worklist.push_back(&SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine">    auto SU = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine">    auto SU = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeLine">    if (DoNotPipeline.count(SU))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2671</td>
    <td class="codeLine">    if (DoNotPipeline.count(SU))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2672</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Do not pipeline SU(" << SU->NodeNum << ")\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2673</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Do not pipeline SU(" << SU->NodeNum << ")\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeLine">    DoNotPipeline.insert(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2674</td>
    <td class="codeLine">    DoNotPipeline.insert(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeLine">    for (auto &Dep : SU->Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2675</td>
    <td class="codeLine">    for (auto &Dep : SU->Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeLine">      Worklist.push_back(Dep.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2676</td>
    <td class="codeLine">      Worklist.push_back(Dep.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeLine">    if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2677</td>
    <td class="codeLine">    if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeLine">      for (auto &Dep : SU->Succs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2678</td>
    <td class="codeLine">      for (auto &Dep : SU->Succs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeLine">        if (Dep.getKind() == SDep::Anti)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2679</td>
    <td class="codeLine">        if (Dep.getKind() == SDep::Anti)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeLine">          Worklist.push_back(Dep.getSUnit());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2680</td>
    <td class="codeLine">          Worklist.push_back(Dep.getSUnit());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeLine">  return DoNotPipeline;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2682</td>
    <td class="codeLine">  return DoNotPipeline;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2683</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeLine">// Determine all instructions upon which any unpipelineable instruction depends</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2685</td>
    <td class="codeLine">// Determine all instructions upon which any unpipelineable instruction depends</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeLine">// and ensure that they are in stage 0.  If unable to do so, return false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2686</td>
    <td class="codeLine">// and ensure that they are in stage 0.  If unable to do so, return false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeLine">bool SMSchedule::normalizeNonPipelinedInstructions(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2687</td>
    <td class="codeLine">bool SMSchedule::normalizeNonPipelinedInstructions(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeLine">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2688</td>
    <td class="codeLine">    SwingSchedulerDAG *SSD, TargetInstrInfo::PipelinerLoopInfo *PLI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeLine">  SmallSet<SUnit *, 8> DNP = computeUnpipelineableNodes(SSD, PLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2689</td>
    <td class="codeLine">  SmallSet<SUnit *, 8> DNP = computeUnpipelineableNodes(SSD, PLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeLine">  int NewLastCycle = INT_MIN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2691</td>
    <td class="codeLine">  int NewLastCycle = INT_MIN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeLine">  for (SUnit &SU : SSD->SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2692</td>
    <td class="codeLine">  for (SUnit &SU : SSD->SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeLine">    if (!SU.isInstr())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2693</td>
    <td class="codeLine">    if (!SU.isInstr())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2694</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeLine">    if (!DNP.contains(&SU) || stageScheduled(&SU) == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2695</td>
    <td class="codeLine">    if (!DNP.contains(&SU) || stageScheduled(&SU) == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeLine">      NewLastCycle = std::max(NewLastCycle, InstrToCycle[&SU]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2696</td>
    <td class="codeLine">      NewLastCycle = std::max(NewLastCycle, InstrToCycle[&SU]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2697</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2698</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeLine">    // Put the non-pipelined instruction as early as possible in the schedule</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2700</td>
    <td class="codeLine">    // Put the non-pipelined instruction as early as possible in the schedule</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeLine">    int NewCycle = getFirstCycle();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2701</td>
    <td class="codeLine">    int NewCycle = getFirstCycle();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeLine">    for (auto &Dep : SU.Preds)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2702</td>
    <td class="codeLine">    for (auto &Dep : SU.Preds)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeLine">      NewCycle = std::max(InstrToCycle[Dep.getSUnit()], NewCycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2703</td>
    <td class="codeLine">      NewCycle = std::max(InstrToCycle[Dep.getSUnit()], NewCycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeLine">    int OldCycle = InstrToCycle[&SU];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2705</td>
    <td class="codeLine">    int OldCycle = InstrToCycle[&SU];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeLine">    if (OldCycle != NewCycle) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2706</td>
    <td class="codeLine">    if (OldCycle != NewCycle) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeLine">      InstrToCycle[&SU] = NewCycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2707</td>
    <td class="codeLine">      InstrToCycle[&SU] = NewCycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeLine">      auto &OldS = getInstructions(OldCycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2708</td>
    <td class="codeLine">      auto &OldS = getInstructions(OldCycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeLine">      llvm::erase_value(OldS, &SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2709</td>
    <td class="codeLine">      llvm::erase_value(OldS, &SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeLine">      getInstructions(NewCycle).emplace_back(&SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2710</td>
    <td class="codeLine">      getInstructions(NewCycle).emplace_back(&SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "SU(" << SU.NodeNum</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2711</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "SU(" << SU.NodeNum</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeLine">                        << ") is not pipelined; moving from cycle " << OldCycle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2712</td>
    <td class="codeLine">                        << ") is not pipelined; moving from cycle " << OldCycle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeLine">                        << " to " << NewCycle << " Instr:" << *SU.getInstr());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2713</td>
    <td class="codeLine">                        << " to " << NewCycle << " Instr:" << *SU.getInstr());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2714</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeLine">    NewLastCycle = std::max(NewLastCycle, NewCycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2715</td>
    <td class="codeLine">    NewLastCycle = std::max(NewLastCycle, NewCycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2716</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeLine">  LastCycle = NewLastCycle;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2717</td>
    <td class="codeLine">  LastCycle = NewLastCycle;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2718</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2719</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeLine">// Check if the generated schedule is valid. This function checks if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2721</td>
    <td class="codeLine">// Check if the generated schedule is valid. This function checks if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeLine">// an instruction that uses a physical register is scheduled in a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2722</td>
    <td class="codeLine">// an instruction that uses a physical register is scheduled in a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeLine">// different stage than the definition. The pipeliner does not handle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2723</td>
    <td class="codeLine">// different stage than the definition. The pipeliner does not handle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeLine">// physical register values that may cross a basic block boundary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2724</td>
    <td class="codeLine">// physical register values that may cross a basic block boundary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeLine">// Furthermore, if a physical def/use pair is assigned to the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2725</td>
    <td class="codeLine">// Furthermore, if a physical def/use pair is assigned to the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeLine">// cycle, orderDependence does not guarantee def/use ordering, so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2726</td>
    <td class="codeLine">// cycle, orderDependence does not guarantee def/use ordering, so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeLine">// case should be considered invalid.  (The test checks for both</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2727</td>
    <td class="codeLine">// case should be considered invalid.  (The test checks for both</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeLine">// earlier and same-cycle use to be more robust.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2728</td>
    <td class="codeLine">// earlier and same-cycle use to be more robust.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeLine">bool SMSchedule::isValidSchedule(SwingSchedulerDAG *SSD) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2729</td>
    <td class="codeLine">bool SMSchedule::isValidSchedule(SwingSchedulerDAG *SSD) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeLine">  for (SUnit &SU : SSD->SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2730</td>
    <td class="codeLine">  for (SUnit &SU : SSD->SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeLine">    if (!SU.hasPhysRegDefs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2731</td>
    <td class="codeLine">    if (!SU.hasPhysRegDefs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2732</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeLine">    int StageDef = stageScheduled(&SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2733</td>
    <td class="codeLine">    int StageDef = stageScheduled(&SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeLine">    int CycleDef = InstrToCycle[&SU];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2734</td>
    <td class="codeLine">    int CycleDef = InstrToCycle[&SU];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeLine">    assert(StageDef != -1 && "Instruction should have been scheduled.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2735</td>
    <td class="codeLine">    assert(StageDef != -1 && "Instruction should have been scheduled.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeLine">    for (auto &SI : SU.Succs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2736</td>
    <td class="codeLine">    for (auto &SI : SU.Succs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeLine">      if (SI.isAssignedRegDep() && !SI.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2737</td>
    <td class="codeLine">      if (SI.isAssignedRegDep() && !SI.getSUnit()->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeLine">        if (Register::isPhysicalRegister(SI.getReg())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2738</td>
    <td class="codeLine">        if (Register::isPhysicalRegister(SI.getReg())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeLine">          if (stageScheduled(SI.getSUnit()) != StageDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2739</td>
    <td class="codeLine">          if (stageScheduled(SI.getSUnit()) != StageDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2740</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeLine">          if (InstrToCycle[SI.getSUnit()] <= CycleDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2741</td>
    <td class="codeLine">          if (InstrToCycle[SI.getSUnit()] <= CycleDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2742</td>
    <td class="codeLine">            return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2743</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2744</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2745</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2746</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeLine">/// A property of the node order in swing-modulo-scheduling is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2748</td>
    <td class="codeLine">/// A property of the node order in swing-modulo-scheduling is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeLine">/// that for nodes outside circuits the following holds:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2749</td>
    <td class="codeLine">/// that for nodes outside circuits the following holds:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeLine">/// none of them is scheduled after both a successor and a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2750</td>
    <td class="codeLine">/// none of them is scheduled after both a successor and a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeLine">/// predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2751</td>
    <td class="codeLine">/// predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeLine">/// The method below checks whether the property is met.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2752</td>
    <td class="codeLine">/// The method below checks whether the property is met.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeLine">/// If not, debug information is printed and statistics information updated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2753</td>
    <td class="codeLine">/// If not, debug information is printed and statistics information updated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeLine">/// Note that we do not use an assert statement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2754</td>
    <td class="codeLine">/// Note that we do not use an assert statement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeLine">/// The reason is that although an invalid node oder may prevent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2755</td>
    <td class="codeLine">/// The reason is that although an invalid node oder may prevent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeLine">/// the pipeliner from finding a pipelined schedule for arbitrary II,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2756</td>
    <td class="codeLine">/// the pipeliner from finding a pipelined schedule for arbitrary II,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeLine">/// it does not lead to the generation of incorrect code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2757</td>
    <td class="codeLine">/// it does not lead to the generation of incorrect code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeLine">void SwingSchedulerDAG::checkValidNodeOrder(const NodeSetType &Circuits) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2758</td>
    <td class="codeLine">void SwingSchedulerDAG::checkValidNodeOrder(const NodeSetType &Circuits) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeLine">  // a sorted vector that maps each SUnit to its index in the NodeOrder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2760</td>
    <td class="codeLine">  // a sorted vector that maps each SUnit to its index in the NodeOrder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeLine">  typedef std::pair<SUnit *, unsigned> UnitIndex;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2761</td>
    <td class="codeLine">  typedef std::pair<SUnit *, unsigned> UnitIndex;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeLine">  std::vector<UnitIndex> Indices(NodeOrder.size(), std::make_pair(nullptr, 0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2762</td>
    <td class="codeLine">  std::vector<UnitIndex> Indices(NodeOrder.size(), std::make_pair(nullptr, 0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeLine">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2764</td>
    <td class="codeLine">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeLine">    Indices.push_back(std::make_pair(NodeOrder[i], i));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2765</td>
    <td class="codeLine">    Indices.push_back(std::make_pair(NodeOrder[i], i));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeLine">  auto CompareKey = [](UnitIndex i1, UnitIndex i2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2767</td>
    <td class="codeLine">  auto CompareKey = [](UnitIndex i1, UnitIndex i2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeLine">    return std::get<0>(i1) < std::get<0>(i2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2768</td>
    <td class="codeLine">    return std::get<0>(i1) < std::get<0>(i2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2769</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeLine">  // sort, so that we can perform a binary search</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2771</td>
    <td class="codeLine">  // sort, so that we can perform a binary search</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeLine">  llvm::sort(Indices, CompareKey);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2772</td>
    <td class="codeLine">  llvm::sort(Indices, CompareKey);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeLine">  bool Valid = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2774</td>
    <td class="codeLine">  bool Valid = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeLine">  (void)Valid;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2775</td>
    <td class="codeLine">  (void)Valid;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeLine">  // for each SUnit in the NodeOrder, check whether</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2776</td>
    <td class="codeLine">  // for each SUnit in the NodeOrder, check whether</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeLine">  // it appears after both a successor and a predecessor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2777</td>
    <td class="codeLine">  // it appears after both a successor and a predecessor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeLine">  // of the SUnit. If this is the case, and the SUnit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2778</td>
    <td class="codeLine">  // of the SUnit. If this is the case, and the SUnit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeLine">  // is not part of circuit, then the NodeOrder is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2779</td>
    <td class="codeLine">  // is not part of circuit, then the NodeOrder is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeLine">  // valid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2780</td>
    <td class="codeLine">  // valid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeLine">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2781</td>
    <td class="codeLine">  for (unsigned i = 0, s = NodeOrder.size(); i < s; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeLine">    SUnit *SU = NodeOrder[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2782</td>
    <td class="codeLine">    SUnit *SU = NodeOrder[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeLine">    unsigned Index = i;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2783</td>
    <td class="codeLine">    unsigned Index = i;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeLine">    bool PredBefore = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2785</td>
    <td class="codeLine">    bool PredBefore = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeLine">    bool SuccBefore = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2786</td>
    <td class="codeLine">    bool SuccBefore = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeLine">    SUnit *Succ;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2788</td>
    <td class="codeLine">    SUnit *Succ;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeLine">    SUnit *Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2789</td>
    <td class="codeLine">    SUnit *Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeLine">    (void)Succ;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2790</td>
    <td class="codeLine">    (void)Succ;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeLine">    (void)Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2791</td>
    <td class="codeLine">    (void)Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeLine">    for (SDep &PredEdge : SU->Preds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2793</td>
    <td class="codeLine">    for (SDep &PredEdge : SU->Preds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeLine">      SUnit *PredSU = PredEdge.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2794</td>
    <td class="codeLine">      SUnit *PredSU = PredEdge.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeLine">      unsigned PredIndex = std::get<1>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2795</td>
    <td class="codeLine">      unsigned PredIndex = std::get<1>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeLine">          *llvm::lower_bound(Indices, std::make_pair(PredSU, 0), CompareKey));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2796</td>
    <td class="codeLine">          *llvm::lower_bound(Indices, std::make_pair(PredSU, 0), CompareKey));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeLine">      if (!PredSU->getInstr()->isPHI() && PredIndex < Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2797</td>
    <td class="codeLine">      if (!PredSU->getInstr()->isPHI() && PredIndex < Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeLine">        PredBefore = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2798</td>
    <td class="codeLine">        PredBefore = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeLine">        Pred = PredSU;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2799</td>
    <td class="codeLine">        Pred = PredSU;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2800</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2801</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2802</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeLine">    for (SDep &SuccEdge : SU->Succs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2804</td>
    <td class="codeLine">    for (SDep &SuccEdge : SU->Succs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeLine">      SUnit *SuccSU = SuccEdge.getSUnit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2805</td>
    <td class="codeLine">      SUnit *SuccSU = SuccEdge.getSUnit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeLine">      // Do not process a boundary node, it was not included in NodeOrder,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2806</td>
    <td class="codeLine">      // Do not process a boundary node, it was not included in NodeOrder,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeLine">      // hence not in Indices either, call to std::lower_bound() below will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2807</td>
    <td class="codeLine">      // hence not in Indices either, call to std::lower_bound() below will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeLine">      // return Indices.end().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2808</td>
    <td class="codeLine">      // return Indices.end().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeLine">      if (SuccSU->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2809</td>
    <td class="codeLine">      if (SuccSU->isBoundaryNode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2810</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeLine">      unsigned SuccIndex = std::get<1>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2811</td>
    <td class="codeLine">      unsigned SuccIndex = std::get<1>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeLine">          *llvm::lower_bound(Indices, std::make_pair(SuccSU, 0), CompareKey));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2812</td>
    <td class="codeLine">          *llvm::lower_bound(Indices, std::make_pair(SuccSU, 0), CompareKey));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeLine">      if (!SuccSU->getInstr()->isPHI() && SuccIndex < Index) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2813</td>
    <td class="codeLine">      if (!SuccSU->getInstr()->isPHI() && SuccIndex < Index) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeLine">        SuccBefore = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2814</td>
    <td class="codeLine">        SuccBefore = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeLine">        Succ = SuccSU;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2815</td>
    <td class="codeLine">        Succ = SuccSU;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2816</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2817</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2818</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeLine">    if (PredBefore && SuccBefore && !SU->getInstr()->isPHI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2820</td>
    <td class="codeLine">    if (PredBefore && SuccBefore && !SU->getInstr()->isPHI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeLine">      // instructions in circuits are allowed to be scheduled</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2821</td>
    <td class="codeLine">      // instructions in circuits are allowed to be scheduled</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeLine">      // after both a successor and predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2822</td>
    <td class="codeLine">      // after both a successor and predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeLine">      bool InCircuit = llvm::any_of(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2823</td>
    <td class="codeLine">      bool InCircuit = llvm::any_of(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeLine">          Circuits, [SU](const NodeSet &Circuit) { return Circuit.count(SU); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2824</td>
    <td class="codeLine">          Circuits, [SU](const NodeSet &Circuit) { return Circuit.count(SU); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeLine">      if (InCircuit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2825</td>
    <td class="codeLine">      if (InCircuit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "In a circuit, predecessor ";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2826</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "In a circuit, predecessor ";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2827</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeLine">        Valid = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2828</td>
    <td class="codeLine">        Valid = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeLine">        NumNodeOrderIssues++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2829</td>
    <td class="codeLine">        NumNodeOrderIssues++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Predecessor ";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2830</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Predecessor ";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2831</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << Pred->NodeNum << " and successor " << Succ->NodeNum</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2832</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << Pred->NodeNum << " and successor " << Succ->NodeNum</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeLine">                        << " are scheduled before node " << SU->NodeNum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2833</td>
    <td class="codeLine">                        << " are scheduled before node " << SU->NodeNum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeLine">                        << "\n";);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2834</td>
    <td class="codeLine">                        << "\n";);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2835</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2836</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2838</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeLine">    if (!Valid)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2839</td>
    <td class="codeLine">    if (!Valid)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeLine">      dbgs() << "Invalid node order found!\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2840</td>
    <td class="codeLine">      dbgs() << "Invalid node order found!\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2841</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2842</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeLine">/// Attempt to fix the degenerate cases when the instruction serialization</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2844</td>
    <td class="codeLine">/// Attempt to fix the degenerate cases when the instruction serialization</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeLine">/// causes the register lifetimes to overlap. For example,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2845</td>
    <td class="codeLine">/// causes the register lifetimes to overlap. For example,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeLine">///   p' = store_pi(p, b)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2846</td>
    <td class="codeLine">///   p' = store_pi(p, b)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeLine">///      = load p, offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2847</td>
    <td class="codeLine">///      = load p, offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeLine">/// In this case p and p' overlap, which means that two registers are needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2848</td>
    <td class="codeLine">/// In this case p and p' overlap, which means that two registers are needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeLine">/// Instead, this function changes the load to use p' and updates the offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2849</td>
    <td class="codeLine">/// Instead, this function changes the load to use p' and updates the offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeLine">void SwingSchedulerDAG::fixupRegisterOverlaps(std::deque<SUnit *> &Instrs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2850</td>
    <td class="codeLine">void SwingSchedulerDAG::fixupRegisterOverlaps(std::deque<SUnit *> &Instrs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeLine">  unsigned OverlapReg = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2851</td>
    <td class="codeLine">  unsigned OverlapReg = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeLine">  unsigned NewBaseReg = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2852</td>
    <td class="codeLine">  unsigned NewBaseReg = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeLine">  for (SUnit *SU : Instrs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2853</td>
    <td class="codeLine">  for (SUnit *SU : Instrs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeLine">    MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2854</td>
    <td class="codeLine">    MachineInstr *MI = SU->getInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeLine">    for (unsigned i = 0, e = MI->getNumOperands(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2855</td>
    <td class="codeLine">    for (unsigned i = 0, e = MI->getNumOperands(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeLine">      const MachineOperand &MO = MI->getOperand(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2856</td>
    <td class="codeLine">      const MachineOperand &MO = MI->getOperand(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeLine">      // Look for an instruction that uses p. The instruction occurs in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2857</td>
    <td class="codeLine">      // Look for an instruction that uses p. The instruction occurs in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeLine">      // same cycle but occurs later in the serialized order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2858</td>
    <td class="codeLine">      // same cycle but occurs later in the serialized order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeLine">      if (MO.isReg() && MO.isUse() && MO.getReg() == OverlapReg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2859</td>
    <td class="codeLine">      if (MO.isReg() && MO.isUse() && MO.getReg() == OverlapReg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeLine">        // Check that the instruction appears in the InstrChanges structure,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2860</td>
    <td class="codeLine">        // Check that the instruction appears in the InstrChanges structure,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeLine">        // which contains instructions that can have the offset updated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2861</td>
    <td class="codeLine">        // which contains instructions that can have the offset updated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeLine">        DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2862</td>
    <td class="codeLine">        DenseMap<SUnit *, std::pair<unsigned, int64_t>>::iterator It =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeLine">          InstrChanges.find(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2863</td>
    <td class="codeLine">          InstrChanges.find(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeLine">        if (It != InstrChanges.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2864</td>
    <td class="codeLine">        if (It != InstrChanges.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeLine">          unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2865</td>
    <td class="codeLine">          unsigned BasePos, OffsetPos;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeLine">          // Update the base register and adjust the offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2866</td>
    <td class="codeLine">          // Update the base register and adjust the offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeLine">          if (TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2867</td>
    <td class="codeLine">          if (TII->getBaseAndOffsetPosition(*MI, BasePos, OffsetPos)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeLine">            MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2868</td>
    <td class="codeLine">            MachineInstr *NewMI = MF.CloneMachineInstr(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeLine">            NewMI->getOperand(BasePos).setReg(NewBaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2869</td>
    <td class="codeLine">            NewMI->getOperand(BasePos).setReg(NewBaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeLine">            int64_t NewOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2870</td>
    <td class="codeLine">            int64_t NewOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeLine">                MI->getOperand(OffsetPos).getImm() - It->second.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2871</td>
    <td class="codeLine">                MI->getOperand(OffsetPos).getImm() - It->second.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeLine">            NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2872</td>
    <td class="codeLine">            NewMI->getOperand(OffsetPos).setImm(NewOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeLine">            SU->setInstr(NewMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2873</td>
    <td class="codeLine">            SU->setInstr(NewMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeLine">            MISUnitMap[NewMI] = SU;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2874</td>
    <td class="codeLine">            MISUnitMap[NewMI] = SU;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeLine">            NewMIs[MI] = NewMI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2875</td>
    <td class="codeLine">            NewMIs[MI] = NewMI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2876</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2877</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeLine">        OverlapReg = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2878</td>
    <td class="codeLine">        OverlapReg = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeLine">        NewBaseReg = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2879</td>
    <td class="codeLine">        NewBaseReg = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2880</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2881</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeLine">      // Look for an instruction of the form p' = op(p), which uses and defines</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2882</td>
    <td class="codeLine">      // Look for an instruction of the form p' = op(p), which uses and defines</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeLine">      // two virtual registers that get allocated to the same physical register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2883</td>
    <td class="codeLine">      // two virtual registers that get allocated to the same physical register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeLine">      unsigned TiedUseIdx = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2884</td>
    <td class="codeLine">      unsigned TiedUseIdx = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeLine">      if (MI->isRegTiedToUseOperand(i, &TiedUseIdx)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2885</td>
    <td class="codeLine">      if (MI->isRegTiedToUseOperand(i, &TiedUseIdx)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeLine">        // OverlapReg is p in the example above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2886</td>
    <td class="codeLine">        // OverlapReg is p in the example above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeLine">        OverlapReg = MI->getOperand(TiedUseIdx).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2887</td>
    <td class="codeLine">        OverlapReg = MI->getOperand(TiedUseIdx).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeLine">        // NewBaseReg is p' in the example above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2888</td>
    <td class="codeLine">        // NewBaseReg is p' in the example above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeLine">        NewBaseReg = MI->getOperand(i).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2889</td>
    <td class="codeLine">        NewBaseReg = MI->getOperand(i).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2890</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2891</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2892</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2893</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2894</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2895</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeLine">/// After the schedule has been formed, call this function to combine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2896</td>
    <td class="codeLine">/// After the schedule has been formed, call this function to combine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeLine">/// the instructions from the different stages/cycles.  That is, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2897</td>
    <td class="codeLine">/// the instructions from the different stages/cycles.  That is, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeLine">/// function creates a schedule that represents a single iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2898</td>
    <td class="codeLine">/// function creates a schedule that represents a single iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeLine">void SMSchedule::finalizeSchedule(SwingSchedulerDAG *SSD) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2899</td>
    <td class="codeLine">void SMSchedule::finalizeSchedule(SwingSchedulerDAG *SSD) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeLine">  // Move all instructions to the first stage from later stages.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2900</td>
    <td class="codeLine">  // Move all instructions to the first stage from later stages.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeLine">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2901</td>
    <td class="codeLine">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeLine">    for (int stage = 1, lastStage = getMaxStageCount(); stage <= lastStage;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2902</td>
    <td class="codeLine">    for (int stage = 1, lastStage = getMaxStageCount(); stage <= lastStage;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeLine">         ++stage) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2903</td>
    <td class="codeLine">         ++stage) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeLine">      std::deque<SUnit *> &cycleInstrs =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2904</td>
    <td class="codeLine">      std::deque<SUnit *> &cycleInstrs =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeLine">          ScheduledInstrs[cycle + (stage * InitiationInterval)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2905</td>
    <td class="codeLine">          ScheduledInstrs[cycle + (stage * InitiationInterval)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeLine">      for (SUnit *SU : llvm::reverse(cycleInstrs))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2906</td>
    <td class="codeLine">      for (SUnit *SU : llvm::reverse(cycleInstrs))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeLine">        ScheduledInstrs[cycle].push_front(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2907</td>
    <td class="codeLine">        ScheduledInstrs[cycle].push_front(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2908</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2909</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeLine">  // Erase all the elements in the later stages. Only one iteration should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2911</td>
    <td class="codeLine">  // Erase all the elements in the later stages. Only one iteration should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeLine">  // remain in the scheduled list, and it contains all the instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2912</td>
    <td class="codeLine">  // remain in the scheduled list, and it contains all the instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeLine">  for (int cycle = getFinalCycle() + 1; cycle <= LastCycle; ++cycle)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2913</td>
    <td class="codeLine">  for (int cycle = getFinalCycle() + 1; cycle <= LastCycle; ++cycle)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeLine">    ScheduledInstrs.erase(cycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2914</td>
    <td class="codeLine">    ScheduledInstrs.erase(cycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeLine">  // Change the registers in instruction as specified in the InstrChanges</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2916</td>
    <td class="codeLine">  // Change the registers in instruction as specified in the InstrChanges</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeLine">  // map. We need to use the new registers to create the correct order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2917</td>
    <td class="codeLine">  // map. We need to use the new registers to create the correct order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeLine">  for (const SUnit &SU : SSD->SUnits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2918</td>
    <td class="codeLine">  for (const SUnit &SU : SSD->SUnits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeLine">    SSD->applyInstrChange(SU.getInstr(), *this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2919</td>
    <td class="codeLine">    SSD->applyInstrChange(SU.getInstr(), *this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeLine">  // Reorder the instructions in each cycle to fix and improve the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2921</td>
    <td class="codeLine">  // Reorder the instructions in each cycle to fix and improve the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeLine">  // generated code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2922</td>
    <td class="codeLine">  // generated code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeLine">  for (int Cycle = getFirstCycle(), E = getFinalCycle(); Cycle <= E; ++Cycle) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2923</td>
    <td class="codeLine">  for (int Cycle = getFirstCycle(), E = getFinalCycle(); Cycle <= E; ++Cycle) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeLine">    std::deque<SUnit *> &cycleInstrs = ScheduledInstrs[Cycle];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2924</td>
    <td class="codeLine">    std::deque<SUnit *> &cycleInstrs = ScheduledInstrs[Cycle];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeLine">    std::deque<SUnit *> newOrderPhi;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2925</td>
    <td class="codeLine">    std::deque<SUnit *> newOrderPhi;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeLine">    for (SUnit *SU : cycleInstrs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2926</td>
    <td class="codeLine">    for (SUnit *SU : cycleInstrs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeLine">      if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2927</td>
    <td class="codeLine">      if (SU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeLine">        newOrderPhi.push_back(SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2928</td>
    <td class="codeLine">        newOrderPhi.push_back(SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2929</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeLine">    std::deque<SUnit *> newOrderI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2930</td>
    <td class="codeLine">    std::deque<SUnit *> newOrderI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeLine">    for (SUnit *SU : cycleInstrs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2931</td>
    <td class="codeLine">    for (SUnit *SU : cycleInstrs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeLine">      if (!SU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2932</td>
    <td class="codeLine">      if (!SU->getInstr()->isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeLine">        orderDependence(SSD, SU, newOrderI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2933</td>
    <td class="codeLine">        orderDependence(SSD, SU, newOrderI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2934</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeLine">    // Replace the old order with the new order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2935</td>
    <td class="codeLine">    // Replace the old order with the new order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeLine">    cycleInstrs.swap(newOrderPhi);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2936</td>
    <td class="codeLine">    cycleInstrs.swap(newOrderPhi);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeLine">    llvm::append_range(cycleInstrs, newOrderI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2937</td>
    <td class="codeLine">    llvm::append_range(cycleInstrs, newOrderI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeLine">    SSD->fixupRegisterOverlaps(cycleInstrs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2938</td>
    <td class="codeLine">    SSD->fixupRegisterOverlaps(cycleInstrs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2939</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeLine">  LLVM_DEBUG(dump(););</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2941</td>
    <td class="codeLine">  LLVM_DEBUG(dump(););</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2942</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeLine">void NodeSet::print(raw_ostream &os) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2944</td>
    <td class="codeLine">void NodeSet::print(raw_ostream &os) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeLine">  os << "Num nodes " << size() << " rec " << RecMII << " mov " << MaxMOV</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2945</td>
    <td class="codeLine">  os << "Num nodes " << size() << " rec " << RecMII << " mov " << MaxMOV</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeLine">     << " depth " << MaxDepth << " col " << Colocate << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2946</td>
    <td class="codeLine">     << " depth " << MaxDepth << " col " << Colocate << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeLine">  for (const auto &I : Nodes)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2947</td>
    <td class="codeLine">  for (const auto &I : Nodes)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeLine">    os << "   SU(" << I->NodeNum << ") " << *(I->getInstr());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2948</td>
    <td class="codeLine">    os << "   SU(" << I->NodeNum << ") " << *(I->getInstr());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeLine">  os << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2949</td>
    <td class="codeLine">  os << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2950</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2952</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeLine">/// Print the schedule information to the given output.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2953</td>
    <td class="codeLine">/// Print the schedule information to the given output.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeLine">void SMSchedule::print(raw_ostream &os) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2954</td>
    <td class="codeLine">void SMSchedule::print(raw_ostream &os) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeLine">  // Iterate over each cycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2955</td>
    <td class="codeLine">  // Iterate over each cycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeLine">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2956</td>
    <td class="codeLine">  for (int cycle = getFirstCycle(); cycle <= getFinalCycle(); ++cycle) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeLine">    // Iterate over each instruction in the cycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2957</td>
    <td class="codeLine">    // Iterate over each instruction in the cycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeLine">    const_sched_iterator cycleInstrs = ScheduledInstrs.find(cycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2958</td>
    <td class="codeLine">    const_sched_iterator cycleInstrs = ScheduledInstrs.find(cycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeLine">    for (SUnit *CI : cycleInstrs->second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2959</td>
    <td class="codeLine">    for (SUnit *CI : cycleInstrs->second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeLine">      os << "cycle " << cycle << " (" << stageScheduled(CI) << ") ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2960</td>
    <td class="codeLine">      os << "cycle " << cycle << " (" << stageScheduled(CI) << ") ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeLine">      os << "(" << CI->NodeNum << ") ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2961</td>
    <td class="codeLine">      os << "(" << CI->NodeNum << ") ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeLine">      CI->getInstr()->print(os);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2962</td>
    <td class="codeLine">      CI->getInstr()->print(os);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeLine">      os << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2963</td>
    <td class="codeLine">      os << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2964</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2965</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2966</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeLine">/// Utility function used for debugging to print the schedule.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2968</td>
    <td class="codeLine">/// Utility function used for debugging to print the schedule.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeLine">LLVM_DUMP_METHOD void SMSchedule::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2969</td>
    <td class="codeLine">LLVM_DUMP_METHOD void SMSchedule::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeLine">LLVM_DUMP_METHOD void NodeSet::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2970</td>
    <td class="codeLine">LLVM_DUMP_METHOD void NodeSet::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeLine">void ResourceManager::dumpMRT() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2972</td>
    <td class="codeLine">void ResourceManager::dumpMRT() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2973</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeLine">    if (UseDFA)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2974</td>
    <td class="codeLine">    if (UseDFA)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2975</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeLine">    std::stringstream SS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2976</td>
    <td class="codeLine">    std::stringstream SS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeLine">    SS << "MRT:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2977</td>
    <td class="codeLine">    SS << "MRT:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeLine">    SS << std::setw(4) << "Slot";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2978</td>
    <td class="codeLine">    SS << std::setw(4) << "Slot";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeLine">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2979</td>
    <td class="codeLine">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeLine">      SS << std::setw(3) << I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2980</td>
    <td class="codeLine">      SS << std::setw(3) << I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeLine">    SS << std::setw(7) << "#Mops"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2981</td>
    <td class="codeLine">    SS << std::setw(7) << "#Mops"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeLine">       << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2982</td>
    <td class="codeLine">       << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeLine">    for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2983</td>
    <td class="codeLine">    for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeLine">      SS << std::setw(4) << Slot;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2984</td>
    <td class="codeLine">      SS << std::setw(4) << Slot;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeLine">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2985</td>
    <td class="codeLine">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeLine">        SS << std::setw(3) << MRT[Slot][I];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2986</td>
    <td class="codeLine">        SS << std::setw(3) << MRT[Slot][I];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeLine">      SS << std::setw(7) << NumScheduledMops[Slot] << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2987</td>
    <td class="codeLine">      SS << std::setw(7) << NumScheduledMops[Slot] << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2988</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeLine">    dbgs() << SS.str();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2989</td>
    <td class="codeLine">    dbgs() << SS.str();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2990</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2991</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2992</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeLine">void ResourceManager::initProcResourceVectors(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2994</td>
    <td class="codeLine">void ResourceManager::initProcResourceVectors(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeLine">    const MCSchedModel &SM, SmallVectorImpl<uint64_t> &Masks) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2995</td>
    <td class="codeLine">    const MCSchedModel &SM, SmallVectorImpl<uint64_t> &Masks) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeLine">  unsigned ProcResourceID = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2996</td>
    <td class="codeLine">  unsigned ProcResourceID = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeLine">  // We currently limit the resource kinds to 64 and below so that we can use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2998</td>
    <td class="codeLine">  // We currently limit the resource kinds to 64 and below so that we can use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeLine">  // uint64_t for Masks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2999</td>
    <td class="codeLine">  // uint64_t for Masks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeLine">  assert(SM.getNumProcResourceKinds() < 64 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3000</td>
    <td class="codeLine">  assert(SM.getNumProcResourceKinds() < 64 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeLine">         "Too many kinds of resources, unsupported");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3001</td>
    <td class="codeLine">         "Too many kinds of resources, unsupported");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeLine">  // Create a unique bitmask for every processor resource unit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3002</td>
    <td class="codeLine">  // Create a unique bitmask for every processor resource unit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeLine">  // Skip resource at index 0, since it always references 'InvalidUnit'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3003</td>
    <td class="codeLine">  // Skip resource at index 0, since it always references 'InvalidUnit'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeLine">  Masks.resize(SM.getNumProcResourceKinds());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3004</td>
    <td class="codeLine">  Masks.resize(SM.getNumProcResourceKinds());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3005</td>
    <td class="codeLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeLine">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3006</td>
    <td class="codeLine">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeLine">    if (Desc.SubUnitsIdxBegin)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3007</td>
    <td class="codeLine">    if (Desc.SubUnitsIdxBegin)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3008</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeLine">    Masks[I] = 1ULL << ProcResourceID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3009</td>
    <td class="codeLine">    Masks[I] = 1ULL << ProcResourceID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeLine">    ProcResourceID++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3010</td>
    <td class="codeLine">    ProcResourceID++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3011</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeLine">  // Create a unique bitmask for every processor resource group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3012</td>
    <td class="codeLine">  // Create a unique bitmask for every processor resource group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3013</td>
    <td class="codeLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeLine">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3014</td>
    <td class="codeLine">    const MCProcResourceDesc &Desc = *SM.getProcResource(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeLine">    if (!Desc.SubUnitsIdxBegin)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3015</td>
    <td class="codeLine">    if (!Desc.SubUnitsIdxBegin)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3016</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeLine">    Masks[I] = 1ULL << ProcResourceID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3017</td>
    <td class="codeLine">    Masks[I] = 1ULL << ProcResourceID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeLine">    for (unsigned U = 0; U < Desc.NumUnits; ++U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3018</td>
    <td class="codeLine">    for (unsigned U = 0; U < Desc.NumUnits; ++U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeLine">      Masks[I] |= Masks[Desc.SubUnitsIdxBegin[U]];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3019</td>
    <td class="codeLine">      Masks[I] |= Masks[Desc.SubUnitsIdxBegin[U]];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeLine">    ProcResourceID++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3020</td>
    <td class="codeLine">    ProcResourceID++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3021</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3022</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeLine">    if (SwpShowResMask) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3023</td>
    <td class="codeLine">    if (SwpShowResMask) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeLine">      dbgs() << "ProcResourceDesc:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3024</td>
    <td class="codeLine">      dbgs() << "ProcResourceDesc:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeLine">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3025</td>
    <td class="codeLine">      for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeLine">        const MCProcResourceDesc *ProcResource = SM.getProcResource(I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3026</td>
    <td class="codeLine">        const MCProcResourceDesc *ProcResource = SM.getProcResource(I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeLine">        dbgs() << format(" %16s(%2d): Mask: 0x%08x, NumUnits:%2d\n",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3027</td>
    <td class="codeLine">        dbgs() << format(" %16s(%2d): Mask: 0x%08x, NumUnits:%2d\n",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeLine">                         ProcResource->Name, I, Masks[I],</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3028</td>
    <td class="codeLine">                         ProcResource->Name, I, Masks[I],</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeLine">                         ProcResource->NumUnits);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3029</td>
    <td class="codeLine">                         ProcResource->NumUnits);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3030</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeLine">      dbgs() << " -----------------\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3031</td>
    <td class="codeLine">      dbgs() << " -----------------\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3032</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3033</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3034</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeLine">bool ResourceManager::canReserveResources(SUnit &SU, int Cycle) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3036</td>
    <td class="codeLine">bool ResourceManager::canReserveResources(SUnit &SU, int Cycle) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3037</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeLine">    if (SwpDebugResource)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3038</td>
    <td class="codeLine">    if (SwpDebugResource)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeLine">      dbgs() << "canReserveResources:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3039</td>
    <td class="codeLine">      dbgs() << "canReserveResources:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3040</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeLine">  if (UseDFA)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3041</td>
    <td class="codeLine">  if (UseDFA)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeLine">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3042</td>
    <td class="codeLine">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeLine">        ->canReserveResources(&SU.getInstr()->getDesc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3043</td>
    <td class="codeLine">        ->canReserveResources(&SU.getInstr()->getDesc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeLine">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3045</td>
    <td class="codeLine">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeLine">  if (!SCDesc->isValid()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3046</td>
    <td class="codeLine">  if (!SCDesc->isValid()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3047</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeLine">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3048</td>
    <td class="codeLine">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeLine">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3049</td>
    <td class="codeLine">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3050</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3051</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3052</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeLine">  reserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3054</td>
    <td class="codeLine">  reserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeLine">  bool Result = !isOverbooked();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3055</td>
    <td class="codeLine">  bool Result = !isOverbooked();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeLine">  unreserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3056</td>
    <td class="codeLine">  unreserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeLine">  LLVM_DEBUG(if (SwpDebugResource) dbgs() << "return " << Result << "\n\n";);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3058</td>
    <td class="codeLine">  LLVM_DEBUG(if (SwpDebugResource) dbgs() << "return " << Result << "\n\n";);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3059</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3060</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3061</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeLine">void ResourceManager::reserveResources(SUnit &SU, int Cycle) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3062</td>
    <td class="codeLine">void ResourceManager::reserveResources(SUnit &SU, int Cycle) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3063</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeLine">    if (SwpDebugResource)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3064</td>
    <td class="codeLine">    if (SwpDebugResource)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeLine">      dbgs() << "reserveResources:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3065</td>
    <td class="codeLine">      dbgs() << "reserveResources:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3066</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeLine">  if (UseDFA)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3067</td>
    <td class="codeLine">  if (UseDFA)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeLine">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3068</td>
    <td class="codeLine">    return DFAResources[positiveModulo(Cycle, InitiationInterval)]</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeLine">        ->reserveResources(&SU.getInstr()->getDesc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3069</td>
    <td class="codeLine">        ->reserveResources(&SU.getInstr()->getDesc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3070</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeLine">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3071</td>
    <td class="codeLine">  const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeLine">  if (!SCDesc->isValid()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3072</td>
    <td class="codeLine">  if (!SCDesc->isValid()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3073</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeLine">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3074</td>
    <td class="codeLine">      dbgs() << "No valid Schedule Class Desc for schedClass!\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeLine">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3075</td>
    <td class="codeLine">      dbgs() << "isPseudo:" << SU.getInstr()->isPseudo() << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3076</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3077</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3078</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="codeLine">  reserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3080</td>
    <td class="codeLine">  reserveResources(SCDesc, Cycle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3082</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="codeLine">    if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3083</td>
    <td class="codeLine">    if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="codeLine">      dumpMRT();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3084</td>
    <td class="codeLine">      dumpMRT();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="codeLine">      dbgs() << "reserveResources: done!\n\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3085</td>
    <td class="codeLine">      dbgs() << "reserveResources: done!\n\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3086</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3087</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3088</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="codeLine">void ResourceManager::reserveResources(const MCSchedClassDesc *SCDesc,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3090</td>
    <td class="codeLine">void ResourceManager::reserveResources(const MCSchedClassDesc *SCDesc,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="codeLine">                                       int Cycle) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3091</td>
    <td class="codeLine">                                       int Cycle) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="codeLine">  assert(!UseDFA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3092</td>
    <td class="codeLine">  assert(!UseDFA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="codeLine">  for (const MCWriteProcResEntry &PRE : make_range(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3093</td>
    <td class="codeLine">  for (const MCWriteProcResEntry &PRE : make_range(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="codeLine">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3094</td>
    <td class="codeLine">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="codeLine">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3095</td>
    <td class="codeLine">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="codeLine">      ++MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3096</td>
    <td class="codeLine">      ++MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="codeLine">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3098</td>
    <td class="codeLine">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="codeLine">    ++NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3099</td>
    <td class="codeLine">    ++NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3100</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="codeLine">void ResourceManager::unreserveResources(const MCSchedClassDesc *SCDesc,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3102</td>
    <td class="codeLine">void ResourceManager::unreserveResources(const MCSchedClassDesc *SCDesc,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="codeLine">                                         int Cycle) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3103</td>
    <td class="codeLine">                                         int Cycle) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="codeLine">  assert(!UseDFA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3104</td>
    <td class="codeLine">  assert(!UseDFA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="codeLine">  for (const MCWriteProcResEntry &PRE : make_range(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3105</td>
    <td class="codeLine">  for (const MCWriteProcResEntry &PRE : make_range(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="codeLine">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3106</td>
    <td class="codeLine">           STI->getWriteProcResBegin(SCDesc), STI->getWriteProcResEnd(SCDesc)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="codeLine">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3107</td>
    <td class="codeLine">    for (int C = Cycle; C < Cycle + PRE.Cycles; ++C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="codeLine">      --MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3108</td>
    <td class="codeLine">      --MRT[positiveModulo(C, InitiationInterval)][PRE.ProcResourceIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="codeLine">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3110</td>
    <td class="codeLine">  for (int C = Cycle; C < Cycle + SCDesc->NumMicroOps; ++C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="codeLine">    --NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3111</td>
    <td class="codeLine">    --NumScheduledMops[positiveModulo(C, InitiationInterval)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3112</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="codeLine">bool ResourceManager::isOverbooked() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3114</td>
    <td class="codeLine">bool ResourceManager::isOverbooked() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="codeLine">  assert(!UseDFA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3115</td>
    <td class="codeLine">  assert(!UseDFA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="codeLine">  for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3116</td>
    <td class="codeLine">  for (int Slot = 0; Slot < InitiationInterval; ++Slot) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="codeLine">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3117</td>
    <td class="codeLine">    for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="codeLine">      const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3118</td>
    <td class="codeLine">      const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="codeLine">      if (MRT[Slot][I] > Desc->NumUnits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3119</td>
    <td class="codeLine">      if (MRT[Slot][I] > Desc->NumUnits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3120</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3121</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="codeLine">    if (NumScheduledMops[Slot] > IssueWidth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3122</td>
    <td class="codeLine">    if (NumScheduledMops[Slot] > IssueWidth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3123</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3124</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3125</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3126</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="codeLine">int ResourceManager::calculateResMIIDFA() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3128</td>
    <td class="codeLine">int ResourceManager::calculateResMIIDFA() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="codeLine">  assert(UseDFA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3129</td>
    <td class="codeLine">  assert(UseDFA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="codeLine">  // Sort the instructions by the number of available choices for scheduling,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3131</td>
    <td class="codeLine">  // Sort the instructions by the number of available choices for scheduling,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="codeLine">  // least to most. Use the number of critical resources as the tie breaker.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3132</td>
    <td class="codeLine">  // least to most. Use the number of critical resources as the tie breaker.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="codeLine">  FuncUnitSorter FUS = FuncUnitSorter(*ST);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3133</td>
    <td class="codeLine">  FuncUnitSorter FUS = FuncUnitSorter(*ST);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="codeLine">  for (SUnit &SU : DAG->SUnits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3134</td>
    <td class="codeLine">  for (SUnit &SU : DAG->SUnits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="codeLine">    FUS.calcCriticalResources(*SU.getInstr());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3135</td>
    <td class="codeLine">    FUS.calcCriticalResources(*SU.getInstr());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="codeLine">  PriorityQueue<MachineInstr *, std::vector<MachineInstr *>, FuncUnitSorter></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3136</td>
    <td class="codeLine">  PriorityQueue<MachineInstr *, std::vector<MachineInstr *>, FuncUnitSorter></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="codeLine">      FuncUnitOrder(FUS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3137</td>
    <td class="codeLine">      FuncUnitOrder(FUS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="codeLine">  for (SUnit &SU : DAG->SUnits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3139</td>
    <td class="codeLine">  for (SUnit &SU : DAG->SUnits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="codeLine">    FuncUnitOrder.push(SU.getInstr());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3140</td>
    <td class="codeLine">    FuncUnitOrder.push(SU.getInstr());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="codeLine">  SmallVector<std::unique_ptr<DFAPacketizer>, 8> Resources;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3142</td>
    <td class="codeLine">  SmallVector<std::unique_ptr<DFAPacketizer>, 8> Resources;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="codeLine">  Resources.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3143</td>
    <td class="codeLine">  Resources.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="codeLine">      std::unique_ptr<DFAPacketizer>(TII->CreateTargetScheduleState(*ST)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3144</td>
    <td class="codeLine">      std::unique_ptr<DFAPacketizer>(TII->CreateTargetScheduleState(*ST)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="codeLine">  while (!FuncUnitOrder.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3146</td>
    <td class="codeLine">  while (!FuncUnitOrder.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="codeLine">    MachineInstr *MI = FuncUnitOrder.top();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3147</td>
    <td class="codeLine">    MachineInstr *MI = FuncUnitOrder.top();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="codeLine">    FuncUnitOrder.pop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3148</td>
    <td class="codeLine">    FuncUnitOrder.pop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="codeLine">    if (TII->isZeroCost(MI->getOpcode()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3149</td>
    <td class="codeLine">    if (TII->isZeroCost(MI->getOpcode()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3150</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="codeLine">    // Attempt to reserve the instruction in an existing DFA. At least one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3152</td>
    <td class="codeLine">    // Attempt to reserve the instruction in an existing DFA. At least one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="codeLine">    // DFA is needed for each cycle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3153</td>
    <td class="codeLine">    // DFA is needed for each cycle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="codeLine">    unsigned NumCycles = DAG->getSUnit(MI)->Latency;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3154</td>
    <td class="codeLine">    unsigned NumCycles = DAG->getSUnit(MI)->Latency;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="codeLine">    unsigned ReservedCycles = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3155</td>
    <td class="codeLine">    unsigned ReservedCycles = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="codeLine">    auto *RI = Resources.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3156</td>
    <td class="codeLine">    auto *RI = Resources.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="codeLine">    auto *RE = Resources.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3157</td>
    <td class="codeLine">    auto *RE = Resources.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3158</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="codeLine">      dbgs() << "Trying to reserve resource for " << NumCycles</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3159</td>
    <td class="codeLine">      dbgs() << "Trying to reserve resource for " << NumCycles</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="codeLine">             << " cycles for \n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3160</td>
    <td class="codeLine">             << " cycles for \n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="codeLine">      MI->dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3161</td>
    <td class="codeLine">      MI->dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3162</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="codeLine">    for (unsigned C = 0; C < NumCycles; ++C)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3163</td>
    <td class="codeLine">    for (unsigned C = 0; C < NumCycles; ++C)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="codeLine">      while (RI != RE) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3164</td>
    <td class="codeLine">      while (RI != RE) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="codeLine">        if ((*RI)->canReserveResources(*MI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3165</td>
    <td class="codeLine">        if ((*RI)->canReserveResources(*MI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="codeLine">          (*RI)->reserveResources(*MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3166</td>
    <td class="codeLine">          (*RI)->reserveResources(*MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="codeLine">          ++ReservedCycles;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3167</td>
    <td class="codeLine">          ++ReservedCycles;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3168</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3169</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="codeLine">        RI++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3170</td>
    <td class="codeLine">        RI++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3171</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "ReservedCycles:" << ReservedCycles</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3172</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "ReservedCycles:" << ReservedCycles</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="codeLine">                      << ", NumCycles:" << NumCycles << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3173</td>
    <td class="codeLine">                      << ", NumCycles:" << NumCycles << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="codeLine">    // Add new DFAs, if needed, to reserve resources.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3174</td>
    <td class="codeLine">    // Add new DFAs, if needed, to reserve resources.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="codeLine">    for (unsigned C = ReservedCycles; C < NumCycles; ++C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3175</td>
    <td class="codeLine">    for (unsigned C = ReservedCycles; C < NumCycles; ++C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="codeLine">      LLVM_DEBUG(if (SwpDebugResource) dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3176</td>
    <td class="codeLine">      LLVM_DEBUG(if (SwpDebugResource) dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="codeLine">                 << "NewResource created to reserve resources"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3177</td>
    <td class="codeLine">                 << "NewResource created to reserve resources"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="codeLine">                 << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3178</td>
    <td class="codeLine">                 << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="codeLine">      auto *NewResource = TII->CreateTargetScheduleState(*ST);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3179</td>
    <td class="codeLine">      auto *NewResource = TII->CreateTargetScheduleState(*ST);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="codeLine">      assert(NewResource->canReserveResources(*MI) && "Reserve error.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3180</td>
    <td class="codeLine">      assert(NewResource->canReserveResources(*MI) && "Reserve error.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="codeLine">      NewResource->reserveResources(*MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3181</td>
    <td class="codeLine">      NewResource->reserveResources(*MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="codeLine">      Resources.push_back(std::unique_ptr<DFAPacketizer>(NewResource));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3182</td>
    <td class="codeLine">      Resources.push_back(std::unique_ptr<DFAPacketizer>(NewResource));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3183</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3184</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="codeLine">  int Resmii = Resources.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3186</td>
    <td class="codeLine">  int Resmii = Resources.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Return Res MII:" << Resmii << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3187</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Return Res MII:" << Resmii << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="codeLine">  return Resmii;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3188</td>
    <td class="codeLine">  return Resmii;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3189</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="codeLine">int ResourceManager::calculateResMII() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3191</td>
    <td class="codeLine">int ResourceManager::calculateResMII() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="codeLine">  if (UseDFA)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3192</td>
    <td class="codeLine">  if (UseDFA)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="codeLine">    return calculateResMIIDFA();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3193</td>
    <td class="codeLine">    return calculateResMIIDFA();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="codeLine">  // Count each resource consumption and divide it by the number of units.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3195</td>
    <td class="codeLine">  // Count each resource consumption and divide it by the number of units.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="codeLine">  // ResMII is the max value among them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3196</td>
    <td class="codeLine">  // ResMII is the max value among them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="codeLine">  int NumMops = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3198</td>
    <td class="codeLine">  int NumMops = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="codeLine">  SmallVector<uint64_t> ResourceCount(SM.getNumProcResourceKinds());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3199</td>
    <td class="codeLine">  SmallVector<uint64_t> ResourceCount(SM.getNumProcResourceKinds());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="codeLine">  for (SUnit &SU : DAG->SUnits) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3200</td>
    <td class="codeLine">  for (SUnit &SU : DAG->SUnits) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="codeLine">    if (TII->isZeroCost(SU.getInstr()->getOpcode()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3201</td>
    <td class="codeLine">    if (TII->isZeroCost(SU.getInstr()->getOpcode()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3202</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="codeLine">    const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3204</td>
    <td class="codeLine">    const MCSchedClassDesc *SCDesc = DAG->getSchedClass(&SU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="codeLine">    if (!SCDesc->isValid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3205</td>
    <td class="codeLine">    if (!SCDesc->isValid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3206</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3208</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="codeLine">      if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3209</td>
    <td class="codeLine">      if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="codeLine">        DAG->dumpNode(SU);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3210</td>
    <td class="codeLine">        DAG->dumpNode(SU);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="codeLine">        dbgs() << "  #Mops: " << SCDesc->NumMicroOps << "\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3211</td>
    <td class="codeLine">        dbgs() << "  #Mops: " << SCDesc->NumMicroOps << "\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="codeLine">               << "  WriteProcRes: ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3212</td>
    <td class="codeLine">               << "  WriteProcRes: ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3213</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3214</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="codeLine">    NumMops += SCDesc->NumMicroOps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3215</td>
    <td class="codeLine">    NumMops += SCDesc->NumMicroOps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="codeLine">    for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3216</td>
    <td class="codeLine">    for (const MCWriteProcResEntry &PRE :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="codeLine">         make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3217</td>
    <td class="codeLine">         make_range(STI->getWriteProcResBegin(SCDesc),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="codeLine">                    STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3218</td>
    <td class="codeLine">                    STI->getWriteProcResEnd(SCDesc))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3219</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="codeLine">        if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3220</td>
    <td class="codeLine">        if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="codeLine">          const MCProcResourceDesc *Desc =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3221</td>
    <td class="codeLine">          const MCProcResourceDesc *Desc =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="codeLine">              SM.getProcResource(PRE.ProcResourceIdx);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3222</td>
    <td class="codeLine">              SM.getProcResource(PRE.ProcResourceIdx);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="codeLine">          dbgs() << Desc->Name << ": " << PRE.Cycles << ", ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3223</td>
    <td class="codeLine">          dbgs() << Desc->Name << ": " << PRE.Cycles << ", ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3224</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3225</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="codeLine">      ResourceCount[PRE.ProcResourceIdx] += PRE.Cycles;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3226</td>
    <td class="codeLine">      ResourceCount[PRE.ProcResourceIdx] += PRE.Cycles;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3227</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="codeLine">    LLVM_DEBUG(if (SwpDebugResource) dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3228</td>
    <td class="codeLine">    LLVM_DEBUG(if (SwpDebugResource) dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3229</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="codeLine">  int Result = (NumMops + IssueWidth - 1) / IssueWidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3231</td>
    <td class="codeLine">  int Result = (NumMops + IssueWidth - 1) / IssueWidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3232</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="codeLine">    if (SwpDebugResource)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3233</td>
    <td class="codeLine">    if (SwpDebugResource)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="codeLine">      dbgs() << "#Mops: " << NumMops << ", "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3234</td>
    <td class="codeLine">      dbgs() << "#Mops: " << NumMops << ", "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="codeLine">             << "IssueWidth: " << IssueWidth << ", "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3235</td>
    <td class="codeLine">             << "IssueWidth: " << IssueWidth << ", "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="codeLine">             << "Cycles: " << Result << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3236</td>
    <td class="codeLine">             << "Cycles: " << Result << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3237</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3239</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="codeLine">    if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3240</td>
    <td class="codeLine">    if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="codeLine">      std::stringstream SS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3241</td>
    <td class="codeLine">      std::stringstream SS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="codeLine">      SS << std::setw(2) << "ID" << std::setw(16) << "Name" << std::setw(10)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3242</td>
    <td class="codeLine">      SS << std::setw(2) << "ID" << std::setw(16) << "Name" << std::setw(10)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="codeLine">         << "Units" << std::setw(10) << "Consumed" << std::setw(10) << "Cycles"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3243</td>
    <td class="codeLine">         << "Units" << std::setw(10) << "Consumed" << std::setw(10) << "Cycles"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="codeLine">         << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3244</td>
    <td class="codeLine">         << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="codeLine">      dbgs() << SS.str();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3245</td>
    <td class="codeLine">      dbgs() << SS.str();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3246</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3247</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="codeLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3248</td>
    <td class="codeLine">  for (unsigned I = 1, E = SM.getNumProcResourceKinds(); I < E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="codeLine">    const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3249</td>
    <td class="codeLine">    const MCProcResourceDesc *Desc = SM.getProcResource(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="codeLine">    int Cycles = (ResourceCount[I] + Desc->NumUnits - 1) / Desc->NumUnits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3250</td>
    <td class="codeLine">    int Cycles = (ResourceCount[I] + Desc->NumUnits - 1) / Desc->NumUnits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3251</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="codeLine">      if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3252</td>
    <td class="codeLine">      if (SwpDebugResource) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="codeLine">        std::stringstream SS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3253</td>
    <td class="codeLine">        std::stringstream SS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="codeLine">        SS << std::setw(2) << I << std::setw(16) << Desc->Name << std::setw(10)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3254</td>
    <td class="codeLine">        SS << std::setw(2) << I << std::setw(16) << Desc->Name << std::setw(10)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="codeLine">           << Desc->NumUnits << std::setw(10) << ResourceCount[I]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3255</td>
    <td class="codeLine">           << Desc->NumUnits << std::setw(10) << ResourceCount[I]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="codeLine">           << std::setw(10) << Cycles << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3256</td>
    <td class="codeLine">           << std::setw(10) << Cycles << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="codeLine">        dbgs() << SS.str();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3257</td>
    <td class="codeLine">        dbgs() << SS.str();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3258</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3259</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="codeLine">    if (Cycles > Result)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3260</td>
    <td class="codeLine">    if (Cycles > Result)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="codeLine">      Result = Cycles;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3261</td>
    <td class="codeLine">      Result = Cycles;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3262</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3263</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3264</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="codeLine">void ResourceManager::init(int II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3266</td>
    <td class="codeLine">void ResourceManager::init(int II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="codeLine">  InitiationInterval = II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3267</td>
    <td class="codeLine">  InitiationInterval = II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="codeLine">  DFAResources.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3268</td>
    <td class="codeLine">  DFAResources.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="codeLine">  DFAResources.resize(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3269</td>
    <td class="codeLine">  DFAResources.resize(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="codeLine">  for (auto &I : DFAResources)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3270</td>
    <td class="codeLine">  for (auto &I : DFAResources)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="codeLine">    I.reset(ST->getInstrInfo()->CreateTargetScheduleState(*ST));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3271</td>
    <td class="codeLine">    I.reset(ST->getInstrInfo()->CreateTargetScheduleState(*ST));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="codeLine">  MRT.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3272</td>
    <td class="codeLine">  MRT.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="codeLine">  MRT.resize(II, SmallVector<uint64_t>(SM.getNumProcResourceKinds()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3273</td>
    <td class="codeLine">  MRT.resize(II, SmallVector<uint64_t>(SM.getNumProcResourceKinds()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="codeLine">  NumScheduledMops.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3274</td>
    <td class="codeLine">  NumScheduledMops.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="codeLine">  NumScheduledMops.resize(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3275</td>
    <td class="codeLine">  NumScheduledMops.resize(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3276</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>