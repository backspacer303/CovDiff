<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>STLExtras.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/ADT/STLExtras.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// This file contains some templates that are useful if you are working with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// the STL at all.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">/// No library is required when using these functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#ifndef LLVM_ADT_STLEXTRAS_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#define LLVM_ADT_STLEXTRAS_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/ADT/ADL.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/ADT/Hashing.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/ADT/STLForwardCompat.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/ADT/STLFunctionalExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/ADT/identity.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/ADT/iterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/ADT/iterator_range.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/Config/abi-breaking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include <cstddef></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include <cstdlib></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include <functional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include <initializer_list></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include <limits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include <memory></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include <tuple></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include <type_traits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#ifdef EXPENSIVE_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include <random> // for std::mt19937</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">//     Extra additions to <type_traits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">template <typename T> struct make_const_ptr {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">  using type = std::add_pointer_t<std::add_const_t<T>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">template <typename T> struct make_const_ref {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">  using type = std::add_lvalue_reference_t<std::add_const_t<T>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">template <class, template <class...> class Op, class... Args> struct detector {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">  using value_t = std::false_type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">template <template <class...> class Op, class... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">struct detector<std::void_t<Op<Args...>>, Op, Args...> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">  using value_t = std::true_type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">} // end namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">/// Detects if a given trait holds for some set of arguments 'Args'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">/// For example, the given trait could be used to detect if a given type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">/// has a copy assignment operator:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">///   template<class T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">///   using has_copy_assign_t = decltype(std::declval<T&>()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">///                                                 = std::declval<const T&>());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">template <template <class...> class Op, class... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">using is_detected = typename detail::detector<void, Op, Args...>::value_t;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">/// This class provides various trait information about a callable object.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">///   * To access the number of arguments: Traits::num_args</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">///   * To access the type of an argument: Traits::arg_t<Index></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">///   * To access the type of the result:  Traits::result_t</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">template <typename T, bool isClass = std::is_class<T>::value></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">struct function_traits : public function_traits<decltype(&T::operator())> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">/// Overload for class function types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">template <typename ClassType, typename ReturnType, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  /// The number of arguments to this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  enum { num_args = sizeof...(Args) };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  /// The result type of this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">  using result_t = ReturnType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  /// The type of an argument to this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  template <size_t Index></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  using arg_t = std::tuple_element_t<Index, std::tuple<Args...>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">/// Overload for class function types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">template <typename ClassType, typename ReturnType, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">struct function_traits<ReturnType (ClassType::*)(Args...), false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">/// Overload for non-class function types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">template <typename ReturnType, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">struct function_traits<ReturnType (*)(Args...), false> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  /// The number of arguments to this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  enum { num_args = sizeof...(Args) };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  /// The result type of this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">  using result_t = ReturnType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">  /// The type of an argument to this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">  template <size_t i></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  using arg_t = std::tuple_element_t<i, std::tuple<Args...>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">template <typename ReturnType, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">struct function_traits<ReturnType (*const)(Args...), false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">    : public function_traits<ReturnType (*)(Args...)> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">/// Overload for non-class function type references.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">template <typename ReturnType, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">struct function_traits<ReturnType (&)(Args...), false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">    : public function_traits<ReturnType (*)(Args...)> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">/// traits class for checking whether type T is one of any of the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">/// types in the variadic list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">template <typename T, typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">/// traits class for checking whether type T is a base class for all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">///  the given types in the variadic list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">template <typename T, typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">template <typename T, typename... Us> struct TypesAreDistinct;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">template <typename T, typename... Us></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">struct TypesAreDistinct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">                                       TypesAreDistinct<Us...>::value> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">template <typename T> struct TypesAreDistinct<T> : std::true_type {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">/// Determine if all types in Ts are distinct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">/// Useful to statically assert when Ts is intended to describe a non-multi set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">/// of types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">/// Expensive (currently quadratic in sizeof(Ts...)), and so should only be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">/// asserted once per instantiation of a type which requires it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">template <typename... Ts> struct TypesAreDistinct;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">template <> struct TypesAreDistinct<> : std::true_type {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">template <typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">struct TypesAreDistinct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">/// Find the first index where a type appears in a list of types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">/// FirstIndexOfType<T, Us...>::value is the first index of T in Us.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">/// Typically only meaningful when it is otherwise statically known that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">/// type pack has no duplicate types. This should be guaranteed explicitly with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">/// static_assert(TypesAreDistinct<Us...>::value).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">/// It is a compile-time error to instantiate when T is not present in Us, i.e.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">/// if is_one_of<T, Us...>::value is false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">template <typename T, typename... Us> struct FirstIndexOfType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">template <typename T, typename U, typename... Us></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">struct FirstIndexOfType<T, U, Us...></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">template <typename T, typename... Us></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">/// Find the type at a given index in a list of types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">/// TypeAtIndex<I, Ts...> is the type at index I in Ts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">template <size_t I, typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">/// Helper which adds two underlying types of enumeration type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">/// Implicit conversion to a common type is accepted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">template <typename EnumTy1, typename EnumTy2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">                                          std::underlying_type_t<EnumTy1>>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">                                          std::underlying_type_t<EnumTy2>>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">//     Extra additions to <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">namespace callable_detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">/// Templated storage wrapper for a callable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">/// This class is consistently default constructible, copy / move</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">/// constructible / assignable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">/// Supported callable types:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">///  - Function pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">///  - Function reference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">///  - Lambda</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">///  - Function object</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">template <typename T,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">          bool = std::is_function_v<std::remove_pointer_t<remove_cvref_t<T>>>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">class Callable {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">  using value_type = std::remove_reference_t<T>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  using reference = value_type &;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">  using const_reference = value_type const &;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  std::optional<value_type> Obj;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">  static_assert(!std::is_pointer_v<value_type>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">                "Pointers to non-functions are not callable.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">  Callable() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  Callable(T const &O) : Obj(std::in_place, O) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">  Callable(Callable const &Other) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  Callable(Callable &&Other) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">  Callable &operator=(Callable const &Other) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">    Obj = std::nullopt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">    if (Other.Obj)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">      Obj.emplace(*Other.Obj);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">    return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  Callable &operator=(Callable &&Other) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">    Obj = std::nullopt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">    if (Other.Obj)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">      Obj.emplace(std::move(*Other.Obj));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">    return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  template <typename... Pn,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  decltype(auto) operator()(Pn &&...Params) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">    return (*Obj)(std::forward<Pn>(Params)...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  template <typename... Pn,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">            std::enable_if_t<std::is_invocable_v<T const, Pn...>, int> = 0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  decltype(auto) operator()(Pn &&...Params) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">    return (*Obj)(std::forward<Pn>(Params)...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  bool valid() const { return Obj != std::nullopt; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  bool reset() { return Obj = std::nullopt; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  operator reference() { return *Obj; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">  operator const_reference() const { return *Obj; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">// Function specialization.  No need to waste extra space wrapping with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">// std::optional.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">template <typename T> class Callable<T, true> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  static constexpr bool IsPtr = std::is_pointer_v<remove_cvref_t<T>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  using StorageT = std::conditional_t<IsPtr, T, std::remove_reference_t<T> *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  using CastT = std::conditional_t<IsPtr, T, T &>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  StorageT Func = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="coveredLine">  template <typename In> static constexpr auto convertIn(In &&I) {</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">    if constexpr (IsPtr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">      // Pointer... just echo it back.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="coveredLine">      return I;</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">      // Must be a function reference.  Return its address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">      return &I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  Callable() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  // Construct from a function pointer or reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  // Disable this constructor for references to 'Callable' so we don't violate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">  // the rule of 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  template < // clang-format off</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">    typename FnPtrOrRef,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">    std::enable_if_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">      !std::is_same_v<remove_cvref_t<FnPtrOrRef>, Callable>, int</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">    > = 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  > // clang-format on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="coveredLine">  Callable(FnPtrOrRef &&F) : Func(convertIn(F)) {}</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">  template <typename... Pn,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="coveredLine">  decltype(auto) operator()(Pn &&...Params) const {</td>
    <td>135</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="coveredLine">    return Func(std::forward<Pn>(Params)...);</td>
    <td>135</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">  bool valid() const { return Func != nullptr; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">  void reset() { Func = nullptr; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">  operator T const &() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">    if constexpr (IsPtr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">      // T is a pointer... just echo it back.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">      return Func;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">      static_assert(std::is_reference_v<T>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">                    "Expected a reference to a function.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">      // T is a function reference... dereference the stored pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">      return *Func;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">} // namespace callable_detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">/// Returns true if the given container only contains a single element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="coveredLine">template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="coveredLine">  auto B = std::begin(C), E = std::end(C);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="coveredLine">  return B != E && std::next(B) == E;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">/// Return a range covering \p RangeOrContainer with the first N elements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">/// excluded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="coveredLine">template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {</td>
    <td>135</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="coveredLine">  return make_range(std::next(adl_begin(RangeOrContainer), N),</td>
    <td>135</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="coveredLine">                    adl_end(RangeOrContainer));</td>
    <td>135</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">/// Return a range covering \p RangeOrContainer with the last N elements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">/// excluded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  return make_range(adl_begin(RangeOrContainer),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">                    std::prev(adl_end(RangeOrContainer), N));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">// mapped_iterator - This is a simple iterator adapter that causes a function to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">// be applied whenever operator* is invoked on the iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">template <typename ItTy, typename FuncTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">          typename ReferenceTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">class mapped_iterator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">    : public iterator_adaptor_base<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">          mapped_iterator<ItTy, FuncTy>, ItTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">          typename std::iterator_traits<ItTy>::iterator_category,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">          std::remove_reference_t<ReferenceTy>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">          typename std::iterator_traits<ItTy>::difference_type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">  mapped_iterator() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="coveredLine">  mapped_iterator(ItTy U, FuncTy F)</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="coveredLine">    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">  ItTy getCurrent() { return this->I; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">  const FuncTy &getFunction() const { return F; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="coveredLine">  ReferenceTy operator*() const { return F(*this->I); }</td>
    <td>135</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">  callable_detail::Callable<FuncTy> F{};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">// map_iterator - Provide a convenient way to create mapped_iterators, just like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">// make_pair is useful for creating pairs...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">template <class ItTy, class FuncTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="coveredLine">inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="coveredLine">  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));</td>
    <td>160</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">template <class ContainerTy, class FuncTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">auto map_range(ContainerTy &&C, FuncTy F) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">  return make_range(map_iterator(std::begin(C), F),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">                    map_iterator(std::end(C), F));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">/// A base type of mapped iterator, that is useful for building derived</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">/// iterators that do not need/want to store the map function (as in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">/// mapped_iterator). These iterators must simply provide a `mapElement` method</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">/// that defines how to map a value of the iterator to the provided reference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">/// type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">template <typename DerivedT, typename ItTy, typename ReferenceTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">class mapped_iterator_base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">    : public iterator_adaptor_base<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">          DerivedT, ItTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">          typename std::iterator_traits<ItTy>::iterator_category,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">          std::remove_reference_t<ReferenceTy>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">          typename std::iterator_traits<ItTy>::difference_type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">  using BaseT = mapped_iterator_base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">  mapped_iterator_base(ItTy U)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  ItTy getCurrent() { return this->I; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  ReferenceTy operator*() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">    return static_cast<const DerivedT &>(*this).mapElement(*this->I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">/// Helper to determine if type T has a member called rbegin().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">template <typename Ty> class has_rbegin_impl {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  using yes = char[1];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  using no = char[2];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">  template <typename Inner></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">  template <typename></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  static no& test(...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">/// Metafunction to determine if T& or T has a member called rbegin().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">template <typename Ty></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">struct has_rbegin : has_rbegin_impl<std::remove_reference_t<Ty>> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">// Returns an iterator_range over the given container which iterates in reverse.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="coveredLine">template <typename ContainerTy> auto reverse(ContainerTy &&C) {</td>
    <td>176</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  if constexpr (has_rbegin<ContainerTy>::value)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="coveredLine">    return make_range(C.rbegin(), C.rend());</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">    return make_range(std::make_reverse_iterator(std::end(C)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="coveredLine">                      std::make_reverse_iterator(std::begin(C)));</td>
    <td>158</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">/// An iterator adaptor that filters the elements of given inner iterators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">/// The predicate parameter should be a callable object that accepts the wrapped</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">/// iterator's reference type and returns a bool. When incrementing or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">/// decrementing the iterator, it will call the predicate on each element and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">/// skip any where it returns false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">/// \code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">///   int A[] = { 1, 2, 3, 4 };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">///   // R contains { 1, 3 }.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">/// \endcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">/// Note: filter_iterator_base implements support for forward iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">/// filter_iterator_impl exists to provide support for bidirectional iteration,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">/// conditional on whether the wrapped iterator supports it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">template <typename WrappedIteratorT, typename PredicateT, typename IterTag></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">class filter_iterator_base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">    : public iterator_adaptor_base<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">          WrappedIteratorT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">          std::common_type_t<IterTag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">                             typename std::iterator_traits<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">                                 WrappedIteratorT>::iterator_category>> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">  using BaseT = typename filter_iterator_base::iterator_adaptor_base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  WrappedIteratorT End;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  PredicateT Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="coveredLine">  void findNextValid() {</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="coveredLine">    while (this->I != End && !Pred(*this->I))</td>
    <td>58</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="coveredLine">      BaseT::operator++();</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="coveredLine">  }</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  filter_iterator_base() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">  // Construct the iterator. The begin iterator needs to know where the end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  // is, so that it can properly stop when it gets there. The end iterator only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">  // needs the predicate to support bidirectional iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="coveredLine">  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">                       PredicateT Pred)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="coveredLine">      : BaseT(Begin), End(End), Pred(Pred) {</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="coveredLine">    findNextValid();</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="coveredLine">  }</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  using BaseT::operator++;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="coveredLine">  filter_iterator_base &operator++() {</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="coveredLine">    BaseT::operator++();</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="coveredLine">    findNextValid();</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="coveredLine">    return *this;</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="coveredLine">  decltype(auto) operator*() const {</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="coveredLine">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="coveredLine">    return BaseT::operator*();</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">  decltype(auto) operator->() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">    return BaseT::operator->();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">/// Specialization of filter_iterator_base for forward iteration only.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">template <typename WrappedIteratorT, typename PredicateT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">          typename IterTag = std::forward_iterator_tag></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">class filter_iterator_impl</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  filter_iterator_impl() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">                       PredicateT Pred)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">/// Specialization of filter_iterator_base for bidirectional iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">template <typename WrappedIteratorT, typename PredicateT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">class filter_iterator_impl<WrappedIteratorT, PredicateT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">                           std::bidirectional_iterator_tag></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">    : public filter_iterator_base<WrappedIteratorT, PredicateT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">                                  std::bidirectional_iterator_tag> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  using BaseT = typename filter_iterator_impl::filter_iterator_base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">  void findPrevValid() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">    while (!this->Pred(*this->I))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">      BaseT::operator--();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  using BaseT::operator--;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">  filter_iterator_impl() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="coveredLine">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">                       PredicateT Pred)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="coveredLine">      : BaseT(Begin, End, Pred) {}</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">  filter_iterator_impl &operator--() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">    BaseT::operator--();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">    findPrevValid();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">    return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  using type = std::forward_iterator_tag;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">template <> struct fwd_or_bidi_tag_impl<true> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">  using type = std::bidirectional_iterator_tag;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">/// Helper which sets its type member to forward_iterator_tag if the category</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">/// of \p IterT does not derive from bidirectional_iterator_tag, and to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">/// bidirectional_iterator_tag otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">template <typename IterT> struct fwd_or_bidi_tag {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">      std::bidirectional_iterator_tag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">      typename std::iterator_traits<IterT>::iterator_category>::value>::type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">/// Defines filter_iterator to a suitable specialization of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">/// filter_iterator_impl, based on the underlying iterator's category.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">template <typename WrappedIteratorT, typename PredicateT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">using filter_iterator = filter_iterator_impl<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">    WrappedIteratorT, PredicateT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">/// Convenience function that takes a range of elements and a predicate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">/// and return a new filter_iterator range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">/// lifetime of that temporary is not kept by the returned range object, and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">/// temporary is going to be dropped on the floor after the make_iterator_range</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">/// full expression that contains this function call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">template <typename RangeT, typename PredicateT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="coveredLine">make_filter_range(RangeT &&Range, PredicateT Pred) {</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">  using FilterIteratorT =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="coveredLine">  return make_range(</td>
    <td>65</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="coveredLine">      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="coveredLine">                      std::end(std::forward<RangeT>(Range)), Pred),</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="coveredLine">      FilterIteratorT(std::end(std::forward<RangeT>(Range)),</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="coveredLine">                      std::end(std::forward<RangeT>(Range)), Pred));</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">/// A pseudo-iterator adaptor that is designed to implement "early increment"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">/// style loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">/// This is *not a normal iterator* and should almost never be used directly. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">/// is intended primarily to be used with range based for loops and some range</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">/// algorithms.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">/// somewhere between them. The constraints of these iterators are:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">/// - On construction or after being incremented, it is comparable and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">///   dereferencable. It is *not* incrementable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">/// - After being dereferenced, it is neither comparable nor dereferencable, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">///   is only incrementable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">/// This means you can only dereference the iterator once, and you can only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">/// increment it once between dereferences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">template <typename WrappedIteratorT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">class early_inc_iterator_impl</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">                                   WrappedIteratorT, std::input_iterator_tag> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">  bool IsEarlyIncremented = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="coveredLine">  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}</td>
    <td>136</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">  using BaseT::operator*;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="coveredLine">  decltype(*std::declval<WrappedIteratorT>()) operator*() {</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="coveredLine">    assert(!IsEarlyIncremented && "Cannot dereference twice!");</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="coveredLine">    IsEarlyIncremented = true;</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="coveredLine">    return *(this->I)++;</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">  using BaseT::operator++;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="coveredLine">  early_inc_iterator_impl &operator++() {</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="coveredLine">    assert(IsEarlyIncremented && "Cannot increment before dereferencing!");</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="coveredLine">    IsEarlyIncremented = false;</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="coveredLine">    return *this;</td>
    <td>354</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="coveredLine">  friend bool operator==(const early_inc_iterator_impl &LHS,</td>
    <td>422</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">                         const early_inc_iterator_impl &RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="coveredLine">    assert(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!");</td>
    <td>422</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="coveredLine">    return (const BaseT &)LHS == (const BaseT &)RHS;</td>
    <td>422</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">/// Make a range that does early increment to allow mutation of the underlying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">/// range without disrupting iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">/// The underlying iterator will be incremented immediately after it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">/// dereferenced, allowing deletion of the current node or insertion of nodes to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">/// not disrupt iteration provided they do not invalidate the *next* iterator --</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">/// the current iterator can be invalidated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">/// This requires a very exact pattern of use that is only really suitable to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">/// range based for loops and other range algorithms that explicitly guarantee</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">/// to dereference exactly once each element, and to increment exactly once each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">/// element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">template <typename RangeT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="coveredLine">make_early_inc_range(RangeT &&Range) {</td>
    <td>68</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  using EarlyIncIteratorT =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="coveredLine">  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),</td>
    <td>136</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="coveredLine">                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));</td>
    <td>116</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">// Forward declarations required by zip_shortest/zip_equal/zip_first/zip_longest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">bool all_of(R &&range, UnaryPredicate P);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">bool any_of(R &&range, UnaryPredicate P);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">template <typename T> bool all_equal(std::initializer_list<T> Values);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">template <typename R> constexpr size_t range_size(R &&Range);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">using std::declval;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">// We have to alias this since inlining the actual type at the usage site</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">template<typename... Iters> struct ZipTupleType {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">  using type = std::tuple<decltype(*declval<Iters>())...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">using zip_traits = iterator_facade_base<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">    ZipType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">    std::common_type_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">        std::bidirectional_iterator_tag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">        typename std::iterator_traits<Iters>::iterator_category...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">    // ^ TODO: Implement random access methods.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">    ReferenceTupleType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">    typename std::iterator_traits<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">        std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">    // inner iterators have the same difference_type. It would fail if, for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">    // instance, the second field's difference_type were non-numeric while the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">    // first is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">    ReferenceTupleType *, ReferenceTupleType>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">struct zip_common : public zip_traits<ZipType, ReferenceTupleType, Iters...> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">  using Base = zip_traits<ZipType, ReferenceTupleType, Iters...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">  using IndexSequence = std::index_sequence_for<Iters...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  using value_type = typename Base::value_type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">  std::tuple<Iters...> iterators;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="coveredLine">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="coveredLine">    return value_type(*std::get<Ns>(iterators)...);</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="coveredLine">  template <size_t... Ns> void tup_inc(std::index_sequence<Ns...>) {</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="coveredLine">    (++std::get<Ns>(iterators), ...);</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="coveredLine">  }</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">  template <size_t... Ns> void tup_dec(std::index_sequence<Ns...>) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">    (--std::get<Ns>(iterators), ...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">  bool test_all_equals(const zip_common &other,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">                       std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">            ...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="coveredLine">  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}</td>
    <td>28</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="coveredLine">  value_type operator*() const { return deref(IndexSequence{}); }</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="coveredLine">  ZipType &operator++() {</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="coveredLine">    tup_inc(IndexSequence{});</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="coveredLine">    return static_cast<ZipType &>(*this);</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  ZipType &operator--() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">    static_assert(Base::IsBidirectional,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">                  "All inner iterators must be at least bidirectional.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">    tup_dec(IndexSequence{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">    return static_cast<ZipType &>(*this);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">  /// Return true if all the iterator are matching `other`'s iterators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">  bool all_equals(zip_common &other) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">    return test_all_equals(other, IndexSequence{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">template <typename... Iters></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">struct zip_first : zip_common<zip_first<Iters...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">                              typename ZipTupleType<Iters...>::type, Iters...> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">  using zip_common<zip_first, typename ZipTupleType<Iters...>::type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">                   Iters...>::zip_common;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">  bool operator==(const zip_first &other) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">    return std::get<0>(this->iterators) == std::get<0>(other.iterators);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">template <typename... Iters></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">struct zip_shortest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">    : zip_common<zip_shortest<Iters...>, typename ZipTupleType<Iters...>::type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">                 Iters...> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">  using zip_common<zip_shortest, typename ZipTupleType<Iters...>::type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">                   Iters...>::zip_common;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">  bool operator==(const zip_shortest &other) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">    return any_iterator_equals(other, std::index_sequence_for<Iters...>{});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">  bool any_iterator_equals(const zip_shortest &other,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">                           std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">            ...);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">/// Helper to obtain the iterator types for the tuple storage within `zippy`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">template <template <typename...> class ItType, typename TupleStorageType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">          typename IndexSequence></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">struct ZippyIteratorTuple;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">/// Partial specialization for non-const tuple storage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">template <template <typename...> class ItType, typename... Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">          std::size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">struct ZippyIteratorTuple<ItType, std::tuple<Args...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">                          std::index_sequence<Ns...>> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">  using type = ItType<decltype(adl_begin(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">      std::get<Ns>(declval<std::tuple<Args...> &>())))...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">/// Partial specialization for const tuple storage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">template <template <typename...> class ItType, typename... Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">          std::size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">struct ZippyIteratorTuple<ItType, const std::tuple<Args...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">                          std::index_sequence<Ns...>> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  using type = ItType<decltype(adl_begin(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">      std::get<Ns>(declval<const std::tuple<Args...> &>())))...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">template <template <typename...> class ItType, typename... Args> class zippy {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  std::tuple<Args...> storage;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  using IndexSequence = std::index_sequence_for<Args...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">  using iterator = typename ZippyIteratorTuple<ItType, decltype(storage),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">                                               IndexSequence>::type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">  using const_iterator =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">      typename ZippyIteratorTuple<ItType, const decltype(storage),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">                                  IndexSequence>::type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">  using iterator_category = typename iterator::iterator_category;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">  using value_type = typename iterator::value_type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  using difference_type = typename iterator::difference_type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">  using pointer = typename iterator::pointer;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">  using reference = typename iterator::reference;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">  using const_reference = typename const_iterator::reference;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="coveredLine">  zippy(Args &&...args) : storage(std::forward<Args>(args)...) {}</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="">  const_iterator begin() const { return begin_impl(IndexSequence{}); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="coveredLine">  iterator begin() { return begin_impl(IndexSequence{}); }</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">  const_iterator end() const { return end_impl(IndexSequence{}); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="coveredLine">  iterator end() { return end_impl(IndexSequence{}); }</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">  const_iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">    return const_iterator(adl_begin(std::get<Ns>(storage))...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="coveredLine">  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="coveredLine">    return iterator(adl_begin(std::get<Ns>(storage))...);</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">  const_iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">    return const_iterator(adl_end(std::get<Ns>(storage))...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="coveredLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="coveredLine">    return iterator(adl_end(std::get<Ns>(storage))...);</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">} // end namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">/// zip iterator for two or more iteratable types. Iteration continues until the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">/// end of the *shortest* iteratee is reached.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">template <typename T, typename U, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">                                                       Args &&...args) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">  return detail::zippy<detail::zip_shortest, T, U, Args...>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">/// zip iterator that assumes that all iteratees have the same length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">/// In builds with assertions on, this assumption is checked before the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">/// iteration starts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">template <typename T, typename U, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">detail::zippy<detail::zip_first, T, U, Args...> zip_equal(T &&t, U &&u,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">                                                          Args &&...args) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  assert(all_equal({range_size(t), range_size(u), range_size(args)...}) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">         "Iteratees do not have equal length");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">/// zip iterator that, for the sake of efficiency, assumes the first iteratee to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">/// be the shortest. Iteration continues until the end of the first iteratee is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">/// reached. In builds with assertions on, we check that the assumption about</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">/// the first iteratee being the shortest holds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">template <typename T, typename U, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">                                                          Args &&...args) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">  assert(range_size(t) <= std::min({range_size(u), range_size(args)...}) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">         "First iteratee is not the shortest");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">template <typename Iter></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">Iter next_or_end(const Iter &I, const Iter &End) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">  if (I == End)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">    return End;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">  return std::next(I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">template <typename Iter></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">auto deref_or_none(const Iter &I, const Iter &End) -> std::optional<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">  if (I == End)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">    return std::nullopt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">  return *I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">template <typename Iter> struct ZipLongestItemType {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">  using type = std::optional<std::remove_const_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">      std::remove_reference_t<decltype(*std::declval<Iter>())>>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">template <typename... Iters> struct ZipLongestTupleType {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="">template <typename... Iters></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">class zip_longest_iterator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">    : public iterator_facade_base<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="">          zip_longest_iterator<Iters...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">          std::common_type_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">              std::forward_iterator_tag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">              typename std::iterator_traits<Iters>::iterator_category...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">          typename ZipLongestTupleType<Iters...>::type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">          typename std::iterator_traits<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">              std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">          typename ZipLongestTupleType<Iters...>::type *,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">          typename ZipLongestTupleType<Iters...>::type> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">  using value_type = typename ZipLongestTupleType<Iters...>::type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">  std::tuple<Iters...> iterators;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  std::tuple<Iters...> end_iterators;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">  bool test(const zip_longest_iterator<Iters...> &other,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">            std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">    return ((std::get<Ns>(this->iterators) != std::get<Ns>(other.iterators)) ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">            ...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">    return value_type(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">    return std::tuple<Iters...>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">      : iterators(std::forward<Iters>(ts.first)...),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">        end_iterators(std::forward<Iters>(ts.second)...) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">  value_type operator*() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">    return deref(std::index_sequence_for<Iters...>{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  zip_longest_iterator<Iters...> &operator++() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">    iterators = tup_inc(std::index_sequence_for<Iters...>{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">    return *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">  bool operator==(const zip_longest_iterator<Iters...> &other) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">    return !test(other, std::index_sequence_for<Iters...>{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">template <typename... Args> class zip_longest_range {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">  using iterator =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">  using iterator_category = typename iterator::iterator_category;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  using value_type = typename iterator::value_type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">  using difference_type = typename iterator::difference_type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">  using pointer = typename iterator::pointer;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">  using reference = typename iterator::reference;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">  std::tuple<Args...> ts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">                                   adl_end(std::get<Ns>(ts)))...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">                                   adl_end(std::get<Ns>(ts)))...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">  iterator begin() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">    return begin_impl(std::index_sequence_for<Args...>{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">/// Iterate over two or more iterators at the same time. Iteration continues</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">/// until all iterators reach the end. The std::optional only contains a value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">/// if the iterator has not reached the end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">template <typename T, typename U, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">                                                     Args &&... args) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  return detail::zip_longest_range<T, U, Args...>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">/// Iterator wrapper that concatenates sequences together.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">/// This can concatenate different iterators, even with different types, into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">/// a single iterator provided the value types of all the concatenated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">/// iterators expose `reference` and `pointer` types that can be converted to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">/// `ValueT &` and `ValueT *` respectively. It doesn't support more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">/// interesting/customized pointer or reference types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">/// Currently this only supports forward or higher iterator categories as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">/// inputs and always exposes a forward iterator interface.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">template <typename ValueT, typename... IterTs></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">class concat_iterator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">                                  std::forward_iterator_tag, ValueT> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">  using BaseT = typename concat_iterator::iterator_facade_base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">  /// We store both the current and end iterators for each concatenated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">  /// sequence in a tuple of pairs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">  /// Note that something like iterator_range seems nice at first here, but the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">  /// range properties are of little benefit and end up getting in the way</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">  /// because we need to do mutation on the current iterators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">  std::tuple<IterTs...> Begins;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  std::tuple<IterTs...> Ends;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">  /// Attempts to increment a specific iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">  /// Returns true if it was able to increment the iterator. Returns false if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">  /// the iterator is already at the end iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="coveredLine">  template <size_t Index> bool incrementHelper() {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="coveredLine">    auto &Begin = std::get<Index>(Begins);</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="coveredLine">    auto &End = std::get<Index>(Ends);</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="coveredLine">    if (Begin == End)</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="coveredLine">    ++Begin;</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="coveredLine">    return true;</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  /// Increments the first non-end iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  /// It is an error to call this with all iterators at the end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="coveredLine">  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">    // Build a sequence of functions to increment each iterator if possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="coveredLine">    bool (concat_iterator::*IncrementHelperFns[])() = {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">        &concat_iterator::incrementHelper<Ns>...};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">    // Loop over them, and stop as soon as we succeed at incrementing one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="coveredLine">    for (auto &IncrementHelperFn : IncrementHelperFns)</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="coveredLine">      if ((this->*IncrementHelperFn)())</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="coveredLine">        return;</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">    llvm_unreachable("Attempted to increment an end concat iterator!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">  /// Returns null if the specified iterator is at the end. Otherwise,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">  /// dereferences the iterator and returns the address of the resulting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="">  /// reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="coveredLine">  template <size_t Index> ValueT *getHelper() const {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="coveredLine">    auto &Begin = std::get<Index>(Begins);</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="coveredLine">    auto &End = std::get<Index>(Ends);</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="coveredLine">    if (Begin == End)</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="coveredLine">    return &*Begin;</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">  /// Finds the first non-end iterator, dereferences, and returns the resulting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">  /// reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">  /// It is an error to call this with all iterators at the end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="coveredLine">  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">    // Build a sequence of functions to get from iterator if possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="coveredLine">    ValueT *(concat_iterator::*GetHelperFns[])() const = {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">        &concat_iterator::getHelper<Ns>...};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">    // Loop over them, and return the first result we find.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="coveredLine">    for (auto &GetHelperFn : GetHelperFns)</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="coveredLine">      if (ValueT *P = (this->*GetHelperFn)())</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="coveredLine">        return *P;</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">    llvm_unreachable("Attempted to get a pointer from an end concat iterator!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  /// Constructs an iterator from a sequence of ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">  /// We need the full range to know how to switch between each of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">  /// iterators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">  template <typename... RangeTs></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="coveredLine">  explicit concat_iterator(RangeTs &&... Ranges)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="coveredLine">      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  using BaseT::operator++;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="coveredLine">  concat_iterator &operator++() {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="coveredLine">    increment(std::index_sequence_for<IterTs...>());</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="coveredLine">    return *this;</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="coveredLine">  ValueT &operator*() const {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="coveredLine">    return get(std::index_sequence_for<IterTs...>());</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="coveredLine">  bool operator==(const concat_iterator &RHS) const {</td>
    <td>5</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="coveredLine">    return Begins == RHS.Begins && Ends == RHS.Ends;</td>
    <td>5</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">/// Helper to store a sequence of ranges being concatenated and access them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">/// This is designed to facilitate providing actual storage when temporaries</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">/// are passed into the constructor such that we can use it as part of range</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">/// based for loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">template <typename ValueT, typename... RangeTs> class concat_range {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">  using iterator =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">      concat_iterator<ValueT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">                      decltype(std::begin(std::declval<RangeTs &>()))...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">  std::tuple<RangeTs...> Ranges;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">  iterator begin_impl(std::index_sequence<Ns...>) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">    return iterator(std::get<Ns>(Ranges)...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">  template <size_t... Ns></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="coveredLine">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="coveredLine">    return iterator(std::get<Ns>(Ranges)...);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">                               std::end(std::get<Ns>(Ranges)))...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="coveredLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="coveredLine">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="coveredLine">                               std::end(std::get<Ns>(Ranges)))...);</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="coveredLine">  concat_range(RangeTs &&... Ranges)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="coveredLine">      : Ranges(std::forward<RangeTs>(Ranges)...) {}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">  iterator begin() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="coveredLine">  iterator begin() const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="coveredLine">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">  iterator end() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="coveredLine">  iterator end() const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="coveredLine">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">} // end namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">/// Concatenated range across two or more ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">/// The desired value type must be explicitly specified.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">template <typename ValueT, typename... RangeTs></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="coveredLine">detail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  static_assert(sizeof...(RangeTs) > 1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">                "Need more than one range to concatenate!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  return detail::concat_range<ValueT, RangeTs...>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="coveredLine">      std::forward<RangeTs>(Ranges)...);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="">/// A utility class used to implement an iterator that contains some base object</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">/// and an index. The iterator moves the index but keeps the base constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">template <typename DerivedT, typename BaseT, typename T,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">class indexed_accessor_iterator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">    : public llvm::iterator_facade_base<DerivedT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">                                        std::random_access_iterator_tag, T,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">                                        std::ptrdiff_t, PointerT, ReferenceT> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">    assert(base == rhs.base && "incompatible iterators");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">    return index - rhs.index;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="">  bool operator==(const indexed_accessor_iterator &rhs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">    return base == rhs.base && index == rhs.index;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">  bool operator<(const indexed_accessor_iterator &rhs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">    assert(base == rhs.base && "incompatible iterators");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">    return index < rhs.index;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  DerivedT &operator+=(ptrdiff_t offset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">    this->index += offset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">    return static_cast<DerivedT &>(*this);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  DerivedT &operator-=(ptrdiff_t offset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="">    this->index -= offset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">    return static_cast<DerivedT &>(*this);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  /// Returns the current index of the iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">  ptrdiff_t getIndex() const { return index; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  /// Returns the current base of the iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  const BaseT &getBase() const { return base; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  indexed_accessor_iterator(BaseT base, ptrdiff_t index)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">      : base(base), index(index) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">  BaseT base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">  ptrdiff_t index;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">/// The class represents the base of a range of indexed_accessor_iterators. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">/// provides support for many different range functionalities, e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">/// drop_front/slice/etc.. Derived range classes must implement the following</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">/// static methods:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">///     - Dereference an iterator pointing to the base object at the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">///       index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">///     - Return a new base that is offset from the provide base by 'index'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">///       elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">template <typename DerivedT, typename BaseT, typename T,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">class indexed_accessor_range_base {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">  using RangeBaseT = indexed_accessor_range_base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  /// An iterator element of this range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">                                                    PointerT, ReferenceT> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">    // Index into this iterator, invoking a static method on the derived type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">    ReferenceT operator*() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">    iterator(BaseT owner, ptrdiff_t curIndex)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">        : iterator::indexed_accessor_iterator(owner, curIndex) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">    /// Allow access to the constructor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">                                       ReferenceT>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">  indexed_accessor_range_base(iterator begin, iterator end)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">      : base(offset_base(begin.getBase(), begin.getIndex())),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">        count(end.getIndex() - begin.getIndex()) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  indexed_accessor_range_base(const iterator_range<iterator> &range)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">      : indexed_accessor_range_base(range.begin(), range.end()) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">  indexed_accessor_range_base(BaseT base, ptrdiff_t count)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">      : base(base), count(count) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">  iterator begin() const { return iterator(base, 0); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  iterator end() const { return iterator(base, count); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  ReferenceT operator[](size_t Index) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">    assert(Index < size() && "invalid index for value range");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">  ReferenceT front() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">    assert(!empty() && "expected non-empty range");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">    return (*this)[0];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">  ReferenceT back() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">    assert(!empty() && "expected non-empty range");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">    return (*this)[size() - 1];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">  /// Compare this range with another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">  template <typename OtherT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">  friend bool operator==(const indexed_accessor_range_base &lhs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">                         const OtherT &rhs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">  template <typename OtherT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">  friend bool operator!=(const indexed_accessor_range_base &lhs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">                         const OtherT &rhs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">    return !(lhs == rhs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">  /// Return the size of this range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">  size_t size() const { return count; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">  /// Return if the range is empty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">  bool empty() const { return size() == 0; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">  /// Drop the first N elements, and keep M elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  DerivedT slice(size_t n, size_t m) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">    assert(n + m <= size() && "invalid size specifiers");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">    return DerivedT(offset_base(base, n), m);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">  /// Drop the first n elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">  DerivedT drop_front(size_t n = 1) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">    assert(size() >= n && "Dropping more elements than exist");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">    return slice(n, size() - n);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">  /// Drop the last n elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">  DerivedT drop_back(size_t n = 1) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">    assert(size() >= n && "Dropping more elements than exist");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">    return DerivedT(base, size() - n);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">  /// Take the first n elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">  DerivedT take_front(size_t n = 1) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">    return n < size() ? drop_back(size() - n)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">                      : static_cast<const DerivedT &>(*this);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">  /// Take the last n elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">  DerivedT take_back(size_t n = 1) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">    return n < size() ? drop_front(size() - n)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">                      : static_cast<const DerivedT &>(*this);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">  /// Allow conversion to any type accepting an iterator_range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="">                                 RangeT, iterator_range<iterator>>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">  operator RangeT() const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">    return RangeT(iterator_range<iterator>(*this));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">  /// Returns the base of this range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="">  const BaseT &getBase() const { return base; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">  /// Offset the given base by the given amount.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">  static BaseT offset_base(const BaseT &base, size_t n) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">    return n == 0 ? base : DerivedT::offset_base(base, n);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">  indexed_accessor_range_base &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">  operator=(const indexed_accessor_range_base &) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">  /// The base that owns the provided range of values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">  BaseT base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">  /// The size from the owning range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">  ptrdiff_t count;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">} // end namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">/// This class provides an implementation of a range of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">/// indexed_accessor_iterators where the base is not indexable. Ranges with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">/// bases that are offsetable should derive from indexed_accessor_range_base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">/// instead. Derived range classes are expected to implement the following</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">/// static method:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">///     - Dereference an iterator pointing to a parent base at the given index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">template <typename DerivedT, typename BaseT, typename T,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">class indexed_accessor_range</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">    : public detail::indexed_accessor_range_base<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">      : detail::indexed_accessor_range_base<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">            std::make_pair(base, startIndex), count) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">  using detail::indexed_accessor_range_base<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">      ReferenceT>::indexed_accessor_range_base;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">  /// Returns the current base of the range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">  const BaseT &getBase() const { return this->base.first; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">  /// Returns the current start index of the range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">  ptrdiff_t getStartIndex() const { return this->base.second; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">  /// See `detail::indexed_accessor_range_base` for details.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">  static std::pair<BaseT, ptrdiff_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">    // We encode the internal base as a pair of the derived base and a start</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">    // index into the derived base.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">    return std::make_pair(base.first, base.second + index);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="">  /// See `detail::indexed_accessor_range_base` for details.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">  static ReferenceT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">                       ptrdiff_t index) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">    return DerivedT::dereference(base.first, base.second + index);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">/// Return a reference to the first or second member of a reference. Otherwise,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">/// return a copy of the member of a temporary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">/// When passing a range whose iterators return values instead of references,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">/// the reference must be dropped from `decltype((elt.first))`, which will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">/// always be a reference, to avoid returning a reference to a temporary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">template <typename EltTy, typename FirstTy> class first_or_second_type {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">  using type = std::conditional_t<std::is_reference<EltTy>::value, FirstTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">                                  std::remove_reference_t<FirstTy>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">} // end namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">/// Given a container of pairs, return a range over the first elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  using EltTy = decltype((*std::begin(c)));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">  return llvm::map_range(std::forward<ContainerTy>(c),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">                         [](EltTy elt) -> typename detail::first_or_second_type<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">                                           EltTy, decltype((elt.first))>::type {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">                           return elt.first;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">                         });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">/// Given a container of pairs, return a range over the second elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">  using EltTy = decltype((*std::begin(c)));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">  return llvm::map_range(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">      std::forward<ContainerTy>(c),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">      [](EltTy elt) -></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">      typename detail::first_or_second_type<EltTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">                                            decltype((elt.second))>::type {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">        return elt.second;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">//     Extra additions to <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">/// Function object to check whether the first component of a container</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">/// first component of another container.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">struct less_first {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="coveredLine">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="coveredLine">    return std::less<>()(std::get<0>(lhs), std::get<0>(rhs));</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">/// Function object to check whether the second component of a container</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">/// second component of another container.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">struct less_second {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="uncoveredLine">    return std::less<>()(std::get<1>(lhs), std::get<1>(rhs));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">/// \brief Function object to apply a binary function to the first component of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="">/// a std::pair.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">template<typename FuncTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="">struct on_first {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">  FuncTy func;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">  template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">  decltype(auto) operator()(const T &lhs, const T &rhs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">    return func(lhs.first, rhs.first);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">/// Utility type to build an inheritance chain that makes it easy to rank</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">/// overload candidates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">template <int N> struct rank : rank<N - 1> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">template <> struct rank<0> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">/// traits class for checking whether type T is one of any of the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">/// types in the variadic list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">template <typename T, typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">/// traits class for checking whether type T is a base class for all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">///  the given types in the variadic list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="">template <typename T, typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">template <typename... Ts> struct Visitor;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">template <typename HeadT, typename... TailTs></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">  using remove_cvref_t<HeadT>::operator();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  using Visitor<TailTs...>::operator();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">  explicit constexpr Visitor(HeadT &&Head)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="">  using remove_cvref_t<HeadT>::operator();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">/// Returns an opaquely-typed Callable object whose operator() overload set is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">/// the sum of the operator() overload sets of each CallableT in CallableTs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">/// The type of the returned object derives from each CallableT in CallableTs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">/// The returned object is constructed by invoking the appropriate copy or move</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">/// constructor of each CallableT, as selected by overload resolution on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">/// corresponding argument to makeVisitor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="">/// Example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">/// \code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">/// auto visitor = makeVisitor([](auto) { return "unhandled type"; },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">///                            [](int i) { return "int"; },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">///                            [](std::string s) { return "str"; });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">/// auto a = visitor(42);    // `a` is now "int".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="">/// auto b = visitor("foo"); // `b` is now "str".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">/// auto c = visitor(3.14f); // `c` is now "unhandled type".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">/// \endcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">/// Example of making a visitor with a lambda which captures a move-only type:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="">/// \code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">/// std::unique_ptr<FooHandler> FH = /* ... */;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">/// auto visitor = makeVisitor(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="">///     [FH{std::move(FH)}](Foo F) { return FH->handle(F); },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">///     [](int i) { return i; },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="">///     [](std::string s) { return atoi(s); });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="">/// \endcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="">template <typename... CallableTs></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="">constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="">  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">//     Extra additions to <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">// We have a copy here so that LLVM behaves the same when using different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">// standard libraries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="">template <class Iterator, class RNG></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">void shuffle(Iterator first, Iterator last, RNG &&g) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">  // It would be better to use a std::uniform_int_distribution,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">  // but that would be stdlib dependent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="">  typedef</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">      typename std::iterator_traits<Iterator>::difference_type difference_type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="">  for (auto size = last - first; size > 1; ++first, (void)--size) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="">    difference_type offset = g() % size;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">    // Avoid self-assignment due to incorrect assertions in libstdc++</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="">    if (offset != difference_type(0))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">      std::iter_swap(first, first + offset);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">/// Adapt std::less<T> for array_pod_sort.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="">template<typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="coveredLine">inline int array_pod_sort_comparator(const void *P1, const void *P2) {</td>
    <td>39</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="coveredLine">  if (std::less<T>()(*reinterpret_cast<const T*>(P1),</td>
    <td>39</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">                     *reinterpret_cast<const T*>(P2)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="coveredLine">    return -1;</td>
    <td>31</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="coveredLine">  if (std::less<T>()(*reinterpret_cast<const T*>(P2),</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">                     *reinterpret_cast<const T*>(P1)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="coveredLine">    return 1;</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">/// get_array_pod_sort_comparator - This is an internal helper function used to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">/// get type deduction of T right.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">template<typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="coveredLine">inline int (*get_array_pod_sort_comparator(const T &))</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">             (const void*, const void*) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="coveredLine">  return array_pod_sort_comparator<T>;</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="">#ifdef EXPENSIVE_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="">inline unsigned presortShuffleEntropy() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="">  static unsigned Result(std::random_device{}());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">  return Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="">template <class IteratorTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">inline void presortShuffle(IteratorTy Start, IteratorTy End) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">  std::mt19937 Generator(presortShuffleEntropy());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">  llvm::shuffle(Start, End, Generator);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="">} // end namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">/// array_pod_sort - This sorts an array with the specified start and end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">/// extent.  This is just like std::sort, except that it calls qsort instead of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">/// using an inlined template.  qsort is slightly slower than std::sort, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="">/// most sorts are not performance critical in LLVM and std::sort has to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="">/// template instantiated for each type, leading to significant measured code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">/// bloat.  This function should generally be used instead of std::sort where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="">/// possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="">/// This function assumes that you have simple POD-like types that can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="">/// compared with std::less and can be moved with memcpy.  If this isn't true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">/// you should use std::sort.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="">/// NOTE: If qsort_r were portable, we could allow a custom comparator and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">/// default to std::less.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="">template<class IteratorTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="coveredLine">inline void array_pod_sort(IteratorTy Start, IteratorTy End) {</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">  // Don't inefficiently call qsort with one element or trigger undefined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">  // behavior with an empty sequence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="coveredLine">  auto NElts = End - Start;</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="coveredLine">  if (NElts <= 1) return;</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">#ifdef EXPENSIVE_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="coveredLine">  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="">template <class IteratorTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="coveredLine">inline void array_pod_sort(</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="">    IteratorTy Start, IteratorTy End,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">    int (*Compare)(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="">        const typename std::iterator_traits<IteratorTy>::value_type *,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">        const typename std::iterator_traits<IteratorTy>::value_type *)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">  // Don't inefficiently call qsort with one element or trigger undefined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="">  // behavior with an empty sequence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="coveredLine">  auto NElts = End - Start;</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="coveredLine">  if (NElts <= 1) return;</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="">#ifdef EXPENSIVE_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="coveredLine">  qsort(&*Start, NElts, sizeof(*Start),</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">        reinterpret_cast<int (*)(const void *, const void *)>(Compare));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">// We can use qsort if the iterator type is a pointer and the underlying value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="">// is trivially copyable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="">using sort_trivially_copyable = std::conjunction<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="">    std::is_pointer<T>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">// Provide wrappers to std::sort which shuffle the elements before sorting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">// to help uncover non-deterministic behavior (PR35135).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="">template <typename IteratorTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="coveredLine">inline void sort(IteratorTy Start, IteratorTy End) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="">  if constexpr (detail::sort_trivially_copyable<IteratorTy>::value) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="">    // Forward trivially copyable types to array_pod_sort. This avoids a large</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">    // amount of code bloat for a minor performance hit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="coveredLine">    array_pod_sort(Start, End);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">#ifdef EXPENSIVE_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="">    detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="uncoveredLine">    std::sort(Start, End);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="coveredLine">}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="coveredLine">template <typename Container> inline void sort(Container &&C) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="coveredLine">  llvm::sort(adl_begin(C), adl_end(C));</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="coveredLine">}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="">template <typename IteratorTy, typename Compare></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="coveredLine">inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">#ifdef EXPENSIVE_CHECKS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="coveredLine">  std::sort(Start, End, Comp);</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="coveredLine">}</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">template <typename Container, typename Compare></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="coveredLine">inline void sort(Container &&C, Compare Comp) {</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="coveredLine">  llvm::sort(adl_begin(C), adl_end(C), Comp);</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="coveredLine">}</td>
    <td>17</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">/// Get the size of a range. This is a wrapper function around std::distance</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="">/// which is only enabled when the operation is O(1).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="">template <typename R></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">auto size(R &&Range,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="">          std::enable_if_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">              std::is_base_of<std::random_access_iterator_tag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="">                              typename std::iterator_traits<decltype(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">                                  Range.begin())>::iterator_category>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="">              void> * = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="">  return std::distance(Range.begin(), Range.end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="">template <typename Range></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="">using check_has_free_function_size =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="">    decltype(adl_size(std::declval<Range &>()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">template <typename Range></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">static constexpr bool HasFreeFunctionSize =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="">    is_detected<check_has_free_function_size, Range>::value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">/// Returns the size of the \p Range, i.e., the number of elements. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">/// implementation takes inspiration from `std::ranges::size` from C++20 and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">/// delegates the size check to `adl_size` or `std::distance`, in this order of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">/// preference. Unlike `llvm::size`, this function does *not* guarantee O(1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">/// running time, and is intended to be used in generic code that does not know</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">/// the exact range type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">template <typename R> constexpr size_t range_size(R &&Range) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="">  if constexpr (detail::HasFreeFunctionSize<R>)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="">    return adl_size(Range);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">    return static_cast<size_t>(std::distance(adl_begin(Range), adl_end(Range)));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="">/// Provide wrappers to std::for_each which take ranges instead of having to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">/// pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="">template <typename R, typename UnaryFunction></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">UnaryFunction for_each(R &&Range, UnaryFunction F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">  return std::for_each(adl_begin(Range), adl_end(Range), F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">/// Provide wrappers to std::all_of which take ranges instead of having to pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">/// begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="coveredLine">bool all_of(R &&Range, UnaryPredicate P) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="coveredLine">  return std::all_of(adl_begin(Range), adl_end(Range), P);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">/// Provide wrappers to std::any_of which take ranges instead of having to pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">/// begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="coveredLine">bool any_of(R &&Range, UnaryPredicate P) {</td>
    <td>155</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="coveredLine">  return std::any_of(adl_begin(Range), adl_end(Range), P);</td>
    <td>155</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">/// Provide wrappers to std::none_of which take ranges instead of having to pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="">/// begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="coveredLine">bool none_of(R &&Range, UnaryPredicate P) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="coveredLine">  return std::none_of(adl_begin(Range), adl_end(Range), P);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">/// Provide wrappers to std::find which take ranges instead of having to pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="">/// begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="coveredLine">template <typename R, typename T> auto find(R &&Range, const T &Val) {</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="coveredLine">  return std::find(adl_begin(Range), adl_end(Range), Val);</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">/// Provide wrappers to std::find_if which take ranges instead of having to pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">/// begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="coveredLine">auto find_if(R &&Range, UnaryPredicate P) {</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="coveredLine">  return std::find_if(adl_begin(Range), adl_end(Range), P);</td>
    <td>0</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="uncoveredLine">auto find_if_not(R &&Range, UnaryPredicate P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">  return std::find_if_not(adl_begin(Range), adl_end(Range), P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="">/// Provide wrappers to std::remove_if which take ranges instead of having to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">/// pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">auto remove_if(R &&Range, UnaryPredicate P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">  return std::remove_if(adl_begin(Range), adl_end(Range), P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">/// Provide wrappers to std::copy_if which take ranges instead of having to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="">/// pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">template <typename R, typename OutputIt, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">/// Return the single value in \p Range that satisfies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">/// \p P(<member of \p Range> *, AllowRepeats)->T * returning nullptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">/// when no values or multiple values were found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">/// When \p AllowRepeats is true, multiple values that compare equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">/// are allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">template <typename T, typename R, typename Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">T *find_singleton(R &&Range, Predicate P, bool AllowRepeats = false) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">  T *RC = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="uncoveredLine">  for (auto *A : Range) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">    if (T *PRC = P(A, AllowRepeats)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">      if (RC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">        if (!AllowRepeats || PRC != RC)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">          return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">      } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">        RC = PRC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">  return RC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">/// Return a pair consisting of the single value in \p Range that satisfies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">/// \p P(<member of \p Range> *, AllowRepeats)->std::pair<T*, bool> returning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">/// nullptr when no values or multiple values were found, and a bool indicating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">/// whether multiple values were found to cause the nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">/// When \p AllowRepeats is true, multiple values that compare equal are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">/// allowed.  The predicate \p P returns a pair<T *, bool> where T is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">/// singleton while the bool indicates whether multiples have already been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">/// found.  It is expected that first will be nullptr when second is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">/// This allows using find_singleton_nested within the predicate \P.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">template <typename T, typename R, typename Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="uncoveredLine">std::pair<T *, bool> find_singleton_nested(R &&Range, Predicate P,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">                                           bool AllowRepeats = false) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">  T *RC = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">  for (auto *A : Range) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="uncoveredLine">    std::pair<T *, bool> PRC = P(A, AllowRepeats);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">    if (PRC.second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">      assert(PRC.first == nullptr &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">             "Inconsistent return values in find_singleton_nested.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">      return PRC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">    if (PRC.first) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="uncoveredLine">      if (RC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">        if (!AllowRepeats || PRC.first != RC)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">          return {nullptr, true};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">      } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">        RC = PRC.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="uncoveredLine">  return {RC, false};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">template <typename R, typename OutputIt></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="coveredLine">OutputIt copy(R &&Range, OutputIt Out) {</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="coveredLine">  return std::copy(adl_begin(Range), adl_end(Range), Out);</td>
    <td>20</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="">/// Provide wrappers to std::replace_copy_if which take ranges instead of having</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">/// to pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">template <typename R, typename OutputIt, typename UnaryPredicate, typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">OutputIt replace_copy_if(R &&Range, OutputIt Out, UnaryPredicate P,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="">                         const T &NewValue) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">  return std::replace_copy_if(adl_begin(Range), adl_end(Range), Out, P,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">                              NewValue);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="">/// Provide wrappers to std::replace_copy which take ranges instead of having to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">/// pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">template <typename R, typename OutputIt, typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">OutputIt replace_copy(R &&Range, OutputIt Out, const T &OldValue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">                      const T &NewValue) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">  return std::replace_copy(adl_begin(Range), adl_end(Range), Out, OldValue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="">                           NewValue);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">/// Provide wrappers to std::move which take ranges instead of having to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">/// pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="">template <typename R, typename OutputIt></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">OutputIt move(R &&Range, OutputIt Out) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">  return std::move(adl_begin(Range), adl_end(Range), Out);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">template <typename Range, typename Element></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="">using check_has_member_contains_t =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="">    decltype(std::declval<Range &>().contains(std::declval<const Element &>()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="">template <typename Range, typename Element></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="">static constexpr bool HasMemberContains =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="">    is_detected<check_has_member_contains_t, Range, Element>::value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">template <typename Range, typename Element></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">using check_has_member_find_t =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="">    decltype(std::declval<Range &>().find(std::declval<const Element &>()) !=</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">             std::declval<Range &>().end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">template <typename Range, typename Element></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">static constexpr bool HasMemberFind =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="">    is_detected<check_has_member_find_t, Range, Element>::value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="">/// Returns true if \p Element is found in \p Range. Delegates the check to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">/// either `.contains(Element)`, `.find(Element)`, or `std::find`, in this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="">/// order of preference. This is intended as the canonical way to check if an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">/// element exists in a range in generic code or range type that does not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">/// expose a `.contains(Element)` member.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="">template <typename R, typename E></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="coveredLine">bool is_contained(R &&Range, const E &Element) {</td>
    <td>4693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  if constexpr (detail::HasMemberContains<R, E>)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="uncoveredLine">    return Range.contains(Element);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">  else if constexpr (detail::HasMemberFind<R, E>)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">    return Range.find(Element) != Range.end();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="coveredLine">    return std::find(adl_begin(Range), adl_end(Range), Element) !=</td>
    <td>4693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="coveredLine">           adl_end(Range);</td>
    <td>4693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">/// Returns true iff \p Element exists in \p Set. This overload takes \p Set as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">/// an initializer list and is `constexpr`-friendly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">template <typename T, typename E></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="uncoveredLine">constexpr bool is_contained(std::initializer_list<T> Set, const E &Element) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">  // TODO: Use std::find when we switch to C++20.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">  for (const T &V : Set)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">    if (V == Element)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="">/// are sorted with respect to a comparator \p C.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="coveredLine">template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {</td>
    <td>25</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="coveredLine">  return std::is_sorted(adl_begin(Range), adl_end(Range), C);</td>
    <td>25</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="">/// are sorted in non-descending order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="coveredLine">template <typename R> bool is_sorted(R &&Range) {</td>
    <td>31</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="coveredLine">  return std::is_sorted(adl_begin(Range), adl_end(Range));</td>
    <td>31</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="">/// Wrapper function around std::count to count the number of times an element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">/// \p Element occurs in the given range \p Range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="coveredLine">template <typename R, typename E> auto count(R &&Range, const E &Element) {</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="coveredLine">  return std::count(adl_begin(Range), adl_end(Range), Element);</td>
    <td>8</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="">/// Wrapper function around std::count_if to count the number of times an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">/// element satisfying a given predicate occurs in a range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="coveredLine">auto count_if(R &&Range, UnaryPredicate P) {</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="coveredLine">  return std::count_if(adl_begin(Range), adl_end(Range), P);</td>
    <td>40</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">/// Wrapper function around std::transform to apply a function to a range and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">/// store the result elsewhere.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">template <typename R, typename OutputIt, typename UnaryFunction></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="">/// Provide wrappers to std::partition which take ranges instead of having to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">/// pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">template <typename R, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">auto partition(R &&Range, UnaryPredicate P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">  return std::partition(adl_begin(Range), adl_end(Range), P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">/// Provide wrappers to std::lower_bound which take ranges instead of having to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">/// pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="coveredLine">template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {</td>
    <td>56</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="coveredLine">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
    <td>56</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="coveredLine">                          std::forward<T>(Value));</td>
    <td>96</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">template <typename R, typename T, typename Compare></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="coveredLine">auto lower_bound(R &&Range, T &&Value, Compare C) {</td>
    <td>49</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="coveredLine">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
    <td>49</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="coveredLine">                          std::forward<T>(Value), C);</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="">/// Provide wrappers to std::upper_bound which take ranges instead of having to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">/// pass begin/end explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="coveredLine">template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="coveredLine">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="coveredLine">                          std::forward<T>(Value));</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="">template <typename R, typename T, typename Compare></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">auto upper_bound(R &&Range, T &&Value, Compare C) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="">                          std::forward<T>(Value), C);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="">template <typename R></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">void stable_sort(R &&Range) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="">  std::stable_sort(adl_begin(Range), adl_end(Range));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">template <typename R, typename Compare></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">void stable_sort(R &&Range, Compare C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">  std::stable_sort(adl_begin(Range), adl_end(Range), C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="">/// Binary search for the first iterator in a range where a predicate is false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="">/// Requires that C is always true below some limit, and always false above it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">template <typename R, typename Predicate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">          typename Val = decltype(*adl_begin(std::declval<R>()))></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="coveredLine">auto partition_point(R &&Range, Predicate P) {</td>
    <td>101</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="coveredLine">  return std::partition_point(adl_begin(Range), adl_end(Range), P);</td>
    <td>101</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">template<typename Range, typename Predicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">auto unique(Range &&R, Predicate P) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">  return std::unique(adl_begin(R), adl_end(R), P);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">/// Wrapper function around std::equal to detect if pair-wise elements between</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">/// two ranges are the same.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">                    adl_end(RRange));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">/// Returns true if all elements in Range are equal or when the Range is empty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">template <typename R> bool all_equal(R &&Range) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">  auto Begin = adl_begin(Range);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="uncoveredLine">  auto End = adl_end(Range);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="uncoveredLine">  return Begin == End || std::equal(Begin + 1, End, Begin);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="">/// Returns true if all Values in the initializer lists are equal or the list</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="">// is empty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="">template <typename T> bool all_equal(std::initializer_list<T> Values) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="">  return all_equal<std::initializer_list<T>>(std::move(Values));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">/// Provide a container algorithm similar to C++ Library Fundamentals v2's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="">/// `erase_if` which is equivalent to:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">///   C.erase(remove_if(C, pred), C.end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">/// This version works for any container with an erase method call accepting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">/// two iterators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="">template <typename Container, typename UnaryPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">void erase_if(Container &C, UnaryPredicate P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">  C.erase(remove_if(C, P), C.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">/// Wrapper function to remove a value from a container:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">/// C.erase(remove(C.begin(), C.end(), V), C.end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="">template <typename Container, typename ValueType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="coveredLine">void erase_value(Container &C, ValueType V) {</td>
    <td>280</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="coveredLine">  C.erase(std::remove(C.begin(), C.end(), V), C.end());</td>
    <td>280</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="coveredLine">}</td>
    <td>280</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="">/// Wrapper function to append a range to a container.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">/// C.insert(C.end(), R.begin(), R.end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="">template <typename Container, typename Range></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="coveredLine">inline void append_range(Container &C, Range &&R) {</td>
    <td>33</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="coveredLine">  C.insert(C.end(), adl_begin(R), adl_end(R));</td>
    <td>33</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="coveredLine">}</td>
    <td>33</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="">/// the range [ValIt, ValEnd) (which is not from the same container).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">template<typename Container, typename RandomAccessIterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">void replace(Container &Cont, typename Container::iterator ContIt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">             typename Container::iterator ContEnd, RandomAccessIterator ValIt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="">             RandomAccessIterator ValEnd) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="">  while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="">    if (ValIt == ValEnd) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="">      Cont.erase(ContIt, ContEnd);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="">      return;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">    } else if (ContIt == ContEnd) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="">      Cont.insert(ContIt, ValIt, ValEnd);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="">      return;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="">    *ContIt++ = *ValIt++;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">/// the range R.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">template<typename Container, typename Range = std::initializer_list<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="">                                 typename Container::value_type>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">void replace(Container &Cont, typename Container::iterator ContIt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="">             typename Container::iterator ContEnd, Range R) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="">  replace(Cont, ContIt, ContEnd, R.begin(), R.end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="">/// An STL-style algorithm similar to std::for_each that applies a second</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="">/// functor between every pair of elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">/// This provides the control flow logic to, for example, print a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="">/// comma-separated list:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="">/// \code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="">///   interleave(names.begin(), names.end(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">///              [&](StringRef name) { os << name; },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">///              [&] { os << ", "; });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="">/// \endcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="">template <typename ForwardIterator, typename UnaryFunctor,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">          typename NullaryFunctor,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="">          typename = std::enable_if_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">inline void interleave(ForwardIterator begin, ForwardIterator end,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="">                       UnaryFunctor each_fn, NullaryFunctor between_fn) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">  if (begin == end)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">    return;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="">  each_fn(*begin);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="">  ++begin;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">  for (; begin != end; ++begin) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="">    between_fn();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="">    each_fn(*begin);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="">template <typename Container, typename UnaryFunctor, typename NullaryFunctor,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="">          typename = std::enable_if_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">inline void interleave(const Container &c, UnaryFunctor each_fn,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">                       NullaryFunctor between_fn) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">  interleave(c.begin(), c.end(), each_fn, between_fn);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">/// Overload of interleave for the common case of string separator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">          typename T = detail::ValueOfRange<Container>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">                       const StringRef &separator) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">template <typename Container, typename StreamT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">          typename T = detail::ValueOfRange<Container>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">inline void interleave(const Container &c, StreamT &os,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">                       const StringRef &separator) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">  interleave(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">      c, os, [&](const T &a) { os << a; }, separator);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">          typename T = detail::ValueOfRange<Container>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">inline void interleaveComma(const Container &c, StreamT &os,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">                            UnaryFunctor each_fn) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">  interleave(c, os, each_fn, ", ");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">template <typename Container, typename StreamT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="">          typename T = detail::ValueOfRange<Container>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">inline void interleaveComma(const Container &c, StreamT &os) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">  interleaveComma(c, os, [&](const T &a) { os << a; });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">//     Extra additions to <memory></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">struct FreeDeleter {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="">  void operator()(void* v) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">    ::free(v);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">template<typename First, typename Second></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="">struct pair_hash {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="uncoveredLine">  size_t operator()(const std::pair<First, Second> &P) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="uncoveredLine">    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="">/// Binary functor that adapts to any other binary functor after dereferencing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="">/// operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="">template <typename T> struct deref {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="">  T func;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="">  // Could be further improved to cope with non-derivable functors and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">  // non-binary functors (should be a variadic template member function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">  // operator()).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="">  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="">    assert(lhs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="">    assert(rhs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="">    return func(*lhs, *rhs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="">/// Tuple-like type for `zip_enumerator` dereference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">template <typename... Refs> struct enumerator_result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="">template <typename... Iters></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="">using EnumeratorTupleType = enumerator_result<decltype(*declval<Iters>())...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="">/// Zippy iterator that uses the second iterator for comparisons. For the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">/// increment to be safe, the second range has to be the shortest.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">/// Returns `enumerator_result` on dereference to provide `.index()` and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="">/// `.value()` member functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="">/// Note: Because the dereference operator returns `enumerator_result` as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="">/// value instead of a reference and does not strictly conform to the C++17's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="">/// definition of forward iterator. However, it satisfies all the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="">/// forward_iterator requirements that the `zip_common` and `zippy` depend on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="">/// and fully conforms to the C++20 definition of forward iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="">/// This is similar to `std::vector<bool>::iterator` that returns bit reference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="">/// wrappers on dereference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="">template <typename... Iters></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="">struct zip_enumerator : zip_common<zip_enumerator<Iters...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">                                   EnumeratorTupleType<Iters...>, Iters...> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="">  static_assert(sizeof...(Iters) >= 2, "Expected at least two iteratees");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="">  using zip_common<zip_enumerator<Iters...>, EnumeratorTupleType<Iters...>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="">                   Iters...>::zip_common;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="coveredLine">  bool operator==(const zip_enumerator &Other) const {</td>
    <td>35</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="coveredLine">    return std::get<1>(this->iterators) == std::get<1>(Other.iterators);</td>
    <td>35</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="">template <typename... Refs> struct enumerator_result<std::size_t, Refs...> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="">  static constexpr std::size_t NumRefs = sizeof...(Refs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="">  static_assert(NumRefs != 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">  // `NumValues` includes the index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">  static constexpr std::size_t NumValues = NumRefs + 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">  // Tuple type whose element types are references for each `Ref`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">  using range_reference_tuple = std::tuple<Refs...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="">  // Tuple type who elements are references to all values, including both</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="">  // the index and `Refs` reference types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="">  using value_reference_tuple = std::tuple<std::size_t, Refs...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="coveredLine">  enumerator_result(std::size_t Index, Refs &&...Rs)</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="coveredLine">      : Idx(Index), Storage(std::forward<Refs>(Rs)...) {}</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">  /// Returns the 0-based index of the current position within the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="">  /// input range(s).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="coveredLine">  std::size_t index() const { return Idx; }</td>
    <td>23</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="">  /// Returns the value(s) for the current iterator. This does not include the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">  /// index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="coveredLine">  decltype(auto) value() const {</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="">    if constexpr (NumRefs == 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="coveredLine">      return std::get<0>(Storage);</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="">      return Storage;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">  /// Returns the value at index `I`. This case covers the index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">  template <std::size_t I, typename = std::enable_if_t<I == 0>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="">  friend std::size_t get(const enumerator_result &Result) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">    return Result.Idx;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="">  /// Returns the value at index `I`. This case covers references to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">  /// iteratees.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">  template <std::size_t I, typename = std::enable_if_t<I != 0>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="">  friend decltype(auto) get(const enumerator_result &Result) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">    // Note: This is a separate function from the other `get`, instead of an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">    // `if constexpr` case, to work around an MSVC 19.31.31XXX compiler</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">    // (Visual Studio 2022 17.1) return type deduction bug.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="">    return std::get<I - 1>(Result.Storage);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="">  template <typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">  friend bool operator==(const enumerator_result &Result,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">                         const std::tuple<std::size_t, Ts...> &Other) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">    static_assert(NumRefs == sizeof...(Ts), "Size mismatch");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">    if (Result.Idx != std::get<0>(Other))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">      return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">    return Result.is_value_equal(Other, std::make_index_sequence<NumRefs>{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="">  template <typename Tuple, std::size_t... Idx></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">  bool is_value_equal(const Tuple &Other, std::index_sequence<Idx...>) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="">    return ((std::get<Idx>(Storage) == std::get<Idx + 1>(Other)) && ...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="">  std::size_t Idx;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">  // Make this tuple mutable to avoid casts that obfuscate const-correctness</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">  // issues. Const-correctness of references is taken care of by `zippy` that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="">  // defines const-non and const iterator types that will propagate down to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="">  // `enumerator_result`'s `Refs`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="">  //  Note that unlike the results of `zip*` functions, `enumerate`'s result are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="">  //  supposed to be modifiable even when defined as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="">  // `const`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="">  mutable range_reference_tuple Storage;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">/// Infinite stream of increasing 0-based `size_t` indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">struct index_stream {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">  struct iterator : iterator_facade_base<iterator, std::forward_iterator_tag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="">                                         const iterator> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="coveredLine">    iterator &operator++() {</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="coveredLine">      assert(Index != std::numeric_limits<std::size_t>::max() &&</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">             "Attempting to increment end iterator");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="coveredLine">      ++Index;</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="coveredLine">      return *this;</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="">    // Note: This dereference operator returns a value instead of a reference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="">    // and does not strictly conform to the C++17's definition of forward</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="">    // iterator. However, it satisfies all the forward_iterator requirements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="">    // that the `zip_common` depends on and fully conforms to the C++20</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="">    // definition of forward iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="coveredLine">    std::size_t operator*() const { return Index; }</td>
    <td>24</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">    friend bool operator==(const iterator &Lhs, const iterator &Rhs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="">      return Lhs.Index == Rhs.Index;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">    std::size_t Index = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="coveredLine">  iterator begin() const { return {}; }</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="coveredLine">  iterator end() const {</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="">    // We approximate 'infinity' with the max size_t value, which should be good</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">    // enough to index over any container.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="coveredLine">    iterator It;</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="coveredLine">    It.Index = std::numeric_limits<std::size_t>::max();</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="coveredLine">    return It;</td>
    <td>14</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="">} // end namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="">/// Given two or more input ranges, returns a new range whose values are are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">/// tuples (A, B, C, ...), such that A is the 0-based index of the item in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="">/// sequence, and B, C, ..., are the values from the original input ranges. All</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="">/// input ranges are required to have equal lengths. Note that the returned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="">/// iterator allows for the values (B, C, ...) to be modified.  Example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="">/// ```c++</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="">/// std::vector<char> Letters = {'A', 'B', 'C', 'D'};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="">/// std::vector<int> Vals = {10, 11, 12, 13};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="">/// for (auto [Index, Letter, Value] : enumerate(Letters, Vals)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="">///   printf("Item %zu - %c: %d\n", Index, Letter, Value);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="">///   Value -= 10;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">/// }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">/// Output:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="">///   Item 0 - A: 10</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">///   Item 1 - B: 11</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">///   Item 2 - C: 12</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="">///   Item 3 - D: 13</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">/// or using an iterator:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="">/// ```c++</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="">/// for (auto it : enumerate(Vals)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="">///   it.value() += 10;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="">///   printf("Item %zu: %d\n", it.index(), it.value());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="">/// }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">/// Output:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="">///   Item 0: 20</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="">///   Item 1: 21</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="">///   Item 2: 22</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="">///   Item 3: 23</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="">template <typename FirstRange, typename... RestRanges></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="coveredLine">auto enumerate(FirstRange &&First, RestRanges &&...Rest) {</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="">  if constexpr (sizeof...(Rest) != 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="">    // Note: Create an array instead of an initializer list to work around an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="">    // Apple clang 14 compiler bug.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="">    size_t sizes[] = {range_size(First), range_size(Rest)...};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="">    assert(all_equal(sizes) && "Ranges have different length");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="">  using enumerator = detail::zippy<detail::zip_enumerator, detail::index_stream,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="">                                   FirstRange, RestRanges...>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="">  return enumerator(detail::index_stream{}, std::forward<FirstRange>(First),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="coveredLine">                    std::forward<RestRanges>(Rest)...);</td>
    <td>13</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="">template <typename Predicate, typename... Args></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="">bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="">  auto z = zip(args...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="">  auto it = z.begin();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">  auto end = z.end();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="">  while (it != end) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="">    if (!std::apply([&](auto &&...args) { return P(args...); }, *it))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="">      return false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="">    ++it;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="">  return it.all_equals(end);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="">// Just an adaptor to switch the order of argument and have the predicate before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="">// the zipped inputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="">template <typename... ArgsThenPredicate, size_t... InputIndexes></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="">bool all_of_zip_predicate_last(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">    std::tuple<ArgsThenPredicate...> argsThenPredicate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="">    std::index_sequence<InputIndexes...>) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="">  auto constexpr OutputIndex =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="">      std::tuple_size<decltype(argsThenPredicate)>::value - 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">                             std::get<InputIndexes>(argsThenPredicate)...);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="">} // end namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="">/// Compare two zipped ranges using the provided predicate (as last argument).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="">/// Return true if all elements satisfy the predicate and false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="">//  Return false if the zipped iterator aren't all at end (size mismatch).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="">template <typename... ArgsAndPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="">bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="">  return detail::all_of_zip_predicate_last(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="">      std::forward_as_tuple(argsAndPredicate...),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="">      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="">/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="">/// time. Not meant for use with random-access iterators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="">/// Can optionally take a predicate to filter lazily some items.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="">template <typename IterTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="">bool hasNItems(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="">    Pred &&ShouldBeCounted =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="">    std::enable_if_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="">        !std::is_base_of<std::random_access_iterator_tag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="">                         typename std::iterator_traits<std::remove_reference_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="">                             decltype(Begin)>>::iterator_category>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">        void> * = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="">  for (; N; ++Begin) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="">    if (Begin == End)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="">      return false; // Too few.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="">    N -= ShouldBeCounted(*Begin);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="">  for (; Begin != End; ++Begin)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="">    if (ShouldBeCounted(*Begin))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="">      return false; // Too many.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">  return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="">/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="">/// time. Not meant for use with random-access iterators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="">/// Can optionally take a predicate to lazily filter some items.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="">template <typename IterTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="uncoveredLine">bool hasNItemsOrMore(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="">    Pred &&ShouldBeCounted =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="">    std::enable_if_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="">        !std::is_base_of<std::random_access_iterator_tag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">                         typename std::iterator_traits<std::remove_reference_t<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="">                             decltype(Begin)>>::iterator_category>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="">        void> * = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="uncoveredLine">  for (; N; ++Begin) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="uncoveredLine">    if (Begin == End)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="uncoveredLine">      return false; // Too few.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="uncoveredLine">    N -= ShouldBeCounted(*Begin);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="">/// Returns true if the sequence [Begin, End) has N or less items. Can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="">/// optionally take a predicate to lazily filter some items.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">template <typename IterTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="uncoveredLine">bool hasNItemsOrLess(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="uncoveredLine">    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="">    }) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="uncoveredLine">  assert(N != std::numeric_limits<unsigned>::max());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="uncoveredLine">  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="">/// Returns true if the given container has exactly N items</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="">template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="">  return hasNItems(std::begin(C), std::end(C), N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="">/// Returns true if the given container has N or more items</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="">template <typename ContainerTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="">bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="">  return hasNItemsOrMore(std::begin(C), std::end(C), N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="">/// Returns true if the given container has N or less items</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="">template <typename ContainerTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="">bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="">  return hasNItemsOrLess(std::begin(C), std::end(C), N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="">/// Returns a raw pointer that represents the same address as the argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="">/// This implementation can be removed once we move to C++20 where it's defined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="">/// as std::to_address().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="">/// The std::pointer_traits<>::to_address(p) variations of these overloads has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="">/// not been implemented.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="">template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="">template <class T> constexpr T *to_address(T *P) { return P; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="">namespace std {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="">template <typename... Refs></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="">struct tuple_size<llvm::detail::enumerator_result<Refs...>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="">    : std::integral_constant<std::size_t, sizeof...(Refs)> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="">template <std::size_t I, typename... Refs></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="">struct tuple_element<I, llvm::detail::enumerator_result<Refs...>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="">template <std::size_t I, typename... Refs></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="">struct tuple_element<I, const llvm::detail::enumerator_result<Refs...>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">} // namespace std</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="">#endif // LLVM_ADT_STLEXTRAS_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_8ArrayRefINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEENS_9StringRefEEEbOT_RKT0_</td>
    <td class="numberOfCalls">340</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10less_firstclISt4pairIjNS_9AttributeEEEEbRKT_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10less_firstclISt4pairIjNS_12AttributeSetEEEEbRKT_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm25array_pod_sort_comparatorINS_9AttributeEEEiPKvS3_</td>
    <td class="numberOfCalls">24</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29get_array_pod_sort_comparatorINS_9AttributeEEEPFiPKvS3_ERKT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIPNS_9AttributeEEEvT_S3_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPNS_9AttributeEEEvT_S3_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorINS_9AttributeELj8EEEEEvOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefISt4pairIjNS_9AttributeEEEEZNS_13AttributeList3getERNS_11LLVMContextES5_EUlRKS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRKNS_11SmallVectorINS_9AttributeELj8EEEZNKS_11AttrBuilder8overlapsERKNS_13AttributeMaskEEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofIRNS_8ArrayRefISt4pairIjNS_12AttributeSetEEEEZNS_13AttributeList3getERNS_11LLVMContextES5_EUlRKS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorINS_9AttributeELj8EEEZNS_11AttrBuilder6removeERKNS_13AttributeMaskEEUlS2_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_8ArrayRefINS_9AttributeEEEPS2_EET0_OT_S6_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_8ArrayRefINS_12AttributeSetEEEPS2_EET0_OT_S6_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_9StringRefEPcEET0_OT_S4_</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_8ArrayRefISt4pairIjNS_12AttributeSetEEEENS_10less_firstEEEbOT_T0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_8ArrayRefISt4pairIjNS_9AttributeEEEENS_10less_firstEEEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_8ArrayRefIjEEEEbOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_11SmallVectorINS_9AttributeELj8EEEEEbOT_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_8ArrayRefINS_9AttributeEEEEEbOT_</td>
    <td class="numberOfCalls">9</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRKNS_11SmallVectorINS_9AttributeELj8EEERNS_9StringRefE19AttributeComparatorEEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRKNS_11SmallVectorINS_9AttributeELj8EEERNS2_8AttrKindE19AttributeComparatorEEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">9</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_11SmallVectorINS_9AttributeELj8EEERNS_9StringRefE19AttributeComparatorEEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_11SmallVectorINS_9AttributeELj8EEERNS2_8AttrKindE19AttributeComparatorEEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_15SmallVectorImplINS_9AttributeEEERNS_9StringRefE19AttributeComparatorEEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_15SmallVectorImplINS_9AttributeEEERNS2_8AttrKindE19AttributeComparatorEEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">53</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8erase_ifINS_11SmallVectorINS_9AttributeELj8EEEZNS_11AttrBuilder6removeERKNS_13AttributeMaskEEUlS2_E_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorINS_12AttributeSetELj8EEERNS_8ArrayRefIS2_EEEEvRT_OT0_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorINS_9AttributeELj8EEERNS_12AttributeSetEEEvRT_OT0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorIKNS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEENS3_INS5_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEENS3_INS5_INS_11GlobalAliasELb1ELb0EvEELb0ELb1EEENS3_INS5_INS_11GlobalIFuncELb1ELb0EvEELb0ELb1EEEEEC2IJRKNS_14iterator_rangeIS8_EERKNSK_ISB_EERKNSK_ISE_EERKNSK_ISH_EEEEEDpOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEC2IJNS_14iterator_rangeIS7_EENSJ_ISA_EENSJ_ISD_EENSJ_ISG_EEEEEDpOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEC2IJRKNS_14iterator_rangeIS7_EERKNSJ_ISA_EERKNSJ_ISD_EERKNSJ_ISG_EEEEEDpOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorIKNS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEENS3_INS5_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEEC2IJNS_14iterator_rangeIS8_EENSE_ISB_EEEEEDpOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorIKNS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEENS3_INS5_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEEC2IJRKNS_14iterator_rangeIS8_EERKNSE_ISB_EEEEEDpOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEC2IJNS_14iterator_rangeIS7_EENSD_ISA_EEEEEDpOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEC2IJRKNS_14iterator_rangeIS7_EERKNSD_ISA_EEEEEDpOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorIKNS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEENS3_INS5_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEENS3_INS5_INS_11GlobalAliasELb1ELb0EvEELb0ELb1EEENS3_INS5_INS_11GlobalIFuncELb1ELb0EvEELb0ELb1EEEEEC2IJNS_14iterator_rangeIS8_EENSK_ISB_EENSK_ISE_EENSK_ISH_EEEEEDpOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeIKNS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalAliasELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalIFuncELb1ELb0EvEELb0ELb1EEEEEEE10begin_implIJLm0ELm1ELm2ELm3EEEENS_15concat_iteratorIS3_JSA_SE_SI_SM_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeINS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEEE10begin_implIJLm0ELm1EEEENS_15concat_iteratorIS2_JS9_SD_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeINS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEEE10begin_implIJLm0ELm1ELm2ELm3EEEENS_15concat_iteratorIS2_JS9_SD_SH_SL_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeIKNS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEEEE10begin_implIJLm0ELm1EEEENS_15concat_iteratorIS3_JSA_SE_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeIKNS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEEEE8end_implIJLm0ELm1EEEENS_15concat_iteratorIS3_JSA_SE_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeINS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEEE8end_implIJLm0ELm1EEEENS_15concat_iteratorIS2_JS9_SD_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeINS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEEE8end_implIJLm0ELm1ELm2ELm3EEEENS_15concat_iteratorIS2_JS9_SD_SH_SL_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeIKNS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalAliasELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalIFuncELb1ELb0EvEELb0ELb1EEEEEEE8end_implIJLm0ELm1ELm2ELm3EEEENS_15concat_iteratorIS3_JSA_SE_SI_SM_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail12concat_rangeINS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEEEC2EOSA_OSE_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail12concat_rangeIKNS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEEEEC2EOSB_OSF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail12concat_rangeINS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEEEC2EOSA_OSE_OSI_OSM_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail12concat_rangeIKNS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalAliasELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalIFuncELb1ELb0EvEELb0ELb1EEEEEEEC2EOSB_OSF_OSJ_OSN_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeIKNS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalAliasELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalIFuncELb1ELb0EvEELb0ELb1EEEEEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeINS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEEE5beginEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeIKNS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeINS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEEE5beginEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeIKNS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalAliasELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_11GlobalIFuncELb1ELb0EvEELb0ELb1EEEEEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeINS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEEE3endEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeIKNS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS4_INS5_INS7_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12concat_rangeINS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEEEENS3_INS4_INS6_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEEE3endEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6concatIKNS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEENS3_INS4_INS6_INS_11GlobalAliasELb1ELb0EvEELb0ELb1EEEEENS3_INS4_INS6_INS_11GlobalIFuncELb1ELb0EvEELb0ELb1EEEEEEEENS_6detail12concat_rangeIT_JDpT0_EEEDpOSQ_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6concatINS_11GlobalValueEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS2_INS3_INS5_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEENS2_INS3_INS5_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEEEENS2_INS3_INS5_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEEEENS_6detail12concat_rangeIT_JDpT0_EEEDpOSP_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6concatIKNS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb1EEEEENS3_INS4_INS6_INS_14GlobalVariableELb1ELb0EvEELb0ELb1EEEEEEEENS_6detail12concat_rangeIT_JDpT0_EEEDpOSI_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6concatINS_12GlobalObjectEJNS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEENS2_INS3_INS5_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEEEENS_6detail12concat_rangeIT_JDpT0_EEEDpOSH_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRNS_6ModuleEZNS_13PMDataManager27emitInstrCountChangedRemarkEPNS_4PassES2_ljRNS_9StringMapISt4pairIjjENS_15MallocAllocatorEEEPNS_8FunctionEEUlRKSC_E0_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_15SmallVectorImplIPKvEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">1170</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_11SmallVectorINS_16PointerAlignElemELj8EEERjZNS_10DataLayout25setPointerAlignmentInBitsEjNS_5AlignES7_jjEUlRKS2_jE_EEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRKNS_11SmallVectorINS_16PointerAlignElemELj8EEERjZNKS_10DataLayout19getPointerAlignElemEjEUlRKS2_jE_EEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15partition_pointIRNS_15SmallVectorImplINS_15LayoutAlignElemEEEZNS_10DataLayout12setAlignmentENS_13AlignTypeEnumENS_5AlignES7_jEUlRKS2_E_RS2_EEDaOT_T0_</td>
    <td class="numberOfCalls">78</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15partition_pointIRKNS_15SmallVectorImplINS_15LayoutAlignElemEEEZL23findAlignmentLowerBoundS5_jEUlRKS2_E_S7_EEDaOT_T0_</td>
    <td class="numberOfCalls">24</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15mapped_iteratorIPNS_3UseEPFPNS_10BasicBlockEPNS_5ValueEES4_E10getCurrentEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseINS_10iota_rangeIjEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8for_eachIRNS_8ArrayRefIiEEZNS_17ShuffleVectorInst24isOneUseSingleSourceMaskES2_iEUliE0_EET0_OT_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorIjLj8EEEZNS_27SwitchInstProfUpdateWrapper24buildProfBranchWeightsMDEvEUljE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefIiEEZNS_17ShuffleVectorInst24isOneUseSingleSourceMaskES2_iEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefIiEEZL27isReplicationMaskWithParamsS2_iiEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11find_if_notIRKNS_8ArrayRefIiEEZNS_17ShuffleVectorInst17isReplicationMaskES2_RiS6_EUliE_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_8ArrayRefIPNS_5ValueEEEPNS_3UseEEET0_OT_S8_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_14iterator_rangeIPKPNS_10BasicBlockEEEPS3_EET0_OT_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_8ArrayRefIiEEiEEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_8ArrayRefIjEEjEEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9all_equalIRNS_8ArrayRefIiEEEEbOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeISt6vectorIPNS_5ValueESaIS3_EERKNS_8ArrayRefINS_3UseEEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15callable_detail8CallableIPFPNS_10BasicBlockEPNS_5ValueEELb1EE9convertInIRS7_EEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15callable_detail8CallableIPFPNS_10BasicBlockEPNS_5ValueEELb1EEC2IS7_Li0EEEOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15callable_detail8CallableIPFPNS_10BasicBlockEPNS_5ValueEELb1EEclIJRNS_3UseEELi0EEEDcDpOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10drop_beginINS_8ArrayRefINS_9MDOperandEEEEEDaOT_m</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15mapped_iteratorIPNS_3UseEPFPNS_10BasicBlockEPNS_5ValueEES4_EC2ES2_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15mapped_iteratorIPNS_3UseEPFPNS_10BasicBlockEPNS_5ValueEES4_EdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_3UseEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EE5derefIJLm0ELm1EEEESA_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_3UseEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_3UseEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEC2EOS4_OS6_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_3UseEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEdeEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_3UseEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_14iterator_rangeIPNS_3UseEEEEEC2EOS3_OS7_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_14iterator_rangeIPNS_3UseEEEEE5beginEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_14iterator_rangeIPNS_3UseEEEEE3endEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_14iterator_rangeIPNS_3UseEEEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorES6_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_14iterator_rangeIPNS_3UseEEEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorES6_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm25array_pod_sort_comparatorIPNS_10BasicBlockEEEiPKvS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29get_array_pod_sort_comparatorIPNS_10BasicBlockEEEPFiPKvS4_ERKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIPPNS_10BasicBlockEEEvT_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_10BasicBlockEEEvT_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPSt4pairIPNS_10BasicBlockEPNS_5ValueEEEEvT_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorIPNS_10BasicBlockELj8EEEEEvOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorISt4pairIPNS_10BasicBlockEPNS_5ValueEELj8EEEEEvOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_13IntrinsicInstEZN12_GLOBAL__N_18Verifier22verifyNoAliasScopeDeclEvEUlS2_S2_E0_EEvT_S7_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorIPNS_13IntrinsicInstELj4EEEZN12_GLOBAL__N_18Verifier22verifyNoAliasScopeDeclEvEUlS3_S3_E0_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorIPNS_5ValueELj16EEEZN12_GLOBAL__N_18Verifier22visitGetElementPtrInstERNS_17GetElementPtrInstEEUlS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_9MDOperandEEEZN12_GLOBAL__N_18Verifier20visitMemProfMetadataERNS_11InstructionEPNS_6MDNodeEEUlRS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefINS_9MDOperandEEEZN12_GLOBAL__N_18Verifier23visitAnnotationMetadataEPNS_6MDNodeEEUlRT_E_EEbOS8_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_11SmallVectorIPNS_10BasicBlockELj16EEEZN12_GLOBAL__N_18Verifier18visitIntrinsicCallEjRNS_8CallBaseEEUlPKS2_E1_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_8CallBaseELj8EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_15SmallVectorImplIPNS_8CallBaseEEEPNS_5ValueEEEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_11AllocFnKindES1_EEbSt16initializer_listIT_ERKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9partitionIRNS_11SmallVectorIPNS_8CallBaseELj8EEEZN12_GLOBAL__N_18Verifier24verifyConvergenceControlERNS_8FunctionEEUlS3_E0_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPKNS_5ValueELj6EEENS_14iterator_rangeINS2_18user_iterator_implIKNS_4UserEEEEEEEvRT_OT0_</td>
    <td class="numberOfCalls">11</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_3UseEEEeqERKS6_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRNS_3UseEEEC2EmS3_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRNS_3UseEEE5indexEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRNS_3UseEEE5valueEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail12index_stream8iteratorppEv</td>
    <td class="numberOfCalls">21</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12index_stream8iteratordeEv</td>
    <td class="numberOfCalls">24</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12index_stream5beginEv</td>
    <td class="numberOfCalls">14</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12index_stream3endEv</td>
    <td class="numberOfCalls">14</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateINS_14iterator_rangeIPNS_3UseEEEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10less_firstclISt4pairIjPNS_6MDNodeEEEEbRKT_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPSt4pairIPvS1_INS_12PointerUnionIJPNS_15MetadataAsValueEPNS_8MetadataEEEEmEEZNS_23ReplaceableMetadataImpl14resolveAllUsesEbEUlRKSA_SE_E_EEvT_SG_T0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPSt4pairIPvS1_INS_12PointerUnionIJPNS_15MetadataAsValueEPNS_8MetadataEEEEmEEZNS_23ReplaceableMetadataImpl18replaceAllUsesWithES7_EUlRKSA_SE_E_EEvT_SG_T0_</td>
    <td class="numberOfCalls">37</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPSt4pairINS_12PointerUnionIJPNS_15MetadataAsValueEPNS_8MetadataEEEEmEZNS_23ReplaceableMetadataImpl18getAllArgListUsersEvEUlT_T0_E_EEvSC_SC_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorIPSt4pairINS_12PointerUnionIJPNS_15MetadataAsValueEPNS_8MetadataEEEEmELj6EEEZNS_23ReplaceableMetadataImpl18getAllArgListUsersEvEUlT_T0_E_EEvOSE_SF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorISt4pairIPvS2_INS_12PointerUnionIJPNS_15MetadataAsValueEPNS_8MetadataEEEEmEELj8EEEZNS_23ReplaceableMetadataImpl18replaceAllUsesWithES8_EUlRKSB_SG_E_EEvOT_T0_</td>
    <td class="numberOfCalls">37</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorISt4pairIPvS2_INS_12PointerUnionIJPNS_15MetadataAsValueEPNS_8MetadataEEEEmEELj8EEEZNS_23ReplaceableMetadataImpl14resolveAllUsesEbEUlRKSB_SG_E_EEvOT_T0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_8ArrayRefINS_9MDOperandEEEZNS_11Instruction21addAnnotationMetadataENS_11SmallVectorINS_9StringRefELj3EEEEUlRT_E_EEbOS8_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorINS_9StringRefELj2EEES2_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_8MetadataELj4EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorINS_13MDAttachments10AttachmentELj1EEEZNS2_5eraseEjEUlRKS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorIPNS_8MetadataELj4EEEZNS_6MDNode9intersectEPS6_S7_EUlS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorIPNS_8MetadataELj4EEENS_9SetVectorIS3_S4_NS_8DenseSetIS3_NS_12DenseMapInfoIS3_vEEEELj4EE19TestAndEraseFromSetIZNS_6MDNode9intersectEPSD_SE_EUlS3_E_EEEEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorINS_13MDAttachments10AttachmentELj1EEEZNS_11Instruction27dropUnknownNonDebugMetadataENS_8ArrayRefIjEEEUlRKS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_8ArrayRefImEEN9__gnu_cxx17__normal_iteratorIPmSt6vectorImSaImEEEEEET0_OT_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4moveINS_15MutableArrayRefINS_9MDOperandEEEPS2_EET0_OT_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorINS_9StringRefELj2EEES2_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_8ArrayRefINS_9MDOperandEEEPNS_6MDNodeEEEbOT_RKT0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8count_ifINS_8ArrayRefINS_9MDOperandEEEPFbPNS_8MetadataEEEEDaOT_T0_</td>
    <td class="numberOfCalls">32</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11stable_sortIRNS_15SmallVectorImplISt4pairIjPNS_6MDNodeEEEENS_10less_firstEEEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8erase_ifINS_11SmallVectorINS_13MDAttachments10AttachmentELj1EEEZNS2_5eraseEjEUlRKS3_E_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8erase_ifINS_11SmallVectorINS_13MDAttachments10AttachmentELj1EEEZNS_11Instruction27dropUnknownNonDebugMetadataENS_8ArrayRefIjEEEUlRKS3_E_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16hasSingleElementINS_14iterator_rangeINS_5Value17use_iterator_implIKNS_3UseEEEEEEEbOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb1EEESt8functionIFbRKS4_EESt26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb1EEESt8functionIFbRKS4_EESt26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeINS_5Value18user_iterator_implIKNS_4UserEEEEEZNKS_8Function15hasAddressTakenEPPS5_bbbbEUlS9_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeINS_5Value18user_iterator_implIKNS_4UserEEEEEZNKS_8Function15hasAddressTakenEPPS5_bbbbEUlS9_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_15MutableArrayRefINS_8ArgumentEEEZNS_8Function21stealArgumentListFromERS4_EUlRKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_8ArrayRefIPNS_4TypeEEEZL20getIntrinsicNameImpljS4_PNS_6ModuleEPNS_12FunctionTypeEbEUlS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15partition_pointIRNS_8ArrayRefI19IntrinsicTargetInfoEEZL18findTargetSubtableNS_9StringRefEEUlRKS2_E_S7_EEDaOT_T0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELj3EEENS_9StringRefEEEDaOT_RKT0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11stable_sortIRSt6vectorINS_16MCDwarfFrameInfoESaIS2_EEZNS_19MCDwarfFrameEmitter4EmitERNS_16MCObjectStreamerEPNS_12MCAsmBackendEbEUlRKS2_SC_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefINS_16AliasPatternCondEEEZNS_13MCInstPrinter18matchAliasPatternsEPKNS_6MCInstEPKNS_15MCSubtargetInfoERKNS_17AliasMatchingDataEEUlRKS2_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRKNS_8ArrayRefINS_17PatternsForOpcodeEEEjZNS_13MCInstPrinter18matchAliasPatternsEPKNS_6MCInstEPKNS_15MCSubtargetInfoERKNS_17AliasMatchingDataEEUlRKS2_jE_EEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">49</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRKNS_8ArrayRefINS_18SubtargetSubTypeKVEEEEEbOT_</td>
    <td class="numberOfCalls">26</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_8ArrayRefINS_18SubtargetFeatureKVEEEEEbOT_</td>
    <td class="numberOfCalls">22</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_8ArrayRefINS_18SubtargetSubTypeKVEEEEEbOT_</td>
    <td class="numberOfCalls">22</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_8ArrayRefINS_18SubtargetSubTypeKVEEERNS_9StringRefEEEDaOT_OT0_</td>
    <td class="numberOfCalls">58</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_8ArrayRefINS_18SubtargetFeatureKVEEERNS_9StringRefEEEDaOT_OT0_</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIN9__gnu_cxx17__normal_iteratorIPSt4pairINS_9StringRefEPKNS_6TargetEESt6vectorIS8_SaIS8_EEEEEEvT_SE_PFiPKNSt15iterator_traitsISE_E10value_typeESJ_E</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifINS_14iterator_rangeINS_14TargetRegistry8iteratorEEEZNS2_12lookupTargetENS_9StringRefERNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEUlRKNS_6TargetEE_EEDaOT_T0_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifINS_14iterator_rangeINS_14TargetRegistry8iteratorEEEZNS2_12lookupTargetENS_9StringRefERNS_6TripleERNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEUlRKNS_6TargetEE_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_11SmallVectorIPKNS_11GlobalAliasELj16EEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE15incrementHelperILm3EEEbv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE15incrementHelperILm2EEEbv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE15incrementHelperILm1EEEbv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE15incrementHelperILm0EEEbv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEE15incrementHelperILm0EEEbv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEE15incrementHelperILm1EEEbv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEE9incrementIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE9incrementIJLm0ELm1ELm2ELm3EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE9getHelperILm2EEEPS1_v</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEE9getHelperILm0EEEPS1_v</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEE9getHelperILm1EEEPS1_v</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE9getHelperILm3EEEPS1_v</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE9getHelperILm1EEEPS1_v</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE9getHelperILm0EEEPS1_v</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEE3getIJLm0ELm1ELm2ELm3EEEERS1_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEE3getIJLm0ELm1EEEERS1_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEppEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEppEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEdeEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEdeEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_12GlobalObjectEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEEEEeqERKSB_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15concat_iteratorINS_11GlobalValueEJNS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_14GlobalVariableELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalAliasELb1ELb0EvEELb0ELb0EEENS2_INS4_INS_11GlobalIFuncELb1ELb0EvEELb0ELb0EEEEEeqERKSH_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPSt4pairINS_9StringRefEjEZNS_10AsmPrinter16emitFunctionBodyEvEUlRKS3_S7_E_EEvT_S9_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorISt4pairINS_9StringRefEjELj128EEEZNS_10AsmPrinter16emitFunctionBodyEvEUlRKS4_S9_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11stable_sortIRNS_11SmallVectorINS_10AsmPrinter8StructorELj8EEEZNS2_24preprocessXXStructorListERKNS_10DataLayoutEPKNS_8ConstantES5_EUlRKS3_SD_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_13TinyPtrVectorIPNS_8MCSymbolEEERS4_EEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKNS_14MachineOperandEPFbRS2_ESt26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">32</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKNS_14MachineOperandEPFbRS2_ESt26bidirectional_iterator_tagEC2ES3_S3_S6_</td>
    <td class="numberOfCalls">26</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKNS_14MachineOperandEPFbRS2_ESt26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20filter_iterator_baseIPKNS_14MachineOperandEPFbRS2_ESt26bidirectional_iterator_tagEdeEv</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_implIPKNS_14MachineOperandEPFbRS2_ESt26bidirectional_iterator_tagEC2ES3_S3_S6_</td>
    <td class="numberOfCalls">26</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17make_filter_rangeINS_14iterator_rangeIPKNS_14MachineOperandEEEPFbRS3_EEENS1_INS_20filter_iterator_implIDTcl9adl_begincl7declvalIRT_EEEET0_NS_6detail15fwd_or_bidi_tagISC_E4typeEEEEEOSA_SD_</td>
    <td class="numberOfCalls">13</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPcEEENS0_17enumerator_resultIJmRcEEEJS4_S5_EE5derefIJLm0ELm1EEEES9_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPcEEENS0_17enumerator_resultIJmRcEEEJS4_S5_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPcEEENS0_17enumerator_resultIJmRcEEEJS4_S5_EEC2EOS4_OS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPcEEENS0_17enumerator_resultIJmRcEEEJS4_S5_EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPcEEENS0_17enumerator_resultIJmRcEEEJS4_S5_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallStringILj32EEEEEC2EOS3_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallStringILj32EEEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallStringILj32EEEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallStringILj32EEEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPcEEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallStringILj32EEEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPcEEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPNS_11DbgValueLocEEEvT_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorINS_11DbgValueLocELj1EEEEEvOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPNS_16DwarfCompileUnit10GlobalExprEZL15sortGlobalExprsRNS_15SmallVectorImplIS2_EEEUlS2_S2_E_EEvT_S8_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIN9__gnu_cxx17__normal_iteratorIPPNS_16DwarfCompileUnitESt6vectorIS4_SaIS4_EEEEZNS_10DwarfDebug16emitDebugARangesEvEUlPKS3_SC_E0_EEvT_SE_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPNS_11DbgVariable14FrameIndexExprEZNKS1_18getFrameIndexExprsEvEUlRKS2_S5_E0_EEvT_S7_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPSt4pairINS_9StringRefEPKNS_3DIEEEZNS_10DwarfDebug19emitDebugPubSectionEbS2_PNS_16DwarfCompileUnitERKNS_9StringMapIS5_NS_15MallocAllocatorEEEEUlRT_RT0_E_EEvSG_SG_SI_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorISt4pairINS_9StringRefEPKNS_3DIEEELj0EEEZNS_10DwarfDebug19emitDebugPubSectionEbS3_PNS_16DwarfCompileUnitERKNS_9StringMapIS6_NS_15MallocAllocatorEEEEUlRT_RT0_E_EEvOSI_SK_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRSt6vectorIPNS_16DwarfCompileUnitESaIS3_EEZNS_10DwarfDebug16emitDebugARangesEvEUlPKS2_S9_E0_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorINS_11DbgVariable14FrameIndexExprELj1EEEZNKS2_18getFrameIndexExprsEvEUlRKS3_S7_E0_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_15SmallVectorImplINS_16DwarfCompileUnit10GlobalExprEEEZL15sortGlobalExprsS5_EUlS3_S3_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorINS_11DbgValueLocELj1EEEZNS_13DebugLocEntry9addValuesENS_8ArrayRefIS2_EEEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorINS_11DbgValueLocELj1EEEZNS_13DebugLocEntry8finalizeERKNS_10AsmPrinterERNS_14DebugLocStream11ListBuilderEPKNS_11DIBasicTypeERNS_16DwarfCompileUnitEEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_14MachineOperandEEEZL15validThroughoutRNS_13LexicalScopesEPKNS_12MachineInstrESA_RKNS_19InstructionOrderingEEUlRS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorINS_11DbgVariable14FrameIndexExprELj1EEEZNKS2_18getFrameIndexExprsEvEUlRKS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorINS_11DbgVariable14FrameIndexExprELj1EEEZNS2_11addMMIEntryERKS2_EUlRS3_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_8ArrayRefINS_16DbgValueLocEntryEEEZNS_10DwarfDebug17emitDebugLocValueERKNS_10AsmPrinterEPKNS_11DIBasicTypeERKNS_11DbgValueLocERNS_15DwarfExpressionEEUlRKS2_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_9MapVectorIPKNS_6MDNodeEPNS_16DwarfCompileUnitENS_8DenseMapIS4_jNS_12DenseMapInfoIS4_vEENS_6detail12DenseMapPairIS4_jEEEENS_11SmallVectorISt4pairIS4_S6_ELj0EEEEEZNS_10DwarfDebug19emitDebugRangesImplERKNS_9DwarfFileEPNS_9MCSectionEEUlRKSG_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_8ArrayRefINS_16DbgValueLocEntryEEEZNS_11DbgValueLocC4EPKNS_12DIExpressionES3_bEUlT_E_EEbOS9_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofIRNS_11SmallVectorI15FwdRegParamInfoLj2EEEZL19addToFwdRegWorklistRNS_9MapVectorIjS3_NS_8DenseMapIjjNS_12DenseMapInfoIjvEENS_6detail12DenseMapPairIjjEEEENS1_ISt4pairIjS3_ELj0EEEEEjPKNS_12DIExpressionENS_8ArrayRefIS2_EEEUlRKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofIRNS_11SmallVectorINS_11DbgVariable14FrameIndexExprELj1EEEZNS2_11addMMIEntryERKS2_EUlRKS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPKNS_12DISubprogramELj16EEES4_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIjLj4EEEjEEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorISt4pairImNS_11DbgValueLocEELj4EEEZNS_10DwarfDebug17buildLocationListERNS_15SmallVectorImplINS_13DebugLocEntryEEERKNS1_INS_18DbgValueHistoryMap5EntryELj4EEEEUlRS4_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_11SmallVectorINS_11DbgValueLocELj1EEEEEbOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11stable_sortIRNS_11SmallVectorINS_8SymbolCUELj8EEEZNS_10DwarfDebug16emitDebugARangesEvEUlRKS2_S7_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8erase_ifINS_11SmallVectorISt4pairImNS_11DbgValueLocEELj4EEEZNS_10DwarfDebug17buildLocationListERNS_15SmallVectorImplINS_13DebugLocEntryEEERKNS1_INS_18DbgValueHistoryMap5EntryELj4EEEEUlRS4_E_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueISt6vectorImSaImEENS_5dwarf12LocationAtomEEEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9pair_hashIPKNS_12DILocalScopeEPKNS_10DILocationEEclERKSt4pairIS3_S6_E</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPcEEeqERKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRcEEC2EmS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRcEE5indexEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRcEE5valueEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateIRNS_11SmallStringILj32EEEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEENS0_17enumerator_resultIJmRSA_EEEJS4_SB_EE5derefIJLm0ELm1EEEESF_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEENS0_17enumerator_resultIJmRSB_EEEJS4_SC_EE5derefIJLm0ELm1EEEESG_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKPNS_8MCSymbolEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EE5derefIJLm0ELm1EEEESC_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEENS0_17enumerator_resultIJmRSA_EEEJS4_SB_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEENS0_17enumerator_resultIJmRSB_EEEJS4_SC_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKPNS_8MCSymbolEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEENS0_17enumerator_resultIJmRSB_EEEJS4_SC_EEC2EOS4_OSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEENS0_17enumerator_resultIJmRSA_EEEJS4_SB_EEC2EOS4_OSB_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKPNS_8MCSymbolEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EEC2EOS4_OS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEENS0_17enumerator_resultIJmRSA_EEEJS4_SB_EEdeEv</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEENS0_17enumerator_resultIJmRSB_EEEJS4_SC_EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKPNS_8MCSymbolEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEENS0_17enumerator_resultIJmRSA_EEEJS4_SB_EEppEv</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEENS0_17enumerator_resultIJmRSB_EEEJS4_SC_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKPNS_8MCSymbolEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_8ArrayRefISt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEEEC2EOS3_SB_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefISt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEEEC2EOS3_OSB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERKNS_8ArrayRefIPNS_8MCSymbolEEEEEC2EOS3_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_8ArrayRefISt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEEE5beginEv</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERKNS_8ArrayRefIPNS_8MCSymbolEEEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefISt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERKNS_8ArrayRefIPNS_8MCSymbolEEEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_8ArrayRefISt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEEE3endEv</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefISt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_8ArrayRefISt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKS9_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefISt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKSA_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERKNS_8ArrayRefIPNS_8MCSymbolEEEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKS6_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefISt6vectorIPNS_14AccelTableBase8HashDataESaIS8_EEEEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKSA_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERKNS_8ArrayRefIPNS_8MCSymbolEEEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKS6_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_8ArrayRefISt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS6_EEEEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKS9_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm25array_pod_sort_comparatorIjEEiPKvS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29get_array_pod_sort_comparatorIjEEPFiPKvS2_ERKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIN9__gnu_cxx17__normal_iteratorIPjSt6vectorIjSaIjEEEEEEvT_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11stable_sortIRSt6vectorIPNS_14AccelTableBase8HashDataESaIS4_EEZNS2_8finalizeEPNS_10AsmPrinterENS_9StringRefEEUlS4_S4_E0_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11stable_sortIRSt6vectorIPNS_14AccelTableDataESaIS3_EEZNS_14AccelTableBase8finalizeEPNS_10AsmPrinterENS_9StringRefEEUlPKS2_SC_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS5_EEEEeqERKSB_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPKPNS_8MCSymbolEEEeqERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPKSt6vectorIPNS_14AccelTableBase8HashDataESaIS7_EEEEeqERKSC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS3_EEEEC2EmS8_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRKPNS_8MCSymbolEEEC2EmS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRKSt6vectorIPNS_14AccelTableBase8HashDataESaIS5_EEEEC2EmS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKPNS_8MCSymbolEEE5indexEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS3_EEEE5indexEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKSt6vectorIPNS_14AccelTableBase8HashDataESaIS5_EEEE5indexEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKSt6vectorIPNS_14AccelTableBase8HashDataESaIS5_EEEE5valueEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKSt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS3_EEEE5valueEv</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKPNS_8MCSymbolEEE5valueEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateIRNS_8ArrayRefISt10unique_ptrINS_16DwarfCompileUnitESt14default_deleteIS3_EEEEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateINS_8ArrayRefISt6vectorIPNS_14AccelTableBase8HashDataESaIS5_EEEEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateIRKNS_8ArrayRefIPNS_8MCSymbolEEEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRSt6vectorINS_16DwarfCompileUnit11BaseTypeRefESaIS3_EEEEDaOT_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_15SmallVectorImplIPNS_11DbgVariableEEEEEDaOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_8ArrayRefINS_16DbgValueLocEntryEEEZNS_16DwarfCompileUnit24constructVariableDIEImplERKNS_11DbgVariableEbEUlRKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPKNS_14StringMapEntryINS_20DwarfStringPoolEntryEEEZNS_15DwarfStringPool4emitERNS_10AsmPrinterEPNS_9MCSectionESB_bEUlS5_S5_E_EEvT_SD_T0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorIPKNS_14StringMapEntryINS_20DwarfStringPoolEntryEEELj64EEEZNS_15DwarfStringPool4emitERNS_10AsmPrinterEPNS_9MCSectionESD_bEUlS6_S6_E_EEvOT_T0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_6SDNodeELb1ELb0EvEELb0ELb0EEEEC2ES6_</td>
    <td class="numberOfCalls">32</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_6SDNodeELb1ELb0EvEELb0ELb0EEEEdeEv</td>
    <td class="numberOfCalls">164</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_6SDNodeELb1ELb0EvEELb0ELb0EEEEppEv</td>
    <td class="numberOfCalls">164</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_6SDNodeELb1ELb0EvEELb0ELb0EEEEES9_</td>
    <td class="numberOfCalls">180</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeINS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_6SDNodeELb1ELb0EvEELb0ELb0EEEEEEENS1_INS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOSA_</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm25array_pod_sort_comparatorIN12_GLOBAL__N_17UseMemoEEEiPKvS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29get_array_pod_sort_comparatorIN12_GLOBAL__N_17UseMemoEEEPFiPKvS4_ERKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIPN12_GLOBAL__N_17UseMemoEEEvT_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPN12_GLOBAL__N_17UseMemoEEEvT_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorIN12_GLOBAL__N_17UseMemoELj4EEEEEvOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefINS_7SDValueEEEZNS_12SelectionDAG22FoldConstantArithmeticEjRKNS_5SDLocENS_3EVTES3_EUlRKS2_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefINS_7SDValueEEEZNS_12SelectionDAG22FoldConstantArithmeticEjRKNS_5SDLocENS_3EVTES3_EUlRKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefINS_7SDValueEEEZL18foldCONCAT_VECTORSRKNS_5SDLocENS_3EVTES3_RNS_12SelectionDAGEEUlS2_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefINS_7SDValueEEEZL18foldCONCAT_VECTORSRKNS_5SDLocENS_3EVTES3_RNS_12SelectionDAGEEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefINS_7SDValueEEEZL16FoldBUILD_VECTORRKNS_5SDLocENS_3EVTES3_RNS_12SelectionDAGEEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefINS_5SDUseEEEZNKS_12SelectionDAG32isGuaranteedNotToBeUndefOrPoisonENS_7SDValueERKNS_5APIntEbjEUlS5_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefINS_5SDUseEEEZNKS_12SelectionDAG22isKnownToBeAPowerOfTwoENS_7SDValueEjEUlS5_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefIiEEZNS_12SelectionDAG16getVectorShuffleENS_3EVTERKNS_5SDLocENS_7SDValueES9_S2_EUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeINS_6SDNode17value_op_iteratorEEEZNS_3ISD16allOperandsUndefEPKS2_EUlNS_7SDValueEE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefINS_5SDUseEEEZNKS_7SDValue30reachesChainWithoutSideEffectsES4_jEUlS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_6SDNode17value_op_iteratorEEEZNS_12SelectionDAG7isUndefEjNS_8ArrayRefINS_7SDValueEEEEUlS7_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRKNS_11SmallVectorImLj6EEEZNKS_9BitVector3anyEvEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_6SDNode17value_op_iteratorEEEZNKS2_11isOperandOfEPKS2_EUlNS_7SDValueEE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofIRNS_8ArrayRefINS_3ISD8NodeTypeEEEZNS_12SelectionDAG19matchBinOpReductionEPNS_6SDNodeERS3_S4_bEUlS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_8ArrayRefINS_3EVTEEEPS2_EET0_OT_S6_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_8ArrayRefIPNS_17MachineMemOperandEEEPS3_EET0_OT_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_11SmallVectorIiLj8EEEPiEET0_OT_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_11SmallVectorIPNS_6SDNodeELj6EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_8ArrayRefIPKNS_6SDNodeEEES4_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_14iterator_rangeINS_6SDNode17value_op_iteratorEEENS_7SDValueEEEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_8ArrayRefINS_5SDUseEEENS_7SDValueEEEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPNS_6SDNodeELj16EEENS_14iterator_rangeINS2_12use_iteratorEEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorINS_7SDValueELj8EEERNS1_IS2_Lj2EEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16hasSingleElementINS_14iterator_rangeINS_6SDNode12use_iteratorEEEEEbOT_</td>
    <td class="numberOfCalls">14</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10drop_beginINS_8ArrayRefINS_5SDUseEEEEEDaOT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseINS_8ArrayRefINS_5SDUseEEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKiEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EE5derefIJLm0ELm1EEEESA_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_7SDValueEEEESt5tupleIJRS4_RS6_EEJS5_S7_EE5derefIJLm0ELm1EEEESC_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKNS_5SDUseEEEENS0_17enumerator_resultIJmRS6_EEEJS4_S7_EE5derefIJLm0ELm1EEEESB_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_7SDValueEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EE5derefIJLm0ELm1EEEESA_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_5APIntES7_EEESt5tupleIJRS4_RS6_SB_EEJS5_S7_S7_EE5derefIJLm0ELm1ELm2EEEESC_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_7SDValueEEEESt5tupleIJRS4_RS6_EEJS5_S7_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKNS_5SDUseEEEENS0_17enumerator_resultIJmRS6_EEEJS4_S7_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_7SDValueEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_5APIntES7_EEESt5tupleIJRS4_RS6_SB_EEJS5_S7_S7_EE7tup_incIJLm0ELm1ELm2EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKiEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_5APIntES7_EEESt5tupleIJRS4_RS6_SB_EEJS5_S7_S7_EEC2EOS5_OS7_SF_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_7SDValueEEEESt5tupleIJRS4_RS6_EEJS5_S7_EEC2EOS5_OS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKNS_5SDUseEEEENS0_17enumerator_resultIJmRS6_EEEJS4_S7_EEC2EOS4_OS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_7SDValueEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEC2EOS4_OS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKiEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEC2EOS4_OS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKiEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_7SDValueEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKNS_5SDUseEEEENS0_17enumerator_resultIJmRS6_EEEJS4_S7_EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_7SDValueEEEESt5tupleIJRS4_RS6_EEJS5_S7_EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_5APIntES7_EEESt5tupleIJRS4_RS6_SB_EEJS5_S7_S7_EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_7SDValueEEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKiEEENS0_17enumerator_resultIJmRS5_EEEJS4_S6_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_5APIntES7_EEESt5tupleIJRS4_RS6_SB_EEJS5_S7_S7_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_12zip_shortestIJPKNS_5SDUseEPNS_7SDValueEEEESt5tupleIJRS4_RS6_EEJS5_S7_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPKNS_5SDUseEEEENS0_17enumerator_resultIJmRS6_EEEJS4_S7_EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12zip_shortestIJPKNS_5SDUseEPNS_7SDValueEEEeqERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12zip_shortestIJPKNS_5SDUseEPNS_5APIntES6_EEeqERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12zip_shortestIJPKNS_5SDUseEPNS_5APIntES6_EE19any_iterator_equalsIJLm0ELm1ELm2EEEEbRKS7_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail12zip_shortestIJPKNS_5SDUseEPNS_7SDValueEEE19any_iterator_equalsIJLm0ELm1EEEEbRKS7_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_7SDValueELm2EEEEC2EOS5_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_5APIntELm2EES9_EEC2EOS5_S9_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefINS_5SDUseEEEEEC2EOS3_OS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefIiEEEEC2EOS3_OS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallVectorINS_7SDValueELj8EEEEEC2EOS3_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_5APIntELm2EES9_EE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefIiEEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_7SDValueELm2EEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefINS_5SDUseEEEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallVectorINS_7SDValueELj8EEEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_5APIntELm2EES9_EE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallVectorINS_7SDValueELj8EEEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefIiEEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_7SDValueELm2EEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefINS_5SDUseEEEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_5APIntELm2EES9_EE10begin_implIJLm0ELm1ELm2EEEENS2_IJPKS4_PS7_SE_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefIiEEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKiEEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_7SDValueELm2EEEE10begin_implIJLm0ELm1EEEENS2_IJPKS4_PS7_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefINS_5SDUseEEEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKS5_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallVectorINS_7SDValueELj8EEEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPS5_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERNS_11SmallVectorINS_7SDValueELj8EEEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPS5_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefINS_5SDUseEEEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKS5_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_7SDValueELm2EEEE8end_implIJLm0ELm1EEEENS2_IJPKS4_PS7_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_12zip_shortestEJNS_8ArrayRefINS_5SDUseEEERSt5arrayINS_5APIntELm2EES9_EE8end_implIJLm0ELm1ELm2EEEENS2_IJPKS4_PS7_SE_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamENS_8ArrayRefIiEEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPKiEEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm3zipINS_8ArrayRefINS_5SDUseEEERSt5arrayINS_5APIntELm2EEJS7_EEENS_6detail5zippyINS8_12zip_shortestEJT_T0_DpT1_EEEOSB_OSC_DpOSD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm3zipINS_8ArrayRefINS_5SDUseEEERSt5arrayINS_7SDValueELm2EEJEEENS_6detail5zippyINS8_12zip_shortestEJT_T0_DpT1_EEEOSB_OSC_DpOSD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPN12_GLOBAL__N_111DAGCombiner9MemOpLinkEZNS2_22mergeConsecutiveStoresEPNS_11StoreSDNodeEEUlS3_S3_E_EEvT_S8_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPN12_GLOBAL__N_111LoadedSliceEZL20adjustCostForPairingRNS_15SmallVectorImplIS2_EERNS2_4CostEEUlRKS2_SA_E_EEvT_SC_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_15SmallVectorImplIN12_GLOBAL__N_111LoadedSliceEEEZL20adjustCostForPairingS5_RNS3_4CostEEUlRKS3_S9_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorIN12_GLOBAL__N_111DAGCombiner9MemOpLinkELj8EEEZNS3_22mergeConsecutiveStoresEPNS_11StoreSDNodeEEUlS4_S4_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefIiEEZL25partitionShuffleOfConcatsPNS_6SDNodeERNS_12SelectionDAGEEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_6detail5zippyINS1_14zip_enumeratorEJNS1_12index_streamENS_8ArrayRefIiEEEEEZN12_GLOBAL__N_111DAGCombiner22combineInsertEltToLoadEPNS_6SDNodeEjEUlT_E_EEbOSC_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorINS_7SDValueELj8EEEZN12_GLOBAL__N_111DAGCombiner22visitINSERT_VECTOR_ELTEPNS_6SDNodeEEUlS2_E1_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorINS_7SDValueELj8EEEZN12_GLOBAL__N_111DAGCombiner22visitINSERT_VECTOR_ELTEPNS_6SDNodeEEUlS2_E2_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorIZN12_GLOBAL__N_111DAGCombiner57refineExtractVectorEltIntoMultipleNarrowExtractVectorEltsEPNS_6SDNodeEE5EntryLj32EEEZNS3_57refineExtractVectorEltIntoMultipleNarrowExtractVectorEltsES5_EUlRKS6_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeINS_6SDNode12use_iteratorEEEZN12_GLOBAL__N_111DAGCombiner23visitEXTRACT_VECTOR_ELTEPS2_EUlS7_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorINS_7SDValueELj8EEEZN12_GLOBAL__N_111DAGCombiner24parallelizeChainedStoresEPNS_11StoreSDNodeEEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_5SDUseEEEZZN12_GLOBAL__N_111DAGCombiner14SimplifyVBinOpEPNS_6SDNodeERKNS_5SDLocEENKUlNS_7SDValueEE_clESD_EUlRKSD_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefINS_5SDUseEEEZL42combineConcatVectorOfShuffleAndItsOperandsPNS_6SDNodeERNS_12SelectionDAGERKNS_14TargetLoweringEbbEUlNS_7SDValueEE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefIiEEZL25partitionShuffleOfConcatsPNS_6SDNodeERNS_12SelectionDAGEEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefINS_5SDUseEEEZN12_GLOBAL__N_111DAGCombiner19visitCONCAT_VECTORSEPNS_6SDNodeEEUlRKNS_7SDValueEE0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_5SDUseEEEZN12_GLOBAL__N_111DAGCombiner19visitCONCAT_VECTORSEPNS_6SDNodeEEUlRKNS_7SDValueEE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefIiEEZZL37combineShuffleToZeroExtendVectorInRegPNS_19ShuffleVectorSDNodeERNS_12SelectionDAGERKNS_14TargetLoweringEbENKUljE2_clEjEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorIiLj32EEEZL21formSplatFromShufflesPNS_19ShuffleVectorSDNodeERNS_12SelectionDAGEEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefIiEEZZN12_GLOBAL__N_111DAGCombiner19visitVECTOR_SHUFFLEEPNS_6SDNodeEENKUlNS_7SDValueES8_S2_E_clES8_S8_S2_EUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorIiLj4EEEZN12_GLOBAL__N_111DAGCombiner19visitVECTOR_SHUFFLEEPNS_6SDNodeEEUliE1_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_15SmallVectorImplIiEEZZN12_GLOBAL__N_111DAGCombiner19visitVECTOR_SHUFFLEEPNS_6SDNodeEENKUlbPNS_19ShuffleVectorSDNodeES9_NS_7SDValueERKNS_14TargetLoweringERSA_SE_S3_E0_clEbS9_S9_SA_SD_SE_SE_S3_EUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_6SDNode12use_iteratorEEEZL18combineShiftToMULHPS2_RNS_12SelectionDAGERKNS_14TargetLoweringEEUlS5_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_11SmallVectorIiLj16EEEZL37foldExtractSubvectorFromShuffleVectorPNS_6SDNodeERNS_12SelectionDAGERKNS_14TargetLoweringEbEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_8ArrayRefIiEEZZN12_GLOBAL__N_111DAGCombiner19visitVECTOR_SHUFFLEEPNS_6SDNodeEENKUlRNS_7SDValueES8_RNS_15SmallVectorImplIiEEbbE2_clES8_S8_SB_bbEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofIRNS_15SmallVectorImplIiEEZZN12_GLOBAL__N_111DAGCombiner19visitVECTOR_SHUFFLEEPNS_6SDNodeEENKUlRNS_7SDValueES9_S3_bbE2_clES9_S9_S3_bbEUliE0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_8ArrayRefISt4pairINS_7SDValueEiEEES4_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_6SDNodeELj32EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">346</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_6SDNodeELj16EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">34</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorISt4pairINS_7SDValueEiELj2EEES4_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorINS_7SDValueELj8EEES2_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_6SDNodeELj8EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8count_ifINS_8ArrayRefINS_5SDUseEEEZL22scalarizeBinOpOfSplatsPNS_6SDNodeERNS_12SelectionDAGERKNS_5SDLocEEUlNS_7SDValueEE_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8count_ifINS_8ArrayRefINS_5SDUseEEEZL22scalarizeBinOpOfSplatsPNS_6SDNodeERNS_12SelectionDAGERKNS_5SDLocEEUlNS_7SDValueEE0_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8count_ifIRNS_11SmallVectorINS_7SDValueELj8EEEZN12_GLOBAL__N_111DAGCombiner22visitINSERT_VECTOR_ELTEPNS_6SDNodeEEUlS2_E3_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11stable_sortINS_15MutableArrayRefINS_7SDValueEEEZN12_GLOBAL__N_111DAGCombiner23reduceBuildVecToShuffleEPNS_6SDNodeEEUlRKS2_S9_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9all_equalINS_8ArrayRefIiEEEEbOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIiLj16EEENS_8ArrayRefIiEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIiLj32EEERNS_15MutableArrayRefIiEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIiLj32EEERNS1_IiLj16EEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPKiEEeqERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPKNS_5SDUseEEEeqERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPNS_7SDValueEEEeqERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRNS_7SDValueEEEC2EmS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRKNS_5SDUseEEEC2EmS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRKiEEC2EmS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRNS_7SDValueEEE5indexEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKNS_5SDUseEEE5indexEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKiEE5indexEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKiEE5valueEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRKNS_5SDUseEEE5valueEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRNS_7SDValueEEE5valueEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateINS_8ArrayRefIiEEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateIRNS_11SmallVectorINS_7SDValueELj8EEEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateINS_8ArrayRefINS_5SDUseEEEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_6SDNode17value_op_iteratorEEEZN12_GLOBAL__N_115VectorLegalizer10LegalizeOpENS_7SDValueEEUlS7_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPKNS_3EVTEEEZN12_GLOBAL__N_115VectorLegalizer10LegalizeOpENS_7SDValueEEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPKNS_3EVTEEEZN12_GLOBAL__N_115VectorLegalizer3RunEvEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">82</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_11SmallVectorIPNS_6SDNodeELj3EEEZNS_16SelectionDAGISel16SelectCodeCommonES3_PKhjEUlS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_6SDNodeELj3EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_6SDNodeELj4EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_15SmallVectorImplIPKvEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">3154</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueINS_11SmallVectorIPNS_6SDNodeELj3EEES3_EEvRT_T0_</td>
    <td class="numberOfCalls">26</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeISt6vectorINS_7SDValueESaIS2_EERS4_EEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10drop_beginIRSt16initializer_listIjEEEDaOT_m</td>
    <td class="numberOfCalls">130</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_11SmallVectorIPNS_17MachineBasicBlockELj8EEEEEDaOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRKNS_15SmallVectorImplIPNS_17MachineBasicBlockEEEZNS_16isCycleInvariantEPKNS_12GenericCycleINS_17GenericSSAContextINS_15MachineFunctionEEEEERNS_12MachineInstrEEUlPKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_17MachineBasicBlockELj8EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRSt6vectorISt10unique_ptrINS_12GenericCycleINS_17GenericSSAContextINS_15MachineFunctionEEEEESt14default_deleteIS7_EESaISA_EEZNS_16GenericCycleInfoIS6_E28moveTopLevelCycleToNewParentEPS7_SG_EUlRKT_E_EEDaOSH_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorIPNS_17MachineBasicBlockELj8EEEPKS2_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_9SetVectorIPNS_17MachineBasicBlockENS_11SmallVectorIS3_Lj8EEENS_8DenseSetIPKS2_NS_12DenseMapInfoIS8_vEEEELj8EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorIPNS_17MachineBasicBlockELj1EEEPKS2_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_9SetVectorIPNS_17MachineBasicBlockENS_11SmallVectorIS3_Lj8EEENS_8DenseSetIPKS2_NS_12DenseMapInfoIS8_vEEEELj8EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_14iterator_rangeINS_12GenericCycleINS_17GenericSSAContextINS_15MachineFunctionEEEE20const_child_iteratorEEEPKS6_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPNS_17MachineBasicBlockELj8EEENS_14iterator_rangeIN9__gnu_cxx17__normal_iteratorIPKS3_St6vectorIS3_SaIS3_EEEEEEEEvRT_OT0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_15SmallVectorImplIPNS_17MachineBasicBlockEEENS_14iterator_rangeIN9__gnu_cxx17__normal_iteratorIPKS3_St6vectorIS3_SaIS3_EEEEEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_8ArrayRefItEEtEEbOT_RKT0_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRKNS_15SmallVectorImplIPKNS_12LiveIntervalEEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorItLj16EEEjEEbOT_RKT0_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb1ELb0ELb1ELb0ELb0EEEEC2ES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb1ELb0ELb1ELb0ELb0EEEEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb1ELb0ELb1ELb0ELb0EEEEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb1ELb0ELb1ELb0ELb0EEEEES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeINS_14iterator_rangeINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb1ELb0ELb1ELb0ELb0EEEEEEENS1_INS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_8ArrayRefINS_9SlotIndexEEEZNKS_9LiveRange9isUndefInES3_S2_S2_EUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">22</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofIRNS_9LiveRangeEZNS1_17removeValNoIfDeadEPNS_6VNInfoEEUlRKNS1_7SegmentEE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorINS_9LiveRange7SegmentELj2EEEZNS2_11removeValNoEPNS_6VNInfoEEUlRKS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRKNS_9LiveRangeERNS_9SlotIndexEEEDaOT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11upper_boundIRNS_9LiveRangeERNS_9SlotIndexEEEDaOT_OT0_</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15partition_pointIRNS_9LiveRangeEZNS1_4findENS_9SlotIndexEEUlRKNS1_7SegmentEE_RS4_EEDaOT_T0_</td>
    <td class="numberOfCalls">76</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8erase_ifINS_11SmallVectorINS_9LiveRange7SegmentELj2EEEZNS2_11removeValNoEPNS_6VNInfoEEUlRKS3_E_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_11SmallVectorIPKNS_17MachineMemOperandELj2EEEZNS_8RAGreedy12computeStatsERNS_17MachineBasicBlockEEUlS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofINS_14iterator_rangeINS_17MCRegUnitIteratorEEEZNKS_23RegAllocEvictionAdvisor11canReassignERKNS_12LiveIntervalENS_10MCRegisterEEUljE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPKNS_12LiveIntervalELj4EEES4_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPKNS_12LiveIntervalELj8EEES4_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorIPKNS_12LiveIntervalELj4EEES4_EEbOT_RKT0_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_8ArrayRefINS_9SlotIndexEEES2_EEDaOT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10drop_beginIRNS_8FunctionEEEDaOT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_11SmallVectorIPNS_10SelectInstELj2EEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_11SmallVectorIPNS_3UseELj4EEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_10BasicBlockEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEEC2ES6_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_10BasicBlockELb1ELb0EvEELb0ELb0EEEEC2ES6_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEEdeEv</td>
    <td class="numberOfCalls">17</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_10BasicBlockELb1ELb0EvEELb0ELb0EEEEdeEv</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEEppEv</td>
    <td class="numberOfCalls">17</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_10BasicBlockELb1ELb0EvEELb0ELb0EEEEppEv</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEEES9_</td>
    <td class="numberOfCalls">21</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_10BasicBlockELb1ELb0EvEELb0ELb0EEEEES9_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeIRNS_10BasicBlockEEENS_14iterator_rangeINS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS5_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeIRNS_8FunctionEEENS_14iterator_rangeINS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS5_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPSt4pairINS_11AssertingVHINS_17GetElementPtrInstEEElEZN12_GLOBAL__N_114CodeGenPrepare20splitLargeGEPOffsetsEvEUlRKS1_IPS3_lESC_E_EEvT_SE_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_15SmallVectorImplISt4pairINS_11AssertingVHINS_17GetElementPtrInstEEElEEEZN12_GLOBAL__N_114CodeGenPrepare20splitLargeGEPOffsetsEvEUlRKS2_IPS4_lESE_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefIiEEZNS_12PatternMatch10m_ZeroMask5matchES2_EUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKjEEZN12_GLOBAL__N_114CodeGenPrepare26dupRetToEnableTailCallOptsEPNS_10BasicBlockERNS5_8ModifyDTEEUljE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeINS_10BasicBlock17phi_iterator_implINS_7PHINodeENS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11InstructionELb1ELb0EvEELb0ELb0EEEEEEEZN12_GLOBAL__N_114CodeGenPrepare29isMergingEmptyBlockProfitableEPS2_SF_bEUlRKS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_5Value18user_iterator_implINS_4UserEEEEEZN12_GLOBAL__N_114CodeGenPrepare15optimizePhiTypeEPNS_7PHINodeERNS_15SmallPtrSetImplISA_EERNSB_IPNS_11InstructionEEEEUlPS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofIRNS_11SmallVectorIPNS_11InstructionELj16EEEZN12_GLOBAL__N_114CodeGenPrepare18optimizeMemoryInstES3_PNS_5ValueEPNS_4TypeEjEUlS9_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofINS_14iterator_rangeINS_5Value18user_iterator_implINS_4UserEEEEEZL32tryUnmergingGEPsAcrossIndirectBrPNS_17GetElementPtrInstEPKNS_19TargetTransformInfoEEUlPS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofINS_14iterator_rangeINS_5Value18user_iterator_implINS_4UserEEEEEZL32tryUnmergingGEPsAcrossIndirectBrPNS_17GetElementPtrInstEPKNS_19TargetTransformInfoEEUlPS4_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_10BasicBlockELj8EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorISt4pairIPNS_7PHINodeES4_ELj8EEES5_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorISt4pairINS_11AssertingVHINS_17GetElementPtrInstEEElELj32EEEZN12_GLOBAL__N_114CodeGenPrepare30removeAllAssertingVHReferencesEPNS_5ValueEEUlRT_E_EEDaOSD_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorISt4pairIjPNS_6MDNodeEELj2EEEZNS_13IRBuilderBase25AddOrRemoveMetadataToCopyEjS4_EUlRKS5_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorISt4pairIPNS_7PHINodeES4_ELj8EEES5_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_11InstructionELj32EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8erase_ifINS_11SmallVectorISt4pairINS_11AssertingVHINS_17GetElementPtrInstEEElELj32EEEZN12_GLOBAL__N_114CodeGenPrepare30removeAllAssertingVHReferencesEPNS_5ValueEEUlRT_E_EEvSD_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8erase_ifINS_11SmallVectorISt4pairIjPNS_6MDNodeEELj2EEEZNS_13IRBuilderBase25AddOrRemoveMetadataToCopyEjS4_EUlRKS5_E_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPNS_4LoopELj16EEERS2_EEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPNS_5ValueELj32EEENS_14iterator_rangeIPNS_3UseEEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPNS_5ValueELj8EEENS_14iterator_rangeIPNS_3UseEEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIN9__gnu_cxx17__normal_iteratorIPSt4pairIPNS_8MCSymbolENS_14PointerIntPairIS5_Lj1EbNS_21PointerLikeTypeTraitsIS5_EENS_18PointerIntPairInfoIS5_Lj1ES8_EEEEESt6vectorISC_SaISC_EEEEEEvT_SI_PFiPKNSt15iterator_traitsISI_E10value_typeESN_E</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10drop_beginINS_14iterator_rangeIPKNS_14MachineOperandEEEEEDaOT_m</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKNS_14MachineOperandESt8functionIFbRS2_EESt26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPNS_14MachineOperandESt8functionIFbRS1_EESt26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKNS_14MachineOperandESt8functionIFbRS2_EESt26bidirectional_iterator_tagEC2ES3_S3_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPNS_14MachineOperandESt8functionIFbRS1_EESt26bidirectional_iterator_tagEC2ES2_S2_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPNS_14MachineOperandESt8functionIFbRS1_EESt26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKNS_14MachineOperandESt8functionIFbRS2_EESt26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20filter_iterator_baseIPNS_14MachineOperandESt8functionIFbRS1_EESt26bidirectional_iterator_tagEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20filter_iterator_baseIPKNS_14MachineOperandESt8functionIFbRS2_EESt26bidirectional_iterator_tagEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_implIPKNS_14MachineOperandESt8functionIFbRS2_EESt26bidirectional_iterator_tagEC2ES3_S3_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_implIPNS_14MachineOperandESt8functionIFbRS1_EESt26bidirectional_iterator_tagEC2ES2_S2_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17make_filter_rangeINS_14iterator_rangeIPNS_14MachineOperandEEESt8functionIFbRS2_EEEENS1_INS_20filter_iterator_implIDTcl9adl_begincl7declvalIRT_EEEET0_NS_6detail15fwd_or_bidi_tagISC_E4typeEEEEEOSA_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17make_filter_rangeINS_14iterator_rangeIPKNS_14MachineOperandEEESt8functionIFbRS3_EEEENS1_INS_20filter_iterator_implIDTcl9adl_begincl7declvalIRT_EEEET0_NS_6detail15fwd_or_bidi_tagISD_E4typeEEEEEOSB_SE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_8ArrayRefIPNS_17MachineMemOperandEEEZNKS_12MachineInstr19hasOrderedMemoryRefEvEUlPKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">11</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPKNS_14MachineOperandEEEZNKS_12MachineInstr21hasDebugOperandForRegENS_8RegisterEEUlRS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofIRNS_8ArrayRefINS_8RegisterEEEZNS_12MachineInstr21setPhysRegsDeadExceptES3_RKNS_18TargetRegisterInfoEEUlNS_10MCRegisterEE_EEbOT_T0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_15SmallVectorImplIPKNS_14MachineOperandEEES4_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_14iterator_rangeINS_18MCSuperRegIteratorEEENS_10MCRegisterEEEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm5countIRSt6vectorIPNS_5SUnitESaIS3_EEDnEEDaOT_RKT0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16hasSingleElementINS_14iterator_rangeINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb0ELb1ELb1ELb0ELb0EEEEEEEbOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16hasSingleElementINS_14iterator_rangeINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb1ELb0ELb1ELb0EEEEEEEbOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb0ELb0ELb1ELb0EEEEC2ES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb0ELb0ELb1ELb0EEEEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb0ELb0ELb1ELb0EEEEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb0ELb0ELb1ELb0EEEEES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeINS_14iterator_rangeINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb0ELb0ELb1ELb0EEEEEEENS1_INS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeINS_18MCSuperRegIteratorEEEZNKS_19MachineRegisterInfo17isReservedRegUnitEjEUltE_EEbOT_T0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueINS_11SmallVectorItLj16EEENS_10MCRegisterEEEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorItLj16EEERNS_8ArrayRefItEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15hasNItemsOrMoreIRNS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb1ELb0ELb1ELb0EEERPFbRNS_12MachineInstrEEEEbOT_SB_jOT0_PNSt9enable_ifIXntsrSt10is_base_ofISt26random_access_iterator_tagNSt15iterator_traitsINSt16remove_referenceIDtfL0p_EE4typeEE17iterator_categoryEE5valueEvE4typeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15hasNItemsOrLessINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb1ELb0ELb1ELb0EEEPFbRNS_12MachineInstrEEEEbOT_S9_jOT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNKUlRN4llvm12MachineInstrEE2_clES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_11SmallVectorINS_9SlotIndexELj8EEERS2_EEDaOT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRNS_8ArrayRefINS_9SlotIndexEEERKS2_EEDaOT_OT0_</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueINS_11SmallVectorINS_8RegisterELj12EEES2_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16hasSingleElementINS_14iterator_rangeINS_19MachineRegisterInfo20defusechain_iteratorILb0ELb1ELb0ELb1ELb0ELb0EEEEEEEbOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_11SmallVectorIjLj4EEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPNS_14MachineOperandEPFbRKS1_ESt26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPNS_14MachineOperandEPFbRKS1_ESt26bidirectional_iterator_tagEC2ES2_S2_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPNS_14MachineOperandEPFbRKS1_ESt26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20filter_iterator_baseIPNS_14MachineOperandEPFbRKS1_ESt26bidirectional_iterator_tagEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_implIPNS_14MachineOperandEPFbRKS1_ESt26bidirectional_iterator_tagEC2ES2_S2_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17make_filter_rangeINS_14iterator_rangeIPNS_14MachineOperandEEEPFbRKS2_EEENS1_INS_20filter_iterator_implIDTcl9adl_begincl7declvalIRT_EEEET0_NS_6detail15fwd_or_bidi_tagISC_E4typeEEEEEOSA_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4copyIRNS_8ArrayRefIiEEPiEET0_OT_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeISt6vectorIjSaIjEERNS_8ArrayRefIjEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseINS_26MachineInstrBundleIteratorIKNS_12MachineInstrELb0EEEZNS_24instructionsWithoutDebugIS4_EEDaT_S6_bEUlRS3_E_St26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseINS_26MachineInstrBundleIteratorIKNS_12MachineInstrELb0EEEZNS_24instructionsWithoutDebugIS4_EEDaT_S6_bEUlRS3_E_St26bidirectional_iterator_tagEC2ES4_S4_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseINS_26MachineInstrBundleIteratorIKNS_12MachineInstrELb0EEEZNS_24instructionsWithoutDebugIS4_EEDaT_S6_bEUlRS3_E_St26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_implINS_26MachineInstrBundleIteratorIKNS_12MachineInstrELb0EEEZNS_24instructionsWithoutDebugIS4_EEDaT_S6_bEUlRS3_E_St26bidirectional_iterator_tagEC2ES4_S4_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17make_filter_rangeINS_14iterator_rangeINS_26MachineInstrBundleIteratorIKNS_12MachineInstrELb0EEEEEZNS_24instructionsWithoutDebugIS5_EEDaT_S8_bEUlRS4_E_EENS1_INS_20filter_iterator_implIDTcl9adl_begincl7declvalIRS8_EEEET0_NS_6detail15fwd_or_bidi_tagISD_E4typeEEEEEOS8_SE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10less_firstclISt4pairINS_9SlotIndexEPNS_17MachineBasicBlockEEEEbRKT_S9_</td>
    <td class="numberOfCalls">24</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPSt4pairINS_9SlotIndexEPNS_17MachineBasicBlockEENS_10less_firstEEEvT_S8_T0_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIN9__gnu_cxx17__normal_iteratorIPNS_17MachineBasicBlock16RegisterMaskPairESt6vectorIS4_SaIS4_EEEEZNS3_17sortUniqueLiveInsEvEUlRKS4_SB_E_EEvT_SD_T0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRSt6vectorINS_17MachineBasicBlock16RegisterMaskPairESaIS3_EEZNS2_17sortUniqueLiveInsEvEUlRKS3_S8_E_EEvOT_T0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorISt4pairINS_9SlotIndexEPNS_17MachineBasicBlockEELj8EEENS_10less_firstEEEvOT_T0_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRSt6vectorIPNS_17MachineBasicBlockESaIS3_EES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findINS_14iterator_rangeIN9__gnu_cxx17__normal_iteratorIPPNS_17MachineBasicBlockESt6vectorIS5_SaIS5_EEEEEES5_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRSt6vectorIPNS_12MachineInstrESaIS3_EES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRKSt6vectorINS_17MachineBasicBlock16RegisterMaskPairESaIS3_EEZNKS2_8isLiveInEtNS_11LaneBitmaskEEUlRKS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRSt6vectorINS_17MachineBasicBlock16RegisterMaskPairESaIS3_EEZNS2_12removeLiveInEtNS_11LaneBitmaskEEUlRKS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifINS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MachineInstrELb1ELb1EvEELb0ELb0EEEEEZNS_17MachineBasicBlock25getFirstTerminatorForwardEvEUlRT_E_EEDaOSA_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_14iterator_rangeIN9__gnu_cxx17__normal_iteratorIPPNS_17MachineBasicBlockESt6vectorIS5_SaIS5_EEEEEES5_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_14iterator_rangeIN9__gnu_cxx17__normal_iteratorIPKPNS_17MachineBasicBlockESt6vectorIS5_SaIS5_EEEEEEPKS4_EEbOT_RKT0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorINS_8RegisterELj4EEES2_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_12MachineInstrELj4EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb1ELb0ELb1ELb0ELb0EEEEEZNS_14VirtRegAuxInfo24isLiveAtStatepointVarArgERNS_12LiveIntervalEEUlRNS_14MachineOperandEE_EEbOT_T0_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_14iterator_rangeIN9__gnu_cxx17__normal_iteratorIPPNS_17MachineBasicBlockESt6vectorIS5_SaIS5_EEEEEEEEDaOT_</td>
    <td class="numberOfCalls">82</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_17MachineBasicBlockEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS1_Lb0EEEE6runDFSILb0EZNS8_21verifySiblingPropertyERKS7_EUlS2_S2_E_EEjS2_jT0_jPKNS_8DenseMapIS2_jNS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_jEEEEEUlS2_S2_E_EEvT_SO_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_17MachineBasicBlockEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS1_Lb0EEEE6runDFSILb0EZNS8_20verifyParentPropertyERKS7_EUlS2_S2_E_EEjS2_jT0_jPKNS_8DenseMapIS2_jNS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_jEEEEEUlS2_S2_E_EEvT_SO_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_17MachineBasicBlockEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS1_Lb0EEEE6runDFSILb0EPFbS2_S2_EEEjS2_jT0_jPKNS_8DenseMapIS2_jNS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_jEEEEEUlS2_S2_E_EEvT_SN_SC_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_17MachineBasicBlockEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS1_Lb0EEEE6runDFSILb0EZNS8_17DeleteUnreachableERS7_PNS8_15BatchUpdateInfoEPNS_15DomTreeNodeBaseIS1_EEEUlS2_S2_E0_EEjS2_jT0_jPKNS_8DenseMapIS2_jNS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_jEEEEEUlS2_S2_E_EEvT_SS_SH_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_17MachineBasicBlockEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS1_Lb0EEEE6runDFSILb0EZNS8_17DeleteUnreachableERS7_PNS8_15BatchUpdateInfoEPNS_15DomTreeNodeBaseIS1_EEEUlS2_S2_E_EEjS2_jT0_jPKNS_8DenseMapIS2_jNS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_jEEEEEUlS2_S2_E_EEvT_SS_SH_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_17MachineBasicBlockEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS1_Lb0EEEE6runDFSILb0EZNS8_15DeleteReachableERS7_PNS8_15BatchUpdateInfoEPNS_15DomTreeNodeBaseIS1_EESF_EUlS2_S2_E_EEjS2_jT0_jPKNS_8DenseMapIS2_jNS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_jEEEEEUlS2_S2_E_EEvT_SS_SH_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_17MachineBasicBlockEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS1_Lb0EEEE6runDFSILb0EZNS8_28ComputeUnreachableDominatorsERS7_PNS8_15BatchUpdateInfoES2_PNS_15DomTreeNodeBaseIS1_EERNS_15SmallVectorImplISt4pairIS2_SF_EEEEUlS2_S2_E_EEjS2_jT0_jPKNS_8DenseMapIS2_jNS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_jEEEEEUlS2_S2_E_EEvT_SX_SM_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPPNS_15DomTreeNodeBaseINS_17MachineBasicBlockEEEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS2_Lb0EEEE16VerifyDFSNumbersERKS9_EUlS4_S4_E0_EEvT_SE_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPNS_3cfg6UpdateIPNS_17MachineBasicBlockEEEZNS1_15LegalizeUpdatesIS4_EEvNS_8ArrayRefINS2_IT_EEEERNS_15SmallVectorImplISA_EEbbEUlRKS5_SG_E_EEvS9_S9_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_15SmallVectorImplINS_3cfg6UpdateIPNS_17MachineBasicBlockEEEEEZNS2_15LegalizeUpdatesIS5_EEvNS_8ArrayRefINS3_IT_EEEERNS1_ISC_EEbbEUlRKS6_SH_E_EEvOSB_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorIPNS_15DomTreeNodeBaseINS_17MachineBasicBlockEEELj8EEEZNS_14DomTreeBuilder11SemiNCAInfoINS_17DominatorTreeBaseIS3_Lb0EEEE16VerifyDFSNumbersERKSB_EUlS5_S5_E0_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_15DomTreeNodeBaseINS_17MachineBasicBlockEEELj4EEES5_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_17MachineBasicBlockELj16EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_17MachineBasicBlockELj8EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueINS_11SmallVectorIPNS_17MachineBasicBlockELj8EEEDnEEvRT_T0_</td>
    <td class="numberOfCalls">130</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueINS_11SmallVectorIPNS_17MachineBasicBlockELj8EEES3_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorINS_3cfg6UpdateIPNS_17MachineBasicBlockEEELj3EEERNS_8ArrayRefIS6_EEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPNS_17MachineBasicBlockELj8EEERKNS1_IS3_Lj2EEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb0ELb0ELb1ELb0ELb0EEEEC2ES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb0ELb0ELb1ELb0ELb0EEEEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb0ELb0ELb1ELb0ELb0EEEEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb0ELb0ELb1ELb0ELb0EEEEES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeINS_14iterator_rangeINS_19MachineRegisterInfo20defusechain_iteratorILb1ELb0ELb0ELb1ELb0ELb0EEEEEEENS1_INS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm25array_pod_sort_comparatorINS_8RegisterEEEiPKvS3_</td>
    <td class="numberOfCalls">15</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29get_array_pod_sort_comparatorINS_8RegisterEEEPFiPKvS3_ERKT_</td>
    <td class="numberOfCalls">15</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIPNS_8RegisterEEEvT_S3_</td>
    <td class="numberOfCalls">22</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIN9__gnu_cxx17__normal_iteratorIPN12_GLOBAL__N_115MBBPriorityInfoESt6vectorIS4_SaIS4_EEEEEEvT_SA_PFiPKNSt15iterator_traitsISA_E10value_typeESF_E</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIN9__gnu_cxx17__normal_iteratorIPSt4pairINS_9SlotIndexEPNS_12MachineInstrEESt6vectorIS7_SaIS7_EEEEEEvT_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRSt6vectorISt4pairINS_9SlotIndexEPNS_12MachineInstrEESaIS6_EEEEvOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPNS_14MachineOperandEEEZN12_GLOBAL__N_117RegisterCoalescer22buildVRegToDbgValueMapERNS_15MachineFunctionEEUlRKS2_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11upper_boundIRNS_12LiveIntervalERNS_9SlotIndexEEEDaOT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_14MachineOperandEEEZN12_GLOBAL__N_114VarLocBasedLDV18transferDebugValueERKNS_12MachineInstrERNS7_13OpenRangesSetERNS7_9VarLocMapERSt8multimapIPS9_NS6_8LocIndexESt4lessISG_ESaISt4pairIKSG_SH_EEERNS_8DenseMapINS_8RegisterEPS8_NS_12DenseMapInfoISR_vEENS_6detail12DenseMapPairISR_SS_EEEEEUlRS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorIjLj4EEEZN12_GLOBAL__N_114VarLocBasedLDV9VarLocMap6insertERKNS5_6VarLocEEUlT_E_EEbOSA_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_11SmallVectorIPKjLj4EEEZN12_GLOBAL__N_114VarLocBasedLDV19transferRegisterDefERNS_12MachineInstrERNS7_13OpenRangesSetERNS7_9VarLocMapERSt8multimapIPKS8_NS6_8LocIndexESt4lessISG_ESaISt4pairIKSG_SH_EEERNS_8DenseMapINS_8RegisterEPS8_NS_12DenseMapInfoISR_vEENS_6detail12DenseMapPairISR_SS_EEEEEUlS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRKNS_11SmallVectorIN12_GLOBAL__N_114VarLocBasedLDV6VarLoc10MachineLocELj8EEEZNKS4_16containsWasmLocsEvEUlS5_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRKNS_11SmallVectorIN12_GLOBAL__N_114VarLocBasedLDV6VarLoc10MachineLocELj8EEEZNKS4_17containsSpillLocsEvEUlS5_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7none_ofINS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MachineInstrELb1ELb1EvEELb0ELb0EEEEEZN12_GLOBAL__N_114VarLocBasedLDV12ExtendRangesERNS_15MachineFunctionEPNS_20MachineDominatorTreeEPNS_16TargetPassConfigEjjEUlRKS5_E_EEbOT_T0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIN12_GLOBAL__N_114VarLocBasedLDV6VarLoc10MachineLocELj8EEES5_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRNS_8ArrayRefISt4pairIiPKcEEEZNK12_GLOBAL__N_114VarLocBasedLDV6VarLoc4dumpEPKNS_18TargetRegisterInfoEPKNS_15TargetInstrInfoERNS_11raw_ostreamEEUlRKS5_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorIN12_GLOBAL__N_114VarLocBasedLDV6VarLoc10MachineLocELj8EEES5_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_15SmallVectorImplISt4pairImmEEEZNKS_19CoalescingBitVectorImE11getOverlapsERKS7_S5_EUlS3_S3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">23</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorINS_8RegisterELj32EEERKNS_8SmallSetIS2_Lj32ESt4lessIS2_EEEEEvRT_OT0_</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_8ArrayRefINS_15CalleeSavedInfoEEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRSt6vectorINS_15CalleeSavedInfoESaIS2_EEEEDaOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIN9__gnu_cxx17__normal_iteratorIPKPNS_17MachineBasicBlockESt6vectorIS5_SaIS5_EEEEEEZL21blockEndIsUnreachableRKS4_NS_26MachineInstrBundleIteratorIKNS_12MachineInstrELb0EEEEUlPSD_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRNS_17MachineBasicBlockEZNKS_16X86FrameLowering16inlineStackProbeERNS_15MachineFunctionES2_EUlRNS_12MachineInstrEE_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11stable_sortIRSt6vectorIN12_GLOBAL__N_121X86FrameSortingObjectESaIS3_EENS2_25X86FrameSortingComparatorEEEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9transformIRNS_11SmallVectorINS_7SDValueELj4EEEPS2_N12_GLOBAL__N_111WidenVectorEEET0_OT_S8_T1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEEEC2ES3_</td>
    <td class="numberOfCalls">56</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEEEdeEv</td>
    <td class="numberOfCalls">73</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEEEppEv</td>
    <td class="numberOfCalls">73</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEEEES6_</td>
    <td class="numberOfCalls">101</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeIRNS_17MachineBasicBlockEEENS_14iterator_rangeINS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS5_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_17MachineBasicBlockEEEDaOT_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEZNS_24instructionsWithoutDebugIS3_EEDaT_S5_bEUlRKS2_E_St26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEZNS_24instructionsWithoutDebugIS3_EEDaT_S5_bEUlRKS2_E_St26bidirectional_iterator_tagEC2ES3_S3_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEZNS_24instructionsWithoutDebugIS3_EEDaT_S5_bEUlRKS2_E_St26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20filter_iterator_baseINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEZNS_24instructionsWithoutDebugIS3_EEDaT_S5_bEUlRKS2_E_St26bidirectional_iterator_tagEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEZNS_24instructionsWithoutDebugIS3_EEDaT_S5_bEUlRKS2_E_St26bidirectional_iterator_tagEC2ES3_S3_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17make_filter_rangeINS_14iterator_rangeINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEEEZNS_24instructionsWithoutDebugIS4_EEDaT_S7_bEUlRKS3_E_EENS1_INS_20filter_iterator_implIDTcl9adl_begincl7declvalIRS7_EEEET0_NS_6detail15fwd_or_bidi_tagISD_E4typeEEEEEOS7_SE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeINS_14iterator_rangeINS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEEEEEENS1_INS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS7_</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPPKNS_12RegisterBankEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EE5derefIJLm0ELm1EEEESC_St16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPPKNS_12RegisterBankEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EE7tup_incIJLm0ELm1EEEEvSt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPPKNS_12RegisterBankEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EEC2EOS4_OS8_</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPPKNS_12RegisterBankEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EEdeEv</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10zip_commonINS0_14zip_enumeratorIJNS0_12index_stream8iteratorEPPKNS_12RegisterBankEEEENS0_17enumerator_resultIJmRS7_EEEJS4_S8_EEppEv</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA3_PKNS_12RegisterBankEEEC2EOS3_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA3_PKNS_12RegisterBankEEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA3_PKNS_12RegisterBankEEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA3_PKNS_12RegisterBankEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPS6_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA3_PKNS_12RegisterBankEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPS6_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_14MachineOperandEEEZNKS_23AArch64RegisterBankInfo15getInstrMappingERKNS_12MachineInstrEEUlRS3_E2_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb1ELb0ELb1ELb0EEEEEZNKS_23AArch64RegisterBankInfo15getInstrMappingERKNS_12MachineInstrEEUlRS7_E1_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb1ELb0ELb1ELb0EEEEEZNKS_23AArch64RegisterBankInfo15getInstrMappingERKNS_12MachineInstrEEUlRS7_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_19MachineRegisterInfo26defusechain_instr_iteratorILb1ELb0ELb1ELb0ELb1ELb0EEEEEZNKS_23AArch64RegisterBankInfo15getInstrMappingERKNS_12MachineInstrEEUlS9_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPKNS_14MachineOperandEEEZNKS_23AArch64RegisterBankInfo16hasFPConstraintsERKNS_12MachineInstrERKNS_19MachineRegisterInfoERKNS_18TargetRegisterInfoEjEUlRS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail14zip_enumeratorIJNS0_12index_stream8iteratorEPPKNS_12RegisterBankEEEeqERKS8_</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail17enumerator_resultIJmRPKNS_12RegisterBankEEEC2EmS5_</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRPKNS_12RegisterBankEEE5indexEv</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail17enumerator_resultIJmRPKNS_12RegisterBankEEE5valueEv</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateIRA3_PKNS_12RegisterBankEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPNS_14MachineOperandEEEZNKS_19AArch64CallLowering13lowerTailCallERNS_16MachineIRBuilderERNS_12CallLowering16CallLoweringInfoERNS_15SmallVectorImplINS8_7ArgInfoEEEEUlRKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPKNS_8ArgumentEEEZNKS_19AArch64CallLowering33isEligibleForTailCallOptimizationERNS_16MachineIRBuilderERNS_12CallLowering16CallLoweringInfoERNS_15SmallVectorImplINS9_7ArgInfoEEESF_EUlRS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPKNS_8ArgumentEEEZNKS_19AArch64CallLowering17fallBackToDAGISelERKNS_15MachineFunctionEEUlRS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_8ArrayRefItEENS_8RegisterEEEbOT_RKT0_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRSt6vectorIN12_GLOBAL__N_118ARMConstantIslands9ImmBranchESaIS4_EEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseINS_14iterator_rangeINS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEEEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRSt6vectorIN12_GLOBAL__N_118ARMConstantIslands7CPEntryESaIS4_EEZNS3_24optimizeThumb2JumpTablesEvEUlRS4_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_15MachineFunctionEZN12_GLOBAL__N_118ARMConstantIslands6verifyEvEUlRKNS_17MachineBasicBlockES7_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRSt6vectorIPNS_17MachineBasicBlockESaIS3_EERS3_PFbPKS2_S9_EEEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA2_PKNS_12RegisterBankEEEC2EOS3_S8_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA2_PKNS_12RegisterBankEEE5beginEv</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA2_PKNS_12RegisterBankEEE3endEv</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA2_PKNS_12RegisterBankEEE10begin_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPS6_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail5zippyINS0_14zip_enumeratorEJNS0_12index_streamERA2_PKNS_12RegisterBankEEE8end_implIJLm0ELm1EEEENS2_IJNS3_8iteratorEPS6_EEESt16integer_sequenceImJXspT_EEE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9enumerateIRA2_PKNS_12RegisterBankEJEEEDaOT_DpOT0_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_8ArrayRefIiEEZL19LowerVECTOR_SHUFFLENS_7SDValueERNS_12SelectionDAGEPKNS_12ARMSubtargetEEUliE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_5SDUseEEEZL20LowerBUILD_VECTOR_i1NS_7SDValueERNS_12SelectionDAGEPKNS_12ARMSubtargetEEUlRS3_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeINS_6SDNode12use_iteratorEEEZNKS_17ARMTargetLowering17LowerBUILD_VECTORENS_7SDValueERNS_12SelectionDAGEPKNS_12ARMSubtargetEEUlPKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefINS_5SDUseEEEZNKS_17ARMTargetLowering22PerformMVETruncCombineEPNS_6SDNodeERNS_14TargetLowering15DAGCombinerInfoEEUlNS_7SDValueEE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_8ArrayRefINS_5SDUseEEEZNKS_17ARMTargetLowering22PerformMVETruncCombineEPNS_6SDNodeERNS_14TargetLowering15DAGCombinerInfoEEUlNS_7SDValueEE0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_15SmallVectorImplIPNS_3UseEEEZNKS_17ARMTargetLowering18shouldSinkOperandsEPNS_11InstructionES5_EUlS3_E2_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_8ArrayRefINS_3MVTEEEZZL27PerformVECREDUCE_ADDCombinePNS_6SDNodeERNS_12SelectionDAGEPKNS_12ARMSubtargetEENKUlNS_7SDValueES3_E_clESC_S3_EUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIZNKS_17ARMTargetLowering18ReconstructShuffleENS_7SDValueERNS_12SelectionDAGEE17ShuffleSourceInfoLj2EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifINS_14iterator_rangeINS_6SDNode12use_iteratorEEEZL26PerformExtractEltToVMOVRRDPS2_RNS_14TargetLowering15DAGCombinerInfoEEUlS5_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8count_ifINS_14iterator_rangeINS_5Value18user_iterator_implIKNS_4UserEEEEEZNKS_17ARMTargetLowering9LowerCallERNS_14TargetLowering16CallLoweringInfoERNS_15SmallVectorImplINS_7SDValueEEEEUlPS5_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPKNS_4UserELj4EEENS_14iterator_rangeINS_5Value18user_iterator_implIS3_EEEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPNS_5ValueELj6EEERNS_15SmallVectorImplIS3_EEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRKSt5arrayImLm4EEZNKS_13FeatureBitset3anyEvEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MachineInstrELb1ELb1EvEELb0ELb0EEEEC2ES6_</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MachineInstrELb1ELb1EvEELb0ELb0EEEEdeEv</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MachineInstrELb1ELb1EvEELb0ELb0EEEEppEv</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MachineInstrELb1ELb1EvEELb0ELb0EEEEES9_</td>
    <td class="numberOfCalls">44</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeINS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_12MachineInstrELb1ELb1EvEELb0ELb0EEEEEEENS1_INS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOSA_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_8ArrayRefIPNS_17MachineMemOperandEEEZNK12_GLOBAL__N_116SIInsertWaitcnts27mayAccessScratchThroughFlatERKNS_12MachineInstrEEUlPKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_15SmallVectorImplIPNS_12MachineInstrEEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorINS_8RegisterELj16EEES2_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_17MachineBasicBlockELj2EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_17MachineBasicBlockELj16EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_12MachineInstrELj6EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorIPNS_17MachineBasicBlockELj16EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorIPNS_17MachineBasicBlockELj2EEES3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKNS_11SmallVectorINS_8RegisterELj16EEES2_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEEC2ES3_</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEEdeEv</td>
    <td class="numberOfCalls">53</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEEppEv</td>
    <td class="numberOfCalls">53</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEEES6_</td>
    <td class="numberOfCalls">61</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeINS_14iterator_rangeINS_26MachineInstrBundleIteratorINS_12MachineInstrELb1EEEEEEENS1_INS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS7_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRNS_11SmallVectorINS_16RegisterMaskPairELj8EEEZL21collectVirtualRegUsesRKNS_12MachineInstrERKNS_13LiveIntervalsERKNS_19MachineRegisterInfoEEUlRKS2_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRKNS_12LoopInfoBaseINS_10BasicBlockENS_4LoopEEEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE19getUniqueExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE27getUniqueNonLatchExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagE13findNextValidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE27getUniqueNonLatchExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagEC2ES4_S4_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE19getUniqueExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagEC2ES4_S4_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE27getUniqueNonLatchExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_baseIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE19getUniqueExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20filter_iterator_baseIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE19getUniqueExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20filter_iterator_baseIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE27getUniqueNonLatchExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_implIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE27getUniqueNonLatchExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagEC2ES4_S4_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20filter_iterator_implIPKPNS_10BasicBlockEZNKS_8LoopBaseIS1_NS_4LoopEE19getUniqueExitBlocksERNS_15SmallVectorImplIS2_EEEUlPKS1_E_St26bidirectional_iterator_tagEC2ES4_S4_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17make_filter_rangeINS_14iterator_rangeIPKPNS_10BasicBlockEEEZNKS_8LoopBaseIS2_NS_4LoopEE27getUniqueNonLatchExitBlocksERNS_15SmallVectorImplIS3_EEEUlPKS2_E_EENS1_INS_20filter_iterator_implIDTcl9adl_begincl7declvalIRT_EEEET0_NS_6detail15fwd_or_bidi_tagISJ_E4typeEEEEEOSH_SK_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17make_filter_rangeINS_14iterator_rangeIPKPNS_10BasicBlockEEEZNKS_8LoopBaseIS2_NS_4LoopEE19getUniqueExitBlocksERNS_15SmallVectorImplIS3_EEEUlPKS2_E_EENS1_INS_20filter_iterator_implIDTcl9adl_begincl7declvalIRT_EEEET0_NS_6detail15fwd_or_bidi_tagISJ_E4typeEEEEEOSH_SK_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIN9__gnu_cxx17__normal_iteratorIPPNS_10BasicBlockESt6vectorIS4_SaIS4_EEEEEEvT_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRSt6vectorIPNS_10BasicBlockESaIS3_EEEEvOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKPNS_10BasicBlockEEEZNKS_4Loop22isRecursivelyLCSSAFormERKNS_13DominatorTreeERKNS_8LoopInfoEbEUlPKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKPNS_10BasicBlockEEEZNKS_4Loop11isLCSSAFormERKNS_13DominatorTreeEbEUlPKS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_3UseEEEZNKS_4Loop24hasLoopInvariantOperandsEPKNS_11InstructionEEUlPNS_5ValueEE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeINS_12SuccIteratorINS_11InstructionENS_10BasicBlockEEEEEZNKS_8LoopBaseIS4_NS_4LoopEE15getExitingBlockEvEUlPS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_8ArrayRefINS_9StringRefEEEZNS_30makePostTransformationMetadataERNS_11LLVMContextEPNS_6MDNodeES3_NS1_IS8_EEEUlS2_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRSt6vectorIPNS_10BasicBlockESaIS3_EES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_8LoopBaseINS_10BasicBlockENS_4LoopEEEPS3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRSt6vectorIPNS_4LoopESaIS3_EES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14find_singletonINS_10BasicBlockENS_14iterator_rangeIPKPS1_EEZNKS_8LoopBaseIS1_NS_4LoopEE15getExitingBlockEvEUlS3_bE0_EEPT_OT0_T1_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm21find_singleton_nestedINS_10BasicBlockENS_14iterator_rangeINS_12SuccIteratorINS_11InstructionES1_EEEEZNS_18getExitBlockHelperIS1_NS_4LoopEEESt4pairIPT_bEPKNS_8LoopBaseISA_T0_EEbEUlPS1_bE_EESC_OSE_T1_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm21find_singleton_nestedINS_10BasicBlockENS_14iterator_rangeIPKPS1_EEZNS_18getExitBlockHelperIS1_NS_4LoopEEESt4pairIPT_bEPKNS_8LoopBaseISA_T0_EEbEUlS3_bE0_EESC_OSE_T1_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRKSt6vectorIPNS_4LoopESaIS3_EEPKNS_8LoopBaseINS_10BasicBlockES2_EEEEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_8LoopInfoEEEDaOT_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_4LoopEEEDaOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifINS_14iterator_rangeIPKPNS_10BasicBlockEEEZN12_GLOBAL__N_120PrintLoopPassWrapper9runOnLoopEPNS_4LoopERNS_13LPPassManagerEEUlS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueISt5dequeIPNS_4LoopESaIS3_EES3_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIN9__gnu_cxx17__normal_iteratorIPNS_7VecDescESt6vectorIS3_SaIS3_EEEEPFbRKS3_SA_EEEvT_SD_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRSt6vectorINS_7VecDescESaIS2_EEPFbRKS2_S7_EEEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9is_sortedIRNS_8ArrayRefINS_13StringLiteralEEEZL10initializeRNS_21TargetLibraryInfoImplERKNS_6TripleES3_EUlNS_9StringRefESA_E_EEbOT_T0_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11lower_boundIRKSt6vectorINS_7VecDescESaIS2_EERNS_9StringRefEPFbRKS2_S7_EEEDaOT_OT0_T1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeISt6vectorINS_7VecDescESaIS2_EERNS_8ArrayRefIS2_EEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm25array_pod_sort_comparatorINS_26BlockFrequencyInfoImplBase9BlockNodeEEEiPKvS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29get_array_pod_sort_comparatorINS_26BlockFrequencyInfoImplBase9BlockNodeEEEPFiPKvS4_ERKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIPNS_26BlockFrequencyInfoImplBase9BlockNodeEEEvT_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPNS_26BlockFrequencyInfoImplBase9BlockNodeEEEvT_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorINS_26BlockFrequencyInfoImplBase9BlockNodeELj4EEEEEvOT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIPNS_26BlockFrequencyInfoImplBase6WeightEZL23combineWeightsBySortingRNS_11SmallVectorIS2_Lj4EEEEUlRKS2_S8_E_EEvT_SA_T0_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRNS_11SmallVectorINS_26BlockFrequencyInfoImplBase6WeightELj4EEEZL23combineWeightsBySortingS5_EUlRKS3_S7_E_EEvOT_T0_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7reverseIRNS_14iterator_rangeINS_12SuccIteratorINS_11InstructionENS_10BasicBlockEEEEEEEDaOT_</td>
    <td class="numberOfCalls">76</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11less_secondclISt4pairIPNS_15DomTreeNodeBaseINS_10BasicBlockEEES2_IjjEEEEbRKT_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRKNS_11SmallVectorIN12_GLOBAL__N_113ClobberWalker14TerminatedPathELj4EEEZNKS3_15verifyOptResultERKNS3_11OptznResultEEUlRKS4_E_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorIjLj8EEEZN12_GLOBAL__N_113ClobberWalker14tryOptimizePhiEPNS_9MemoryPhiEPNS_12MemoryAccessERKNS_14MemoryLocationEEUljE2_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRNS_11SmallVectorIN12_GLOBAL__N_113ClobberWalker14TerminatedPathELj4EEEZNS3_14tryOptimizePhiEPNS_9MemoryPhiEPNS_12MemoryAccessERKNS_14MemoryLocationEEUlRKS4_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifINS_14iterator_rangeIN12_GLOBAL__N_113ClobberWalker25generic_def_path_iteratorINS3_7DefPathES3_EEEEZNS3_14tryOptimizePhiEPNS_9MemoryPhiEPNS_12MemoryAccessERKNS_14MemoryLocationEEUlRKS5_E1_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11find_if_notIRNS_12simple_ilistINS_12MemoryAccessEJNS_9ilist_tagINS_11MSSAHelpers11DefsOnlyTagEEEEEEZNS_9MemorySSA23insertIntoListsForBlockEPS2_PKNS_10BasicBlockENS9_14InsertionPlaceEEUlRKS2_E0_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11find_if_notIRNS_6iplistINS_12MemoryAccessEJNS_9ilist_tagINS_11MSSAHelpers12AllAccessTagEEEEEEZNS_9MemorySSA23insertIntoListsForBlockEPS2_PKNS_10BasicBlockENS9_14InsertionPlaceEEUlRKS2_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_14iterator_rangeINS_5Value18user_iterator_implINS_4UserEEEEEPNS_12MemoryAccessEEEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedINS_14iterator_rangeINS_12PredIteratorINS_10BasicBlockENS_5Value18user_iterator_implINS_4UserEEEEEEEPS3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueINS_11SmallVectorIPNS_10BasicBlockELj8EEES3_EEvRT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11erase_valueINS_11SmallVectorIPNS_10BasicBlockELj8EEEDnEEvRT_T0_</td>
    <td class="numberOfCalls">124</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12append_rangeINS_11SmallVectorIPNS_10BasicBlockELj8EEERKNS1_IS3_Lj2EEEEEvRT_OT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15callable_detail8CallableIPFccELb1EE9convertInIRS3_EEDaOT_</td>
    <td class="numberOfCalls">160</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15callable_detail8CallableIPFccELb1EEC2IS3_Li0EEEOT_</td>
    <td class="numberOfCalls">160</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15callable_detail8CallableIPFccELb1EEclIJRKcELi0EEEDcDpOT_</td>
    <td class="numberOfCalls">135</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15mapped_iteratorIPKcPFccEcEC2ES2_S4_</td>
    <td class="numberOfCalls">160</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15mapped_iteratorIPKcPFccEcEdeEv</td>
    <td class="numberOfCalls">135</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12map_iteratorIPKcPFccEEENS_15mapped_iteratorIT_T0_DTclcl7declvalIS7_EEdecl7declvalIS6_EEEEEES6_S7_</td>
    <td class="numberOfCalls">160</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10drop_beginIRNS_11SmallVectorIZNS_2cl16ExpansionContext19expandResponseFilesERNS_15SmallVectorImplIPKcEEE18ResponseFileRecordLj3EEEEEDaOT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIN9__gnu_cxx17__normal_iteratorIPPNS_2cl14OptionCategoryESt6vectorIS5_SaIS5_EEEEEEvT_SB_PFiPKNSt15iterator_traitsISB_E10value_typeESG_E</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIPSt4pairIPKcPNS_2cl10SubCommandEEEEvT_S9_PFiPKNSt15iterator_traitsIS9_E10value_typeESE_E</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14array_pod_sortIPSt4pairIPKcPNS_2cl6OptionEEEEvT_S9_PFiPKNSt15iterator_traitsIS9_E10value_typeESE_E</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_8ArrayRefIPKNS_2cl14OptionCategoryEEEPS3_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRSt6vectorIPNS_2cl14OptionCategoryESaIS4_EES4_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12is_containedIRNS_11SmallVectorIPNS_2cl14OptionCategoryELj1EEES4_EEbOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8count_ifIRNS_11SmallPtrSetIPNS_2cl10SubCommandELj4EEEZN12_GLOBAL__N_117CommandLineParser18registerSubCommandES4_EUlPKS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8count_ifIRNS_11SmallPtrSetIPNS_2cl14OptionCategoryELj16EEEZN12_GLOBAL__N_117CommandLineParser16registerCategoryES4_EUlPKS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">8</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L12semFloatTF32EEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L20semFloat8E4M3B11FNUZEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L17semFloat8E4M3FNUZEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L15semFloat8E4M3FNEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L17semFloat8E5M2FNUZEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semFloat8E5M2EEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L11semIEEEhalfEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L9semBFloatEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semIEEEsingleEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm1EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L13semIEEEdoubleEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofIRSt5arrayImLm2EEZNS_6detail9IEEEFloat17initFromIEEEAPIntIL_ZNS_L11semIEEEquadEEEEvRKNS_5APIntEEUlmE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEC2ES6_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEdeEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEppEv</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_8FunctionELb1ELb0EvEELb0ELb0EEEEES9_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeIRNS_6ModuleEEENS_14iterator_rangeINS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOS5_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIN9__gnu_cxx17__normal_iteratorIPZNS_8LLParser17parseOptionalRefsERSt6vectorINS_9ValueInfoESaIS5_EEE12ValueContextS4_IS9_SaIS9_EEEEZNS3_17parseOptionalRefsES8_EUlRKS9_SF_E_EEvT_SH_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sortIRSt6vectorIZNS_8LLParser17parseOptionalRefsERS1_INS_9ValueInfoESaIS3_EEE12ValueContextSaIS7_EEZNS2_17parseOptionalRefsES6_EUlRKS7_SC_E_EEvOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7find_ifIRNS_8ArrayRefISt10unique_ptrINS_18GlobalValueSummaryESt14default_deleteIS3_EEEEZNKS_18ModuleSummaryIndex19findSummaryInModuleENS_9ValueInfoENS_9StringRefEEUlRKS6_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofINS_14iterator_rangeIPNS_3UseEEEZL16optimizeCallInstPNS_8CallInstERbRKNS_19TargetTransformInfoERKNS_10DataLayoutEPNS_14DomTreeUpdaterEEUlPNS_5ValueEE_EEbOT_T0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11NamedMDNodeELb1ELb0EvEELb0ELb0EEEEC2ES6_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11NamedMDNodeELb1ELb0EvEELb0ELb0EEEEdeEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11NamedMDNodeELb1ELb0EvEELb0ELb0EEEEppEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmeqERKNS_23early_inc_iterator_implINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11NamedMDNodeELb1ELb0EvEELb0ELb0EEEEES9_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20make_early_inc_rangeINS_14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsINS_11NamedMDNodeELb1ELb0EvEELb0ELb0EEEEEEENS1_INS_23early_inc_iterator_implIDTcl9adl_begincl7declvalIRT_EEEEEEEEOSA_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6all_ofINS_14iterator_rangeIPKNS_9MDOperandEEEZL23stripDebugLocFromLoopIDPNS_6MDNodeEEUlRS3_E0_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6any_ofIRNS_14iterator_rangeINS_2at11DbgAssignItEEEZNS_22AssignmentTrackingPass13runOnFunctionERNS_8FunctionEEUlPNS_18DbgAssignIntrinsicEE_EEbOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8count_ifINS_14iterator_rangeIPKNS_9MDOperandEEEZL23stripDebugLocFromLoopIDPNS_6MDNodeEEUlRS3_E_EEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_8FunctionELj4EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4findIRNS_11SmallVectorIPNS_13IntrinsicInstELj4EEES3_EEDaOT_RKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorIPNS_13IntrinsicInstELj4EEENS_9SetVectorIS3_S4_NS_8DenseSetIS3_NS_12DenseMapInfoIS3_vEEEELj4EE19TestAndEraseFromSetIPFbS3_EEEEEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9remove_ifIRNS_11SmallVectorIPNS_13IntrinsicInstELj4EEEPFbS3_EEEDaOT_T0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">///</td>
    <td class="lineNumber">8</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// This file contains some templates that are useful if you are working with</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// This file contains some templates that are useful if you are working with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// the STL at all.</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// the STL at all.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">///</td>
    <td class="lineNumber">12</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">/// No library is required when using these functions.</td>
    <td class="lineNumber">13</td>
    <td class="codeline">/// No library is required when using these functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">///</td>
    <td class="lineNumber">14</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">15</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline"></td>
    <td class="lineNumber">16</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#ifndef LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#ifndef LLVM_ADT_STLEXTRAS_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#define LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#define LLVM_ADT_STLEXTRAS_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline"></td>
    <td class="lineNumber">19</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/ADL.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/ADL.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/Hashing.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/ADT/STLForwardCompat.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/ADT/STLForwardCompat.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/STLFunctionalExtras.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/STLFunctionalExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/identity.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/identity.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/iterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Config/abi-breaking.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Config/abi-breaking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include <cstddef></td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include <cstddef></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include <cstdlib></td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include <cstdlib></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include <functional></td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include <functional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include <initializer_list></td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include <initializer_list></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include <limits></td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include <limits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include <memory></td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include <memory></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include <tuple></td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include <tuple></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include <type_traits></td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include <type_traits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline"></td>
    <td class="lineNumber">43</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include <random> // for std::mt19937</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include <random> // for std::mt19937</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">48</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline"></td>
    <td class="lineNumber">49</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">50</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">//     Extra additions to <type_traits></td>
    <td class="lineNumber">51</td>
    <td class="codeline">//     Extra additions to <type_traits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">52</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">template <typename T> struct make_const_ptr {</td>
    <td class="lineNumber">54</td>
    <td class="codeline">template <typename T> struct make_const_ptr {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">  using type = std::add_pointer_t<std::add_const_t<T>>;</td>
    <td class="lineNumber">55</td>
    <td class="codeline">  using type = std::add_pointer_t<std::add_const_t<T>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">};</td>
    <td class="lineNumber">56</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">template <typename T> struct make_const_ref {</td>
    <td class="lineNumber">58</td>
    <td class="codeline">template <typename T> struct make_const_ref {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">  using type = std::add_lvalue_reference_t<std::add_const_t<T>>;</td>
    <td class="lineNumber">59</td>
    <td class="codeline">  using type = std::add_lvalue_reference_t<std::add_const_t<T>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">};</td>
    <td class="lineNumber">60</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">62</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">template <class, template <class...> class Op, class... Args> struct detector {</td>
    <td class="lineNumber">63</td>
    <td class="codeline">template <class, template <class...> class Op, class... Args> struct detector {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">  using value_t = std::false_type;</td>
    <td class="lineNumber">64</td>
    <td class="codeline">  using value_t = std::false_type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">};</td>
    <td class="lineNumber">65</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">template <template <class...> class Op, class... Args></td>
    <td class="lineNumber">66</td>
    <td class="codeline">template <template <class...> class Op, class... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">struct detector<std::void_t<Op<Args...>>, Op, Args...> {</td>
    <td class="lineNumber">67</td>
    <td class="codeline">struct detector<std::void_t<Op<Args...>>, Op, Args...> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  using value_t = std::true_type;</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  using value_t = std::true_type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">};</td>
    <td class="lineNumber">69</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">} // end namespace detail</td>
    <td class="lineNumber">70</td>
    <td class="codeline">} // end namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">/// Detects if a given trait holds for some set of arguments 'Args'.</td>
    <td class="lineNumber">72</td>
    <td class="codeline">/// Detects if a given trait holds for some set of arguments 'Args'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">/// For example, the given trait could be used to detect if a given type</td>
    <td class="lineNumber">73</td>
    <td class="codeline">/// For example, the given trait could be used to detect if a given type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">/// has a copy assignment operator:</td>
    <td class="lineNumber">74</td>
    <td class="codeline">/// has a copy assignment operator:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">///   template<class T></td>
    <td class="lineNumber">75</td>
    <td class="codeline">///   template<class T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">///   using has_copy_assign_t = decltype(std::declval<T&>()</td>
    <td class="lineNumber">76</td>
    <td class="codeline">///   using has_copy_assign_t = decltype(std::declval<T&>()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">///                                                 = std::declval<const T&>());</td>
    <td class="lineNumber">77</td>
    <td class="codeline">///                                                 = std::declval<const T&>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;</td>
    <td class="lineNumber">78</td>
    <td class="codeline">///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">template <template <class...> class Op, class... Args></td>
    <td class="lineNumber">79</td>
    <td class="codeline">template <template <class...> class Op, class... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">using is_detected = typename detail::detector<void, Op, Args...>::value_t;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">using is_detected = typename detail::detector<void, Op, Args...>::value_t;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">/// This class provides various trait information about a callable object.</td>
    <td class="lineNumber">82</td>
    <td class="codeline">/// This class provides various trait information about a callable object.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">///   * To access the number of arguments: Traits::num_args</td>
    <td class="lineNumber">83</td>
    <td class="codeline">///   * To access the number of arguments: Traits::num_args</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">///   * To access the type of an argument: Traits::arg_t<Index></td>
    <td class="lineNumber">84</td>
    <td class="codeline">///   * To access the type of an argument: Traits::arg_t<Index></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">///   * To access the type of the result:  Traits::result_t</td>
    <td class="lineNumber">85</td>
    <td class="codeline">///   * To access the type of the result:  Traits::result_t</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">template <typename T, bool isClass = std::is_class<T>::value></td>
    <td class="lineNumber">86</td>
    <td class="codeline">template <typename T, bool isClass = std::is_class<T>::value></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">struct function_traits : public function_traits<decltype(&T::operator())> {};</td>
    <td class="lineNumber">87</td>
    <td class="codeline">struct function_traits : public function_traits<decltype(&T::operator())> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">/// Overload for class function types.</td>
    <td class="lineNumber">89</td>
    <td class="codeline">/// Overload for class function types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">template <typename ClassType, typename ReturnType, typename... Args></td>
    <td class="lineNumber">90</td>
    <td class="codeline">template <typename ClassType, typename ReturnType, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {</td>
    <td class="lineNumber">91</td>
    <td class="codeline">struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  /// The number of arguments to this function.</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  /// The number of arguments to this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  enum { num_args = sizeof...(Args) };</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  enum { num_args = sizeof...(Args) };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  /// The result type of this function.</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  /// The result type of this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  using result_t = ReturnType;</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  using result_t = ReturnType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  /// The type of an argument to this function.</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  /// The type of an argument to this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  template <size_t Index></td>
    <td class="lineNumber">99</td>
    <td class="codeline">  template <size_t Index></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  using arg_t = std::tuple_element_t<Index, std::tuple<Args...>>;</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  using arg_t = std::tuple_element_t<Index, std::tuple<Args...>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">};</td>
    <td class="lineNumber">101</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">/// Overload for class function types.</td>
    <td class="lineNumber">102</td>
    <td class="codeline">/// Overload for class function types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">template <typename ClassType, typename ReturnType, typename... Args></td>
    <td class="lineNumber">103</td>
    <td class="codeline">template <typename ClassType, typename ReturnType, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">struct function_traits<ReturnType (ClassType::*)(Args...), false></td>
    <td class="lineNumber">104</td>
    <td class="codeline">struct function_traits<ReturnType (ClassType::*)(Args...), false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};</td>
    <td class="lineNumber">105</td>
    <td class="codeline">    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">/// Overload for non-class function types.</td>
    <td class="lineNumber">106</td>
    <td class="codeline">/// Overload for non-class function types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">107</td>
    <td class="codeline">template <typename ReturnType, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">struct function_traits<ReturnType (*)(Args...), false> {</td>
    <td class="lineNumber">108</td>
    <td class="codeline">struct function_traits<ReturnType (*)(Args...), false> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  /// The number of arguments to this function.</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  /// The number of arguments to this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  enum { num_args = sizeof...(Args) };</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  enum { num_args = sizeof...(Args) };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  /// The result type of this function.</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  /// The result type of this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">  using result_t = ReturnType;</td>
    <td class="lineNumber">113</td>
    <td class="codeline">  using result_t = ReturnType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">  /// The type of an argument to this function.</td>
    <td class="lineNumber">115</td>
    <td class="codeline">  /// The type of an argument to this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  template <size_t i></td>
    <td class="lineNumber">116</td>
    <td class="codeline">  template <size_t i></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  using arg_t = std::tuple_element_t<i, std::tuple<Args...>>;</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  using arg_t = std::tuple_element_t<i, std::tuple<Args...>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">};</td>
    <td class="lineNumber">118</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">119</td>
    <td class="codeline">template <typename ReturnType, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">struct function_traits<ReturnType (*const)(Args...), false></td>
    <td class="lineNumber">120</td>
    <td class="codeline">struct function_traits<ReturnType (*const)(Args...), false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">    : public function_traits<ReturnType (*)(Args...)> {};</td>
    <td class="lineNumber">121</td>
    <td class="codeline">    : public function_traits<ReturnType (*)(Args...)> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">/// Overload for non-class function type references.</td>
    <td class="lineNumber">122</td>
    <td class="codeline">/// Overload for non-class function type references.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">123</td>
    <td class="codeline">template <typename ReturnType, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">struct function_traits<ReturnType (&)(Args...), false></td>
    <td class="lineNumber">124</td>
    <td class="codeline">struct function_traits<ReturnType (&)(Args...), false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">    : public function_traits<ReturnType (*)(Args...)> {};</td>
    <td class="lineNumber">125</td>
    <td class="codeline">    : public function_traits<ReturnType (*)(Args...)> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
    <td class="lineNumber">126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">/// traits class for checking whether type T is one of any of the given</td>
    <td class="lineNumber">127</td>
    <td class="codeline">/// traits class for checking whether type T is one of any of the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">/// types in the variadic list.</td>
    <td class="lineNumber">128</td>
    <td class="codeline">/// types in the variadic list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">template <typename T, typename... Ts></td>
    <td class="lineNumber">129</td>
    <td class="codeline">template <typename T, typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
    <td class="lineNumber">130</td>
    <td class="codeline">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">/// traits class for checking whether type T is a base class for all</td>
    <td class="lineNumber">132</td>
    <td class="codeline">/// traits class for checking whether type T is a base class for all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">///  the given types in the variadic list.</td>
    <td class="lineNumber">133</td>
    <td class="codeline">///  the given types in the variadic list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">template <typename T, typename... Ts></td>
    <td class="lineNumber">134</td>
    <td class="codeline">template <typename T, typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
    <td class="lineNumber">135</td>
    <td class="codeline">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">137</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">template <typename T, typename... Us> struct TypesAreDistinct;</td>
    <td class="lineNumber">138</td>
    <td class="codeline">template <typename T, typename... Us> struct TypesAreDistinct;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">template <typename T, typename... Us></td>
    <td class="lineNumber">139</td>
    <td class="codeline">template <typename T, typename... Us></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">struct TypesAreDistinct</td>
    <td class="lineNumber">140</td>
    <td class="codeline">struct TypesAreDistinct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&</td>
    <td class="lineNumber">141</td>
    <td class="codeline">    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">                                       TypesAreDistinct<Us...>::value> {};</td>
    <td class="lineNumber">142</td>
    <td class="codeline">                                       TypesAreDistinct<Us...>::value> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">template <typename T> struct TypesAreDistinct<T> : std::true_type {};</td>
    <td class="lineNumber">143</td>
    <td class="codeline">template <typename T> struct TypesAreDistinct<T> : std::true_type {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">144</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">/// Determine if all types in Ts are distinct.</td>
    <td class="lineNumber">146</td>
    <td class="codeline">/// Determine if all types in Ts are distinct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">///</td>
    <td class="lineNumber">147</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">/// Useful to statically assert when Ts is intended to describe a non-multi set</td>
    <td class="lineNumber">148</td>
    <td class="codeline">/// Useful to statically assert when Ts is intended to describe a non-multi set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">/// of types.</td>
    <td class="lineNumber">149</td>
    <td class="codeline">/// of types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">///</td>
    <td class="lineNumber">150</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">/// Expensive (currently quadratic in sizeof(Ts...)), and so should only be</td>
    <td class="lineNumber">151</td>
    <td class="codeline">/// Expensive (currently quadratic in sizeof(Ts...)), and so should only be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">/// asserted once per instantiation of a type which requires it.</td>
    <td class="lineNumber">152</td>
    <td class="codeline">/// asserted once per instantiation of a type which requires it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">template <typename... Ts> struct TypesAreDistinct;</td>
    <td class="lineNumber">153</td>
    <td class="codeline">template <typename... Ts> struct TypesAreDistinct;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">template <> struct TypesAreDistinct<> : std::true_type {};</td>
    <td class="lineNumber">154</td>
    <td class="codeline">template <> struct TypesAreDistinct<> : std::true_type {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">template <typename... Ts></td>
    <td class="lineNumber">155</td>
    <td class="codeline">template <typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">struct TypesAreDistinct</td>
    <td class="lineNumber">156</td>
    <td class="codeline">struct TypesAreDistinct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};</td>
    <td class="lineNumber">157</td>
    <td class="codeline">    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
    <td class="lineNumber">158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">/// Find the first index where a type appears in a list of types.</td>
    <td class="lineNumber">159</td>
    <td class="codeline">/// Find the first index where a type appears in a list of types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">///</td>
    <td class="lineNumber">160</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">/// FirstIndexOfType<T, Us...>::value is the first index of T in Us.</td>
    <td class="lineNumber">161</td>
    <td class="codeline">/// FirstIndexOfType<T, Us...>::value is the first index of T in Us.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">///</td>
    <td class="lineNumber">162</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">/// Typically only meaningful when it is otherwise statically known that the</td>
    <td class="lineNumber">163</td>
    <td class="codeline">/// Typically only meaningful when it is otherwise statically known that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">/// type pack has no duplicate types. This should be guaranteed explicitly with</td>
    <td class="lineNumber">164</td>
    <td class="codeline">/// type pack has no duplicate types. This should be guaranteed explicitly with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">/// static_assert(TypesAreDistinct<Us...>::value).</td>
    <td class="lineNumber">165</td>
    <td class="codeline">/// static_assert(TypesAreDistinct<Us...>::value).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">///</td>
    <td class="lineNumber">166</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">/// It is a compile-time error to instantiate when T is not present in Us, i.e.</td>
    <td class="lineNumber">167</td>
    <td class="codeline">/// It is a compile-time error to instantiate when T is not present in Us, i.e.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">/// if is_one_of<T, Us...>::value is false.</td>
    <td class="lineNumber">168</td>
    <td class="codeline">/// if is_one_of<T, Us...>::value is false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">template <typename T, typename... Us> struct FirstIndexOfType;</td>
    <td class="lineNumber">169</td>
    <td class="codeline">template <typename T, typename... Us> struct FirstIndexOfType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">template <typename T, typename U, typename... Us></td>
    <td class="lineNumber">170</td>
    <td class="codeline">template <typename T, typename U, typename... Us></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">struct FirstIndexOfType<T, U, Us...></td>
    <td class="lineNumber">171</td>
    <td class="codeline">struct FirstIndexOfType<T, U, Us...></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};</td>
    <td class="lineNumber">172</td>
    <td class="codeline">    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">template <typename T, typename... Us></td>
    <td class="lineNumber">173</td>
    <td class="codeline">template <typename T, typename... Us></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};</td>
    <td class="lineNumber">174</td>
    <td class="codeline">struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">/// Find the type at a given index in a list of types.</td>
    <td class="lineNumber">176</td>
    <td class="codeline">/// Find the type at a given index in a list of types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">///</td>
    <td class="lineNumber">177</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">/// TypeAtIndex<I, Ts...> is the type at index I in Ts.</td>
    <td class="lineNumber">178</td>
    <td class="codeline">/// TypeAtIndex<I, Ts...> is the type at index I in Ts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">template <size_t I, typename... Ts></td>
    <td class="lineNumber">179</td>
    <td class="codeline">template <size_t I, typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;</td>
    <td class="lineNumber">180</td>
    <td class="codeline">using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">/// Helper which adds two underlying types of enumeration type.</td>
    <td class="lineNumber">182</td>
    <td class="codeline">/// Helper which adds two underlying types of enumeration type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">/// Implicit conversion to a common type is accepted.</td>
    <td class="lineNumber">183</td>
    <td class="codeline">/// Implicit conversion to a common type is accepted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">template <typename EnumTy1, typename EnumTy2,</td>
    <td class="lineNumber">184</td>
    <td class="codeline">template <typename EnumTy1, typename EnumTy2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,</td>
    <td class="lineNumber">185</td>
    <td class="codeline">          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">                                          std::underlying_type_t<EnumTy1>>,</td>
    <td class="lineNumber">186</td>
    <td class="codeline">                                          std::underlying_type_t<EnumTy1>>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,</td>
    <td class="lineNumber">187</td>
    <td class="codeline">          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">                                          std::underlying_type_t<EnumTy2>>></td>
    <td class="lineNumber">188</td>
    <td class="codeline">                                          std::underlying_type_t<EnumTy2>>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {</td>
    <td class="lineNumber">189</td>
    <td class="codeline">constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">}</td>
    <td class="lineNumber">191</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">193</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">//     Extra additions to <iterator></td>
    <td class="lineNumber">194</td>
    <td class="codeline">//     Extra additions to <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">195</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline"></td>
    <td class="lineNumber">196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">namespace callable_detail {</td>
    <td class="lineNumber">197</td>
    <td class="codeline">namespace callable_detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">/// Templated storage wrapper for a callable.</td>
    <td class="lineNumber">199</td>
    <td class="codeline">/// Templated storage wrapper for a callable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">///</td>
    <td class="lineNumber">200</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">/// This class is consistently default constructible, copy / move</td>
    <td class="lineNumber">201</td>
    <td class="codeline">/// This class is consistently default constructible, copy / move</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">/// constructible / assignable.</td>
    <td class="lineNumber">202</td>
    <td class="codeline">/// constructible / assignable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">///</td>
    <td class="lineNumber">203</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">/// Supported callable types:</td>
    <td class="lineNumber">204</td>
    <td class="codeline">/// Supported callable types:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">///  - Function pointer</td>
    <td class="lineNumber">205</td>
    <td class="codeline">///  - Function pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">///  - Function reference</td>
    <td class="lineNumber">206</td>
    <td class="codeline">///  - Function reference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">///  - Lambda</td>
    <td class="lineNumber">207</td>
    <td class="codeline">///  - Lambda</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">///  - Function object</td>
    <td class="lineNumber">208</td>
    <td class="codeline">///  - Function object</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">template <typename T,</td>
    <td class="lineNumber">209</td>
    <td class="codeline">template <typename T,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">          bool = std::is_function_v<std::remove_pointer_t<remove_cvref_t<T>>>></td>
    <td class="lineNumber">210</td>
    <td class="codeline">          bool = std::is_function_v<std::remove_pointer_t<remove_cvref_t<T>>>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">class Callable {</td>
    <td class="lineNumber">211</td>
    <td class="codeline">class Callable {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  using value_type = std::remove_reference_t<T>;</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  using value_type = std::remove_reference_t<T>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  using reference = value_type &;</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  using reference = value_type &;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  using const_reference = value_type const &;</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  using const_reference = value_type const &;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  std::optional<value_type> Obj;</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  std::optional<value_type> Obj;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  static_assert(!std::is_pointer_v<value_type>,</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  static_assert(!std::is_pointer_v<value_type>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">                "Pointers to non-functions are not callable.");</td>
    <td class="lineNumber">219</td>
    <td class="codeline">                "Pointers to non-functions are not callable.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">221</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  Callable() = default;</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  Callable() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  Callable(T const &O) : Obj(std::in_place, O) {}</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  Callable(T const &O) : Obj(std::in_place, O) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  Callable(Callable const &Other) = default;</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  Callable(Callable const &Other) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  Callable(Callable &&Other) = default;</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  Callable(Callable &&Other) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  Callable &operator=(Callable const &Other) {</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  Callable &operator=(Callable const &Other) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">    Obj = std::nullopt;</td>
    <td class="lineNumber">229</td>
    <td class="codeline">    Obj = std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">    if (Other.Obj)</td>
    <td class="lineNumber">230</td>
    <td class="codeline">    if (Other.Obj)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">      Obj.emplace(*Other.Obj);</td>
    <td class="lineNumber">231</td>
    <td class="codeline">      Obj.emplace(*Other.Obj);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">232</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  Callable &operator=(Callable &&Other) {</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  Callable &operator=(Callable &&Other) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    Obj = std::nullopt;</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    Obj = std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">    if (Other.Obj)</td>
    <td class="lineNumber">237</td>
    <td class="codeline">    if (Other.Obj)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">      Obj.emplace(std::move(*Other.Obj));</td>
    <td class="lineNumber">238</td>
    <td class="codeline">      Obj.emplace(std::move(*Other.Obj));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  template <typename... Pn,</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  template <typename... Pn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
    <td class="lineNumber">243</td>
    <td class="codeline">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  decltype(auto) operator()(Pn &&...Params) {</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  decltype(auto) operator()(Pn &&...Params) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">    return (*Obj)(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">245</td>
    <td class="codeline">    return (*Obj)(std::forward<Pn>(Params)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline"></td>
    <td class="lineNumber">247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  template <typename... Pn,</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  template <typename... Pn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">            std::enable_if_t<std::is_invocable_v<T const, Pn...>, int> = 0></td>
    <td class="lineNumber">249</td>
    <td class="codeline">            std::enable_if_t<std::is_invocable_v<T const, Pn...>, int> = 0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  decltype(auto) operator()(Pn &&...Params) const {</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  decltype(auto) operator()(Pn &&...Params) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">    return (*Obj)(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">251</td>
    <td class="codeline">    return (*Obj)(std::forward<Pn>(Params)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline"></td>
    <td class="lineNumber">253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  bool valid() const { return Obj != std::nullopt; }</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  bool valid() const { return Obj != std::nullopt; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  bool reset() { return Obj = std::nullopt; }</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  bool reset() { return Obj = std::nullopt; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
    <td class="lineNumber">256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  operator reference() { return *Obj; }</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  operator reference() { return *Obj; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  operator const_reference() const { return *Obj; }</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  operator const_reference() const { return *Obj; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">};</td>
    <td class="lineNumber">259</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">// Function specialization.  No need to waste extra space wrapping with a</td>
    <td class="lineNumber">261</td>
    <td class="codeline">// Function specialization.  No need to waste extra space wrapping with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">// std::optional.</td>
    <td class="lineNumber">262</td>
    <td class="codeline">// std::optional.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">template <typename T> class Callable<T, true> {</td>
    <td class="lineNumber">263</td>
    <td class="codeline">template <typename T> class Callable<T, true> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  static constexpr bool IsPtr = std::is_pointer_v<remove_cvref_t<T>>;</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  static constexpr bool IsPtr = std::is_pointer_v<remove_cvref_t<T>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  using StorageT = std::conditional_t<IsPtr, T, std::remove_reference_t<T> *>;</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  using StorageT = std::conditional_t<IsPtr, T, std::remove_reference_t<T> *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  using CastT = std::conditional_t<IsPtr, T, T &>;</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  using CastT = std::conditional_t<IsPtr, T, T &>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline"></td>
    <td class="lineNumber">268</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">269</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  StorageT Func = nullptr;</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  StorageT Func = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">272</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  template <typename In> static constexpr auto convertIn(In &&I) {</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  template <typename In> static constexpr auto convertIn(In &&I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">    if constexpr (IsPtr) {</td>
    <td class="lineNumber">274</td>
    <td class="codeline">    if constexpr (IsPtr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">      // Pointer... just echo it back.</td>
    <td class="lineNumber">275</td>
    <td class="codeline">      // Pointer... just echo it back.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">      return I;</td>
    <td class="lineNumber">276</td>
    <td class="codeline">      return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">277</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">      // Must be a function reference.  Return its address.</td>
    <td class="lineNumber">278</td>
    <td class="codeline">      // Must be a function reference.  Return its address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">      return &I;</td>
    <td class="lineNumber">279</td>
    <td class="codeline">      return &I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">280</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">283</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  Callable() = default;</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  Callable() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  // Construct from a function pointer or reference.</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  // Construct from a function pointer or reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  // Disable this constructor for references to 'Callable' so we don't violate</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  // Disable this constructor for references to 'Callable' so we don't violate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  // the rule of 0.</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  // the rule of 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  template < // clang-format off</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  template < // clang-format off</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">    typename FnPtrOrRef,</td>
    <td class="lineNumber">291</td>
    <td class="codeline">    typename FnPtrOrRef,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    std::enable_if_t<</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    std::enable_if_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">      !std::is_same_v<remove_cvref_t<FnPtrOrRef>, Callable>, int</td>
    <td class="lineNumber">293</td>
    <td class="codeline">      !std::is_same_v<remove_cvref_t<FnPtrOrRef>, Callable>, int</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    > = 0</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    > = 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  > // clang-format on</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  > // clang-format on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  Callable(FnPtrOrRef &&F) : Func(convertIn(F)) {}</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  Callable(FnPtrOrRef &&F) : Func(convertIn(F)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  template <typename... Pn,</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  template <typename... Pn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
    <td class="lineNumber">299</td>
    <td class="codeline">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  decltype(auto) operator()(Pn &&...Params) const {</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  decltype(auto) operator()(Pn &&...Params) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">    return Func(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">301</td>
    <td class="codeline">    return Func(std::forward<Pn>(Params)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline"></td>
    <td class="lineNumber">303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  bool valid() const { return Func != nullptr; }</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  bool valid() const { return Func != nullptr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  void reset() { Func = nullptr; }</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  void reset() { Func = nullptr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline"></td>
    <td class="lineNumber">306</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  operator T const &() const {</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  operator T const &() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    if constexpr (IsPtr) {</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    if constexpr (IsPtr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">      // T is a pointer... just echo it back.</td>
    <td class="lineNumber">309</td>
    <td class="codeline">      // T is a pointer... just echo it back.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">      return Func;</td>
    <td class="lineNumber">310</td>
    <td class="codeline">      return Func;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">      static_assert(std::is_reference_v<T>,</td>
    <td class="lineNumber">312</td>
    <td class="codeline">      static_assert(std::is_reference_v<T>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">                    "Expected a reference to a function.");</td>
    <td class="lineNumber">313</td>
    <td class="codeline">                    "Expected a reference to a function.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">      // T is a function reference... dereference the stored pointer.</td>
    <td class="lineNumber">314</td>
    <td class="codeline">      // T is a function reference... dereference the stored pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">      return *Func;</td>
    <td class="lineNumber">315</td>
    <td class="codeline">      return *Func;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">316</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">};</td>
    <td class="lineNumber">318</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">} // namespace callable_detail</td>
    <td class="lineNumber">320</td>
    <td class="codeline">} // namespace callable_detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline"></td>
    <td class="lineNumber">321</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">/// Returns true if the given container only contains a single element.</td>
    <td class="lineNumber">322</td>
    <td class="codeline">/// Returns true if the given container only contains a single element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {</td>
    <td class="lineNumber">323</td>
    <td class="codeline">template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  auto B = std::begin(C), E = std::end(C);</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  auto B = std::begin(C), E = std::end(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  return B != E && std::next(B) == E;</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  return B != E && std::next(B) == E;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">}</td>
    <td class="lineNumber">326</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
    <td class="lineNumber">327</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">/// Return a range covering \p RangeOrContainer with the first N elements</td>
    <td class="lineNumber">328</td>
    <td class="codeline">/// Return a range covering \p RangeOrContainer with the first N elements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">/// excluded.</td>
    <td class="lineNumber">329</td>
    <td class="codeline">/// excluded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {</td>
    <td class="lineNumber">330</td>
    <td class="codeline">template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  return make_range(std::next(adl_begin(RangeOrContainer), N),</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  return make_range(std::next(adl_begin(RangeOrContainer), N),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">                    adl_end(RangeOrContainer));</td>
    <td class="lineNumber">332</td>
    <td class="codeline">                    adl_end(RangeOrContainer));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">}</td>
    <td class="lineNumber">333</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">/// Return a range covering \p RangeOrContainer with the last N elements</td>
    <td class="lineNumber">335</td>
    <td class="codeline">/// Return a range covering \p RangeOrContainer with the last N elements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">/// excluded.</td>
    <td class="lineNumber">336</td>
    <td class="codeline">/// excluded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {</td>
    <td class="lineNumber">337</td>
    <td class="codeline">template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  return make_range(adl_begin(RangeOrContainer),</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  return make_range(adl_begin(RangeOrContainer),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">                    std::prev(adl_end(RangeOrContainer), N));</td>
    <td class="lineNumber">339</td>
    <td class="codeline">                    std::prev(adl_end(RangeOrContainer), N));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">}</td>
    <td class="lineNumber">340</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">// mapped_iterator - This is a simple iterator adapter that causes a function to</td>
    <td class="lineNumber">342</td>
    <td class="codeline">// mapped_iterator - This is a simple iterator adapter that causes a function to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">// be applied whenever operator* is invoked on the iterator.</td>
    <td class="lineNumber">343</td>
    <td class="codeline">// be applied whenever operator* is invoked on the iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">template <typename ItTy, typename FuncTy,</td>
    <td class="lineNumber">345</td>
    <td class="codeline">template <typename ItTy, typename FuncTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">          typename ReferenceTy =</td>
    <td class="lineNumber">346</td>
    <td class="codeline">          typename ReferenceTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))></td>
    <td class="lineNumber">347</td>
    <td class="codeline">              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">class mapped_iterator</td>
    <td class="lineNumber">348</td>
    <td class="codeline">class mapped_iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">349</td>
    <td class="codeline">    : public iterator_adaptor_base<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">          mapped_iterator<ItTy, FuncTy>, ItTy,</td>
    <td class="lineNumber">350</td>
    <td class="codeline">          mapped_iterator<ItTy, FuncTy>, ItTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">          typename std::iterator_traits<ItTy>::iterator_category,</td>
    <td class="lineNumber">351</td>
    <td class="codeline">          typename std::iterator_traits<ItTy>::iterator_category,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">          std::remove_reference_t<ReferenceTy>,</td>
    <td class="lineNumber">352</td>
    <td class="codeline">          std::remove_reference_t<ReferenceTy>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">          typename std::iterator_traits<ItTy>::difference_type,</td>
    <td class="lineNumber">353</td>
    <td class="codeline">          typename std::iterator_traits<ItTy>::difference_type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
    <td class="lineNumber">354</td>
    <td class="codeline">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">355</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  mapped_iterator() = default;</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  mapped_iterator() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">  mapped_iterator(ItTy U, FuncTy F)</td>
    <td class="lineNumber">357</td>
    <td class="codeline">  mapped_iterator(ItTy U, FuncTy F)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}</td>
    <td class="lineNumber">358</td>
    <td class="codeline">    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
    <td class="lineNumber">359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  ItTy getCurrent() { return this->I; }</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  ItTy getCurrent() { return this->I; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline"></td>
    <td class="lineNumber">361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  const FuncTy &getFunction() const { return F; }</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  const FuncTy &getFunction() const { return F; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  ReferenceTy operator*() const { return F(*this->I); }</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  ReferenceTy operator*() const { return F(*this->I); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline"></td>
    <td class="lineNumber">365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">366</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  callable_detail::Callable<FuncTy> F{};</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  callable_detail::Callable<FuncTy> F{};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">};</td>
    <td class="lineNumber">368</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">// map_iterator - Provide a convenient way to create mapped_iterators, just like</td>
    <td class="lineNumber">370</td>
    <td class="codeline">// map_iterator - Provide a convenient way to create mapped_iterators, just like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">// make_pair is useful for creating pairs...</td>
    <td class="lineNumber">371</td>
    <td class="codeline">// make_pair is useful for creating pairs...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">template <class ItTy, class FuncTy></td>
    <td class="lineNumber">372</td>
    <td class="codeline">template <class ItTy, class FuncTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {</td>
    <td class="lineNumber">373</td>
    <td class="codeline">inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">}</td>
    <td class="lineNumber">375</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline"></td>
    <td class="lineNumber">376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">template <class ContainerTy, class FuncTy></td>
    <td class="lineNumber">377</td>
    <td class="codeline">template <class ContainerTy, class FuncTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">auto map_range(ContainerTy &&C, FuncTy F) {</td>
    <td class="lineNumber">378</td>
    <td class="codeline">auto map_range(ContainerTy &&C, FuncTy F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  return make_range(map_iterator(std::begin(C), F),</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  return make_range(map_iterator(std::begin(C), F),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">                    map_iterator(std::end(C), F));</td>
    <td class="lineNumber">380</td>
    <td class="codeline">                    map_iterator(std::end(C), F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">}</td>
    <td class="lineNumber">381</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">/// A base type of mapped iterator, that is useful for building derived</td>
    <td class="lineNumber">383</td>
    <td class="codeline">/// A base type of mapped iterator, that is useful for building derived</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">/// iterators that do not need/want to store the map function (as in</td>
    <td class="lineNumber">384</td>
    <td class="codeline">/// iterators that do not need/want to store the map function (as in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">/// mapped_iterator). These iterators must simply provide a `mapElement` method</td>
    <td class="lineNumber">385</td>
    <td class="codeline">/// mapped_iterator). These iterators must simply provide a `mapElement` method</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">/// that defines how to map a value of the iterator to the provided reference</td>
    <td class="lineNumber">386</td>
    <td class="codeline">/// that defines how to map a value of the iterator to the provided reference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">/// type.</td>
    <td class="lineNumber">387</td>
    <td class="codeline">/// type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">template <typename DerivedT, typename ItTy, typename ReferenceTy></td>
    <td class="lineNumber">388</td>
    <td class="codeline">template <typename DerivedT, typename ItTy, typename ReferenceTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">class mapped_iterator_base</td>
    <td class="lineNumber">389</td>
    <td class="codeline">class mapped_iterator_base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">390</td>
    <td class="codeline">    : public iterator_adaptor_base<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">          DerivedT, ItTy,</td>
    <td class="lineNumber">391</td>
    <td class="codeline">          DerivedT, ItTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">          typename std::iterator_traits<ItTy>::iterator_category,</td>
    <td class="lineNumber">392</td>
    <td class="codeline">          typename std::iterator_traits<ItTy>::iterator_category,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">          std::remove_reference_t<ReferenceTy>,</td>
    <td class="lineNumber">393</td>
    <td class="codeline">          std::remove_reference_t<ReferenceTy>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">          typename std::iterator_traits<ItTy>::difference_type,</td>
    <td class="lineNumber">394</td>
    <td class="codeline">          typename std::iterator_traits<ItTy>::difference_type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
    <td class="lineNumber">395</td>
    <td class="codeline">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">396</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  using BaseT = mapped_iterator_base;</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  using BaseT = mapped_iterator_base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline"></td>
    <td class="lineNumber">398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  mapped_iterator_base(ItTy U)</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  mapped_iterator_base(ItTy U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}</td>
    <td class="lineNumber">400</td>
    <td class="codeline">      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  ItTy getCurrent() { return this->I; }</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  ItTy getCurrent() { return this->I; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  ReferenceTy operator*() const {</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  ReferenceTy operator*() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    return static_cast<const DerivedT &>(*this).mapElement(*this->I);</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    return static_cast<const DerivedT &>(*this).mapElement(*this->I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">};</td>
    <td class="lineNumber">407</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">/// Helper to determine if type T has a member called rbegin().</td>
    <td class="lineNumber">409</td>
    <td class="codeline">/// Helper to determine if type T has a member called rbegin().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">template <typename Ty> class has_rbegin_impl {</td>
    <td class="lineNumber">410</td>
    <td class="codeline">template <typename Ty> class has_rbegin_impl {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  using yes = char[1];</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  using yes = char[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  using no = char[2];</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  using no = char[2];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline"></td>
    <td class="lineNumber">413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  template <typename Inner></td>
    <td class="lineNumber">414</td>
    <td class="codeline">  template <typename Inner></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  template <typename></td>
    <td class="lineNumber">417</td>
    <td class="codeline">  template <typename></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  static no& test(...);</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  static no& test(...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">420</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">};</td>
    <td class="lineNumber">422</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline"></td>
    <td class="lineNumber">423</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">/// Metafunction to determine if T& or T has a member called rbegin().</td>
    <td class="lineNumber">424</td>
    <td class="codeline">/// Metafunction to determine if T& or T has a member called rbegin().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">template <typename Ty></td>
    <td class="lineNumber">425</td>
    <td class="codeline">template <typename Ty></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">struct has_rbegin : has_rbegin_impl<std::remove_reference_t<Ty>> {};</td>
    <td class="lineNumber">426</td>
    <td class="codeline">struct has_rbegin : has_rbegin_impl<std::remove_reference_t<Ty>> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">// Returns an iterator_range over the given container which iterates in reverse.</td>
    <td class="lineNumber">428</td>
    <td class="codeline">// Returns an iterator_range over the given container which iterates in reverse.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">template <typename ContainerTy> auto reverse(ContainerTy &&C) {</td>
    <td class="lineNumber">429</td>
    <td class="codeline">template <typename ContainerTy> auto reverse(ContainerTy &&C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  if constexpr (has_rbegin<ContainerTy>::value)</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  if constexpr (has_rbegin<ContainerTy>::value)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">    return make_range(C.rbegin(), C.rend());</td>
    <td class="lineNumber">431</td>
    <td class="codeline">    return make_range(C.rbegin(), C.rend());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">    return make_range(std::make_reverse_iterator(std::end(C)),</td>
    <td class="lineNumber">433</td>
    <td class="codeline">    return make_range(std::make_reverse_iterator(std::end(C)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">                      std::make_reverse_iterator(std::begin(C)));</td>
    <td class="lineNumber">434</td>
    <td class="codeline">                      std::make_reverse_iterator(std::begin(C)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">}</td>
    <td class="lineNumber">435</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">/// An iterator adaptor that filters the elements of given inner iterators.</td>
    <td class="lineNumber">437</td>
    <td class="codeline">/// An iterator adaptor that filters the elements of given inner iterators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">///</td>
    <td class="lineNumber">438</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">/// The predicate parameter should be a callable object that accepts the wrapped</td>
    <td class="lineNumber">439</td>
    <td class="codeline">/// The predicate parameter should be a callable object that accepts the wrapped</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">/// iterator's reference type and returns a bool. When incrementing or</td>
    <td class="lineNumber">440</td>
    <td class="codeline">/// iterator's reference type and returns a bool. When incrementing or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">/// decrementing the iterator, it will call the predicate on each element and</td>
    <td class="lineNumber">441</td>
    <td class="codeline">/// decrementing the iterator, it will call the predicate on each element and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">/// skip any where it returns false.</td>
    <td class="lineNumber">442</td>
    <td class="codeline">/// skip any where it returns false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">///</td>
    <td class="lineNumber">443</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">/// \code</td>
    <td class="lineNumber">444</td>
    <td class="codeline">/// \code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">///   int A[] = { 1, 2, 3, 4 };</td>
    <td class="lineNumber">445</td>
    <td class="codeline">///   int A[] = { 1, 2, 3, 4 };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });</td>
    <td class="lineNumber">446</td>
    <td class="codeline">///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">///   // R contains { 1, 3 }.</td>
    <td class="lineNumber">447</td>
    <td class="codeline">///   // R contains { 1, 3 }.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">/// \endcode</td>
    <td class="lineNumber">448</td>
    <td class="codeline">/// \endcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">///</td>
    <td class="lineNumber">449</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">/// Note: filter_iterator_base implements support for forward iteration.</td>
    <td class="lineNumber">450</td>
    <td class="codeline">/// Note: filter_iterator_base implements support for forward iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">/// filter_iterator_impl exists to provide support for bidirectional iteration,</td>
    <td class="lineNumber">451</td>
    <td class="codeline">/// filter_iterator_impl exists to provide support for bidirectional iteration,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">/// conditional on whether the wrapped iterator supports it.</td>
    <td class="lineNumber">452</td>
    <td class="codeline">/// conditional on whether the wrapped iterator supports it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">template <typename WrappedIteratorT, typename PredicateT, typename IterTag></td>
    <td class="lineNumber">453</td>
    <td class="codeline">template <typename WrappedIteratorT, typename PredicateT, typename IterTag></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">class filter_iterator_base</td>
    <td class="lineNumber">454</td>
    <td class="codeline">class filter_iterator_base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">455</td>
    <td class="codeline">    : public iterator_adaptor_base<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,</td>
    <td class="lineNumber">456</td>
    <td class="codeline">          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">          WrappedIteratorT,</td>
    <td class="lineNumber">457</td>
    <td class="codeline">          WrappedIteratorT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">          std::common_type_t<IterTag,</td>
    <td class="lineNumber">458</td>
    <td class="codeline">          std::common_type_t<IterTag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">                             typename std::iterator_traits<</td>
    <td class="lineNumber">459</td>
    <td class="codeline">                             typename std::iterator_traits<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">                                 WrappedIteratorT>::iterator_category>> {</td>
    <td class="lineNumber">460</td>
    <td class="codeline">                                 WrappedIteratorT>::iterator_category>> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  using BaseT = typename filter_iterator_base::iterator_adaptor_base;</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  using BaseT = typename filter_iterator_base::iterator_adaptor_base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">463</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  WrappedIteratorT End;</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  WrappedIteratorT End;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  PredicateT Pred;</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  PredicateT Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine diffFirst">  void findNextValid() {</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  void findNextValid() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine diffFirst">    while (this->I != End && !Pred(*this->I))</td>
    <td class="lineNumber">468</td>
    <td class="codeline">    while (this->I != End && !Pred(*this->I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine diffFirst">      BaseT::operator++();</td>
    <td class="lineNumber">469</td>
    <td class="codeline">      BaseT::operator++();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine diffFirst">  }</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  filter_iterator_base() = default;</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  filter_iterator_base() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline"></td>
    <td class="lineNumber">473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  // Construct the iterator. The begin iterator needs to know where the end</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  // Construct the iterator. The begin iterator needs to know where the end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  // is, so that it can properly stop when it gets there. The end iterator only</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  // is, so that it can properly stop when it gets there. The end iterator only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  // needs the predicate to support bidirectional iteration.</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  // needs the predicate to support bidirectional iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine diffFirst">  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">                       PredicateT Pred)</td>
    <td class="lineNumber">478</td>
    <td class="codeline">                       PredicateT Pred)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine diffFirst">      : BaseT(Begin), End(End), Pred(Pred) {</td>
    <td class="lineNumber">479</td>
    <td class="codeline">      : BaseT(Begin), End(End), Pred(Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine diffFirst">    findNextValid();</td>
    <td class="lineNumber">480</td>
    <td class="codeline">    findNextValid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine diffFirst">  }</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline"></td>
    <td class="lineNumber">482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">483</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  using BaseT::operator++;</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  using BaseT::operator++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine diffFirst">  filter_iterator_base &operator++() {</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  filter_iterator_base &operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine diffFirst">    BaseT::operator++();</td>
    <td class="lineNumber">487</td>
    <td class="codeline">    BaseT::operator++();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine diffFirst">    findNextValid();</td>
    <td class="lineNumber">488</td>
    <td class="codeline">    findNextValid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine diffFirst">    return *this;</td>
    <td class="lineNumber">489</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline"></td>
    <td class="lineNumber">491</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine diffFirst">  decltype(auto) operator*() const {</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  decltype(auto) operator*() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine diffFirst">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
    <td class="lineNumber">493</td>
    <td class="codeline">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine diffFirst">    return BaseT::operator*();</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    return BaseT::operator*();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline"></td>
    <td class="lineNumber">496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  decltype(auto) operator->() const {</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  decltype(auto) operator->() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
    <td class="lineNumber">498</td>
    <td class="codeline">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    return BaseT::operator->();</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    return BaseT::operator->();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">};</td>
    <td class="lineNumber">501</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">/// Specialization of filter_iterator_base for forward iteration only.</td>
    <td class="lineNumber">503</td>
    <td class="codeline">/// Specialization of filter_iterator_base for forward iteration only.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">template <typename WrappedIteratorT, typename PredicateT,</td>
    <td class="lineNumber">504</td>
    <td class="codeline">template <typename WrappedIteratorT, typename PredicateT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">          typename IterTag = std::forward_iterator_tag></td>
    <td class="lineNumber">505</td>
    <td class="codeline">          typename IterTag = std::forward_iterator_tag></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">class filter_iterator_impl</td>
    <td class="lineNumber">506</td>
    <td class="codeline">class filter_iterator_impl</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">508</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  filter_iterator_impl() = default;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  filter_iterator_impl() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">                       PredicateT Pred)</td>
    <td class="lineNumber">512</td>
    <td class="codeline">                       PredicateT Pred)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}</td>
    <td class="lineNumber">513</td>
    <td class="codeline">      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">};</td>
    <td class="lineNumber">514</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">/// Specialization of filter_iterator_base for bidirectional iteration.</td>
    <td class="lineNumber">516</td>
    <td class="codeline">/// Specialization of filter_iterator_base for bidirectional iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">template <typename WrappedIteratorT, typename PredicateT></td>
    <td class="lineNumber">517</td>
    <td class="codeline">template <typename WrappedIteratorT, typename PredicateT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">class filter_iterator_impl<WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">518</td>
    <td class="codeline">class filter_iterator_impl<WrappedIteratorT, PredicateT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">                           std::bidirectional_iterator_tag></td>
    <td class="lineNumber">519</td>
    <td class="codeline">                           std::bidirectional_iterator_tag></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">    : public filter_iterator_base<WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">520</td>
    <td class="codeline">    : public filter_iterator_base<WrappedIteratorT, PredicateT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">                                  std::bidirectional_iterator_tag> {</td>
    <td class="lineNumber">521</td>
    <td class="codeline">                                  std::bidirectional_iterator_tag> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  using BaseT = typename filter_iterator_impl::filter_iterator_base;</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  using BaseT = typename filter_iterator_impl::filter_iterator_base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  void findPrevValid() {</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  void findPrevValid() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">    while (!this->Pred(*this->I))</td>
    <td class="lineNumber">525</td>
    <td class="codeline">    while (!this->Pred(*this->I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">      BaseT::operator--();</td>
    <td class="lineNumber">526</td>
    <td class="codeline">      BaseT::operator--();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline"></td>
    <td class="lineNumber">528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">529</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  using BaseT::operator--;</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  using BaseT::operator--;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
    <td class="lineNumber">531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  filter_iterator_impl() = default;</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  filter_iterator_impl() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine diffFirst">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">                       PredicateT Pred)</td>
    <td class="lineNumber">535</td>
    <td class="codeline">                       PredicateT Pred)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine diffFirst">      : BaseT(Begin, End, Pred) {}</td>
    <td class="lineNumber">536</td>
    <td class="codeline">      : BaseT(Begin, End, Pred) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  filter_iterator_impl &operator--() {</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  filter_iterator_impl &operator--() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    BaseT::operator--();</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    BaseT::operator--();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">    findPrevValid();</td>
    <td class="lineNumber">540</td>
    <td class="codeline">    findPrevValid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">541</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">};</td>
    <td class="lineNumber">543</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">545</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {</td>
    <td class="lineNumber">547</td>
    <td class="codeline">template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  using type = std::forward_iterator_tag;</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  using type = std::forward_iterator_tag;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">};</td>
    <td class="lineNumber">549</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline"></td>
    <td class="lineNumber">550</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">template <> struct fwd_or_bidi_tag_impl<true> {</td>
    <td class="lineNumber">551</td>
    <td class="codeline">template <> struct fwd_or_bidi_tag_impl<true> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  using type = std::bidirectional_iterator_tag;</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  using type = std::bidirectional_iterator_tag;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">};</td>
    <td class="lineNumber">553</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline"></td>
    <td class="lineNumber">554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">/// Helper which sets its type member to forward_iterator_tag if the category</td>
    <td class="lineNumber">555</td>
    <td class="codeline">/// Helper which sets its type member to forward_iterator_tag if the category</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">/// of \p IterT does not derive from bidirectional_iterator_tag, and to</td>
    <td class="lineNumber">556</td>
    <td class="codeline">/// of \p IterT does not derive from bidirectional_iterator_tag, and to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">/// bidirectional_iterator_tag otherwise.</td>
    <td class="lineNumber">557</td>
    <td class="codeline">/// bidirectional_iterator_tag otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">template <typename IterT> struct fwd_or_bidi_tag {</td>
    <td class="lineNumber">558</td>
    <td class="codeline">template <typename IterT> struct fwd_or_bidi_tag {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<</td>
    <td class="lineNumber">559</td>
    <td class="codeline">  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">      std::bidirectional_iterator_tag,</td>
    <td class="lineNumber">560</td>
    <td class="codeline">      std::bidirectional_iterator_tag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">      typename std::iterator_traits<IterT>::iterator_category>::value>::type;</td>
    <td class="lineNumber">561</td>
    <td class="codeline">      typename std::iterator_traits<IterT>::iterator_category>::value>::type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">};</td>
    <td class="lineNumber">562</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline"></td>
    <td class="lineNumber">563</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">564</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">/// Defines filter_iterator to a suitable specialization of</td>
    <td class="lineNumber">566</td>
    <td class="codeline">/// Defines filter_iterator to a suitable specialization of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">/// filter_iterator_impl, based on the underlying iterator's category.</td>
    <td class="lineNumber">567</td>
    <td class="codeline">/// filter_iterator_impl, based on the underlying iterator's category.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">template <typename WrappedIteratorT, typename PredicateT></td>
    <td class="lineNumber">568</td>
    <td class="codeline">template <typename WrappedIteratorT, typename PredicateT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">using filter_iterator = filter_iterator_impl<</td>
    <td class="lineNumber">569</td>
    <td class="codeline">using filter_iterator = filter_iterator_impl<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">    WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">570</td>
    <td class="codeline">    WrappedIteratorT, PredicateT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">/// Convenience function that takes a range of elements and a predicate,</td>
    <td class="lineNumber">573</td>
    <td class="codeline">/// Convenience function that takes a range of elements and a predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">/// and return a new filter_iterator range.</td>
    <td class="lineNumber">574</td>
    <td class="codeline">/// and return a new filter_iterator range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">///</td>
    <td class="lineNumber">575</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the</td>
    <td class="lineNumber">576</td>
    <td class="codeline">/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">/// lifetime of that temporary is not kept by the returned range object, and the</td>
    <td class="lineNumber">577</td>
    <td class="codeline">/// lifetime of that temporary is not kept by the returned range object, and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">/// temporary is going to be dropped on the floor after the make_iterator_range</td>
    <td class="lineNumber">578</td>
    <td class="codeline">/// temporary is going to be dropped on the floor after the make_iterator_range</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">/// full expression that contains this function call.</td>
    <td class="lineNumber">579</td>
    <td class="codeline">/// full expression that contains this function call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">template <typename RangeT, typename PredicateT></td>
    <td class="lineNumber">580</td>
    <td class="codeline">template <typename RangeT, typename PredicateT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>></td>
    <td class="lineNumber">581</td>
    <td class="codeline">iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine diffFirst">make_filter_range(RangeT &&Range, PredicateT Pred) {</td>
    <td class="lineNumber">582</td>
    <td class="codeline">make_filter_range(RangeT &&Range, PredicateT Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  using FilterIteratorT =</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  using FilterIteratorT =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;</td>
    <td class="lineNumber">584</td>
    <td class="codeline">      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine diffFirst">  return make_range(</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  return make_range(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine diffFirst">      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),</td>
    <td class="lineNumber">586</td>
    <td class="codeline">      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine diffFirst">                      std::end(std::forward<RangeT>(Range)), Pred),</td>
    <td class="lineNumber">587</td>
    <td class="codeline">                      std::end(std::forward<RangeT>(Range)), Pred),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine diffFirst">      FilterIteratorT(std::end(std::forward<RangeT>(Range)),</td>
    <td class="lineNumber">588</td>
    <td class="codeline">      FilterIteratorT(std::end(std::forward<RangeT>(Range)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine diffFirst">                      std::end(std::forward<RangeT>(Range)), Pred));</td>
    <td class="lineNumber">589</td>
    <td class="codeline">                      std::end(std::forward<RangeT>(Range)), Pred));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">}</td>
    <td class="lineNumber">590</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline"></td>
    <td class="lineNumber">591</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">/// A pseudo-iterator adaptor that is designed to implement "early increment"</td>
    <td class="lineNumber">592</td>
    <td class="codeline">/// A pseudo-iterator adaptor that is designed to implement "early increment"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">/// style loops.</td>
    <td class="lineNumber">593</td>
    <td class="codeline">/// style loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">///</td>
    <td class="lineNumber">594</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">/// This is *not a normal iterator* and should almost never be used directly. It</td>
    <td class="lineNumber">595</td>
    <td class="codeline">/// This is *not a normal iterator* and should almost never be used directly. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">/// is intended primarily to be used with range based for loops and some range</td>
    <td class="lineNumber">596</td>
    <td class="codeline">/// is intended primarily to be used with range based for loops and some range</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">/// algorithms.</td>
    <td class="lineNumber">597</td>
    <td class="codeline">/// algorithms.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">///</td>
    <td class="lineNumber">598</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but</td>
    <td class="lineNumber">599</td>
    <td class="codeline">/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">/// somewhere between them. The constraints of these iterators are:</td>
    <td class="lineNumber">600</td>
    <td class="codeline">/// somewhere between them. The constraints of these iterators are:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">///</td>
    <td class="lineNumber">601</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">/// - On construction or after being incremented, it is comparable and</td>
    <td class="lineNumber">602</td>
    <td class="codeline">/// - On construction or after being incremented, it is comparable and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">///   dereferencable. It is *not* incrementable.</td>
    <td class="lineNumber">603</td>
    <td class="codeline">///   dereferencable. It is *not* incrementable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">/// - After being dereferenced, it is neither comparable nor dereferencable, it</td>
    <td class="lineNumber">604</td>
    <td class="codeline">/// - After being dereferenced, it is neither comparable nor dereferencable, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">///   is only incrementable.</td>
    <td class="lineNumber">605</td>
    <td class="codeline">///   is only incrementable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">///</td>
    <td class="lineNumber">606</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">/// This means you can only dereference the iterator once, and you can only</td>
    <td class="lineNumber">607</td>
    <td class="codeline">/// This means you can only dereference the iterator once, and you can only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">/// increment it once between dereferences.</td>
    <td class="lineNumber">608</td>
    <td class="codeline">/// increment it once between dereferences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">template <typename WrappedIteratorT></td>
    <td class="lineNumber">609</td>
    <td class="codeline">template <typename WrappedIteratorT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">class early_inc_iterator_impl</td>
    <td class="lineNumber">610</td>
    <td class="codeline">class early_inc_iterator_impl</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">                                   WrappedIteratorT, std::input_iterator_tag> {</td>
    <td class="lineNumber">612</td>
    <td class="codeline">                                   WrappedIteratorT, std::input_iterator_tag> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;</td>
    <td class="lineNumber">613</td>
    <td class="codeline">  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline"></td>
    <td class="lineNumber">616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">617</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">618</td>
    <td class="codeline">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  bool IsEarlyIncremented = false;</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  bool IsEarlyIncremented = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">620</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">622</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
    <td class="lineNumber">624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  using BaseT::operator*;</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  using BaseT::operator*;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  decltype(*std::declval<WrappedIteratorT>()) operator*() {</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  decltype(*std::declval<WrappedIteratorT>()) operator*() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">627</td>
    <td class="codeline">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">    assert(!IsEarlyIncremented && "Cannot dereference twice!");</td>
    <td class="lineNumber">628</td>
    <td class="codeline">    assert(!IsEarlyIncremented && "Cannot dereference twice!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">    IsEarlyIncremented = true;</td>
    <td class="lineNumber">629</td>
    <td class="codeline">    IsEarlyIncremented = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">630</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    return *(this->I)++;</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    return *(this->I)++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline"></td>
    <td class="lineNumber">633</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  using BaseT::operator++;</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  using BaseT::operator++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  early_inc_iterator_impl &operator++() {</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  early_inc_iterator_impl &operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">636</td>
    <td class="codeline">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">    assert(IsEarlyIncremented && "Cannot increment before dereferencing!");</td>
    <td class="lineNumber">637</td>
    <td class="codeline">    assert(IsEarlyIncremented && "Cannot increment before dereferencing!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">    IsEarlyIncremented = false;</td>
    <td class="lineNumber">638</td>
    <td class="codeline">    IsEarlyIncremented = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">639</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  friend bool operator==(const early_inc_iterator_impl &LHS,</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  friend bool operator==(const early_inc_iterator_impl &LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">                         const early_inc_iterator_impl &RHS) {</td>
    <td class="lineNumber">644</td>
    <td class="codeline">                         const early_inc_iterator_impl &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">645</td>
    <td class="codeline">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">    assert(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!");</td>
    <td class="lineNumber">646</td>
    <td class="codeline">    assert(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">647</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">    return (const BaseT &)LHS == (const BaseT &)RHS;</td>
    <td class="lineNumber">648</td>
    <td class="codeline">    return (const BaseT &)LHS == (const BaseT &)RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">};</td>
    <td class="lineNumber">650</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">/// Make a range that does early increment to allow mutation of the underlying</td>
    <td class="lineNumber">652</td>
    <td class="codeline">/// Make a range that does early increment to allow mutation of the underlying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">/// range without disrupting iteration.</td>
    <td class="lineNumber">653</td>
    <td class="codeline">/// range without disrupting iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">///</td>
    <td class="lineNumber">654</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">/// The underlying iterator will be incremented immediately after it is</td>
    <td class="lineNumber">655</td>
    <td class="codeline">/// The underlying iterator will be incremented immediately after it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">/// dereferenced, allowing deletion of the current node or insertion of nodes to</td>
    <td class="lineNumber">656</td>
    <td class="codeline">/// dereferenced, allowing deletion of the current node or insertion of nodes to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">/// not disrupt iteration provided they do not invalidate the *next* iterator --</td>
    <td class="lineNumber">657</td>
    <td class="codeline">/// not disrupt iteration provided they do not invalidate the *next* iterator --</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">/// the current iterator can be invalidated.</td>
    <td class="lineNumber">658</td>
    <td class="codeline">/// the current iterator can be invalidated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">///</td>
    <td class="lineNumber">659</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">/// This requires a very exact pattern of use that is only really suitable to</td>
    <td class="lineNumber">660</td>
    <td class="codeline">/// This requires a very exact pattern of use that is only really suitable to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">/// range based for loops and other range algorithms that explicitly guarantee</td>
    <td class="lineNumber">661</td>
    <td class="codeline">/// range based for loops and other range algorithms that explicitly guarantee</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">/// to dereference exactly once each element, and to increment exactly once each</td>
    <td class="lineNumber">662</td>
    <td class="codeline">/// to dereference exactly once each element, and to increment exactly once each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">/// element.</td>
    <td class="lineNumber">663</td>
    <td class="codeline">/// element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">template <typename RangeT></td>
    <td class="lineNumber">664</td>
    <td class="codeline">template <typename RangeT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>></td>
    <td class="lineNumber">665</td>
    <td class="codeline">iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">make_early_inc_range(RangeT &&Range) {</td>
    <td class="lineNumber">666</td>
    <td class="codeline">make_early_inc_range(RangeT &&Range) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  using EarlyIncIteratorT =</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  using EarlyIncIteratorT =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;</td>
    <td class="lineNumber">668</td>
    <td class="codeline">      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));</td>
    <td class="lineNumber">670</td>
    <td class="codeline">                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">}</td>
    <td class="lineNumber">671</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">// Forward declarations required by zip_shortest/zip_equal/zip_first/zip_longest</td>
    <td class="lineNumber">673</td>
    <td class="codeline">// Forward declarations required by zip_shortest/zip_equal/zip_first/zip_longest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">674</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">bool all_of(R &&range, UnaryPredicate P);</td>
    <td class="lineNumber">675</td>
    <td class="codeline">bool all_of(R &&range, UnaryPredicate P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">677</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">bool any_of(R &&range, UnaryPredicate P);</td>
    <td class="lineNumber">678</td>
    <td class="codeline">bool any_of(R &&range, UnaryPredicate P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline"></td>
    <td class="lineNumber">679</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">template <typename T> bool all_equal(std::initializer_list<T> Values);</td>
    <td class="lineNumber">680</td>
    <td class="codeline">template <typename T> bool all_equal(std::initializer_list<T> Values);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline"></td>
    <td class="lineNumber">681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">template <typename R> constexpr size_t range_size(R &&Range);</td>
    <td class="lineNumber">682</td>
    <td class="codeline">template <typename R> constexpr size_t range_size(R &&Range);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">684</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">using std::declval;</td>
    <td class="lineNumber">686</td>
    <td class="codeline">using std::declval;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline"></td>
    <td class="lineNumber">687</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">// We have to alias this since inlining the actual type at the usage site</td>
    <td class="lineNumber">688</td>
    <td class="codeline">// We have to alias this since inlining the actual type at the usage site</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.</td>
    <td class="lineNumber">689</td>
    <td class="codeline">// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">template<typename... Iters> struct ZipTupleType {</td>
    <td class="lineNumber">690</td>
    <td class="codeline">template<typename... Iters> struct ZipTupleType {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  using type = std::tuple<decltype(*declval<Iters>())...>;</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  using type = std::tuple<decltype(*declval<Iters>())...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">};</td>
    <td class="lineNumber">692</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline"></td>
    <td class="lineNumber">693</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
    <td class="lineNumber">694</td>
    <td class="codeline">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">using zip_traits = iterator_facade_base<</td>
    <td class="lineNumber">695</td>
    <td class="codeline">using zip_traits = iterator_facade_base<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">    ZipType,</td>
    <td class="lineNumber">696</td>
    <td class="codeline">    ZipType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    std::common_type_t<</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    std::common_type_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">        std::bidirectional_iterator_tag,</td>
    <td class="lineNumber">698</td>
    <td class="codeline">        std::bidirectional_iterator_tag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">        typename std::iterator_traits<Iters>::iterator_category...>,</td>
    <td class="lineNumber">699</td>
    <td class="codeline">        typename std::iterator_traits<Iters>::iterator_category...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">    // ^ TODO: Implement random access methods.</td>
    <td class="lineNumber">700</td>
    <td class="codeline">    // ^ TODO: Implement random access methods.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    ReferenceTupleType,</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    ReferenceTupleType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">    typename std::iterator_traits<</td>
    <td class="lineNumber">702</td>
    <td class="codeline">    typename std::iterator_traits<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">        std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
    <td class="lineNumber">703</td>
    <td class="codeline">        std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all</td>
    <td class="lineNumber">704</td>
    <td class="codeline">    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    // inner iterators have the same difference_type. It would fail if, for</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    // inner iterators have the same difference_type. It would fail if, for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    // instance, the second field's difference_type were non-numeric while the</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    // instance, the second field's difference_type were non-numeric while the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">    // first is.</td>
    <td class="lineNumber">707</td>
    <td class="codeline">    // first is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">    ReferenceTupleType *, ReferenceTupleType>;</td>
    <td class="lineNumber">708</td>
    <td class="codeline">    ReferenceTupleType *, ReferenceTupleType>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
    <td class="lineNumber">709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
    <td class="lineNumber">710</td>
    <td class="codeline">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">struct zip_common : public zip_traits<ZipType, ReferenceTupleType, Iters...> {</td>
    <td class="lineNumber">711</td>
    <td class="codeline">struct zip_common : public zip_traits<ZipType, ReferenceTupleType, Iters...> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  using Base = zip_traits<ZipType, ReferenceTupleType, Iters...>;</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  using Base = zip_traits<ZipType, ReferenceTupleType, Iters...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  using IndexSequence = std::index_sequence_for<Iters...>;</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  using IndexSequence = std::index_sequence_for<Iters...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  using value_type = typename Base::value_type;</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  using value_type = typename Base::value_type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline"></td>
    <td class="lineNumber">715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  std::tuple<Iters...> iterators;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  std::tuple<Iters...> iterators;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline"></td>
    <td class="lineNumber">717</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">718</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">    return value_type(*std::get<Ns>(iterators)...);</td>
    <td class="lineNumber">720</td>
    <td class="codeline">    return value_type(*std::get<Ns>(iterators)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  template <size_t... Ns> void tup_inc(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  template <size_t... Ns> void tup_inc(std::index_sequence<Ns...>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">    (++std::get<Ns>(iterators), ...);</td>
    <td class="lineNumber">724</td>
    <td class="codeline">    (++std::get<Ns>(iterators), ...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">  template <size_t... Ns> void tup_dec(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">727</td>
    <td class="codeline">  template <size_t... Ns> void tup_dec(std::index_sequence<Ns...>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">    (--std::get<Ns>(iterators), ...);</td>
    <td class="lineNumber">728</td>
    <td class="codeline">    (--std::get<Ns>(iterators), ...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
    <td class="lineNumber">730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">731</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  bool test_all_equals(const zip_common &other,</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  bool test_all_equals(const zip_common &other,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">                       std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">733</td>
    <td class="codeline">                       std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) &&</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">            ...);</td>
    <td class="lineNumber">735</td>
    <td class="codeline">            ...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">738</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline"></td>
    <td class="lineNumber">740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  value_type operator*() const { return deref(IndexSequence{}); }</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  value_type operator*() const { return deref(IndexSequence{}); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline"></td>
    <td class="lineNumber">742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">  ZipType &operator++() {</td>
    <td class="lineNumber">743</td>
    <td class="codeline">  ZipType &operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">    tup_inc(IndexSequence{});</td>
    <td class="lineNumber">744</td>
    <td class="codeline">    tup_inc(IndexSequence{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">    return static_cast<ZipType &>(*this);</td>
    <td class="lineNumber">745</td>
    <td class="codeline">    return static_cast<ZipType &>(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  ZipType &operator--() {</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  ZipType &operator--() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">    static_assert(Base::IsBidirectional,</td>
    <td class="lineNumber">749</td>
    <td class="codeline">    static_assert(Base::IsBidirectional,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">                  "All inner iterators must be at least bidirectional.");</td>
    <td class="lineNumber">750</td>
    <td class="codeline">                  "All inner iterators must be at least bidirectional.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    tup_dec(IndexSequence{});</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    tup_dec(IndexSequence{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    return static_cast<ZipType &>(*this);</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    return static_cast<ZipType &>(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">  /// Return true if all the iterator are matching `other`'s iterators.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">  /// Return true if all the iterator are matching `other`'s iterators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  bool all_equals(zip_common &other) {</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  bool all_equals(zip_common &other) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">    return test_all_equals(other, IndexSequence{});</td>
    <td class="lineNumber">757</td>
    <td class="codeline">    return test_all_equals(other, IndexSequence{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">};</td>
    <td class="lineNumber">759</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">template <typename... Iters></td>
    <td class="lineNumber">761</td>
    <td class="codeline">template <typename... Iters></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">struct zip_first : zip_common<zip_first<Iters...>,</td>
    <td class="lineNumber">762</td>
    <td class="codeline">struct zip_first : zip_common<zip_first<Iters...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">                              typename ZipTupleType<Iters...>::type, Iters...> {</td>
    <td class="lineNumber">763</td>
    <td class="codeline">                              typename ZipTupleType<Iters...>::type, Iters...> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">  using zip_common<zip_first, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">764</td>
    <td class="codeline">  using zip_common<zip_first, typename ZipTupleType<Iters...>::type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">                   Iters...>::zip_common;</td>
    <td class="lineNumber">765</td>
    <td class="codeline">                   Iters...>::zip_common;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  bool operator==(const zip_first &other) const {</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  bool operator==(const zip_first &other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    return std::get<0>(this->iterators) == std::get<0>(other.iterators);</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    return std::get<0>(this->iterators) == std::get<0>(other.iterators);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">};</td>
    <td class="lineNumber">770</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">template <typename... Iters></td>
    <td class="lineNumber">772</td>
    <td class="codeline">template <typename... Iters></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">struct zip_shortest</td>
    <td class="lineNumber">773</td>
    <td class="codeline">struct zip_shortest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">    : zip_common<zip_shortest<Iters...>, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">774</td>
    <td class="codeline">    : zip_common<zip_shortest<Iters...>, typename ZipTupleType<Iters...>::type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">                 Iters...> {</td>
    <td class="lineNumber">775</td>
    <td class="codeline">                 Iters...> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  using zip_common<zip_shortest, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  using zip_common<zip_shortest, typename ZipTupleType<Iters...>::type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">                   Iters...>::zip_common;</td>
    <td class="lineNumber">777</td>
    <td class="codeline">                   Iters...>::zip_common;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  bool operator==(const zip_shortest &other) const {</td>
    <td class="lineNumber">779</td>
    <td class="codeline">  bool operator==(const zip_shortest &other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">    return any_iterator_equals(other, std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">780</td>
    <td class="codeline">    return any_iterator_equals(other, std::index_sequence_for<Iters...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">781</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline"></td>
    <td class="lineNumber">782</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">783</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">784</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">  bool any_iterator_equals(const zip_shortest &other,</td>
    <td class="lineNumber">785</td>
    <td class="codeline">  bool any_iterator_equals(const zip_shortest &other,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">                           std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">786</td>
    <td class="codeline">                           std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) ||</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">            ...);</td>
    <td class="lineNumber">788</td>
    <td class="codeline">            ...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">};</td>
    <td class="lineNumber">790</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">/// Helper to obtain the iterator types for the tuple storage within `zippy`.</td>
    <td class="lineNumber">792</td>
    <td class="codeline">/// Helper to obtain the iterator types for the tuple storage within `zippy`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">template <template <typename...> class ItType, typename TupleStorageType,</td>
    <td class="lineNumber">793</td>
    <td class="codeline">template <template <typename...> class ItType, typename TupleStorageType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">          typename IndexSequence></td>
    <td class="lineNumber">794</td>
    <td class="codeline">          typename IndexSequence></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">struct ZippyIteratorTuple;</td>
    <td class="lineNumber">795</td>
    <td class="codeline">struct ZippyIteratorTuple;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">/// Partial specialization for non-const tuple storage.</td>
    <td class="lineNumber">797</td>
    <td class="codeline">/// Partial specialization for non-const tuple storage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">template <template <typename...> class ItType, typename... Args,</td>
    <td class="lineNumber">798</td>
    <td class="codeline">template <template <typename...> class ItType, typename... Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">          std::size_t... Ns></td>
    <td class="lineNumber">799</td>
    <td class="codeline">          std::size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">struct ZippyIteratorTuple<ItType, std::tuple<Args...>,</td>
    <td class="lineNumber">800</td>
    <td class="codeline">struct ZippyIteratorTuple<ItType, std::tuple<Args...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">                          std::index_sequence<Ns...>> {</td>
    <td class="lineNumber">801</td>
    <td class="codeline">                          std::index_sequence<Ns...>> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">  using type = ItType<decltype(adl_begin(</td>
    <td class="lineNumber">802</td>
    <td class="codeline">  using type = ItType<decltype(adl_begin(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">      std::get<Ns>(declval<std::tuple<Args...> &>())))...>;</td>
    <td class="lineNumber">803</td>
    <td class="codeline">      std::get<Ns>(declval<std::tuple<Args...> &>())))...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">};</td>
    <td class="lineNumber">804</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">/// Partial specialization for const tuple storage.</td>
    <td class="lineNumber">806</td>
    <td class="codeline">/// Partial specialization for const tuple storage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">template <template <typename...> class ItType, typename... Args,</td>
    <td class="lineNumber">807</td>
    <td class="codeline">template <template <typename...> class ItType, typename... Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">          std::size_t... Ns></td>
    <td class="lineNumber">808</td>
    <td class="codeline">          std::size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">struct ZippyIteratorTuple<ItType, const std::tuple<Args...>,</td>
    <td class="lineNumber">809</td>
    <td class="codeline">struct ZippyIteratorTuple<ItType, const std::tuple<Args...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">                          std::index_sequence<Ns...>> {</td>
    <td class="lineNumber">810</td>
    <td class="codeline">                          std::index_sequence<Ns...>> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  using type = ItType<decltype(adl_begin(</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  using type = ItType<decltype(adl_begin(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">      std::get<Ns>(declval<const std::tuple<Args...> &>())))...>;</td>
    <td class="lineNumber">812</td>
    <td class="codeline">      std::get<Ns>(declval<const std::tuple<Args...> &>())))...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">};</td>
    <td class="lineNumber">813</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">template <template <typename...> class ItType, typename... Args> class zippy {</td>
    <td class="lineNumber">815</td>
    <td class="codeline">template <template <typename...> class ItType, typename... Args> class zippy {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">816</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  std::tuple<Args...> storage;</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  std::tuple<Args...> storage;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  using IndexSequence = std::index_sequence_for<Args...>;</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  using IndexSequence = std::index_sequence_for<Args...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline"></td>
    <td class="lineNumber">819</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">820</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  using iterator = typename ZippyIteratorTuple<ItType, decltype(storage),</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  using iterator = typename ZippyIteratorTuple<ItType, decltype(storage),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">                                               IndexSequence>::type;</td>
    <td class="lineNumber">822</td>
    <td class="codeline">                                               IndexSequence>::type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  using const_iterator =</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  using const_iterator =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">      typename ZippyIteratorTuple<ItType, const decltype(storage),</td>
    <td class="lineNumber">824</td>
    <td class="codeline">      typename ZippyIteratorTuple<ItType, const decltype(storage),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">                                  IndexSequence>::type;</td>
    <td class="lineNumber">825</td>
    <td class="codeline">                                  IndexSequence>::type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  using iterator_category = typename iterator::iterator_category;</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  using iterator_category = typename iterator::iterator_category;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  using value_type = typename iterator::value_type;</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  using value_type = typename iterator::value_type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  using difference_type = typename iterator::difference_type;</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  using difference_type = typename iterator::difference_type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  using pointer = typename iterator::pointer;</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  using pointer = typename iterator::pointer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  using reference = typename iterator::reference;</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  using reference = typename iterator::reference;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  using const_reference = typename const_iterator::reference;</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  using const_reference = typename const_iterator::reference;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  zippy(Args &&...args) : storage(std::forward<Args>(args)...) {}</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  zippy(Args &&...args) : storage(std::forward<Args>(args)...) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline"></td>
    <td class="lineNumber">834</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  const_iterator begin() const { return begin_impl(IndexSequence{}); }</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  const_iterator begin() const { return begin_impl(IndexSequence{}); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">  iterator begin() { return begin_impl(IndexSequence{}); }</td>
    <td class="lineNumber">836</td>
    <td class="codeline">  iterator begin() { return begin_impl(IndexSequence{}); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  const_iterator end() const { return end_impl(IndexSequence{}); }</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  const_iterator end() const { return end_impl(IndexSequence{}); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  iterator end() { return end_impl(IndexSequence{}); }</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  iterator end() { return end_impl(IndexSequence{}); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline"></td>
    <td class="lineNumber">839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">840</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">841</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  const_iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  const_iterator begin_impl(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">    return const_iterator(adl_begin(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">843</td>
    <td class="codeline">    return const_iterator(adl_begin(std::get<Ns>(storage))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">    return iterator(adl_begin(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">846</td>
    <td class="codeline">    return iterator(adl_begin(std::get<Ns>(storage))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline"></td>
    <td class="lineNumber">848</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">849</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">  const_iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">850</td>
    <td class="codeline">  const_iterator end_impl(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">    return const_iterator(adl_end(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">851</td>
    <td class="codeline">    return const_iterator(adl_end(std::get<Ns>(storage))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">    return iterator(adl_end(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">854</td>
    <td class="codeline">    return iterator(adl_end(std::get<Ns>(storage))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">};</td>
    <td class="lineNumber">856</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline"></td>
    <td class="lineNumber">857</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">} // end namespace detail</td>
    <td class="lineNumber">858</td>
    <td class="codeline">} // end namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">/// zip iterator for two or more iteratable types. Iteration continues until the</td>
    <td class="lineNumber">860</td>
    <td class="codeline">/// zip iterator for two or more iteratable types. Iteration continues until the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">/// end of the *shortest* iteratee is reached.</td>
    <td class="lineNumber">861</td>
    <td class="codeline">/// end of the *shortest* iteratee is reached.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">862</td>
    <td class="codeline">template <typename T, typename U, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,</td>
    <td class="lineNumber">863</td>
    <td class="codeline">detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">                                                       Args &&...args) {</td>
    <td class="lineNumber">864</td>
    <td class="codeline">                                                       Args &&...args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  return detail::zippy<detail::zip_shortest, T, U, Args...>(</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  return detail::zippy<detail::zip_shortest, T, U, Args...>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">866</td>
    <td class="codeline">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">}</td>
    <td class="lineNumber">867</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline"></td>
    <td class="lineNumber">868</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">/// zip iterator that assumes that all iteratees have the same length.</td>
    <td class="lineNumber">869</td>
    <td class="codeline">/// zip iterator that assumes that all iteratees have the same length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">/// In builds with assertions on, this assumption is checked before the</td>
    <td class="lineNumber">870</td>
    <td class="codeline">/// In builds with assertions on, this assumption is checked before the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">/// iteration starts.</td>
    <td class="lineNumber">871</td>
    <td class="codeline">/// iteration starts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">872</td>
    <td class="codeline">template <typename T, typename U, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">detail::zippy<detail::zip_first, T, U, Args...> zip_equal(T &&t, U &&u,</td>
    <td class="lineNumber">873</td>
    <td class="codeline">detail::zippy<detail::zip_first, T, U, Args...> zip_equal(T &&t, U &&u,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">                                                          Args &&...args) {</td>
    <td class="lineNumber">874</td>
    <td class="codeline">                                                          Args &&...args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  assert(all_equal({range_size(t), range_size(u), range_size(args)...}) &&</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  assert(all_equal({range_size(t), range_size(u), range_size(args)...}) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">         "Iteratees do not have equal length");</td>
    <td class="lineNumber">876</td>
    <td class="codeline">         "Iteratees do not have equal length");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">878</td>
    <td class="codeline">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">}</td>
    <td class="lineNumber">879</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline"></td>
    <td class="lineNumber">880</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">/// zip iterator that, for the sake of efficiency, assumes the first iteratee to</td>
    <td class="lineNumber">881</td>
    <td class="codeline">/// zip iterator that, for the sake of efficiency, assumes the first iteratee to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">/// be the shortest. Iteration continues until the end of the first iteratee is</td>
    <td class="lineNumber">882</td>
    <td class="codeline">/// be the shortest. Iteration continues until the end of the first iteratee is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">/// reached. In builds with assertions on, we check that the assumption about</td>
    <td class="lineNumber">883</td>
    <td class="codeline">/// reached. In builds with assertions on, we check that the assumption about</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">/// the first iteratee being the shortest holds.</td>
    <td class="lineNumber">884</td>
    <td class="codeline">/// the first iteratee being the shortest holds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">885</td>
    <td class="codeline">template <typename T, typename U, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,</td>
    <td class="lineNumber">886</td>
    <td class="codeline">detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">                                                          Args &&...args) {</td>
    <td class="lineNumber">887</td>
    <td class="codeline">                                                          Args &&...args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  assert(range_size(t) <= std::min({range_size(u), range_size(args)...}) &&</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  assert(range_size(t) <= std::min({range_size(u), range_size(args)...}) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">         "First iteratee is not the shortest");</td>
    <td class="lineNumber">889</td>
    <td class="codeline">         "First iteratee is not the shortest");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline"></td>
    <td class="lineNumber">890</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">892</td>
    <td class="codeline">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">}</td>
    <td class="lineNumber">893</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">895</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">template <typename Iter></td>
    <td class="lineNumber">896</td>
    <td class="codeline">template <typename Iter></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">Iter next_or_end(const Iter &I, const Iter &End) {</td>
    <td class="lineNumber">897</td>
    <td class="codeline">Iter next_or_end(const Iter &I, const Iter &End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">  if (I == End)</td>
    <td class="lineNumber">898</td>
    <td class="codeline">  if (I == End)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">    return End;</td>
    <td class="lineNumber">899</td>
    <td class="codeline">    return End;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">  return std::next(I);</td>
    <td class="lineNumber">900</td>
    <td class="codeline">  return std::next(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">}</td>
    <td class="lineNumber">901</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">template <typename Iter></td>
    <td class="lineNumber">903</td>
    <td class="codeline">template <typename Iter></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">auto deref_or_none(const Iter &I, const Iter &End) -> std::optional<</td>
    <td class="lineNumber">904</td>
    <td class="codeline">auto deref_or_none(const Iter &I, const Iter &End) -> std::optional<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {</td>
    <td class="lineNumber">905</td>
    <td class="codeline">    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">  if (I == End)</td>
    <td class="lineNumber">906</td>
    <td class="codeline">  if (I == End)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">907</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  return *I;</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  return *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">}</td>
    <td class="lineNumber">909</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">template <typename Iter> struct ZipLongestItemType {</td>
    <td class="lineNumber">911</td>
    <td class="codeline">template <typename Iter> struct ZipLongestItemType {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  using type = std::optional<std::remove_const_t<</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  using type = std::optional<std::remove_const_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">      std::remove_reference_t<decltype(*std::declval<Iter>())>>>;</td>
    <td class="lineNumber">913</td>
    <td class="codeline">      std::remove_reference_t<decltype(*std::declval<Iter>())>>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">};</td>
    <td class="lineNumber">914</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">template <typename... Iters> struct ZipLongestTupleType {</td>
    <td class="lineNumber">916</td>
    <td class="codeline">template <typename... Iters> struct ZipLongestTupleType {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">};</td>
    <td class="lineNumber">918</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline"></td>
    <td class="lineNumber">919</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">template <typename... Iters></td>
    <td class="lineNumber">920</td>
    <td class="codeline">template <typename... Iters></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">class zip_longest_iterator</td>
    <td class="lineNumber">921</td>
    <td class="codeline">class zip_longest_iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">    : public iterator_facade_base<</td>
    <td class="lineNumber">922</td>
    <td class="codeline">    : public iterator_facade_base<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">          zip_longest_iterator<Iters...>,</td>
    <td class="lineNumber">923</td>
    <td class="codeline">          zip_longest_iterator<Iters...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">          std::common_type_t<</td>
    <td class="lineNumber">924</td>
    <td class="codeline">          std::common_type_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">              std::forward_iterator_tag,</td>
    <td class="lineNumber">925</td>
    <td class="codeline">              std::forward_iterator_tag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">              typename std::iterator_traits<Iters>::iterator_category...>,</td>
    <td class="lineNumber">926</td>
    <td class="codeline">              typename std::iterator_traits<Iters>::iterator_category...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">          typename ZipLongestTupleType<Iters...>::type,</td>
    <td class="lineNumber">927</td>
    <td class="codeline">          typename ZipLongestTupleType<Iters...>::type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">          typename std::iterator_traits<</td>
    <td class="lineNumber">928</td>
    <td class="codeline">          typename std::iterator_traits<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">              std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
    <td class="lineNumber">929</td>
    <td class="codeline">              std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">          typename ZipLongestTupleType<Iters...>::type *,</td>
    <td class="lineNumber">930</td>
    <td class="codeline">          typename ZipLongestTupleType<Iters...>::type *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">          typename ZipLongestTupleType<Iters...>::type> {</td>
    <td class="lineNumber">931</td>
    <td class="codeline">          typename ZipLongestTupleType<Iters...>::type> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">932</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">  using value_type = typename ZipLongestTupleType<Iters...>::type;</td>
    <td class="lineNumber">933</td>
    <td class="codeline">  using value_type = typename ZipLongestTupleType<Iters...>::type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">935</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">  std::tuple<Iters...> iterators;</td>
    <td class="lineNumber">936</td>
    <td class="codeline">  std::tuple<Iters...> iterators;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  std::tuple<Iters...> end_iterators;</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  std::tuple<Iters...> end_iterators;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline"></td>
    <td class="lineNumber">938</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">939</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">  bool test(const zip_longest_iterator<Iters...> &other,</td>
    <td class="lineNumber">940</td>
    <td class="codeline">  bool test(const zip_longest_iterator<Iters...> &other,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">            std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">941</td>
    <td class="codeline">            std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">    return ((std::get<Ns>(this->iterators) != std::get<Ns>(other.iterators)) ||</td>
    <td class="lineNumber">942</td>
    <td class="codeline">    return ((std::get<Ns>(this->iterators) != std::get<Ns>(other.iterators)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">            ...);</td>
    <td class="lineNumber">943</td>
    <td class="codeline">            ...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline"></td>
    <td class="lineNumber">945</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">    return value_type(</td>
    <td class="lineNumber">947</td>
    <td class="codeline">    return value_type(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
    <td class="lineNumber">948</td>
    <td class="codeline">        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">949</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline"></td>
    <td class="lineNumber">950</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">951</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">952</td>
    <td class="codeline">  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">    return std::tuple<Iters...>(</td>
    <td class="lineNumber">953</td>
    <td class="codeline">    return std::tuple<Iters...>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
    <td class="lineNumber">954</td>
    <td class="codeline">        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">955</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">957</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">      : iterators(std::forward<Iters>(ts.first)...),</td>
    <td class="lineNumber">959</td>
    <td class="codeline">      : iterators(std::forward<Iters>(ts.first)...),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">        end_iterators(std::forward<Iters>(ts.second)...) {}</td>
    <td class="lineNumber">960</td>
    <td class="codeline">        end_iterators(std::forward<Iters>(ts.second)...) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline"></td>
    <td class="lineNumber">961</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  value_type operator*() const {</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  value_type operator*() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">    return deref(std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">963</td>
    <td class="codeline">    return deref(std::index_sequence_for<Iters...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  zip_longest_iterator<Iters...> &operator++() {</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  zip_longest_iterator<Iters...> &operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">    iterators = tup_inc(std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">967</td>
    <td class="codeline">    iterators = tup_inc(std::index_sequence_for<Iters...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">968</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  bool operator==(const zip_longest_iterator<Iters...> &other) const {</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  bool operator==(const zip_longest_iterator<Iters...> &other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">    return !test(other, std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">972</td>
    <td class="codeline">    return !test(other, std::index_sequence_for<Iters...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">};</td>
    <td class="lineNumber">974</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline"></td>
    <td class="lineNumber">975</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">template <typename... Args> class zip_longest_range {</td>
    <td class="lineNumber">976</td>
    <td class="codeline">template <typename... Args> class zip_longest_range {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">977</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  using iterator =</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  using iterator =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;</td>
    <td class="lineNumber">979</td>
    <td class="codeline">      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">  using iterator_category = typename iterator::iterator_category;</td>
    <td class="lineNumber">980</td>
    <td class="codeline">  using iterator_category = typename iterator::iterator_category;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  using value_type = typename iterator::value_type;</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  using value_type = typename iterator::value_type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  using difference_type = typename iterator::difference_type;</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  using difference_type = typename iterator::difference_type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  using pointer = typename iterator::pointer;</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  using pointer = typename iterator::pointer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  using reference = typename iterator::reference;</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  using reference = typename iterator::reference;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">986</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">  std::tuple<Args...> ts;</td>
    <td class="lineNumber">987</td>
    <td class="codeline">  std::tuple<Args...> ts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">989</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">                                   adl_end(std::get<Ns>(ts)))...);</td>
    <td class="lineNumber">992</td>
    <td class="codeline">                                   adl_end(std::get<Ns>(ts)))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">993</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline"></td>
    <td class="lineNumber">994</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),</td>
    <td class="lineNumber">996</td>
    <td class="codeline">    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">                                   adl_end(std::get<Ns>(ts)))...);</td>
    <td class="lineNumber">997</td>
    <td class="codeline">                                   adl_end(std::get<Ns>(ts)))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline"></td>
    <td class="lineNumber">999</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline"></td>
    <td class="lineNumber">1002</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">  iterator begin() const {</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">  iterator begin() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    return begin_impl(std::index_sequence_for<Args...>{});</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    return begin_impl(std::index_sequence_for<Args...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">/// Iterate over two or more iterators at the same time. Iteration continues</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">/// Iterate over two or more iterators at the same time. Iteration continues</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">/// until all iterators reach the end. The std::optional only contains a value</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">/// until all iterators reach the end. The std::optional only contains a value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">/// if the iterator has not reached the end.</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">/// if the iterator has not reached the end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">1013</td>
    <td class="codeline">template <typename T, typename U, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">                                                     Args &&... args) {</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">                                                     Args &&... args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  return detail::zip_longest_range<T, U, Args...>(</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  return detail::zip_longest_range<T, U, Args...>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline"></td>
    <td class="lineNumber">1019</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">/// Iterator wrapper that concatenates sequences together.</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">/// Iterator wrapper that concatenates sequences together.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">/// This can concatenate different iterators, even with different types, into</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">/// This can concatenate different iterators, even with different types, into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">/// a single iterator provided the value types of all the concatenated</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">/// a single iterator provided the value types of all the concatenated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">/// iterators expose `reference` and `pointer` types that can be converted to</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">/// iterators expose `reference` and `pointer` types that can be converted to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">/// `ValueT &` and `ValueT *` respectively. It doesn't support more</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">/// `ValueT &` and `ValueT *` respectively. It doesn't support more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">/// interesting/customized pointer or reference types.</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">/// interesting/customized pointer or reference types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">/// Currently this only supports forward or higher iterator categories as</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">/// Currently this only supports forward or higher iterator categories as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">/// inputs and always exposes a forward iterator interface.</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">/// inputs and always exposes a forward iterator interface.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">template <typename ValueT, typename... IterTs></td>
    <td class="lineNumber">1030</td>
    <td class="codeline">template <typename ValueT, typename... IterTs></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">class concat_iterator</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">class concat_iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">                                  std::forward_iterator_tag, ValueT> {</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">                                  std::forward_iterator_tag, ValueT> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  using BaseT = typename concat_iterator::iterator_facade_base;</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  using BaseT = typename concat_iterator::iterator_facade_base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline"></td>
    <td class="lineNumber">1035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  /// We store both the current and end iterators for each concatenated</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  /// We store both the current and end iterators for each concatenated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">  /// sequence in a tuple of pairs.</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">  /// sequence in a tuple of pairs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  /// Note that something like iterator_range seems nice at first here, but the</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  /// Note that something like iterator_range seems nice at first here, but the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  /// range properties are of little benefit and end up getting in the way</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  /// range properties are of little benefit and end up getting in the way</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  /// because we need to do mutation on the current iterators.</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  /// because we need to do mutation on the current iterators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  std::tuple<IterTs...> Begins;</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  std::tuple<IterTs...> Begins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  std::tuple<IterTs...> Ends;</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  std::tuple<IterTs...> Ends;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline"></td>
    <td class="lineNumber">1044</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  /// Attempts to increment a specific iterator.</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  /// Attempts to increment a specific iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">  /// Returns true if it was able to increment the iterator. Returns false if</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">  /// Returns true if it was able to increment the iterator. Returns false if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  /// the iterator is already at the end iterator.</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  /// the iterator is already at the end iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  template <size_t Index> bool incrementHelper() {</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  template <size_t Index> bool incrementHelper() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">    auto &Begin = std::get<Index>(Begins);</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">    auto &Begin = std::get<Index>(Begins);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">    auto &End = std::get<Index>(Ends);</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">    auto &End = std::get<Index>(Ends);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">    if (Begin == End)</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">    if (Begin == End)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline"></td>
    <td class="lineNumber">1054</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">    ++Begin;</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">    ++Begin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  /// Increments the first non-end iterator.</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  /// Increments the first non-end iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  /// It is an error to call this with all iterators at the end.</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  /// It is an error to call this with all iterators at the end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">    // Build a sequence of functions to increment each iterator if possible.</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">    // Build a sequence of functions to increment each iterator if possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">    bool (concat_iterator::*IncrementHelperFns[])() = {</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">    bool (concat_iterator::*IncrementHelperFns[])() = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">        &concat_iterator::incrementHelper<Ns>...};</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">        &concat_iterator::incrementHelper<Ns>...};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">    // Loop over them, and stop as soon as we succeed at incrementing one.</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">    // Loop over them, and stop as soon as we succeed at incrementing one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">    for (auto &IncrementHelperFn : IncrementHelperFns)</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">    for (auto &IncrementHelperFn : IncrementHelperFns)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">      if ((this->*IncrementHelperFn)())</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">      if ((this->*IncrementHelperFn)())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">        return;</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">        return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">    llvm_unreachable("Attempted to increment an end concat iterator!");</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">    llvm_unreachable("Attempted to increment an end concat iterator!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">  /// Returns null if the specified iterator is at the end. Otherwise,</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">  /// Returns null if the specified iterator is at the end. Otherwise,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  /// dereferences the iterator and returns the address of the resulting</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  /// dereferences the iterator and returns the address of the resulting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">  /// reference.</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">  /// reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">  template <size_t Index> ValueT *getHelper() const {</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">  template <size_t Index> ValueT *getHelper() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">    auto &Begin = std::get<Index>(Begins);</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">    auto &Begin = std::get<Index>(Begins);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">    auto &End = std::get<Index>(Ends);</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">    auto &End = std::get<Index>(Ends);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">    if (Begin == End)</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">    if (Begin == End)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">    return &*Begin;</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">    return &*Begin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// Finds the first non-end iterator, dereferences, and returns the resulting</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// Finds the first non-end iterator, dereferences, and returns the resulting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// reference.</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  /// It is an error to call this with all iterators at the end.</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  /// It is an error to call this with all iterators at the end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">    // Build a sequence of functions to get from iterator if possible.</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">    // Build a sequence of functions to get from iterator if possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">    ValueT *(concat_iterator::*GetHelperFns[])() const = {</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">    ValueT *(concat_iterator::*GetHelperFns[])() const = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">        &concat_iterator::getHelper<Ns>...};</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">        &concat_iterator::getHelper<Ns>...};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline"></td>
    <td class="lineNumber">1095</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">    // Loop over them, and return the first result we find.</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">    // Loop over them, and return the first result we find.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">    for (auto &GetHelperFn : GetHelperFns)</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">    for (auto &GetHelperFn : GetHelperFns)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">      if (ValueT *P = (this->*GetHelperFn)())</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">      if (ValueT *P = (this->*GetHelperFn)())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">        return *P;</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">        return *P;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline"></td>
    <td class="lineNumber">1100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    llvm_unreachable("Attempted to get a pointer from an end concat iterator!");</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    llvm_unreachable("Attempted to get a pointer from an end concat iterator!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// Constructs an iterator from a sequence of ranges.</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// Constructs an iterator from a sequence of ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  /// We need the full range to know how to switch between each of the</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  /// We need the full range to know how to switch between each of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  /// iterators.</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  /// iterators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">  template <typename... RangeTs></td>
    <td class="lineNumber">1109</td>
    <td class="codeline">  template <typename... RangeTs></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  explicit concat_iterator(RangeTs &&... Ranges)</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  explicit concat_iterator(RangeTs &&... Ranges)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline"></td>
    <td class="lineNumber">1112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  using BaseT::operator++;</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  using BaseT::operator++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline"></td>
    <td class="lineNumber">1114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  concat_iterator &operator++() {</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  concat_iterator &operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">    increment(std::index_sequence_for<IterTs...>());</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">    increment(std::index_sequence_for<IterTs...>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline"></td>
    <td class="lineNumber">1119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  ValueT &operator*() const {</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  ValueT &operator*() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">    return get(std::index_sequence_for<IterTs...>());</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">    return get(std::index_sequence_for<IterTs...>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  bool operator==(const concat_iterator &RHS) const {</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  bool operator==(const concat_iterator &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">    return Begins == RHS.Begins && Ends == RHS.Ends;</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">    return Begins == RHS.Begins && Ends == RHS.Ends;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline"></td>
    <td class="lineNumber">1128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline"></td>
    <td class="lineNumber">1130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">/// Helper to store a sequence of ranges being concatenated and access them.</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">/// Helper to store a sequence of ranges being concatenated and access them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">/// This is designed to facilitate providing actual storage when temporaries</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">/// This is designed to facilitate providing actual storage when temporaries</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">/// are passed into the constructor such that we can use it as part of range</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">/// are passed into the constructor such that we can use it as part of range</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">/// based for loops.</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">/// based for loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">template <typename ValueT, typename... RangeTs> class concat_range {</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">template <typename ValueT, typename... RangeTs> class concat_range {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">  using iterator =</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">  using iterator =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">      concat_iterator<ValueT,</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">      concat_iterator<ValueT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">                      decltype(std::begin(std::declval<RangeTs &>()))...>;</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">                      decltype(std::begin(std::declval<RangeTs &>()))...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
    <td class="lineNumber">1141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">  std::tuple<RangeTs...> Ranges;</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">  std::tuple<RangeTs...> Ranges;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">  iterator begin_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">  iterator begin_impl(std::index_sequence<Ns...>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    return iterator(std::get<Ns>(Ranges)...);</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    return iterator(std::get<Ns>(Ranges)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  template <size_t... Ns></td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  template <size_t... Ns></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">    return iterator(std::get<Ns>(Ranges)...);</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">    return iterator(std::get<Ns>(Ranges)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">                               std::end(std::get<Ns>(Ranges)))...);</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">                               std::end(std::get<Ns>(Ranges)))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">                               std::end(std::get<Ns>(Ranges)))...);</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">                               std::end(std::get<Ns>(Ranges)))...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  concat_range(RangeTs &&... Ranges)</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  concat_range(RangeTs &&... Ranges)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">      : Ranges(std::forward<RangeTs>(Ranges)...) {}</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">      : Ranges(std::forward<RangeTs>(Ranges)...) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline"></td>
    <td class="lineNumber">1165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  iterator begin() {</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  iterator begin() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  iterator begin() const {</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  iterator begin() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  iterator end() {</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  iterator end() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  iterator end() const {</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  iterator end() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline"></td>
    <td class="lineNumber">1179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">} // end namespace detail</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">} // end namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">/// Concatenated range across two or more ranges.</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">/// Concatenated range across two or more ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">/// The desired value type must be explicitly specified.</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">/// The desired value type must be explicitly specified.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">template <typename ValueT, typename... RangeTs></td>
    <td class="lineNumber">1185</td>
    <td class="codeline">template <typename ValueT, typename... RangeTs></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">detail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">detail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  static_assert(sizeof...(RangeTs) > 1,</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  static_assert(sizeof...(RangeTs) > 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">                "Need more than one range to concatenate!");</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">                "Need more than one range to concatenate!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  return detail::concat_range<ValueT, RangeTs...>(</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  return detail::concat_range<ValueT, RangeTs...>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">      std::forward<RangeTs>(Ranges)...);</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">      std::forward<RangeTs>(Ranges)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">/// A utility class used to implement an iterator that contains some base object</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">/// A utility class used to implement an iterator that contains some base object</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">/// and an index. The iterator moves the index but keeps the base constant.</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">/// and an index. The iterator moves the index but keeps the base constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">template <typename DerivedT, typename BaseT, typename T,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">1196</td>
    <td class="codeline">          typename PointerT = T *, typename ReferenceT = T &></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">class indexed_accessor_iterator</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">class indexed_accessor_iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">    : public llvm::iterator_facade_base<DerivedT,</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">    : public llvm::iterator_facade_base<DerivedT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">                                        std::random_access_iterator_tag, T,</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">                                        std::random_access_iterator_tag, T,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">                                        std::ptrdiff_t, PointerT, ReferenceT> {</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">                                        std::ptrdiff_t, PointerT, ReferenceT> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">    assert(base == rhs.base && "incompatible iterators");</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">    assert(base == rhs.base && "incompatible iterators");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">    return index - rhs.index;</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">    return index - rhs.index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">  bool operator==(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">  bool operator==(const indexed_accessor_iterator &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">    return base == rhs.base && index == rhs.index;</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">    return base == rhs.base && index == rhs.index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  bool operator<(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  bool operator<(const indexed_accessor_iterator &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">    assert(base == rhs.base && "incompatible iterators");</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">    assert(base == rhs.base && "incompatible iterators");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">    return index < rhs.index;</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">    return index < rhs.index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline"></td>
    <td class="lineNumber">1213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  DerivedT &operator+=(ptrdiff_t offset) {</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  DerivedT &operator+=(ptrdiff_t offset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">    this->index += offset;</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">    this->index += offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">    return static_cast<DerivedT &>(*this);</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">    return static_cast<DerivedT &>(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  DerivedT &operator-=(ptrdiff_t offset) {</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  DerivedT &operator-=(ptrdiff_t offset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">    this->index -= offset;</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">    this->index -= offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">    return static_cast<DerivedT &>(*this);</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">    return static_cast<DerivedT &>(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline"></td>
    <td class="lineNumber">1222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  /// Returns the current index of the iterator.</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  /// Returns the current index of the iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  ptrdiff_t getIndex() const { return index; }</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  ptrdiff_t getIndex() const { return index; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// Returns the current base of the iterator.</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// Returns the current base of the iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  const BaseT &getBase() const { return base; }</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  const BaseT &getBase() const { return base; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline"></td>
    <td class="lineNumber">1228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  indexed_accessor_iterator(BaseT base, ptrdiff_t index)</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  indexed_accessor_iterator(BaseT base, ptrdiff_t index)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">      : base(base), index(index) {}</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">      : base(base), index(index) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  BaseT base;</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  BaseT base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  ptrdiff_t index;</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  ptrdiff_t index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline"></td>
    <td class="lineNumber">1235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">/// The class represents the base of a range of indexed_accessor_iterators. It</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">/// The class represents the base of a range of indexed_accessor_iterators. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">/// provides support for many different range functionalities, e.g.</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">/// provides support for many different range functionalities, e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">/// drop_front/slice/etc.. Derived range classes must implement the following</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">/// drop_front/slice/etc.. Derived range classes must implement the following</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">/// static methods:</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">/// static methods:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">///     - Dereference an iterator pointing to the base object at the given</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">///     - Dereference an iterator pointing to the base object at the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">///       index.</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">///       index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">///     - Return a new base that is offset from the provide base by 'index'</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">///     - Return a new base that is offset from the provide base by 'index'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">///       elements.</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">///       elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">template <typename DerivedT, typename BaseT, typename T,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">1248</td>
    <td class="codeline">          typename PointerT = T *, typename ReferenceT = T &></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">class indexed_accessor_range_base {</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">class indexed_accessor_range_base {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  using RangeBaseT = indexed_accessor_range_base;</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  using RangeBaseT = indexed_accessor_range_base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline"></td>
    <td class="lineNumber">1252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  /// An iterator element of this range.</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  /// An iterator element of this range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">                                                    PointerT, ReferenceT> {</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">                                                    PointerT, ReferenceT> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">    // Index into this iterator, invoking a static method on the derived type.</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">    // Index into this iterator, invoking a static method on the derived type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">    ReferenceT operator*() const {</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">    ReferenceT operator*() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline"></td>
    <td class="lineNumber">1261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">    iterator(BaseT owner, ptrdiff_t curIndex)</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">    iterator(BaseT owner, ptrdiff_t curIndex)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">        : iterator::indexed_accessor_iterator(owner, curIndex) {}</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">        : iterator::indexed_accessor_iterator(owner, curIndex) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline"></td>
    <td class="lineNumber">1265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">    /// Allow access to the constructor.</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">    /// Allow access to the constructor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">                                       ReferenceT>;</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">                                       ReferenceT>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline"></td>
    <td class="lineNumber">1270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">  indexed_accessor_range_base(iterator begin, iterator end)</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">  indexed_accessor_range_base(iterator begin, iterator end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">      : base(offset_base(begin.getBase(), begin.getIndex())),</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">      : base(offset_base(begin.getBase(), begin.getIndex())),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">        count(end.getIndex() - begin.getIndex()) {}</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">        count(end.getIndex() - begin.getIndex()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  indexed_accessor_range_base(const iterator_range<iterator> &range)</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  indexed_accessor_range_base(const iterator_range<iterator> &range)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">      : indexed_accessor_range_base(range.begin(), range.end()) {}</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">      : indexed_accessor_range_base(range.begin(), range.end()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">  indexed_accessor_range_base(BaseT base, ptrdiff_t count)</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">  indexed_accessor_range_base(BaseT base, ptrdiff_t count)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">      : base(base), count(count) {}</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">      : base(base), count(count) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline"></td>
    <td class="lineNumber">1278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  iterator begin() const { return iterator(base, 0); }</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  iterator begin() const { return iterator(base, 0); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  iterator end() const { return iterator(base, count); }</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  iterator end() const { return iterator(base, count); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  ReferenceT operator[](size_t Index) const {</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  ReferenceT operator[](size_t Index) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">    assert(Index < size() && "invalid index for value range");</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">    assert(Index < size() && "invalid index for value range");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">  ReferenceT front() const {</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">  ReferenceT front() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">    assert(!empty() && "expected non-empty range");</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">    assert(!empty() && "expected non-empty range");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">    return (*this)[0];</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">    return (*this)[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">  ReferenceT back() const {</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">  ReferenceT back() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">    assert(!empty() && "expected non-empty range");</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">    assert(!empty() && "expected non-empty range");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">    return (*this)[size() - 1];</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">    return (*this)[size() - 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">  /// Compare this range with another.</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">  /// Compare this range with another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">  template <typename OtherT></td>
    <td class="lineNumber">1295</td>
    <td class="codeline">  template <typename OtherT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">  friend bool operator==(const indexed_accessor_range_base &lhs,</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">  friend bool operator==(const indexed_accessor_range_base &lhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">                         const OtherT &rhs) {</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">                         const OtherT &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">  template <typename OtherT></td>
    <td class="lineNumber">1300</td>
    <td class="codeline">  template <typename OtherT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">  friend bool operator!=(const indexed_accessor_range_base &lhs,</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">  friend bool operator!=(const indexed_accessor_range_base &lhs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">                         const OtherT &rhs) {</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">                         const OtherT &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">    return !(lhs == rhs);</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">    return !(lhs == rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// Return the size of this range.</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// Return the size of this range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">  size_t size() const { return count; }</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">  size_t size() const { return count; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
    <td class="lineNumber">1308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">  /// Return if the range is empty.</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">  /// Return if the range is empty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  bool empty() const { return size() == 0; }</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  bool empty() const { return size() == 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  /// Drop the first N elements, and keep M elements.</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  /// Drop the first N elements, and keep M elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  DerivedT slice(size_t n, size_t m) const {</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  DerivedT slice(size_t n, size_t m) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">    assert(n + m <= size() && "invalid size specifiers");</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">    assert(n + m <= size() && "invalid size specifiers");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">    return DerivedT(offset_base(base, n), m);</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">    return DerivedT(offset_base(base, n), m);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  /// Drop the first n elements.</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  /// Drop the first n elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  DerivedT drop_front(size_t n = 1) const {</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  DerivedT drop_front(size_t n = 1) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">    assert(size() >= n && "Dropping more elements than exist");</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">    assert(size() >= n && "Dropping more elements than exist");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">    return slice(n, size() - n);</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">    return slice(n, size() - n);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">  /// Drop the last n elements.</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">  /// Drop the last n elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">  DerivedT drop_back(size_t n = 1) const {</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">  DerivedT drop_back(size_t n = 1) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">    assert(size() >= n && "Dropping more elements than exist");</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">    assert(size() >= n && "Dropping more elements than exist");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    return DerivedT(base, size() - n);</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    return DerivedT(base, size() - n);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline"></td>
    <td class="lineNumber">1328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">  /// Take the first n elements.</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">  /// Take the first n elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">  DerivedT take_front(size_t n = 1) const {</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">  DerivedT take_front(size_t n = 1) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">    return n < size() ? drop_back(size() - n)</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">    return n < size() ? drop_back(size() - n)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">                      : static_cast<const DerivedT &>(*this);</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">                      : static_cast<const DerivedT &>(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline"></td>
    <td class="lineNumber">1334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">  /// Take the last n elements.</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">  /// Take the last n elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">  DerivedT take_back(size_t n = 1) const {</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">  DerivedT take_back(size_t n = 1) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">    return n < size() ? drop_front(size() - n)</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">    return n < size() ? drop_front(size() - n)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">                      : static_cast<const DerivedT &>(*this);</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">                      : static_cast<const DerivedT &>(*this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  /// Allow conversion to any type accepting an iterator_range.</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  /// Allow conversion to any type accepting an iterator_range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">                                 RangeT, iterator_range<iterator>>::value>></td>
    <td class="lineNumber">1343</td>
    <td class="codeline">                                 RangeT, iterator_range<iterator>>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">  operator RangeT() const {</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">  operator RangeT() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">    return RangeT(iterator_range<iterator>(*this));</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">    return RangeT(iterator_range<iterator>(*this));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">  /// Returns the base of this range.</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">  /// Returns the base of this range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">  const BaseT &getBase() const { return base; }</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">  const BaseT &getBase() const { return base; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline"></td>
    <td class="lineNumber">1350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  /// Offset the given base by the given amount.</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  /// Offset the given base by the given amount.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  static BaseT offset_base(const BaseT &base, size_t n) {</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  static BaseT offset_base(const BaseT &base, size_t n) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">    return n == 0 ? base : DerivedT::offset_base(base, n);</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">    return n == 0 ? base : DerivedT::offset_base(base, n);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline"></td>
    <td class="lineNumber">1356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">  indexed_accessor_range_base &</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">  indexed_accessor_range_base &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">  operator=(const indexed_accessor_range_base &) = default;</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">  operator=(const indexed_accessor_range_base &) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  /// The base that owns the provided range of values.</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  /// The base that owns the provided range of values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  BaseT base;</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  BaseT base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// The size from the owning range.</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// The size from the owning range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">  ptrdiff_t count;</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">  ptrdiff_t count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">} // end namespace detail</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">} // end namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline"></td>
    <td class="lineNumber">1369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">/// This class provides an implementation of a range of</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">/// This class provides an implementation of a range of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">/// indexed_accessor_iterators where the base is not indexable. Ranges with</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">/// indexed_accessor_iterators where the base is not indexable. Ranges with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">/// bases that are offsetable should derive from indexed_accessor_range_base</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">/// bases that are offsetable should derive from indexed_accessor_range_base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">/// instead. Derived range classes are expected to implement the following</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">/// instead. Derived range classes are expected to implement the following</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">/// static method:</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">/// static method:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">///     - Dereference an iterator pointing to a parent base at the given index.</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">///     - Dereference an iterator pointing to a parent base at the given index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">template <typename DerivedT, typename BaseT, typename T,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">1378</td>
    <td class="codeline">          typename PointerT = T *, typename ReferenceT = T &></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">class indexed_accessor_range</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">class indexed_accessor_range</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">    : public detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">    : public detail::indexed_accessor_range_base<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">      : detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">      : detail::indexed_accessor_range_base<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">            std::make_pair(base, startIndex), count) {}</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">            std::make_pair(base, startIndex), count) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">  using detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">  using detail::indexed_accessor_range_base<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">      ReferenceT>::indexed_accessor_range_base;</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">      ReferenceT>::indexed_accessor_range_base;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  /// Returns the current base of the range.</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  /// Returns the current base of the range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  const BaseT &getBase() const { return this->base.first; }</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  const BaseT &getBase() const { return this->base.first; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  /// Returns the current start index of the range.</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  /// Returns the current start index of the range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">  ptrdiff_t getStartIndex() const { return this->base.second; }</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">  ptrdiff_t getStartIndex() const { return this->base.second; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline"></td>
    <td class="lineNumber">1396</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  /// See `detail::indexed_accessor_range_base` for details.</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  /// See `detail::indexed_accessor_range_base` for details.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">  static std::pair<BaseT, ptrdiff_t></td>
    <td class="lineNumber">1398</td>
    <td class="codeline">  static std::pair<BaseT, ptrdiff_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">    // We encode the internal base as a pair of the derived base and a start</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">    // We encode the internal base as a pair of the derived base and a start</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">    // index into the derived base.</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">    // index into the derived base.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">    return std::make_pair(base.first, base.second + index);</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">    return std::make_pair(base.first, base.second + index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">  /// See `detail::indexed_accessor_range_base` for details.</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">  /// See `detail::indexed_accessor_range_base` for details.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">  static ReferenceT</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">  static ReferenceT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">                       ptrdiff_t index) {</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">                       ptrdiff_t index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">    return DerivedT::dereference(base.first, base.second + index);</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">    return DerivedT::dereference(base.first, base.second + index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline"></td>
    <td class="lineNumber">1411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">/// Return a reference to the first or second member of a reference. Otherwise,</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">/// Return a reference to the first or second member of a reference. Otherwise,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">/// return a copy of the member of a temporary.</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">/// return a copy of the member of a temporary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">/// When passing a range whose iterators return values instead of references,</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">/// When passing a range whose iterators return values instead of references,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">/// the reference must be dropped from `decltype((elt.first))`, which will</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">/// the reference must be dropped from `decltype((elt.first))`, which will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">/// always be a reference, to avoid returning a reference to a temporary.</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">/// always be a reference, to avoid returning a reference to a temporary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">template <typename EltTy, typename FirstTy> class first_or_second_type {</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">template <typename EltTy, typename FirstTy> class first_or_second_type {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">  using type = std::conditional_t<std::is_reference<EltTy>::value, FirstTy,</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">  using type = std::conditional_t<std::is_reference<EltTy>::value, FirstTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">                                  std::remove_reference_t<FirstTy>>;</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">                                  std::remove_reference_t<FirstTy>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">} // end namespace detail</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">} // end namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline"></td>
    <td class="lineNumber">1425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">/// Given a container of pairs, return a range over the first elements.</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">/// Given a container of pairs, return a range over the first elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  using EltTy = decltype((*std::begin(c)));</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  using EltTy = decltype((*std::begin(c)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">  return llvm::map_range(std::forward<ContainerTy>(c),</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">  return llvm::map_range(std::forward<ContainerTy>(c),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">                         [](EltTy elt) -> typename detail::first_or_second_type<</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">                         [](EltTy elt) -> typename detail::first_or_second_type<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">                                           EltTy, decltype((elt.first))>::type {</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">                                           EltTy, decltype((elt.first))>::type {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">                           return elt.first;</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">                           return elt.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">                         });</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">                         });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline"></td>
    <td class="lineNumber">1435</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">/// Given a container of pairs, return a range over the second elements.</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">/// Given a container of pairs, return a range over the second elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">  using EltTy = decltype((*std::begin(c)));</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">  using EltTy = decltype((*std::begin(c)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">  return llvm::map_range(</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">  return llvm::map_range(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">      std::forward<ContainerTy>(c),</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">      std::forward<ContainerTy>(c),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">      [](EltTy elt) -></td>
    <td class="lineNumber">1441</td>
    <td class="codeline">      [](EltTy elt) -></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">      typename detail::first_or_second_type<EltTy,</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">      typename detail::first_or_second_type<EltTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">                                            decltype((elt.second))>::type {</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">                                            decltype((elt.second))>::type {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">        return elt.second;</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">        return elt.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">//     Extra additions to <utility></td>
    <td class="lineNumber">1449</td>
    <td class="codeline">//     Extra additions to <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">/// Function object to check whether the first component of a container</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">/// Function object to check whether the first component of a container</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">/// first component of another container.</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">/// first component of another container.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">struct less_first {</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">struct less_first {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">    return std::less<>()(std::get<0>(lhs), std::get<0>(rhs));</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">    return std::less<>()(std::get<0>(lhs), std::get<0>(rhs));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline"></td>
    <td class="lineNumber">1460</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">/// Function object to check whether the second component of a container</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">/// Function object to check whether the second component of a container</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">/// second component of another container.</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">/// second component of another container.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">struct less_second {</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">struct less_second {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">    return std::less<>()(std::get<1>(lhs), std::get<1>(rhs));</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">    return std::less<>()(std::get<1>(lhs), std::get<1>(rhs));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">/// \brief Function object to apply a binary function to the first component of</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">/// \brief Function object to apply a binary function to the first component of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">/// a std::pair.</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">/// a std::pair.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">template<typename FuncTy></td>
    <td class="lineNumber">1472</td>
    <td class="codeline">template<typename FuncTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">struct on_first {</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">struct on_first {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">  FuncTy func;</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">  FuncTy func;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline"></td>
    <td class="lineNumber">1475</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  template <typename T></td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">  decltype(auto) operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">  decltype(auto) operator()(const T &lhs, const T &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">    return func(lhs.first, rhs.first);</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">    return func(lhs.first, rhs.first);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">/// Utility type to build an inheritance chain that makes it easy to rank</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">/// Utility type to build an inheritance chain that makes it easy to rank</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">/// overload candidates.</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">/// overload candidates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">template <int N> struct rank : rank<N - 1> {};</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">template <int N> struct rank : rank<N - 1> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">template <> struct rank<0> {};</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">template <> struct rank<0> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline"></td>
    <td class="lineNumber">1486</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">/// traits class for checking whether type T is one of any of the given</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">/// traits class for checking whether type T is one of any of the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">/// types in the variadic list.</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">/// types in the variadic list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">template <typename T, typename... Ts></td>
    <td class="lineNumber">1489</td>
    <td class="codeline">template <typename T, typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline"></td>
    <td class="lineNumber">1491</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">/// traits class for checking whether type T is a base class for all</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">/// traits class for checking whether type T is a base class for all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">///  the given types in the variadic list.</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">///  the given types in the variadic list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">template <typename T, typename... Ts></td>
    <td class="lineNumber">1494</td>
    <td class="codeline">template <typename T, typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">template <typename... Ts> struct Visitor;</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">template <typename... Ts> struct Visitor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline"></td>
    <td class="lineNumber">1499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">template <typename HeadT, typename... TailTs></td>
    <td class="lineNumber">1500</td>
    <td class="codeline">template <typename HeadT, typename... TailTs></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">  using remove_cvref_t<HeadT>::operator();</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">  using remove_cvref_t<HeadT>::operator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  using Visitor<TailTs...>::operator();</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  using Visitor<TailTs...>::operator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline"></td>
    <td class="lineNumber">1508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  explicit constexpr Visitor(HeadT &&Head)</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  explicit constexpr Visitor(HeadT &&Head)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">  using remove_cvref_t<HeadT>::operator();</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">  using remove_cvref_t<HeadT>::operator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline"></td>
    <td class="lineNumber">1515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">/// Returns an opaquely-typed Callable object whose operator() overload set is</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">/// Returns an opaquely-typed Callable object whose operator() overload set is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">/// the sum of the operator() overload sets of each CallableT in CallableTs.</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">/// the sum of the operator() overload sets of each CallableT in CallableTs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">/// The type of the returned object derives from each CallableT in CallableTs.</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">/// The type of the returned object derives from each CallableT in CallableTs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">/// The returned object is constructed by invoking the appropriate copy or move</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">/// The returned object is constructed by invoking the appropriate copy or move</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">/// constructor of each CallableT, as selected by overload resolution on the</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">/// constructor of each CallableT, as selected by overload resolution on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">/// corresponding argument to makeVisitor.</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">/// corresponding argument to makeVisitor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">/// Example:</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">/// Example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">/// \code</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">/// \code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">/// auto visitor = makeVisitor([](auto) { return "unhandled type"; },</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">/// auto visitor = makeVisitor([](auto) { return "unhandled type"; },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">///                            [](int i) { return "int"; },</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">///                            [](int i) { return "int"; },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">///                            [](std::string s) { return "str"; });</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">///                            [](std::string s) { return "str"; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">/// auto a = visitor(42);    // `a` is now "int".</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">/// auto a = visitor(42);    // `a` is now "int".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">/// auto b = visitor("foo"); // `b` is now "str".</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">/// auto b = visitor("foo"); // `b` is now "str".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">/// auto c = visitor(3.14f); // `c` is now "unhandled type".</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">/// auto c = visitor(3.14f); // `c` is now "unhandled type".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">/// \endcode</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">/// \endcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">/// Example of making a visitor with a lambda which captures a move-only type:</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">/// Example of making a visitor with a lambda which captures a move-only type:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">/// \code</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">/// \code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">/// std::unique_ptr<FooHandler> FH = /* ... */;</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">/// std::unique_ptr<FooHandler> FH = /* ... */;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">/// auto visitor = makeVisitor(</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">/// auto visitor = makeVisitor(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">///     [FH{std::move(FH)}](Foo F) { return FH->handle(F); },</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">///     [FH{std::move(FH)}](Foo F) { return FH->handle(F); },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">///     [](int i) { return i; },</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">///     [](int i) { return i; },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">///     [](std::string s) { return atoi(s); });</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">///     [](std::string s) { return atoi(s); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">/// \endcode</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">/// \endcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">template <typename... CallableTs></td>
    <td class="lineNumber">1544</td>
    <td class="codeline">template <typename... CallableTs></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">//     Extra additions to <algorithm></td>
    <td class="lineNumber">1550</td>
    <td class="codeline">//     Extra additions to <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">// We have a copy here so that LLVM behaves the same when using different</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">// We have a copy here so that LLVM behaves the same when using different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">// standard libraries.</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">// standard libraries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">template <class Iterator, class RNG></td>
    <td class="lineNumber">1555</td>
    <td class="codeline">template <class Iterator, class RNG></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">void shuffle(Iterator first, Iterator last, RNG &&g) {</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">void shuffle(Iterator first, Iterator last, RNG &&g) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">  // It would be better to use a std::uniform_int_distribution,</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">  // It would be better to use a std::uniform_int_distribution,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">  // but that would be stdlib dependent.</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">  // but that would be stdlib dependent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  typedef</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  typedef</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">      typename std::iterator_traits<Iterator>::difference_type difference_type;</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">      typename std::iterator_traits<Iterator>::difference_type difference_type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">  for (auto size = last - first; size > 1; ++first, (void)--size) {</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">  for (auto size = last - first; size > 1; ++first, (void)--size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">    difference_type offset = g() % size;</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">    difference_type offset = g() % size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">    // Avoid self-assignment due to incorrect assertions in libstdc++</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">    // Avoid self-assignment due to incorrect assertions in libstdc++</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">    if (offset != difference_type(0))</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">    if (offset != difference_type(0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">      std::iter_swap(first, first + offset);</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">      std::iter_swap(first, first + offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">/// Adapt std::less<T> for array_pod_sort.</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">/// Adapt std::less<T> for array_pod_sort.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">template<typename T></td>
    <td class="lineNumber">1571</td>
    <td class="codeline">template<typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine diffFirst">inline int array_pod_sort_comparator(const void *P1, const void *P2) {</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">inline int array_pod_sort_comparator(const void *P1, const void *P2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine diffFirst">  if (std::less<T>()(*reinterpret_cast<const T*>(P1),</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">  if (std::less<T>()(*reinterpret_cast<const T*>(P1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">                     *reinterpret_cast<const T*>(P2)))</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">                     *reinterpret_cast<const T*>(P2)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine diffFirst">    return -1;</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">    return -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine diffFirst">  if (std::less<T>()(*reinterpret_cast<const T*>(P2),</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">  if (std::less<T>()(*reinterpret_cast<const T*>(P2),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">                     *reinterpret_cast<const T*>(P1)))</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">                     *reinterpret_cast<const T*>(P1)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine diffFirst">    return 1;</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">    return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline"></td>
    <td class="lineNumber">1581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">/// get_array_pod_sort_comparator - This is an internal helper function used to</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">/// get_array_pod_sort_comparator - This is an internal helper function used to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">/// get type deduction of T right.</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">/// get type deduction of T right.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">template<typename T></td>
    <td class="lineNumber">1584</td>
    <td class="codeline">template<typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine diffFirst">inline int (*get_array_pod_sort_comparator(const T &))</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">inline int (*get_array_pod_sort_comparator(const T &))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">             (const void*, const void*) {</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">             (const void*, const void*) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine diffFirst">  return array_pod_sort_comparator<T>;</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">  return array_pod_sort_comparator<T>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline"></td>
    <td class="lineNumber">1589</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline"></td>
    <td class="lineNumber">1592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">inline unsigned presortShuffleEntropy() {</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">inline unsigned presortShuffleEntropy() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">  static unsigned Result(std::random_device{}());</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">  static unsigned Result(std::random_device{}());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">  return Result;</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">  return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">template <class IteratorTy></td>
    <td class="lineNumber">1598</td>
    <td class="codeline">template <class IteratorTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">inline void presortShuffle(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">inline void presortShuffle(IteratorTy Start, IteratorTy End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">  std::mt19937 Generator(presortShuffleEntropy());</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">  std::mt19937 Generator(presortShuffleEntropy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">  llvm::shuffle(Start, End, Generator);</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">  llvm::shuffle(Start, End, Generator);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline"></td>
    <td class="lineNumber">1603</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">} // end namespace detail</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">} // end namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">/// array_pod_sort - This sorts an array with the specified start and end</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">/// array_pod_sort - This sorts an array with the specified start and end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">/// extent.  This is just like std::sort, except that it calls qsort instead of</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">/// extent.  This is just like std::sort, except that it calls qsort instead of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">/// using an inlined template.  qsort is slightly slower than std::sort, but</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">/// using an inlined template.  qsort is slightly slower than std::sort, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">/// most sorts are not performance critical in LLVM and std::sort has to be</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">/// most sorts are not performance critical in LLVM and std::sort has to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">/// template instantiated for each type, leading to significant measured code</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">/// template instantiated for each type, leading to significant measured code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">/// bloat.  This function should generally be used instead of std::sort where</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">/// bloat.  This function should generally be used instead of std::sort where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">/// possible.</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">/// possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">/// This function assumes that you have simple POD-like types that can be</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">/// This function assumes that you have simple POD-like types that can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">/// compared with std::less and can be moved with memcpy.  If this isn't true,</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">/// compared with std::less and can be moved with memcpy.  If this isn't true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">/// you should use std::sort.</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">/// you should use std::sort.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">/// NOTE: If qsort_r were portable, we could allow a custom comparator and</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">/// NOTE: If qsort_r were portable, we could allow a custom comparator and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">/// default to std::less.</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">/// default to std::less.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">template<class IteratorTy></td>
    <td class="lineNumber">1621</td>
    <td class="codeline">template<class IteratorTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">inline void array_pod_sort(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">inline void array_pod_sort(IteratorTy Start, IteratorTy End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">  // Don't inefficiently call qsort with one element or trigger undefined</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">  // Don't inefficiently call qsort with one element or trigger undefined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">  // behavior with an empty sequence.</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">  // behavior with an empty sequence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">  auto NElts = End - Start;</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">  auto NElts = End - Start;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">  if (NElts <= 1) return;</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">  if (NElts <= 1) return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">  detail::presortShuffle<IteratorTy>(Start, End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine diffFirst">  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">template <class IteratorTy></td>
    <td class="lineNumber">1633</td>
    <td class="codeline">template <class IteratorTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">inline void array_pod_sort(</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">inline void array_pod_sort(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">    IteratorTy Start, IteratorTy End,</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">    IteratorTy Start, IteratorTy End,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">    int (*Compare)(</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">    int (*Compare)(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">        const typename std::iterator_traits<IteratorTy>::value_type *,</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">        const typename std::iterator_traits<IteratorTy>::value_type *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">        const typename std::iterator_traits<IteratorTy>::value_type *)) {</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">        const typename std::iterator_traits<IteratorTy>::value_type *)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">  // Don't inefficiently call qsort with one element or trigger undefined</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">  // Don't inefficiently call qsort with one element or trigger undefined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  // behavior with an empty sequence.</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  // behavior with an empty sequence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">  auto NElts = End - Start;</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">  auto NElts = End - Start;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">  if (NElts <= 1) return;</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">  if (NElts <= 1) return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">  detail::presortShuffle<IteratorTy>(Start, End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">  qsort(&*Start, NElts, sizeof(*Start),</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">  qsort(&*Start, NElts, sizeof(*Start),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">        reinterpret_cast<int (*)(const void *, const void *)>(Compare));</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">        reinterpret_cast<int (*)(const void *, const void *)>(Compare));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">1651</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">// We can use qsort if the iterator type is a pointer and the underlying value</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">// We can use qsort if the iterator type is a pointer and the underlying value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">// is trivially copyable.</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">// is trivially copyable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">using sort_trivially_copyable = std::conjunction<</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">using sort_trivially_copyable = std::conjunction<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">    std::is_pointer<T>,</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">    std::is_pointer<T>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline"></td>
    <td class="lineNumber">1658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">// Provide wrappers to std::sort which shuffle the elements before sorting</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">// Provide wrappers to std::sort which shuffle the elements before sorting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">// to help uncover non-deterministic behavior (PR35135).</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">// to help uncover non-deterministic behavior (PR35135).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">template <typename IteratorTy></td>
    <td class="lineNumber">1661</td>
    <td class="codeline">template <typename IteratorTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine diffFirst">inline void sort(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">inline void sort(IteratorTy Start, IteratorTy End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  if constexpr (detail::sort_trivially_copyable<IteratorTy>::value) {</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  if constexpr (detail::sort_trivially_copyable<IteratorTy>::value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">    // Forward trivially copyable types to array_pod_sort. This avoids a large</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">    // Forward trivially copyable types to array_pod_sort. This avoids a large</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">    // amount of code bloat for a minor performance hit.</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">    // amount of code bloat for a minor performance hit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine diffFirst">    array_pod_sort(Start, End);</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">    array_pod_sort(Start, End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">    detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">    detail::presortShuffle<IteratorTy>(Start, End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">    std::sort(Start, End);</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">    std::sort(Start, End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine diffFirst">}</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline"></td>
    <td class="lineNumber">1674</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine diffFirst">template <typename Container> inline void sort(Container &&C) {</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">template <typename Container> inline void sort(Container &&C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine diffFirst">  llvm::sort(adl_begin(C), adl_end(C));</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">  llvm::sort(adl_begin(C), adl_end(C));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine diffFirst">}</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">template <typename IteratorTy, typename Compare></td>
    <td class="lineNumber">1679</td>
    <td class="codeline">template <typename IteratorTy, typename Compare></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">#ifdef EXPENSIVE_CHECKS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  detail::presortShuffle<IteratorTy>(Start, End);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">  std::sort(Start, End, Comp);</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">  std::sort(Start, End, Comp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">template <typename Container, typename Compare></td>
    <td class="lineNumber">1687</td>
    <td class="codeline">template <typename Container, typename Compare></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">inline void sort(Container &&C, Compare Comp) {</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">inline void sort(Container &&C, Compare Comp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">  llvm::sort(adl_begin(C), adl_end(C), Comp);</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">  llvm::sort(adl_begin(C), adl_end(C), Comp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline"></td>
    <td class="lineNumber">1691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">/// Get the size of a range. This is a wrapper function around std::distance</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">/// Get the size of a range. This is a wrapper function around std::distance</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">/// which is only enabled when the operation is O(1).</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">/// which is only enabled when the operation is O(1).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">template <typename R></td>
    <td class="lineNumber">1694</td>
    <td class="codeline">template <typename R></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">auto size(R &&Range,</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">auto size(R &&Range,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">          std::enable_if_t<</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">          std::enable_if_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">              std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">              std::is_base_of<std::random_access_iterator_tag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">                              typename std::iterator_traits<decltype(</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">                              typename std::iterator_traits<decltype(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">                                  Range.begin())>::iterator_category>::value,</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">                                  Range.begin())>::iterator_category>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">              void> * = nullptr) {</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">              void> * = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">  return std::distance(Range.begin(), Range.end());</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">  return std::distance(Range.begin(), Range.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline"></td>
    <td class="lineNumber">1703</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">template <typename Range></td>
    <td class="lineNumber">1705</td>
    <td class="codeline">template <typename Range></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">using check_has_free_function_size =</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">using check_has_free_function_size =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">    decltype(adl_size(std::declval<Range &>()));</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">    decltype(adl_size(std::declval<Range &>()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline"></td>
    <td class="lineNumber">1708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">template <typename Range></td>
    <td class="lineNumber">1709</td>
    <td class="codeline">template <typename Range></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">static constexpr bool HasFreeFunctionSize =</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">static constexpr bool HasFreeFunctionSize =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">    is_detected<check_has_free_function_size, Range>::value;</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">    is_detected<check_has_free_function_size, Range>::value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline"></td>
    <td class="lineNumber">1713</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">/// Returns the size of the \p Range, i.e., the number of elements. This</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">/// Returns the size of the \p Range, i.e., the number of elements. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">/// implementation takes inspiration from `std::ranges::size` from C++20 and</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">/// implementation takes inspiration from `std::ranges::size` from C++20 and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">/// delegates the size check to `adl_size` or `std::distance`, in this order of</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">/// delegates the size check to `adl_size` or `std::distance`, in this order of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">/// preference. Unlike `llvm::size`, this function does *not* guarantee O(1)</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">/// preference. Unlike `llvm::size`, this function does *not* guarantee O(1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">/// running time, and is intended to be used in generic code that does not know</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">/// running time, and is intended to be used in generic code that does not know</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">/// the exact range type.</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">/// the exact range type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">template <typename R> constexpr size_t range_size(R &&Range) {</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">template <typename R> constexpr size_t range_size(R &&Range) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">  if constexpr (detail::HasFreeFunctionSize<R>)</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">  if constexpr (detail::HasFreeFunctionSize<R>)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">    return adl_size(Range);</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">    return adl_size(Range);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">    return static_cast<size_t>(std::distance(adl_begin(Range), adl_end(Range)));</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">    return static_cast<size_t>(std::distance(adl_begin(Range), adl_end(Range)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline"></td>
    <td class="lineNumber">1726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">/// Provide wrappers to std::for_each which take ranges instead of having to</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">/// Provide wrappers to std::for_each which take ranges instead of having to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">template <typename R, typename UnaryFunction></td>
    <td class="lineNumber">1729</td>
    <td class="codeline">template <typename R, typename UnaryFunction></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">UnaryFunction for_each(R &&Range, UnaryFunction F) {</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">UnaryFunction for_each(R &&Range, UnaryFunction F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">  return std::for_each(adl_begin(Range), adl_end(Range), F);</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">  return std::for_each(adl_begin(Range), adl_end(Range), F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline"></td>
    <td class="lineNumber">1733</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">/// Provide wrappers to std::all_of which take ranges instead of having to pass</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">/// Provide wrappers to std::all_of which take ranges instead of having to pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">/// begin/end explicitly.</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">/// begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">1736</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">bool all_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">bool all_of(R &&Range, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">  return std::all_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">  return std::all_of(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
    <td class="lineNumber">1740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">/// Provide wrappers to std::any_of which take ranges instead of having to pass</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">/// Provide wrappers to std::any_of which take ranges instead of having to pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">/// begin/end explicitly.</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">/// begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">1743</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">bool any_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">bool any_of(R &&Range, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">  return std::any_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">  return std::any_of(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline"></td>
    <td class="lineNumber">1747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">/// Provide wrappers to std::none_of which take ranges instead of having to pass</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">/// Provide wrappers to std::none_of which take ranges instead of having to pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">/// begin/end explicitly.</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">/// begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">1750</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">bool none_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">bool none_of(R &&Range, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">  return std::none_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">  return std::none_of(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline"></td>
    <td class="lineNumber">1754</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">/// Provide wrappers to std::find which take ranges instead of having to pass</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">/// Provide wrappers to std::find which take ranges instead of having to pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">/// begin/end explicitly.</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">/// begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">template <typename R, typename T> auto find(R &&Range, const T &Val) {</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">template <typename R, typename T> auto find(R &&Range, const T &Val) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">  return std::find(adl_begin(Range), adl_end(Range), Val);</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">  return std::find(adl_begin(Range), adl_end(Range), Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline"></td>
    <td class="lineNumber">1760</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">/// Provide wrappers to std::find_if which take ranges instead of having to pass</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">/// Provide wrappers to std::find_if which take ranges instead of having to pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">/// begin/end explicitly.</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">/// begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">1763</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">auto find_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">auto find_if(R &&Range, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">  return std::find_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">  return std::find_if(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">1768</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">auto find_if_not(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">auto find_if_not(R &&Range, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  return std::find_if_not(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  return std::find_if_not(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline"></td>
    <td class="lineNumber">1772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">/// Provide wrappers to std::remove_if which take ranges instead of having to</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">/// Provide wrappers to std::remove_if which take ranges instead of having to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">1775</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">auto remove_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">auto remove_if(R &&Range, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  return std::remove_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  return std::remove_if(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline"></td>
    <td class="lineNumber">1779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">/// Provide wrappers to std::copy_if which take ranges instead of having to</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">/// Provide wrappers to std::copy_if which take ranges instead of having to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">template <typename R, typename OutputIt, typename UnaryPredicate></td>
    <td class="lineNumber">1782</td>
    <td class="codeline">template <typename R, typename OutputIt, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline"></td>
    <td class="lineNumber">1786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">/// Return the single value in \p Range that satisfies</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">/// Return the single value in \p Range that satisfies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">/// \p P(<member of \p Range> *, AllowRepeats)->T * returning nullptr</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">/// \p P(<member of \p Range> *, AllowRepeats)->T * returning nullptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">/// when no values or multiple values were found.</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">/// when no values or multiple values were found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">/// When \p AllowRepeats is true, multiple values that compare equal</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">/// When \p AllowRepeats is true, multiple values that compare equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">/// are allowed.</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">/// are allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">template <typename T, typename R, typename Predicate></td>
    <td class="lineNumber">1792</td>
    <td class="codeline">template <typename T, typename R, typename Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">T *find_singleton(R &&Range, Predicate P, bool AllowRepeats = false) {</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">T *find_singleton(R &&Range, Predicate P, bool AllowRepeats = false) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">  T *RC = nullptr;</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">  T *RC = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  for (auto *A : Range) {</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  for (auto *A : Range) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">    if (T *PRC = P(A, AllowRepeats)) {</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">    if (T *PRC = P(A, AllowRepeats)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">      if (RC) {</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">      if (RC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">        if (!AllowRepeats || PRC != RC)</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">        if (!AllowRepeats || PRC != RC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">          return nullptr;</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">          return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">      } else</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">      } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">        RC = PRC;</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">        RC = PRC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">  return RC;</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">  return RC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline"></td>
    <td class="lineNumber">1806</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">/// Return a pair consisting of the single value in \p Range that satisfies</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">/// Return a pair consisting of the single value in \p Range that satisfies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">/// \p P(<member of \p Range> *, AllowRepeats)->std::pair<T*, bool> returning</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">/// \p P(<member of \p Range> *, AllowRepeats)->std::pair<T*, bool> returning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">/// nullptr when no values or multiple values were found, and a bool indicating</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">/// nullptr when no values or multiple values were found, and a bool indicating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">/// whether multiple values were found to cause the nullptr.</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">/// whether multiple values were found to cause the nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">/// When \p AllowRepeats is true, multiple values that compare equal are</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">/// When \p AllowRepeats is true, multiple values that compare equal are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">/// allowed.  The predicate \p P returns a pair<T *, bool> where T is the</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">/// allowed.  The predicate \p P returns a pair<T *, bool> where T is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">/// singleton while the bool indicates whether multiples have already been</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">/// singleton while the bool indicates whether multiples have already been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">/// found.  It is expected that first will be nullptr when second is true.</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">/// found.  It is expected that first will be nullptr when second is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">/// This allows using find_singleton_nested within the predicate \P.</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">/// This allows using find_singleton_nested within the predicate \P.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">template <typename T, typename R, typename Predicate></td>
    <td class="lineNumber">1816</td>
    <td class="codeline">template <typename T, typename R, typename Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">std::pair<T *, bool> find_singleton_nested(R &&Range, Predicate P,</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">std::pair<T *, bool> find_singleton_nested(R &&Range, Predicate P,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">                                           bool AllowRepeats = false) {</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">                                           bool AllowRepeats = false) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">  T *RC = nullptr;</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">  T *RC = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">  for (auto *A : Range) {</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">  for (auto *A : Range) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">    std::pair<T *, bool> PRC = P(A, AllowRepeats);</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">    std::pair<T *, bool> PRC = P(A, AllowRepeats);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">    if (PRC.second) {</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">    if (PRC.second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">      assert(PRC.first == nullptr &&</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">      assert(PRC.first == nullptr &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">             "Inconsistent return values in find_singleton_nested.");</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">             "Inconsistent return values in find_singleton_nested.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">      return PRC;</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">      return PRC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">    if (PRC.first) {</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">    if (PRC.first) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">      if (RC) {</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">      if (RC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">        if (!AllowRepeats || PRC.first != RC)</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">        if (!AllowRepeats || PRC.first != RC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">          return {nullptr, true};</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">          return {nullptr, true};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">      } else</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">      } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">        RC = PRC.first;</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">        RC = PRC.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">  return {RC, false};</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">  return {RC, false};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline"></td>
    <td class="lineNumber">1837</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">template <typename R, typename OutputIt></td>
    <td class="lineNumber">1838</td>
    <td class="codeline">template <typename R, typename OutputIt></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">OutputIt copy(R &&Range, OutputIt Out) {</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">OutputIt copy(R &&Range, OutputIt Out) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">  return std::copy(adl_begin(Range), adl_end(Range), Out);</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">  return std::copy(adl_begin(Range), adl_end(Range), Out);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline"></td>
    <td class="lineNumber">1842</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">/// Provide wrappers to std::replace_copy_if which take ranges instead of having</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">/// Provide wrappers to std::replace_copy_if which take ranges instead of having</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">/// to pass begin/end explicitly.</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">/// to pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">template <typename R, typename OutputIt, typename UnaryPredicate, typename T></td>
    <td class="lineNumber">1845</td>
    <td class="codeline">template <typename R, typename OutputIt, typename UnaryPredicate, typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">OutputIt replace_copy_if(R &&Range, OutputIt Out, UnaryPredicate P,</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">OutputIt replace_copy_if(R &&Range, OutputIt Out, UnaryPredicate P,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">                         const T &NewValue) {</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">                         const T &NewValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">  return std::replace_copy_if(adl_begin(Range), adl_end(Range), Out, P,</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">  return std::replace_copy_if(adl_begin(Range), adl_end(Range), Out, P,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">                              NewValue);</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">                              NewValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">/// Provide wrappers to std::replace_copy which take ranges instead of having to</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">/// Provide wrappers to std::replace_copy which take ranges instead of having to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">template <typename R, typename OutputIt, typename T></td>
    <td class="lineNumber">1854</td>
    <td class="codeline">template <typename R, typename OutputIt, typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">OutputIt replace_copy(R &&Range, OutputIt Out, const T &OldValue,</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">OutputIt replace_copy(R &&Range, OutputIt Out, const T &OldValue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">                      const T &NewValue) {</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">                      const T &NewValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">  return std::replace_copy(adl_begin(Range), adl_end(Range), Out, OldValue,</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">  return std::replace_copy(adl_begin(Range), adl_end(Range), Out, OldValue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">                           NewValue);</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">                           NewValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline"></td>
    <td class="lineNumber">1860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">/// Provide wrappers to std::move which take ranges instead of having to</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">/// Provide wrappers to std::move which take ranges instead of having to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">template <typename R, typename OutputIt></td>
    <td class="lineNumber">1863</td>
    <td class="codeline">template <typename R, typename OutputIt></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">OutputIt move(R &&Range, OutputIt Out) {</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">OutputIt move(R &&Range, OutputIt Out) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">  return std::move(adl_begin(Range), adl_end(Range), Out);</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">  return std::move(adl_begin(Range), adl_end(Range), Out);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline"></td>
    <td class="lineNumber">1867</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">template <typename Range, typename Element></td>
    <td class="lineNumber">1869</td>
    <td class="codeline">template <typename Range, typename Element></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">using check_has_member_contains_t =</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">using check_has_member_contains_t =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">    decltype(std::declval<Range &>().contains(std::declval<const Element &>()));</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">    decltype(std::declval<Range &>().contains(std::declval<const Element &>()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline"></td>
    <td class="lineNumber">1872</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">template <typename Range, typename Element></td>
    <td class="lineNumber">1873</td>
    <td class="codeline">template <typename Range, typename Element></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">static constexpr bool HasMemberContains =</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">static constexpr bool HasMemberContains =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">    is_detected<check_has_member_contains_t, Range, Element>::value;</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">    is_detected<check_has_member_contains_t, Range, Element>::value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">template <typename Range, typename Element></td>
    <td class="lineNumber">1877</td>
    <td class="codeline">template <typename Range, typename Element></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">using check_has_member_find_t =</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">using check_has_member_find_t =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">    decltype(std::declval<Range &>().find(std::declval<const Element &>()) !=</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">    decltype(std::declval<Range &>().find(std::declval<const Element &>()) !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">             std::declval<Range &>().end());</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">             std::declval<Range &>().end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline"></td>
    <td class="lineNumber">1881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">template <typename Range, typename Element></td>
    <td class="lineNumber">1882</td>
    <td class="codeline">template <typename Range, typename Element></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">static constexpr bool HasMemberFind =</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">static constexpr bool HasMemberFind =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">    is_detected<check_has_member_find_t, Range, Element>::value;</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">    is_detected<check_has_member_find_t, Range, Element>::value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline"></td>
    <td class="lineNumber">1885</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline"></td>
    <td class="lineNumber">1887</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">/// Returns true if \p Element is found in \p Range. Delegates the check to</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">/// Returns true if \p Element is found in \p Range. Delegates the check to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">/// either `.contains(Element)`, `.find(Element)`, or `std::find`, in this</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">/// either `.contains(Element)`, `.find(Element)`, or `std::find`, in this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">/// order of preference. This is intended as the canonical way to check if an</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">/// order of preference. This is intended as the canonical way to check if an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">/// element exists in a range in generic code or range type that does not</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">/// element exists in a range in generic code or range type that does not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">/// expose a `.contains(Element)` member.</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">/// expose a `.contains(Element)` member.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">template <typename R, typename E></td>
    <td class="lineNumber">1893</td>
    <td class="codeline">template <typename R, typename E></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">bool is_contained(R &&Range, const E &Element) {</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">bool is_contained(R &&Range, const E &Element) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  if constexpr (detail::HasMemberContains<R, E>)</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  if constexpr (detail::HasMemberContains<R, E>)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">    return Range.contains(Element);</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">    return Range.contains(Element);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">  else if constexpr (detail::HasMemberFind<R, E>)</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">  else if constexpr (detail::HasMemberFind<R, E>)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">    return Range.find(Element) != Range.end();</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">    return Range.find(Element) != Range.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">    return std::find(adl_begin(Range), adl_end(Range), Element) !=</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">    return std::find(adl_begin(Range), adl_end(Range), Element) !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">           adl_end(Range);</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">           adl_end(Range);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline"></td>
    <td class="lineNumber">1903</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">/// Returns true iff \p Element exists in \p Set. This overload takes \p Set as</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">/// Returns true iff \p Element exists in \p Set. This overload takes \p Set as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">/// an initializer list and is `constexpr`-friendly.</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">/// an initializer list and is `constexpr`-friendly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">template <typename T, typename E></td>
    <td class="lineNumber">1906</td>
    <td class="codeline">template <typename T, typename E></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">constexpr bool is_contained(std::initializer_list<T> Set, const E &Element) {</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">constexpr bool is_contained(std::initializer_list<T> Set, const E &Element) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">  // TODO: Use std::find when we switch to C++20.</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">  // TODO: Use std::find when we switch to C++20.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  for (const T &V : Set)</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  for (const T &V : Set)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">    if (V == Element)</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">    if (V == Element)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline"></td>
    <td class="lineNumber">1914</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">/// are sorted with respect to a comparator \p C.</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">/// are sorted with respect to a comparator \p C.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">  return std::is_sorted(adl_begin(Range), adl_end(Range), C);</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">  return std::is_sorted(adl_begin(Range), adl_end(Range), C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline"></td>
    <td class="lineNumber">1920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">/// are sorted in non-descending order.</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">/// are sorted in non-descending order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">template <typename R> bool is_sorted(R &&Range) {</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">template <typename R> bool is_sorted(R &&Range) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  return std::is_sorted(adl_begin(Range), adl_end(Range));</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  return std::is_sorted(adl_begin(Range), adl_end(Range));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">/// Wrapper function around std::count to count the number of times an element</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">/// Wrapper function around std::count to count the number of times an element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">/// \p Element occurs in the given range \p Range.</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">/// \p Element occurs in the given range \p Range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">template <typename R, typename E> auto count(R &&Range, const E &Element) {</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">template <typename R, typename E> auto count(R &&Range, const E &Element) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  return std::count(adl_begin(Range), adl_end(Range), Element);</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  return std::count(adl_begin(Range), adl_end(Range), Element);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">/// Wrapper function around std::count_if to count the number of times an</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">/// Wrapper function around std::count_if to count the number of times an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">/// element satisfying a given predicate occurs in a range.</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">/// element satisfying a given predicate occurs in a range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">1935</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">auto count_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">auto count_if(R &&Range, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  return std::count_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  return std::count_if(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline"></td>
    <td class="lineNumber">1939</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">/// Wrapper function around std::transform to apply a function to a range and</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">/// Wrapper function around std::transform to apply a function to a range and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">/// store the result elsewhere.</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">/// store the result elsewhere.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">template <typename R, typename OutputIt, typename UnaryFunction></td>
    <td class="lineNumber">1942</td>
    <td class="codeline">template <typename R, typename OutputIt, typename UnaryFunction></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">/// Provide wrappers to std::partition which take ranges instead of having to</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">/// Provide wrappers to std::partition which take ranges instead of having to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">1949</td>
    <td class="codeline">template <typename R, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">auto partition(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">auto partition(R &&Range, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">  return std::partition(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">  return std::partition(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline"></td>
    <td class="lineNumber">1953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">/// Provide wrappers to std::lower_bound which take ranges instead of having to</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">/// Provide wrappers to std::lower_bound which take ranges instead of having to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">                          std::forward<T>(Value));</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">                          std::forward<T>(Value));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline"></td>
    <td class="lineNumber">1960</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">template <typename R, typename T, typename Compare></td>
    <td class="lineNumber">1961</td>
    <td class="codeline">template <typename R, typename T, typename Compare></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">auto lower_bound(R &&Range, T &&Value, Compare C) {</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">auto lower_bound(R &&Range, T &&Value, Compare C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">                          std::forward<T>(Value), C);</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">                          std::forward<T>(Value), C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline"></td>
    <td class="lineNumber">1966</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">/// Provide wrappers to std::upper_bound which take ranges instead of having to</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">/// Provide wrappers to std::upper_bound which take ranges instead of having to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">/// pass begin/end explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">                          std::forward<T>(Value));</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">                          std::forward<T>(Value));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">template <typename R, typename T, typename Compare></td>
    <td class="lineNumber">1974</td>
    <td class="codeline">template <typename R, typename T, typename Compare></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">auto upper_bound(R &&Range, T &&Value, Compare C) {</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">auto upper_bound(R &&Range, T &&Value, Compare C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">                          std::forward<T>(Value), C);</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">                          std::forward<T>(Value), C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline"></td>
    <td class="lineNumber">1979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">template <typename R></td>
    <td class="lineNumber">1980</td>
    <td class="codeline">template <typename R></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">void stable_sort(R &&Range) {</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">void stable_sort(R &&Range) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">  std::stable_sort(adl_begin(Range), adl_end(Range));</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">  std::stable_sort(adl_begin(Range), adl_end(Range));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline"></td>
    <td class="lineNumber">1984</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">template <typename R, typename Compare></td>
    <td class="lineNumber">1985</td>
    <td class="codeline">template <typename R, typename Compare></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">void stable_sort(R &&Range, Compare C) {</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">void stable_sort(R &&Range, Compare C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">  std::stable_sort(adl_begin(Range), adl_end(Range), C);</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">  std::stable_sort(adl_begin(Range), adl_end(Range), C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline"></td>
    <td class="lineNumber">1989</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">/// Binary search for the first iterator in a range where a predicate is false.</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">/// Binary search for the first iterator in a range where a predicate is false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">/// Requires that C is always true below some limit, and always false above it.</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">/// Requires that C is always true below some limit, and always false above it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">template <typename R, typename Predicate,</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">template <typename R, typename Predicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">          typename Val = decltype(*adl_begin(std::declval<R>()))></td>
    <td class="lineNumber">1993</td>
    <td class="codeline">          typename Val = decltype(*adl_begin(std::declval<R>()))></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">auto partition_point(R &&Range, Predicate P) {</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">auto partition_point(R &&Range, Predicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">  return std::partition_point(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">  return std::partition_point(adl_begin(Range), adl_end(Range), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">template<typename Range, typename Predicate></td>
    <td class="lineNumber">1998</td>
    <td class="codeline">template<typename Range, typename Predicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">auto unique(Range &&R, Predicate P) {</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">auto unique(Range &&R, Predicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">  return std::unique(adl_begin(R), adl_end(R), P);</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">  return std::unique(adl_begin(R), adl_end(R), P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline"></td>
    <td class="lineNumber">2002</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">/// Wrapper function around std::equal to detect if pair-wise elements between</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">/// Wrapper function around std::equal to detect if pair-wise elements between</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">/// two ranges are the same.</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">/// two ranges are the same.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">                    adl_end(RRange));</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">                    adl_end(RRange));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline"></td>
    <td class="lineNumber">2009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">/// Returns true if all elements in Range are equal or when the Range is empty.</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">/// Returns true if all elements in Range are equal or when the Range is empty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">template <typename R> bool all_equal(R &&Range) {</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">template <typename R> bool all_equal(R &&Range) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  auto Begin = adl_begin(Range);</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  auto Begin = adl_begin(Range);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">  auto End = adl_end(Range);</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">  auto End = adl_end(Range);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  return Begin == End || std::equal(Begin + 1, End, Begin);</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  return Begin == End || std::equal(Begin + 1, End, Begin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline"></td>
    <td class="lineNumber">2016</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">/// Returns true if all Values in the initializer lists are equal or the list</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">/// Returns true if all Values in the initializer lists are equal or the list</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">// is empty.</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">// is empty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">template <typename T> bool all_equal(std::initializer_list<T> Values) {</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">template <typename T> bool all_equal(std::initializer_list<T> Values) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">  return all_equal<std::initializer_list<T>>(std::move(Values));</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">  return all_equal<std::initializer_list<T>>(std::move(Values));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline"></td>
    <td class="lineNumber">2022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">/// Provide a container algorithm similar to C++ Library Fundamentals v2's</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">/// Provide a container algorithm similar to C++ Library Fundamentals v2's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">/// `erase_if` which is equivalent to:</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">/// `erase_if` which is equivalent to:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">///   C.erase(remove_if(C, pred), C.end());</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">///   C.erase(remove_if(C, pred), C.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">/// This version works for any container with an erase method call accepting</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">/// This version works for any container with an erase method call accepting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">/// two iterators.</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">/// two iterators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">template <typename Container, typename UnaryPredicate></td>
    <td class="lineNumber">2030</td>
    <td class="codeline">template <typename Container, typename UnaryPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">void erase_if(Container &C, UnaryPredicate P) {</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">void erase_if(Container &C, UnaryPredicate P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">  C.erase(remove_if(C, P), C.end());</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">  C.erase(remove_if(C, P), C.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline"></td>
    <td class="lineNumber">2034</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">/// Wrapper function to remove a value from a container:</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">/// Wrapper function to remove a value from a container:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">/// C.erase(remove(C.begin(), C.end(), V), C.end());</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">/// C.erase(remove(C.begin(), C.end(), V), C.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">template <typename Container, typename ValueType></td>
    <td class="lineNumber">2038</td>
    <td class="codeline">template <typename Container, typename ValueType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">void erase_value(Container &C, ValueType V) {</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">void erase_value(Container &C, ValueType V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">  C.erase(std::remove(C.begin(), C.end(), V), C.end());</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">  C.erase(std::remove(C.begin(), C.end(), V), C.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline"></td>
    <td class="lineNumber">2042</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">/// Wrapper function to append a range to a container.</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">/// Wrapper function to append a range to a container.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">/// C.insert(C.end(), R.begin(), R.end());</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">/// C.insert(C.end(), R.begin(), R.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">template <typename Container, typename Range></td>
    <td class="lineNumber">2046</td>
    <td class="codeline">template <typename Container, typename Range></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">inline void append_range(Container &C, Range &&R) {</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">inline void append_range(Container &C, Range &&R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  C.insert(C.end(), adl_begin(R), adl_end(R));</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  C.insert(C.end(), adl_begin(R), adl_end(R));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline"></td>
    <td class="lineNumber">2050</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">/// the range [ValIt, ValEnd) (which is not from the same container).</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">/// the range [ValIt, ValEnd) (which is not from the same container).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">template<typename Container, typename RandomAccessIterator></td>
    <td class="lineNumber">2053</td>
    <td class="codeline">template<typename Container, typename RandomAccessIterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">void replace(Container &Cont, typename Container::iterator ContIt,</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">void replace(Container &Cont, typename Container::iterator ContIt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">             typename Container::iterator ContEnd, RandomAccessIterator ValIt,</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">             typename Container::iterator ContEnd, RandomAccessIterator ValIt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">             RandomAccessIterator ValEnd) {</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">             RandomAccessIterator ValEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  while (true) {</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">    if (ValIt == ValEnd) {</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">    if (ValIt == ValEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">      Cont.erase(ContIt, ContEnd);</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">      Cont.erase(ContIt, ContEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">    } else if (ContIt == ContEnd) {</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">    } else if (ContIt == ContEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">      Cont.insert(ContIt, ValIt, ValEnd);</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">      Cont.insert(ContIt, ValIt, ValEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">    *ContIt++ = *ValIt++;</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">    *ContIt++ = *ValIt++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline"></td>
    <td class="lineNumber">2068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">/// the range R.</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">/// the range R.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">template<typename Container, typename Range = std::initializer_list<</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">template<typename Container, typename Range = std::initializer_list<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">                                 typename Container::value_type>></td>
    <td class="lineNumber">2072</td>
    <td class="codeline">                                 typename Container::value_type>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">void replace(Container &Cont, typename Container::iterator ContIt,</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">void replace(Container &Cont, typename Container::iterator ContIt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">             typename Container::iterator ContEnd, Range R) {</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">             typename Container::iterator ContEnd, Range R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">  replace(Cont, ContIt, ContEnd, R.begin(), R.end());</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">  replace(Cont, ContIt, ContEnd, R.begin(), R.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline"></td>
    <td class="lineNumber">2077</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">/// An STL-style algorithm similar to std::for_each that applies a second</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">/// An STL-style algorithm similar to std::for_each that applies a second</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">/// functor between every pair of elements.</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">/// functor between every pair of elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">/// This provides the control flow logic to, for example, print a</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">/// This provides the control flow logic to, for example, print a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">/// comma-separated list:</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">/// comma-separated list:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">/// \code</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">/// \code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">///   interleave(names.begin(), names.end(),</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">///   interleave(names.begin(), names.end(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">///              [&](StringRef name) { os << name; },</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">///              [&](StringRef name) { os << name; },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">///              [&] { os << ", "; });</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">///              [&] { os << ", "; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">/// \endcode</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">/// \endcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">template <typename ForwardIterator, typename UnaryFunctor,</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">template <typename ForwardIterator, typename UnaryFunctor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">          typename NullaryFunctor,</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">          typename NullaryFunctor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">          typename = std::enable_if_t<</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">          typename = std::enable_if_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
    <td class="lineNumber">2092</td>
    <td class="codeline">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">inline void interleave(ForwardIterator begin, ForwardIterator end,</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">inline void interleave(ForwardIterator begin, ForwardIterator end,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">                       UnaryFunctor each_fn, NullaryFunctor between_fn) {</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">                       UnaryFunctor each_fn, NullaryFunctor between_fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">  if (begin == end)</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">  if (begin == end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">  each_fn(*begin);</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">  each_fn(*begin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">  ++begin;</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">  ++begin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">  for (; begin != end; ++begin) {</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">  for (; begin != end; ++begin) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">    between_fn();</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">    between_fn();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">    each_fn(*begin);</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">    each_fn(*begin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline"></td>
    <td class="lineNumber">2104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">template <typename Container, typename UnaryFunctor, typename NullaryFunctor,</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">template <typename Container, typename UnaryFunctor, typename NullaryFunctor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">          typename = std::enable_if_t<</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">          typename = std::enable_if_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
    <td class="lineNumber">2108</td>
    <td class="codeline">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">inline void interleave(const Container &c, UnaryFunctor each_fn,</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">inline void interleave(const Container &c, UnaryFunctor each_fn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">                       NullaryFunctor between_fn) {</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">                       NullaryFunctor between_fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">  interleave(c.begin(), c.end(), each_fn, between_fn);</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">  interleave(c.begin(), c.end(), each_fn, between_fn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline"></td>
    <td class="lineNumber">2113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">/// Overload of interleave for the common case of string separator.</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">/// Overload of interleave for the common case of string separator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">2116</td>
    <td class="codeline">          typename T = detail::ValueOfRange<Container>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">                       const StringRef &separator) {</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">                       const StringRef &separator) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">template <typename Container, typename StreamT,</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">template <typename Container, typename StreamT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">2122</td>
    <td class="codeline">          typename T = detail::ValueOfRange<Container>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">inline void interleave(const Container &c, StreamT &os,</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">inline void interleave(const Container &c, StreamT &os,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">                       const StringRef &separator) {</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">                       const StringRef &separator) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  interleave(</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  interleave(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">      c, os, [&](const T &a) { os << a; }, separator);</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">      c, os, [&](const T &a) { os << a; }, separator);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline"></td>
    <td class="lineNumber">2128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">2130</td>
    <td class="codeline">          typename T = detail::ValueOfRange<Container>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">inline void interleaveComma(const Container &c, StreamT &os,</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">inline void interleaveComma(const Container &c, StreamT &os,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">                            UnaryFunctor each_fn) {</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">                            UnaryFunctor each_fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  interleave(c, os, each_fn, ", ");</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  interleave(c, os, each_fn, ", ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">template <typename Container, typename StreamT,</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">template <typename Container, typename StreamT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">2136</td>
    <td class="codeline">          typename T = detail::ValueOfRange<Container>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">inline void interleaveComma(const Container &c, StreamT &os) {</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">inline void interleaveComma(const Container &c, StreamT &os) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">  interleaveComma(c, os, [&](const T &a) { os << a; });</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">  interleaveComma(c, os, [&](const T &a) { os << a; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline"></td>
    <td class="lineNumber">2140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">//     Extra additions to <memory></td>
    <td class="lineNumber">2142</td>
    <td class="codeline">//     Extra additions to <memory></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline"></td>
    <td class="lineNumber">2144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">struct FreeDeleter {</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">struct FreeDeleter {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">  void operator()(void* v) {</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">  void operator()(void* v) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">    ::free(v);</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">    ::free(v);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline"></td>
    <td class="lineNumber">2150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">template<typename First, typename Second></td>
    <td class="lineNumber">2151</td>
    <td class="codeline">template<typename First, typename Second></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">struct pair_hash {</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">struct pair_hash {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">  size_t operator()(const std::pair<First, Second> &P) const {</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">  size_t operator()(const std::pair<First, Second> &P) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">/// Binary functor that adapts to any other binary functor after dereferencing</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">/// Binary functor that adapts to any other binary functor after dereferencing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">/// operands.</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">/// operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">template <typename T> struct deref {</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">template <typename T> struct deref {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">  T func;</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">  T func;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline"></td>
    <td class="lineNumber">2162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">  // Could be further improved to cope with non-derivable functors and</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">  // Could be further improved to cope with non-derivable functors and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">  // non-binary functors (should be a variadic template member function</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">  // non-binary functors (should be a variadic template member function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  // operator()).</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  // operator()).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">    assert(lhs);</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">    assert(lhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">    assert(rhs);</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">    assert(rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">    return func(*lhs, *rhs);</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">    return func(*lhs, *rhs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline"></td>
    <td class="lineNumber">2172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline"></td>
    <td class="lineNumber">2174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">/// Tuple-like type for `zip_enumerator` dereference.</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">/// Tuple-like type for `zip_enumerator` dereference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">template <typename... Refs> struct enumerator_result;</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">template <typename... Refs> struct enumerator_result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline"></td>
    <td class="lineNumber">2177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">template <typename... Iters></td>
    <td class="lineNumber">2178</td>
    <td class="codeline">template <typename... Iters></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">using EnumeratorTupleType = enumerator_result<decltype(*declval<Iters>())...>;</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">using EnumeratorTupleType = enumerator_result<decltype(*declval<Iters>())...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline"></td>
    <td class="lineNumber">2180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">/// Zippy iterator that uses the second iterator for comparisons. For the</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">/// Zippy iterator that uses the second iterator for comparisons. For the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">/// increment to be safe, the second range has to be the shortest.</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">/// increment to be safe, the second range has to be the shortest.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">/// Returns `enumerator_result` on dereference to provide `.index()` and</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">/// Returns `enumerator_result` on dereference to provide `.index()` and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">/// `.value()` member functions.</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">/// `.value()` member functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">/// Note: Because the dereference operator returns `enumerator_result` as a</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">/// Note: Because the dereference operator returns `enumerator_result` as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">/// value instead of a reference and does not strictly conform to the C++17's</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">/// value instead of a reference and does not strictly conform to the C++17's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">/// definition of forward iterator. However, it satisfies all the</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">/// definition of forward iterator. However, it satisfies all the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">/// forward_iterator requirements that the `zip_common` and `zippy` depend on</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">/// forward_iterator requirements that the `zip_common` and `zippy` depend on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">/// and fully conforms to the C++20 definition of forward iterator.</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">/// and fully conforms to the C++20 definition of forward iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">/// This is similar to `std::vector<bool>::iterator` that returns bit reference</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">/// This is similar to `std::vector<bool>::iterator` that returns bit reference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">/// wrappers on dereference.</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">/// wrappers on dereference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">template <typename... Iters></td>
    <td class="lineNumber">2192</td>
    <td class="codeline">template <typename... Iters></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">struct zip_enumerator : zip_common<zip_enumerator<Iters...>,</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">struct zip_enumerator : zip_common<zip_enumerator<Iters...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">                                   EnumeratorTupleType<Iters...>, Iters...> {</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">                                   EnumeratorTupleType<Iters...>, Iters...> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">  static_assert(sizeof...(Iters) >= 2, "Expected at least two iteratees");</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">  static_assert(sizeof...(Iters) >= 2, "Expected at least two iteratees");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">  using zip_common<zip_enumerator<Iters...>, EnumeratorTupleType<Iters...>,</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">  using zip_common<zip_enumerator<Iters...>, EnumeratorTupleType<Iters...>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">                   Iters...>::zip_common;</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">                   Iters...>::zip_common;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline"></td>
    <td class="lineNumber">2198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">  bool operator==(const zip_enumerator &Other) const {</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">  bool operator==(const zip_enumerator &Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">    return std::get<1>(this->iterators) == std::get<1>(Other.iterators);</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">    return std::get<1>(this->iterators) == std::get<1>(Other.iterators);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline"></td>
    <td class="lineNumber">2203</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">template <typename... Refs> struct enumerator_result<std::size_t, Refs...> {</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">template <typename... Refs> struct enumerator_result<std::size_t, Refs...> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">  static constexpr std::size_t NumRefs = sizeof...(Refs);</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">  static constexpr std::size_t NumRefs = sizeof...(Refs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">  static_assert(NumRefs != 0);</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">  static_assert(NumRefs != 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">  // `NumValues` includes the index.</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">  // `NumValues` includes the index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">  static constexpr std::size_t NumValues = NumRefs + 1;</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">  static constexpr std::size_t NumValues = NumRefs + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline"></td>
    <td class="lineNumber">2209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">  // Tuple type whose element types are references for each `Ref`.</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">  // Tuple type whose element types are references for each `Ref`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">  using range_reference_tuple = std::tuple<Refs...>;</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">  using range_reference_tuple = std::tuple<Refs...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">  // Tuple type who elements are references to all values, including both</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">  // Tuple type who elements are references to all values, including both</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">  // the index and `Refs` reference types.</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">  // the index and `Refs` reference types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">  using value_reference_tuple = std::tuple<std::size_t, Refs...>;</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">  using value_reference_tuple = std::tuple<std::size_t, Refs...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline"></td>
    <td class="lineNumber">2215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">  enumerator_result(std::size_t Index, Refs &&...Rs)</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">  enumerator_result(std::size_t Index, Refs &&...Rs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">      : Idx(Index), Storage(std::forward<Refs>(Rs)...) {}</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">      : Idx(Index), Storage(std::forward<Refs>(Rs)...) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline"></td>
    <td class="lineNumber">2218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">  /// Returns the 0-based index of the current position within the original</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">  /// Returns the 0-based index of the current position within the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">  /// input range(s).</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">  /// input range(s).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">  std::size_t index() const { return Idx; }</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">  std::size_t index() const { return Idx; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline"></td>
    <td class="lineNumber">2222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">  /// Returns the value(s) for the current iterator. This does not include the</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">  /// Returns the value(s) for the current iterator. This does not include the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">  /// index.</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">  /// index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">  decltype(auto) value() const {</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">  decltype(auto) value() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">    if constexpr (NumRefs == 1)</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">    if constexpr (NumRefs == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">      return std::get<0>(Storage);</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">      return std::get<0>(Storage);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">      return Storage;</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">      return Storage;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline"></td>
    <td class="lineNumber">2231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">  /// Returns the value at index `I`. This case covers the index.</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">  /// Returns the value at index `I`. This case covers the index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">  template <std::size_t I, typename = std::enable_if_t<I == 0>></td>
    <td class="lineNumber">2233</td>
    <td class="codeline">  template <std::size_t I, typename = std::enable_if_t<I == 0>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  friend std::size_t get(const enumerator_result &Result) {</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  friend std::size_t get(const enumerator_result &Result) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">    return Result.Idx;</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">    return Result.Idx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline"></td>
    <td class="lineNumber">2237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">  /// Returns the value at index `I`. This case covers references to the</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">  /// Returns the value at index `I`. This case covers references to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">  /// iteratees.</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">  /// iteratees.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">  template <std::size_t I, typename = std::enable_if_t<I != 0>></td>
    <td class="lineNumber">2240</td>
    <td class="codeline">  template <std::size_t I, typename = std::enable_if_t<I != 0>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">  friend decltype(auto) get(const enumerator_result &Result) {</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">  friend decltype(auto) get(const enumerator_result &Result) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">    // Note: This is a separate function from the other `get`, instead of an</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">    // Note: This is a separate function from the other `get`, instead of an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">    // `if constexpr` case, to work around an MSVC 19.31.31XXX compiler</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">    // `if constexpr` case, to work around an MSVC 19.31.31XXX compiler</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">    // (Visual Studio 2022 17.1) return type deduction bug.</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">    // (Visual Studio 2022 17.1) return type deduction bug.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">    return std::get<I - 1>(Result.Storage);</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">    return std::get<I - 1>(Result.Storage);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline"></td>
    <td class="lineNumber">2247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">  template <typename... Ts></td>
    <td class="lineNumber">2248</td>
    <td class="codeline">  template <typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">  friend bool operator==(const enumerator_result &Result,</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">  friend bool operator==(const enumerator_result &Result,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">                         const std::tuple<std::size_t, Ts...> &Other) {</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">                         const std::tuple<std::size_t, Ts...> &Other) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">    static_assert(NumRefs == sizeof...(Ts), "Size mismatch");</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">    static_assert(NumRefs == sizeof...(Ts), "Size mismatch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">    if (Result.Idx != std::get<0>(Other))</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">    if (Result.Idx != std::get<0>(Other))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">    return Result.is_value_equal(Other, std::make_index_sequence<NumRefs>{});</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">    return Result.is_value_equal(Other, std::make_index_sequence<NumRefs>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline"></td>
    <td class="lineNumber">2256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  template <typename Tuple, std::size_t... Idx></td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  template <typename Tuple, std::size_t... Idx></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">  bool is_value_equal(const Tuple &Other, std::index_sequence<Idx...>) const {</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">  bool is_value_equal(const Tuple &Other, std::index_sequence<Idx...>) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    return ((std::get<Idx>(Storage) == std::get<Idx + 1>(Other)) && ...);</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    return ((std::get<Idx>(Storage) == std::get<Idx + 1>(Other)) && ...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline"></td>
    <td class="lineNumber">2262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">  std::size_t Idx;</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">  std::size_t Idx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">  // Make this tuple mutable to avoid casts that obfuscate const-correctness</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">  // Make this tuple mutable to avoid casts that obfuscate const-correctness</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  // issues. Const-correctness of references is taken care of by `zippy` that</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  // issues. Const-correctness of references is taken care of by `zippy` that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">  // defines const-non and const iterator types that will propagate down to</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">  // defines const-non and const iterator types that will propagate down to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">  // `enumerator_result`'s `Refs`.</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">  // `enumerator_result`'s `Refs`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">  //  Note that unlike the results of `zip*` functions, `enumerate`'s result are</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">  //  Note that unlike the results of `zip*` functions, `enumerate`'s result are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">  //  supposed to be modifiable even when defined as</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">  //  supposed to be modifiable even when defined as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">  // `const`.</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">  // `const`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">  mutable range_reference_tuple Storage;</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">  mutable range_reference_tuple Storage;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline"></td>
    <td class="lineNumber">2273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">/// Infinite stream of increasing 0-based `size_t` indices.</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">/// Infinite stream of increasing 0-based `size_t` indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">struct index_stream {</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">struct index_stream {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">  struct iterator : iterator_facade_base<iterator, std::forward_iterator_tag,</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">  struct iterator : iterator_facade_base<iterator, std::forward_iterator_tag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">                                         const iterator> {</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">                                         const iterator> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">    iterator &operator++() {</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">    iterator &operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">      assert(Index != std::numeric_limits<std::size_t>::max() &&</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">      assert(Index != std::numeric_limits<std::size_t>::max() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">             "Attempting to increment end iterator");</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">             "Attempting to increment end iterator");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">      ++Index;</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">      ++Index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">      return *this;</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">      return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline"></td>
    <td class="lineNumber">2284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">    // Note: This dereference operator returns a value instead of a reference</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">    // Note: This dereference operator returns a value instead of a reference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">    // and does not strictly conform to the C++17's definition of forward</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">    // and does not strictly conform to the C++17's definition of forward</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">    // iterator. However, it satisfies all the forward_iterator requirements</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">    // iterator. However, it satisfies all the forward_iterator requirements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">    // that the `zip_common` depends on and fully conforms to the C++20</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">    // that the `zip_common` depends on and fully conforms to the C++20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">    // definition of forward iterator.</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">    // definition of forward iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">    std::size_t operator*() const { return Index; }</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">    std::size_t operator*() const { return Index; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline"></td>
    <td class="lineNumber">2291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">    friend bool operator==(const iterator &Lhs, const iterator &Rhs) {</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">    friend bool operator==(const iterator &Lhs, const iterator &Rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">      return Lhs.Index == Rhs.Index;</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">      return Lhs.Index == Rhs.Index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline"></td>
    <td class="lineNumber">2295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">    std::size_t Index = 0;</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">    std::size_t Index = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline"></td>
    <td class="lineNumber">2298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">  iterator begin() const { return {}; }</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">  iterator begin() const { return {}; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">  iterator end() const {</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">  iterator end() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">    // We approximate 'infinity' with the max size_t value, which should be good</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">    // We approximate 'infinity' with the max size_t value, which should be good</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">    // enough to index over any container.</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">    // enough to index over any container.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">    iterator It;</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">    iterator It;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">    It.Index = std::numeric_limits<std::size_t>::max();</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">    It.Index = std::numeric_limits<std::size_t>::max();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">    return It;</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">    return It;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline"></td>
    <td class="lineNumber">2308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">} // end namespace detail</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">} // end namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline"></td>
    <td class="lineNumber">2310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">/// Given two or more input ranges, returns a new range whose values are are</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">/// Given two or more input ranges, returns a new range whose values are are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">/// tuples (A, B, C, ...), such that A is the 0-based index of the item in the</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">/// tuples (A, B, C, ...), such that A is the 0-based index of the item in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">/// sequence, and B, C, ..., are the values from the original input ranges. All</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">/// sequence, and B, C, ..., are the values from the original input ranges. All</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">/// input ranges are required to have equal lengths. Note that the returned</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">/// input ranges are required to have equal lengths. Note that the returned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">/// iterator allows for the values (B, C, ...) to be modified.  Example:</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">/// iterator allows for the values (B, C, ...) to be modified.  Example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">/// ```c++</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">/// ```c++</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">/// std::vector<char> Letters = {'A', 'B', 'C', 'D'};</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">/// std::vector<char> Letters = {'A', 'B', 'C', 'D'};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">/// std::vector<int> Vals = {10, 11, 12, 13};</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">/// std::vector<int> Vals = {10, 11, 12, 13};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">/// for (auto [Index, Letter, Value] : enumerate(Letters, Vals)) {</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">/// for (auto [Index, Letter, Value] : enumerate(Letters, Vals)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">///   printf("Item %zu - %c: %d\n", Index, Letter, Value);</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">///   printf("Item %zu - %c: %d\n", Index, Letter, Value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">///   Value -= 10;</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">///   Value -= 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">/// }</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">/// }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">/// Output:</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">/// Output:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">///   Item 0 - A: 10</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">///   Item 0 - A: 10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">///   Item 1 - B: 11</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">///   Item 1 - B: 11</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">///   Item 2 - C: 12</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">///   Item 2 - C: 12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">///   Item 3 - D: 13</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">///   Item 3 - D: 13</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">/// or using an iterator:</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">/// or using an iterator:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">/// ```c++</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">/// ```c++</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">/// for (auto it : enumerate(Vals)) {</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">/// for (auto it : enumerate(Vals)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">///   it.value() += 10;</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">///   it.value() += 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">///   printf("Item %zu: %d\n", it.index(), it.value());</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">///   printf("Item %zu: %d\n", it.index(), it.value());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">/// }</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">/// }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">/// Output:</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">/// Output:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">///   Item 0: 20</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">///   Item 0: 20</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">///   Item 1: 21</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">///   Item 1: 21</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">///   Item 2: 22</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">///   Item 2: 22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">///   Item 3: 23</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">///   Item 3: 23</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">template <typename FirstRange, typename... RestRanges></td>
    <td class="lineNumber">2347</td>
    <td class="codeline">template <typename FirstRange, typename... RestRanges></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">auto enumerate(FirstRange &&First, RestRanges &&...Rest) {</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">auto enumerate(FirstRange &&First, RestRanges &&...Rest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">  if constexpr (sizeof...(Rest) != 0) {</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">  if constexpr (sizeof...(Rest) != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">    // Note: Create an array instead of an initializer list to work around an</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">    // Note: Create an array instead of an initializer list to work around an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">    // Apple clang 14 compiler bug.</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">    // Apple clang 14 compiler bug.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">    size_t sizes[] = {range_size(First), range_size(Rest)...};</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">    size_t sizes[] = {range_size(First), range_size(Rest)...};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">    assert(all_equal(sizes) && "Ranges have different length");</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">    assert(all_equal(sizes) && "Ranges have different length");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">  using enumerator = detail::zippy<detail::zip_enumerator, detail::index_stream,</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">  using enumerator = detail::zippy<detail::zip_enumerator, detail::index_stream,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">                                   FirstRange, RestRanges...>;</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">                                   FirstRange, RestRanges...>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">  return enumerator(detail::index_stream{}, std::forward<FirstRange>(First),</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">  return enumerator(detail::index_stream{}, std::forward<FirstRange>(First),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">                    std::forward<RestRanges>(Rest)...);</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">                    std::forward<RestRanges>(Rest)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline"></td>
    <td class="lineNumber">2364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">template <typename Predicate, typename... Args></td>
    <td class="lineNumber">2365</td>
    <td class="codeline">template <typename Predicate, typename... Args></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">  auto z = zip(args...);</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">  auto z = zip(args...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">  auto it = z.begin();</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">  auto it = z.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">  auto end = z.end();</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">  auto end = z.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">  while (it != end) {</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">  while (it != end) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">    if (!std::apply([&](auto &&...args) { return P(args...); }, *it))</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">    if (!std::apply([&](auto &&...args) { return P(args...); }, *it))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">    ++it;</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">    ++it;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">  return it.all_equals(end);</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">  return it.all_equals(end);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline"></td>
    <td class="lineNumber">2377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">// Just an adaptor to switch the order of argument and have the predicate before</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">// Just an adaptor to switch the order of argument and have the predicate before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">// the zipped inputs.</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">// the zipped inputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">template <typename... ArgsThenPredicate, size_t... InputIndexes></td>
    <td class="lineNumber">2380</td>
    <td class="codeline">template <typename... ArgsThenPredicate, size_t... InputIndexes></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">bool all_of_zip_predicate_last(</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">bool all_of_zip_predicate_last(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">    std::tuple<ArgsThenPredicate...> argsThenPredicate,</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">    std::tuple<ArgsThenPredicate...> argsThenPredicate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">    std::index_sequence<InputIndexes...>) {</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">    std::index_sequence<InputIndexes...>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">  auto constexpr OutputIndex =</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">  auto constexpr OutputIndex =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">      std::tuple_size<decltype(argsThenPredicate)>::value - 1;</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">      std::tuple_size<decltype(argsThenPredicate)>::value - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">                             std::get<InputIndexes>(argsThenPredicate)...);</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">                             std::get<InputIndexes>(argsThenPredicate)...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline"></td>
    <td class="lineNumber">2389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">} // end namespace detail</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">} // end namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline"></td>
    <td class="lineNumber">2391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">/// Compare two zipped ranges using the provided predicate (as last argument).</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">/// Compare two zipped ranges using the provided predicate (as last argument).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">/// Return true if all elements satisfy the predicate and false otherwise.</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">/// Return true if all elements satisfy the predicate and false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">//  Return false if the zipped iterator aren't all at end (size mismatch).</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">//  Return false if the zipped iterator aren't all at end (size mismatch).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">template <typename... ArgsAndPredicate></td>
    <td class="lineNumber">2395</td>
    <td class="codeline">template <typename... ArgsAndPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">  return detail::all_of_zip_predicate_last(</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">  return detail::all_of_zip_predicate_last(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">      std::forward_as_tuple(argsAndPredicate...),</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">      std::forward_as_tuple(argsAndPredicate...),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline"></td>
    <td class="lineNumber">2401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">/// time. Not meant for use with random-access iterators.</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">/// time. Not meant for use with random-access iterators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">/// Can optionally take a predicate to filter lazily some items.</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">/// Can optionally take a predicate to filter lazily some items.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">template <typename IterTy,</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">template <typename IterTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">2406</td>
    <td class="codeline">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">bool hasNItems(</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">bool hasNItems(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">    Pred &&ShouldBeCounted =</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">    Pred &&ShouldBeCounted =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">    std::enable_if_t<</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">    std::enable_if_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">        !std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">        !std::is_base_of<std::random_access_iterator_tag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">                         typename std::iterator_traits<std::remove_reference_t<</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">                         typename std::iterator_traits<std::remove_reference_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">                             decltype(Begin)>>::iterator_category>::value,</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">                             decltype(Begin)>>::iterator_category>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">        void> * = nullptr) {</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">        void> * = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">  for (; N; ++Begin) {</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">  for (; N; ++Begin) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">    if (Begin == End)</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">    if (Begin == End)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">      return false; // Too few.</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">      return false; // Too few.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">    N -= ShouldBeCounted(*Begin);</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">    N -= ShouldBeCounted(*Begin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">  for (; Begin != End; ++Begin)</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">  for (; Begin != End; ++Begin)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">    if (ShouldBeCounted(*Begin))</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">    if (ShouldBeCounted(*Begin))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">      return false; // Too many.</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">      return false; // Too many.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline"></td>
    <td class="lineNumber">2426</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">/// time. Not meant for use with random-access iterators.</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">/// time. Not meant for use with random-access iterators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">/// Can optionally take a predicate to lazily filter some items.</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">/// Can optionally take a predicate to lazily filter some items.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">template <typename IterTy,</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">template <typename IterTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">2431</td>
    <td class="codeline">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">bool hasNItemsOrMore(</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">bool hasNItemsOrMore(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">    Pred &&ShouldBeCounted =</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">    Pred &&ShouldBeCounted =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">    std::enable_if_t<</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">    std::enable_if_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">        !std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">        !std::is_base_of<std::random_access_iterator_tag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">                         typename std::iterator_traits<std::remove_reference_t<</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">                         typename std::iterator_traits<std::remove_reference_t<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">                             decltype(Begin)>>::iterator_category>::value,</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">                             decltype(Begin)>>::iterator_category>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">        void> * = nullptr) {</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">        void> * = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">  for (; N; ++Begin) {</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">  for (; N; ++Begin) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">    if (Begin == End)</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">    if (Begin == End)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">      return false; // Too few.</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">      return false; // Too few.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">    N -= ShouldBeCounted(*Begin);</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">    N -= ShouldBeCounted(*Begin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">/// Returns true if the sequence [Begin, End) has N or less items. Can</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">/// Returns true if the sequence [Begin, End) has N or less items. Can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">/// optionally take a predicate to lazily filter some items.</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">/// optionally take a predicate to lazily filter some items.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">template <typename IterTy,</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">template <typename IterTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">2452</td>
    <td class="codeline">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">bool hasNItemsOrLess(</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">bool hasNItemsOrLess(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">    }) {</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">    }) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">  assert(N != std::numeric_limits<unsigned>::max());</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">  assert(N != std::numeric_limits<unsigned>::max());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline"></td>
    <td class="lineNumber">2461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">/// Returns true if the given container has exactly N items</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">/// Returns true if the given container has exactly N items</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">  return hasNItems(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">  return hasNItems(std::begin(C), std::end(C), N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline"></td>
    <td class="lineNumber">2466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">/// Returns true if the given container has N or more items</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">/// Returns true if the given container has N or more items</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">template <typename ContainerTy></td>
    <td class="lineNumber">2468</td>
    <td class="codeline">template <typename ContainerTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">  return hasNItemsOrMore(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">  return hasNItemsOrMore(std::begin(C), std::end(C), N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">/// Returns true if the given container has N or less items</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">/// Returns true if the given container has N or less items</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">template <typename ContainerTy></td>
    <td class="lineNumber">2474</td>
    <td class="codeline">template <typename ContainerTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">  return hasNItemsOrLess(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">  return hasNItemsOrLess(std::begin(C), std::end(C), N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline"></td>
    <td class="lineNumber">2478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">/// Returns a raw pointer that represents the same address as the argument.</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">/// Returns a raw pointer that represents the same address as the argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">/// This implementation can be removed once we move to C++20 where it's defined</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">/// This implementation can be removed once we move to C++20 where it's defined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">/// as std::to_address().</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">/// as std::to_address().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">/// The std::pointer_traits<>::to_address(p) variations of these overloads has</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">/// The std::pointer_traits<>::to_address(p) variations of these overloads has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">/// not been implemented.</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">/// not been implemented.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">template <class T> constexpr T *to_address(T *P) { return P; }</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">template <class T> constexpr T *to_address(T *P) { return P; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline"></td>
    <td class="lineNumber">2488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline"></td>
    <td class="lineNumber">2490</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">namespace std {</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">namespace std {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">template <typename... Refs></td>
    <td class="lineNumber">2492</td>
    <td class="codeline">template <typename... Refs></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">struct tuple_size<llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">2493</td>
    <td class="codeline">struct tuple_size<llvm::detail::enumerator_result<Refs...>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">    : std::integral_constant<std::size_t, sizeof...(Refs)> {};</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">    : std::integral_constant<std::size_t, sizeof...(Refs)> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline"></td>
    <td class="lineNumber">2495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">template <std::size_t I, typename... Refs></td>
    <td class="lineNumber">2496</td>
    <td class="codeline">template <std::size_t I, typename... Refs></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">struct tuple_element<I, llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">2497</td>
    <td class="codeline">struct tuple_element<I, llvm::detail::enumerator_result<Refs...>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline"></td>
    <td class="lineNumber">2499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">template <std::size_t I, typename... Refs></td>
    <td class="lineNumber">2500</td>
    <td class="codeline">template <std::size_t I, typename... Refs></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">struct tuple_element<I, const llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">2501</td>
    <td class="codeline">struct tuple_element<I, const llvm::detail::enumerator_result<Refs...>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline"></td>
    <td class="lineNumber">2503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">} // namespace std</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">} // namespace std</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline"></td>
    <td class="lineNumber">2505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">#endif // LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">#endif // LLVM_ADT_STLEXTRAS_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline"></td>
    <td class="lineNumber">2507</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This file contains some templates that are useful if you are working with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This file contains some templates that are useful if you are working with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// the STL at all.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// the STL at all.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">/// No library is required when using these functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">/// No library is required when using these functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#ifndef LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#ifndef LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#define LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#define LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/ADL.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/ADL.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/Hashing.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/ADT/STLForwardCompat.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/ADT/STLForwardCompat.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/STLFunctionalExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/STLFunctionalExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/identity.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/identity.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Config/abi-breaking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Config/abi-breaking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include <cstdlib></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include <cstdlib></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include <functional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include <functional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include <initializer_list></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include <initializer_list></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include <limits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include <limits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include <type_traits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include <type_traits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include <random> // for std::mt19937</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include <random> // for std::mt19937</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">//     Extra additions to <type_traits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">//     Extra additions to <type_traits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">template <typename T> struct make_const_ptr {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">template <typename T> struct make_const_ptr {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">  using type = std::add_pointer_t<std::add_const_t<T>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">  using type = std::add_pointer_t<std::add_const_t<T>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">template <typename T> struct make_const_ref {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">template <typename T> struct make_const_ref {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">  using type = std::add_lvalue_reference_t<std::add_const_t<T>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">  using type = std::add_lvalue_reference_t<std::add_const_t<T>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">template <class, template <class...> class Op, class... Args> struct detector {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">template <class, template <class...> class Op, class... Args> struct detector {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">  using value_t = std::false_type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">  using value_t = std::false_type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">template <template <class...> class Op, class... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">template <template <class...> class Op, class... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">struct detector<std::void_t<Op<Args...>>, Op, Args...> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">struct detector<std::void_t<Op<Args...>>, Op, Args...> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">  using value_t = std::true_type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">  using value_t = std::true_type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">/// Detects if a given trait holds for some set of arguments 'Args'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">/// Detects if a given trait holds for some set of arguments 'Args'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">/// For example, the given trait could be used to detect if a given type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">/// For example, the given trait could be used to detect if a given type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">/// has a copy assignment operator:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">/// has a copy assignment operator:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">///   template<class T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">///   template<class T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">///   using has_copy_assign_t = decltype(std::declval<T&>()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">///   using has_copy_assign_t = decltype(std::declval<T&>()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">///                                                 = std::declval<const T&>());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">///                                                 = std::declval<const T&>());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">template <template <class...> class Op, class... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">template <template <class...> class Op, class... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">using is_detected = typename detail::detector<void, Op, Args...>::value_t;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">using is_detected = typename detail::detector<void, Op, Args...>::value_t;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">/// This class provides various trait information about a callable object.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">/// This class provides various trait information about a callable object.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">///   * To access the number of arguments: Traits::num_args</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">///   * To access the number of arguments: Traits::num_args</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">///   * To access the type of an argument: Traits::arg_t<Index></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">///   * To access the type of an argument: Traits::arg_t<Index></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">///   * To access the type of the result:  Traits::result_t</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">///   * To access the type of the result:  Traits::result_t</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">template <typename T, bool isClass = std::is_class<T>::value></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">template <typename T, bool isClass = std::is_class<T>::value></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">struct function_traits : public function_traits<decltype(&T::operator())> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">struct function_traits : public function_traits<decltype(&T::operator())> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">/// Overload for class function types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">/// Overload for class function types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">template <typename ClassType, typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">template <typename ClassType, typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  /// The number of arguments to this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  /// The number of arguments to this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  enum { num_args = sizeof...(Args) };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  enum { num_args = sizeof...(Args) };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  /// The result type of this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  /// The result type of this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">  using result_t = ReturnType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">  using result_t = ReturnType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  /// The type of an argument to this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  /// The type of an argument to this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  template <size_t Index></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  template <size_t Index></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  using arg_t = std::tuple_element_t<Index, std::tuple<Args...>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  using arg_t = std::tuple_element_t<Index, std::tuple<Args...>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">/// Overload for class function types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">/// Overload for class function types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">template <typename ClassType, typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">template <typename ClassType, typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">struct function_traits<ReturnType (ClassType::*)(Args...), false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">struct function_traits<ReturnType (ClassType::*)(Args...), false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">/// Overload for non-class function types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">/// Overload for non-class function types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">struct function_traits<ReturnType (*)(Args...), false> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">struct function_traits<ReturnType (*)(Args...), false> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  /// The number of arguments to this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  /// The number of arguments to this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  enum { num_args = sizeof...(Args) };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  enum { num_args = sizeof...(Args) };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  /// The result type of this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  /// The result type of this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">  using result_t = ReturnType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">  using result_t = ReturnType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">  /// The type of an argument to this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">  /// The type of an argument to this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">  template <size_t i></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">  template <size_t i></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  using arg_t = std::tuple_element_t<i, std::tuple<Args...>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  using arg_t = std::tuple_element_t<i, std::tuple<Args...>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">struct function_traits<ReturnType (*const)(Args...), false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">struct function_traits<ReturnType (*const)(Args...), false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">    : public function_traits<ReturnType (*)(Args...)> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">    : public function_traits<ReturnType (*)(Args...)> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">/// Overload for non-class function type references.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">/// Overload for non-class function type references.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">template <typename ReturnType, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">struct function_traits<ReturnType (&)(Args...), false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">struct function_traits<ReturnType (&)(Args...), false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">    : public function_traits<ReturnType (*)(Args...)> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">    : public function_traits<ReturnType (*)(Args...)> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">/// traits class for checking whether type T is one of any of the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">/// traits class for checking whether type T is one of any of the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">/// types in the variadic list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">/// types in the variadic list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">template <typename T, typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">template <typename T, typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">/// traits class for checking whether type T is a base class for all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">/// traits class for checking whether type T is a base class for all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">///  the given types in the variadic list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">///  the given types in the variadic list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">template <typename T, typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">template <typename T, typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">template <typename T, typename... Us> struct TypesAreDistinct;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">template <typename T, typename... Us> struct TypesAreDistinct;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">template <typename T, typename... Us></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">template <typename T, typename... Us></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">struct TypesAreDistinct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">struct TypesAreDistinct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">                                       TypesAreDistinct<Us...>::value> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">                                       TypesAreDistinct<Us...>::value> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">template <typename T> struct TypesAreDistinct<T> : std::true_type {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">template <typename T> struct TypesAreDistinct<T> : std::true_type {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">/// Determine if all types in Ts are distinct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">/// Determine if all types in Ts are distinct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">/// Useful to statically assert when Ts is intended to describe a non-multi set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">/// Useful to statically assert when Ts is intended to describe a non-multi set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">/// of types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">/// of types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">/// Expensive (currently quadratic in sizeof(Ts...)), and so should only be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">/// Expensive (currently quadratic in sizeof(Ts...)), and so should only be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">/// asserted once per instantiation of a type which requires it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">/// asserted once per instantiation of a type which requires it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">template <typename... Ts> struct TypesAreDistinct;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">template <typename... Ts> struct TypesAreDistinct;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">template <> struct TypesAreDistinct<> : std::true_type {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">template <> struct TypesAreDistinct<> : std::true_type {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">template <typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">template <typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">struct TypesAreDistinct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">struct TypesAreDistinct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">/// Find the first index where a type appears in a list of types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">/// Find the first index where a type appears in a list of types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">/// FirstIndexOfType<T, Us...>::value is the first index of T in Us.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">/// FirstIndexOfType<T, Us...>::value is the first index of T in Us.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">/// Typically only meaningful when it is otherwise statically known that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">/// Typically only meaningful when it is otherwise statically known that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">/// type pack has no duplicate types. This should be guaranteed explicitly with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">/// type pack has no duplicate types. This should be guaranteed explicitly with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">/// static_assert(TypesAreDistinct<Us...>::value).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">/// static_assert(TypesAreDistinct<Us...>::value).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">/// It is a compile-time error to instantiate when T is not present in Us, i.e.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">/// It is a compile-time error to instantiate when T is not present in Us, i.e.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">/// if is_one_of<T, Us...>::value is false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">/// if is_one_of<T, Us...>::value is false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">template <typename T, typename... Us> struct FirstIndexOfType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">template <typename T, typename... Us> struct FirstIndexOfType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">template <typename T, typename U, typename... Us></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">template <typename T, typename U, typename... Us></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">struct FirstIndexOfType<T, U, Us...></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">struct FirstIndexOfType<T, U, Us...></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">template <typename T, typename... Us></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">template <typename T, typename... Us></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">/// Find the type at a given index in a list of types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">/// Find the type at a given index in a list of types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">/// TypeAtIndex<I, Ts...> is the type at index I in Ts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">/// TypeAtIndex<I, Ts...> is the type at index I in Ts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">template <size_t I, typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">template <size_t I, typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">/// Helper which adds two underlying types of enumeration type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">/// Helper which adds two underlying types of enumeration type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">/// Implicit conversion to a common type is accepted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">/// Implicit conversion to a common type is accepted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">template <typename EnumTy1, typename EnumTy2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">template <typename EnumTy1, typename EnumTy2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">                                          std::underlying_type_t<EnumTy1>>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">                                          std::underlying_type_t<EnumTy1>>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">                                          std::underlying_type_t<EnumTy2>>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">                                          std::underlying_type_t<EnumTy2>>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">//     Extra additions to <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">//     Extra additions to <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">namespace callable_detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">namespace callable_detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">/// Templated storage wrapper for a callable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">/// Templated storage wrapper for a callable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">/// This class is consistently default constructible, copy / move</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">/// This class is consistently default constructible, copy / move</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">/// constructible / assignable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">/// constructible / assignable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">/// Supported callable types:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">/// Supported callable types:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">///  - Function pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">///  - Function pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">///  - Function reference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">///  - Function reference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">///  - Lambda</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">///  - Lambda</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">///  - Function object</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">///  - Function object</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">template <typename T,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">template <typename T,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">          bool = std::is_function_v<std::remove_pointer_t<remove_cvref_t<T>>>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">          bool = std::is_function_v<std::remove_pointer_t<remove_cvref_t<T>>>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">class Callable {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">class Callable {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  using value_type = std::remove_reference_t<T>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  using value_type = std::remove_reference_t<T>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  using reference = value_type &;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  using reference = value_type &;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  using const_reference = value_type const &;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  using const_reference = value_type const &;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  std::optional<value_type> Obj;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  std::optional<value_type> Obj;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  static_assert(!std::is_pointer_v<value_type>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  static_assert(!std::is_pointer_v<value_type>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">                "Pointers to non-functions are not callable.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">                "Pointers to non-functions are not callable.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  Callable() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  Callable() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  Callable(T const &O) : Obj(std::in_place, O) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  Callable(T const &O) : Obj(std::in_place, O) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  Callable(Callable const &Other) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  Callable(Callable const &Other) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  Callable(Callable &&Other) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  Callable(Callable &&Other) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  Callable &operator=(Callable const &Other) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  Callable &operator=(Callable const &Other) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">    Obj = std::nullopt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">    Obj = std::nullopt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">    if (Other.Obj)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">    if (Other.Obj)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">      Obj.emplace(*Other.Obj);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">      Obj.emplace(*Other.Obj);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  Callable &operator=(Callable &&Other) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  Callable &operator=(Callable &&Other) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    Obj = std::nullopt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    Obj = std::nullopt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">    if (Other.Obj)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">    if (Other.Obj)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">      Obj.emplace(std::move(*Other.Obj));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">      Obj.emplace(std::move(*Other.Obj));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  template <typename... Pn,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  template <typename... Pn,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  decltype(auto) operator()(Pn &&...Params) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  decltype(auto) operator()(Pn &&...Params) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">    return (*Obj)(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">    return (*Obj)(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  template <typename... Pn,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  template <typename... Pn,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">            std::enable_if_t<std::is_invocable_v<T const, Pn...>, int> = 0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">            std::enable_if_t<std::is_invocable_v<T const, Pn...>, int> = 0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  decltype(auto) operator()(Pn &&...Params) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  decltype(auto) operator()(Pn &&...Params) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">    return (*Obj)(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">    return (*Obj)(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  bool valid() const { return Obj != std::nullopt; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  bool valid() const { return Obj != std::nullopt; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  bool reset() { return Obj = std::nullopt; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  bool reset() { return Obj = std::nullopt; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  operator reference() { return *Obj; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  operator reference() { return *Obj; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  operator const_reference() const { return *Obj; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  operator const_reference() const { return *Obj; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">// Function specialization.  No need to waste extra space wrapping with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">// Function specialization.  No need to waste extra space wrapping with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">// std::optional.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">// std::optional.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">template <typename T> class Callable<T, true> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">template <typename T> class Callable<T, true> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  static constexpr bool IsPtr = std::is_pointer_v<remove_cvref_t<T>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  static constexpr bool IsPtr = std::is_pointer_v<remove_cvref_t<T>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  using StorageT = std::conditional_t<IsPtr, T, std::remove_reference_t<T> *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  using StorageT = std::conditional_t<IsPtr, T, std::remove_reference_t<T> *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  using CastT = std::conditional_t<IsPtr, T, T &>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  using CastT = std::conditional_t<IsPtr, T, T &>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  StorageT Func = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  StorageT Func = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine coveredLine">  template <typename In> static constexpr auto convertIn(In &&I) {</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">273</td>
    <td class="codeLine coveredLine">  template <typename In> static constexpr auto convertIn(In &&I) {</td>
    <td class="lineNumber">82</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">    if constexpr (IsPtr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">    if constexpr (IsPtr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">      // Pointer... just echo it back.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">      // Pointer... just echo it back.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine coveredLine">      return I;</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">276</td>
    <td class="codeLine coveredLine">      return I;</td>
    <td class="lineNumber">82</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">      // Must be a function reference.  Return its address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">      // Must be a function reference.  Return its address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">      return &I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">      return &I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  Callable() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  Callable() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  // Construct from a function pointer or reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  // Construct from a function pointer or reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  // Disable this constructor for references to 'Callable' so we don't violate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  // Disable this constructor for references to 'Callable' so we don't violate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  // the rule of 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  // the rule of 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  template < // clang-format off</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  template < // clang-format off</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">    typename FnPtrOrRef,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">    typename FnPtrOrRef,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    std::enable_if_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    std::enable_if_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">      !std::is_same_v<remove_cvref_t<FnPtrOrRef>, Callable>, int</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">      !std::is_same_v<remove_cvref_t<FnPtrOrRef>, Callable>, int</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">    > = 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">    > = 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  > // clang-format on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  > // clang-format on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine coveredLine">  Callable(FnPtrOrRef &&F) : Func(convertIn(F)) {}</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">296</td>
    <td class="codeLine coveredLine">  Callable(FnPtrOrRef &&F) : Func(convertIn(F)) {}</td>
    <td class="lineNumber">82</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  template <typename... Pn,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  template <typename... Pn,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine coveredLine">  decltype(auto) operator()(Pn &&...Params) const {</td>
    <td class="lineNumber">66</td>
    <td class="lineNumber">300</td>
    <td class="codeLine coveredLine">  decltype(auto) operator()(Pn &&...Params) const {</td>
    <td class="lineNumber">69</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine coveredLine">    return Func(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">66</td>
    <td class="lineNumber">301</td>
    <td class="codeLine coveredLine">    return Func(std::forward<Pn>(Params)...);</td>
    <td class="lineNumber">69</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  bool valid() const { return Func != nullptr; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  bool valid() const { return Func != nullptr; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  void reset() { Func = nullptr; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  void reset() { Func = nullptr; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  operator T const &() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  operator T const &() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    if constexpr (IsPtr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    if constexpr (IsPtr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">      // T is a pointer... just echo it back.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">      // T is a pointer... just echo it back.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">      return Func;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">      return Func;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">      static_assert(std::is_reference_v<T>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">      static_assert(std::is_reference_v<T>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">                    "Expected a reference to a function.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">                    "Expected a reference to a function.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">      // T is a function reference... dereference the stored pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">      // T is a function reference... dereference the stored pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">      return *Func;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">      return *Func;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">} // namespace callable_detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">} // namespace callable_detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">/// Returns true if the given container only contains a single element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">/// Returns true if the given container only contains a single element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine coveredLine">template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">323</td>
    <td class="codeLine coveredLine">template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine coveredLine">  auto B = std::begin(C), E = std::end(C);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">324</td>
    <td class="codeLine coveredLine">  auto B = std::begin(C), E = std::end(C);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine coveredLine">  return B != E && std::next(B) == E;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">325</td>
    <td class="codeLine coveredLine">  return B != E && std::next(B) == E;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">/// Return a range covering \p RangeOrContainer with the first N elements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">/// Return a range covering \p RangeOrContainer with the first N elements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">/// excluded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">/// excluded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine coveredLine">template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {</td>
    <td class="lineNumber">69</td>
    <td class="lineNumber">330</td>
    <td class="codeLine coveredLine">template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {</td>
    <td class="lineNumber">66</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine coveredLine">  return make_range(std::next(adl_begin(RangeOrContainer), N),</td>
    <td class="lineNumber">69</td>
    <td class="lineNumber">331</td>
    <td class="codeLine coveredLine">  return make_range(std::next(adl_begin(RangeOrContainer), N),</td>
    <td class="lineNumber">66</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine coveredLine">                    adl_end(RangeOrContainer));</td>
    <td class="lineNumber">69</td>
    <td class="lineNumber">332</td>
    <td class="codeLine coveredLine">                    adl_end(RangeOrContainer));</td>
    <td class="lineNumber">66</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">/// Return a range covering \p RangeOrContainer with the last N elements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">/// Return a range covering \p RangeOrContainer with the last N elements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">/// excluded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">/// excluded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  return make_range(adl_begin(RangeOrContainer),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  return make_range(adl_begin(RangeOrContainer),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">                    std::prev(adl_end(RangeOrContainer), N));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">                    std::prev(adl_end(RangeOrContainer), N));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">// mapped_iterator - This is a simple iterator adapter that causes a function to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">// mapped_iterator - This is a simple iterator adapter that causes a function to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">// be applied whenever operator* is invoked on the iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">// be applied whenever operator* is invoked on the iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">template <typename ItTy, typename FuncTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">template <typename ItTy, typename FuncTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">          typename ReferenceTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">          typename ReferenceTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">class mapped_iterator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">class mapped_iterator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">          mapped_iterator<ItTy, FuncTy>, ItTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">          mapped_iterator<ItTy, FuncTy>, ItTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">          typename std::iterator_traits<ItTy>::iterator_category,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">          typename std::iterator_traits<ItTy>::iterator_category,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">          std::remove_reference_t<ReferenceTy>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">          std::remove_reference_t<ReferenceTy>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">          typename std::iterator_traits<ItTy>::difference_type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">          typename std::iterator_traits<ItTy>::difference_type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  mapped_iterator() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  mapped_iterator() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine coveredLine">  mapped_iterator(ItTy U, FuncTy F)</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">357</td>
    <td class="codeLine coveredLine">  mapped_iterator(ItTy U, FuncTy F)</td>
    <td class="lineNumber">82</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine coveredLine">    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">358</td>
    <td class="codeLine coveredLine">    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}</td>
    <td class="lineNumber">82</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  ItTy getCurrent() { return this->I; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  ItTy getCurrent() { return this->I; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  const FuncTy &getFunction() const { return F; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  const FuncTy &getFunction() const { return F; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine coveredLine">  ReferenceTy operator*() const { return F(*this->I); }</td>
    <td class="lineNumber">66</td>
    <td class="lineNumber">364</td>
    <td class="codeLine coveredLine">  ReferenceTy operator*() const { return F(*this->I); }</td>
    <td class="lineNumber">69</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  callable_detail::Callable<FuncTy> F{};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  callable_detail::Callable<FuncTy> F{};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">// map_iterator - Provide a convenient way to create mapped_iterators, just like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">// map_iterator - Provide a convenient way to create mapped_iterators, just like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">// make_pair is useful for creating pairs...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">// make_pair is useful for creating pairs...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">template <class ItTy, class FuncTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">template <class ItTy, class FuncTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine coveredLine">inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">373</td>
    <td class="codeLine coveredLine">inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {</td>
    <td class="lineNumber">82</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine coveredLine">  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));</td>
    <td class="lineNumber">78</td>
    <td class="lineNumber">374</td>
    <td class="codeLine coveredLine">  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));</td>
    <td class="lineNumber">82</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">template <class ContainerTy, class FuncTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">template <class ContainerTy, class FuncTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">auto map_range(ContainerTy &&C, FuncTy F) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">auto map_range(ContainerTy &&C, FuncTy F) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  return make_range(map_iterator(std::begin(C), F),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  return make_range(map_iterator(std::begin(C), F),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">                    map_iterator(std::end(C), F));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">                    map_iterator(std::end(C), F));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">/// A base type of mapped iterator, that is useful for building derived</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">/// A base type of mapped iterator, that is useful for building derived</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">/// iterators that do not need/want to store the map function (as in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">/// iterators that do not need/want to store the map function (as in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">/// mapped_iterator). These iterators must simply provide a `mapElement` method</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">/// mapped_iterator). These iterators must simply provide a `mapElement` method</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">/// that defines how to map a value of the iterator to the provided reference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">/// that defines how to map a value of the iterator to the provided reference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">/// type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">/// type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">template <typename DerivedT, typename ItTy, typename ReferenceTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">template <typename DerivedT, typename ItTy, typename ReferenceTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">class mapped_iterator_base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">class mapped_iterator_base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">          DerivedT, ItTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">          DerivedT, ItTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">          typename std::iterator_traits<ItTy>::iterator_category,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">          typename std::iterator_traits<ItTy>::iterator_category,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">          std::remove_reference_t<ReferenceTy>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">          std::remove_reference_t<ReferenceTy>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">          typename std::iterator_traits<ItTy>::difference_type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">          typename std::iterator_traits<ItTy>::difference_type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  using BaseT = mapped_iterator_base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  using BaseT = mapped_iterator_base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  mapped_iterator_base(ItTy U)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  mapped_iterator_base(ItTy U)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  ItTy getCurrent() { return this->I; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  ItTy getCurrent() { return this->I; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  ReferenceTy operator*() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  ReferenceTy operator*() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    return static_cast<const DerivedT &>(*this).mapElement(*this->I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    return static_cast<const DerivedT &>(*this).mapElement(*this->I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">/// Helper to determine if type T has a member called rbegin().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">/// Helper to determine if type T has a member called rbegin().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">template <typename Ty> class has_rbegin_impl {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">template <typename Ty> class has_rbegin_impl {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  using yes = char[1];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  using yes = char[1];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  using no = char[2];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  using no = char[2];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  template <typename Inner></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  template <typename Inner></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  template <typename></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  template <typename></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  static no& test(...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  static no& test(...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">/// Metafunction to determine if T& or T has a member called rbegin().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">/// Metafunction to determine if T& or T has a member called rbegin().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">template <typename Ty></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">template <typename Ty></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">struct has_rbegin : has_rbegin_impl<std::remove_reference_t<Ty>> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">struct has_rbegin : has_rbegin_impl<std::remove_reference_t<Ty>> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">// Returns an iterator_range over the given container which iterates in reverse.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">// Returns an iterator_range over the given container which iterates in reverse.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine coveredLine">template <typename ContainerTy> auto reverse(ContainerTy &&C) {</td>
    <td class="lineNumber">93</td>
    <td class="lineNumber">429</td>
    <td class="codeLine coveredLine">template <typename ContainerTy> auto reverse(ContainerTy &&C) {</td>
    <td class="lineNumber">83</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  if constexpr (has_rbegin<ContainerTy>::value)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  if constexpr (has_rbegin<ContainerTy>::value)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine coveredLine">    return make_range(C.rbegin(), C.rend());</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">431</td>
    <td class="codeLine coveredLine">    return make_range(C.rbegin(), C.rend());</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">    return make_range(std::make_reverse_iterator(std::end(C)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">    return make_range(std::make_reverse_iterator(std::end(C)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine coveredLine">                      std::make_reverse_iterator(std::begin(C)));</td>
    <td class="lineNumber">81</td>
    <td class="lineNumber">434</td>
    <td class="codeLine coveredLine">                      std::make_reverse_iterator(std::begin(C)));</td>
    <td class="lineNumber">77</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">/// An iterator adaptor that filters the elements of given inner iterators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">/// An iterator adaptor that filters the elements of given inner iterators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">/// The predicate parameter should be a callable object that accepts the wrapped</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">/// The predicate parameter should be a callable object that accepts the wrapped</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">/// iterator's reference type and returns a bool. When incrementing or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">/// iterator's reference type and returns a bool. When incrementing or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">/// decrementing the iterator, it will call the predicate on each element and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">/// decrementing the iterator, it will call the predicate on each element and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">/// skip any where it returns false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">/// skip any where it returns false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">///   int A[] = { 1, 2, 3, 4 };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">///   int A[] = { 1, 2, 3, 4 };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">///   // R contains { 1, 3 }.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">///   // R contains { 1, 3 }.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">/// Note: filter_iterator_base implements support for forward iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">/// Note: filter_iterator_base implements support for forward iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">/// filter_iterator_impl exists to provide support for bidirectional iteration,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">/// filter_iterator_impl exists to provide support for bidirectional iteration,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">/// conditional on whether the wrapped iterator supports it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">/// conditional on whether the wrapped iterator supports it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">template <typename WrappedIteratorT, typename PredicateT, typename IterTag></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">template <typename WrappedIteratorT, typename PredicateT, typename IterTag></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">class filter_iterator_base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">class filter_iterator_base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">    : public iterator_adaptor_base<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">          WrappedIteratorT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">          WrappedIteratorT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">          std::common_type_t<IterTag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">          std::common_type_t<IterTag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">                             typename std::iterator_traits<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">                             typename std::iterator_traits<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">                                 WrappedIteratorT>::iterator_category>> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">                                 WrappedIteratorT>::iterator_category>> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  using BaseT = typename filter_iterator_base::iterator_adaptor_base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  using BaseT = typename filter_iterator_base::iterator_adaptor_base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  WrappedIteratorT End;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  WrappedIteratorT End;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  PredicateT Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  PredicateT Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine coveredLine">  void findNextValid() {</td>
    <td class="lineNumber">32</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  void findNextValid() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine coveredLine">    while (this->I != End && !Pred(*this->I))</td>
    <td class="lineNumber">58</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">    while (this->I != End && !Pred(*this->I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine coveredLine">      BaseT::operator++();</td>
    <td class="lineNumber">26</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">      BaseT::operator++();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">32</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  filter_iterator_base() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  filter_iterator_base() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  // Construct the iterator. The begin iterator needs to know where the end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  // Construct the iterator. The begin iterator needs to know where the end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  // is, so that it can properly stop when it gets there. The end iterator only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  // is, so that it can properly stop when it gets there. The end iterator only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  // needs the predicate to support bidirectional iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  // needs the predicate to support bidirectional iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine coveredLine">  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">26</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">                       PredicateT Pred)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">                       PredicateT Pred)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine coveredLine">      : BaseT(Begin), End(End), Pred(Pred) {</td>
    <td class="lineNumber">26</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">      : BaseT(Begin), End(End), Pred(Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine coveredLine">    findNextValid();</td>
    <td class="lineNumber">26</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">    findNextValid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">26</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  using BaseT::operator++;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  using BaseT::operator++;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine coveredLine">  filter_iterator_base &operator++() {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  filter_iterator_base &operator++() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine coveredLine">    BaseT::operator++();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">    BaseT::operator++();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine coveredLine">    findNextValid();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">    findNextValid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine coveredLine">  decltype(auto) operator*() const {</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  decltype(auto) operator*() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine coveredLine">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine coveredLine">    return BaseT::operator*();</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">    return BaseT::operator*();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  decltype(auto) operator->() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  decltype(auto) operator->() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    return BaseT::operator->();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    return BaseT::operator->();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">/// Specialization of filter_iterator_base for forward iteration only.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">/// Specialization of filter_iterator_base for forward iteration only.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">template <typename WrappedIteratorT, typename PredicateT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">template <typename WrappedIteratorT, typename PredicateT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">          typename IterTag = std::forward_iterator_tag></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">          typename IterTag = std::forward_iterator_tag></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">class filter_iterator_impl</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">class filter_iterator_impl</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  filter_iterator_impl() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  filter_iterator_impl() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">                       PredicateT Pred)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">                       PredicateT Pred)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">/// Specialization of filter_iterator_base for bidirectional iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">/// Specialization of filter_iterator_base for bidirectional iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">template <typename WrappedIteratorT, typename PredicateT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">template <typename WrappedIteratorT, typename PredicateT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">class filter_iterator_impl<WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">class filter_iterator_impl<WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">                           std::bidirectional_iterator_tag></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">                           std::bidirectional_iterator_tag></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">    : public filter_iterator_base<WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">    : public filter_iterator_base<WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">                                  std::bidirectional_iterator_tag> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">                                  std::bidirectional_iterator_tag> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  using BaseT = typename filter_iterator_impl::filter_iterator_base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  using BaseT = typename filter_iterator_impl::filter_iterator_base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  void findPrevValid() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  void findPrevValid() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">    while (!this->Pred(*this->I))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">    while (!this->Pred(*this->I))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">      BaseT::operator--();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">      BaseT::operator--();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  using BaseT::operator--;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  using BaseT::operator--;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  filter_iterator_impl() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  filter_iterator_impl() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine coveredLine">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">26</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">                       PredicateT Pred)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">                       PredicateT Pred)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine coveredLine">      : BaseT(Begin, End, Pred) {}</td>
    <td class="lineNumber">26</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">      : BaseT(Begin, End, Pred) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  filter_iterator_impl &operator--() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  filter_iterator_impl &operator--() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    BaseT::operator--();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    BaseT::operator--();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">    findPrevValid();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">    findPrevValid();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  using type = std::forward_iterator_tag;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  using type = std::forward_iterator_tag;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">template <> struct fwd_or_bidi_tag_impl<true> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">template <> struct fwd_or_bidi_tag_impl<true> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  using type = std::bidirectional_iterator_tag;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  using type = std::bidirectional_iterator_tag;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">/// Helper which sets its type member to forward_iterator_tag if the category</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">/// Helper which sets its type member to forward_iterator_tag if the category</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">/// of \p IterT does not derive from bidirectional_iterator_tag, and to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">/// of \p IterT does not derive from bidirectional_iterator_tag, and to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">/// bidirectional_iterator_tag otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">/// bidirectional_iterator_tag otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">template <typename IterT> struct fwd_or_bidi_tag {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">template <typename IterT> struct fwd_or_bidi_tag {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">      std::bidirectional_iterator_tag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">      std::bidirectional_iterator_tag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">      typename std::iterator_traits<IterT>::iterator_category>::value>::type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">      typename std::iterator_traits<IterT>::iterator_category>::value>::type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">/// Defines filter_iterator to a suitable specialization of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">/// Defines filter_iterator to a suitable specialization of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">/// filter_iterator_impl, based on the underlying iterator's category.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">/// filter_iterator_impl, based on the underlying iterator's category.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">template <typename WrappedIteratorT, typename PredicateT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">template <typename WrappedIteratorT, typename PredicateT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">using filter_iterator = filter_iterator_impl<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">using filter_iterator = filter_iterator_impl<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">    WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">    WrappedIteratorT, PredicateT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">/// Convenience function that takes a range of elements and a predicate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">/// Convenience function that takes a range of elements and a predicate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">/// and return a new filter_iterator range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">/// and return a new filter_iterator range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">/// lifetime of that temporary is not kept by the returned range object, and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">/// lifetime of that temporary is not kept by the returned range object, and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">/// temporary is going to be dropped on the floor after the make_iterator_range</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">/// temporary is going to be dropped on the floor after the make_iterator_range</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">/// full expression that contains this function call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">/// full expression that contains this function call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">template <typename RangeT, typename PredicateT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">template <typename RangeT, typename PredicateT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine coveredLine">make_filter_range(RangeT &&Range, PredicateT Pred) {</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">make_filter_range(RangeT &&Range, PredicateT Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  using FilterIteratorT =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  using FilterIteratorT =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine coveredLine">  return make_range(</td>
    <td class="lineNumber">65</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  return make_range(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine coveredLine">      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine coveredLine">                      std::end(std::forward<RangeT>(Range)), Pred),</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">                      std::end(std::forward<RangeT>(Range)), Pred),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine coveredLine">      FilterIteratorT(std::end(std::forward<RangeT>(Range)),</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">      FilterIteratorT(std::end(std::forward<RangeT>(Range)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine coveredLine">                      std::end(std::forward<RangeT>(Range)), Pred));</td>
    <td class="lineNumber">26</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">                      std::end(std::forward<RangeT>(Range)), Pred));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">/// A pseudo-iterator adaptor that is designed to implement "early increment"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">/// A pseudo-iterator adaptor that is designed to implement "early increment"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">/// style loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">/// style loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">/// This is *not a normal iterator* and should almost never be used directly. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">/// This is *not a normal iterator* and should almost never be used directly. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">/// is intended primarily to be used with range based for loops and some range</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">/// is intended primarily to be used with range based for loops and some range</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">/// algorithms.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">/// algorithms.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">/// somewhere between them. The constraints of these iterators are:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">/// somewhere between them. The constraints of these iterators are:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">/// - On construction or after being incremented, it is comparable and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">/// - On construction or after being incremented, it is comparable and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">///   dereferencable. It is *not* incrementable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">///   dereferencable. It is *not* incrementable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">/// - After being dereferenced, it is neither comparable nor dereferencable, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">/// - After being dereferenced, it is neither comparable nor dereferencable, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">///   is only incrementable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">///   is only incrementable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">/// This means you can only dereference the iterator once, and you can only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">/// This means you can only dereference the iterator once, and you can only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">/// increment it once between dereferences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">/// increment it once between dereferences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">template <typename WrappedIteratorT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">template <typename WrappedIteratorT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">class early_inc_iterator_impl</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">class early_inc_iterator_impl</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">                                   WrappedIteratorT, std::input_iterator_tag> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">                                   WrappedIteratorT, std::input_iterator_tag> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  bool IsEarlyIncremented = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  bool IsEarlyIncremented = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine coveredLine">  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">623</td>
    <td class="codeLine coveredLine">  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}</td>
    <td class="lineNumber">76</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  using BaseT::operator*;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  using BaseT::operator*;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine coveredLine">  decltype(*std::declval<WrappedIteratorT>()) operator*() {</td>
    <td class="lineNumber">159</td>
    <td class="lineNumber">626</td>
    <td class="codeLine coveredLine">  decltype(*std::declval<WrappedIteratorT>()) operator*() {</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine coveredLine">    assert(!IsEarlyIncremented && "Cannot dereference twice!");</td>
    <td class="lineNumber">159</td>
    <td class="lineNumber">628</td>
    <td class="codeLine coveredLine">    assert(!IsEarlyIncremented && "Cannot dereference twice!");</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine coveredLine">    IsEarlyIncremented = true;</td>
    <td class="lineNumber">159</td>
    <td class="lineNumber">629</td>
    <td class="codeLine coveredLine">    IsEarlyIncremented = true;</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine coveredLine">    return *(this->I)++;</td>
    <td class="lineNumber">159</td>
    <td class="lineNumber">631</td>
    <td class="codeLine coveredLine">    return *(this->I)++;</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  using BaseT::operator++;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  using BaseT::operator++;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine coveredLine">  early_inc_iterator_impl &operator++() {</td>
    <td class="lineNumber">159</td>
    <td class="lineNumber">635</td>
    <td class="codeLine coveredLine">  early_inc_iterator_impl &operator++() {</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine coveredLine">    assert(IsEarlyIncremented && "Cannot increment before dereferencing!");</td>
    <td class="lineNumber">159</td>
    <td class="lineNumber">637</td>
    <td class="codeLine coveredLine">    assert(IsEarlyIncremented && "Cannot increment before dereferencing!");</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine coveredLine">    IsEarlyIncremented = false;</td>
    <td class="lineNumber">159</td>
    <td class="lineNumber">638</td>
    <td class="codeLine coveredLine">    IsEarlyIncremented = false;</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">159</td>
    <td class="lineNumber">640</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">195</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine coveredLine">  friend bool operator==(const early_inc_iterator_impl &LHS,</td>
    <td class="lineNumber">189</td>
    <td class="lineNumber">643</td>
    <td class="codeLine coveredLine">  friend bool operator==(const early_inc_iterator_impl &LHS,</td>
    <td class="lineNumber">233</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">                         const early_inc_iterator_impl &RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">                         const early_inc_iterator_impl &RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">#if LLVM_ENABLE_ABI_BREAKING_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine coveredLine">    assert(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!");</td>
    <td class="lineNumber">189</td>
    <td class="lineNumber">646</td>
    <td class="codeLine coveredLine">    assert(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!");</td>
    <td class="lineNumber">233</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine coveredLine">    return (const BaseT &)LHS == (const BaseT &)RHS;</td>
    <td class="lineNumber">189</td>
    <td class="lineNumber">648</td>
    <td class="codeLine coveredLine">    return (const BaseT &)LHS == (const BaseT &)RHS;</td>
    <td class="lineNumber">233</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">/// Make a range that does early increment to allow mutation of the underlying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">/// Make a range that does early increment to allow mutation of the underlying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">/// range without disrupting iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">/// range without disrupting iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">/// The underlying iterator will be incremented immediately after it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">/// The underlying iterator will be incremented immediately after it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">/// dereferenced, allowing deletion of the current node or insertion of nodes to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">/// dereferenced, allowing deletion of the current node or insertion of nodes to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">/// not disrupt iteration provided they do not invalidate the *next* iterator --</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">/// not disrupt iteration provided they do not invalidate the *next* iterator --</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">/// the current iterator can be invalidated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">/// the current iterator can be invalidated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">/// This requires a very exact pattern of use that is only really suitable to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">/// This requires a very exact pattern of use that is only really suitable to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">/// range based for loops and other range algorithms that explicitly guarantee</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">/// range based for loops and other range algorithms that explicitly guarantee</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">/// to dereference exactly once each element, and to increment exactly once each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">/// to dereference exactly once each element, and to increment exactly once each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">/// element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">/// element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">template <typename RangeT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">template <typename RangeT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine coveredLine">make_early_inc_range(RangeT &&Range) {</td>
    <td class="lineNumber">30</td>
    <td class="lineNumber">666</td>
    <td class="codeLine coveredLine">make_early_inc_range(RangeT &&Range) {</td>
    <td class="lineNumber">38</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  using EarlyIncIteratorT =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  using EarlyIncIteratorT =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine coveredLine">  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">669</td>
    <td class="codeLine coveredLine">  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),</td>
    <td class="lineNumber">76</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine coveredLine">                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));</td>
    <td class="lineNumber">54</td>
    <td class="lineNumber">670</td>
    <td class="codeLine coveredLine">                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));</td>
    <td class="lineNumber">62</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">// Forward declarations required by zip_shortest/zip_equal/zip_first/zip_longest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">// Forward declarations required by zip_shortest/zip_equal/zip_first/zip_longest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">bool all_of(R &&range, UnaryPredicate P);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">bool all_of(R &&range, UnaryPredicate P);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">bool any_of(R &&range, UnaryPredicate P);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">bool any_of(R &&range, UnaryPredicate P);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">template <typename T> bool all_equal(std::initializer_list<T> Values);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">template <typename T> bool all_equal(std::initializer_list<T> Values);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">template <typename R> constexpr size_t range_size(R &&Range);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">template <typename R> constexpr size_t range_size(R &&Range);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">using std::declval;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">using std::declval;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">// We have to alias this since inlining the actual type at the usage site</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">// We have to alias this since inlining the actual type at the usage site</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">template<typename... Iters> struct ZipTupleType {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">template<typename... Iters> struct ZipTupleType {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  using type = std::tuple<decltype(*declval<Iters>())...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  using type = std::tuple<decltype(*declval<Iters>())...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">using zip_traits = iterator_facade_base<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">using zip_traits = iterator_facade_base<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">    ZipType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">    ZipType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    std::common_type_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    std::common_type_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">        std::bidirectional_iterator_tag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">        std::bidirectional_iterator_tag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">        typename std::iterator_traits<Iters>::iterator_category...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">        typename std::iterator_traits<Iters>::iterator_category...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">    // ^ TODO: Implement random access methods.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">    // ^ TODO: Implement random access methods.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    ReferenceTupleType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    ReferenceTupleType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">    typename std::iterator_traits<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">    typename std::iterator_traits<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">        std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">        std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    // inner iterators have the same difference_type. It would fail if, for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    // inner iterators have the same difference_type. It would fail if, for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    // instance, the second field's difference_type were non-numeric while the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    // instance, the second field's difference_type were non-numeric while the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">    // first is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">    // first is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">    ReferenceTupleType *, ReferenceTupleType>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">    ReferenceTupleType *, ReferenceTupleType>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">template <typename ZipType, typename ReferenceTupleType, typename... Iters></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">struct zip_common : public zip_traits<ZipType, ReferenceTupleType, Iters...> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">struct zip_common : public zip_traits<ZipType, ReferenceTupleType, Iters...> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  using Base = zip_traits<ZipType, ReferenceTupleType, Iters...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  using Base = zip_traits<ZipType, ReferenceTupleType, Iters...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  using IndexSequence = std::index_sequence_for<Iters...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  using IndexSequence = std::index_sequence_for<Iters...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  using value_type = typename Base::value_type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  using value_type = typename Base::value_type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  std::tuple<Iters...> iterators;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  std::tuple<Iters...> iterators;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">719</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine coveredLine">    return value_type(*std::get<Ns>(iterators)...);</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">720</td>
    <td class="codeLine coveredLine">    return value_type(*std::get<Ns>(iterators)...);</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> void tup_inc(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">723</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> void tup_inc(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine coveredLine">    (++std::get<Ns>(iterators), ...);</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">724</td>
    <td class="codeLine coveredLine">    (++std::get<Ns>(iterators), ...);</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">725</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">  template <size_t... Ns> void tup_dec(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">  template <size_t... Ns> void tup_dec(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">    (--std::get<Ns>(iterators), ...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">    (--std::get<Ns>(iterators), ...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  bool test_all_equals(const zip_common &other,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  bool test_all_equals(const zip_common &other,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">                       std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">                       std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">            ...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">            ...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine coveredLine">  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}</td>
    <td class="lineNumber">18</td>
    <td class="lineNumber">739</td>
    <td class="codeLine coveredLine">  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine coveredLine">  value_type operator*() const { return deref(IndexSequence{}); }</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">741</td>
    <td class="codeLine coveredLine">  value_type operator*() const { return deref(IndexSequence{}); }</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine coveredLine">  ZipType &operator++() {</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">743</td>
    <td class="codeLine coveredLine">  ZipType &operator++() {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine coveredLine">    tup_inc(IndexSequence{});</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">744</td>
    <td class="codeLine coveredLine">    tup_inc(IndexSequence{});</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine coveredLine">    return static_cast<ZipType &>(*this);</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">745</td>
    <td class="codeLine coveredLine">    return static_cast<ZipType &>(*this);</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  ZipType &operator--() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  ZipType &operator--() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">    static_assert(Base::IsBidirectional,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">    static_assert(Base::IsBidirectional,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">                  "All inner iterators must be at least bidirectional.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">                  "All inner iterators must be at least bidirectional.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    tup_dec(IndexSequence{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    tup_dec(IndexSequence{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">    return static_cast<ZipType &>(*this);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">    return static_cast<ZipType &>(*this);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">  /// Return true if all the iterator are matching `other`'s iterators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">  /// Return true if all the iterator are matching `other`'s iterators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  bool all_equals(zip_common &other) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  bool all_equals(zip_common &other) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">    return test_all_equals(other, IndexSequence{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">    return test_all_equals(other, IndexSequence{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">struct zip_first : zip_common<zip_first<Iters...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">struct zip_first : zip_common<zip_first<Iters...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">                              typename ZipTupleType<Iters...>::type, Iters...> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">                              typename ZipTupleType<Iters...>::type, Iters...> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">  using zip_common<zip_first, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">  using zip_common<zip_first, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">                   Iters...>::zip_common;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">                   Iters...>::zip_common;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  bool operator==(const zip_first &other) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  bool operator==(const zip_first &other) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    return std::get<0>(this->iterators) == std::get<0>(other.iterators);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    return std::get<0>(this->iterators) == std::get<0>(other.iterators);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">struct zip_shortest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">struct zip_shortest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">    : zip_common<zip_shortest<Iters...>, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">    : zip_common<zip_shortest<Iters...>, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">                 Iters...> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">                 Iters...> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  using zip_common<zip_shortest, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  using zip_common<zip_shortest, typename ZipTupleType<Iters...>::type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">                   Iters...>::zip_common;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">                   Iters...>::zip_common;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  bool operator==(const zip_shortest &other) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  bool operator==(const zip_shortest &other) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">    return any_iterator_equals(other, std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">    return any_iterator_equals(other, std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">  bool any_iterator_equals(const zip_shortest &other,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">  bool any_iterator_equals(const zip_shortest &other,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">                           std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">                           std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">            ...);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">            ...);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">/// Helper to obtain the iterator types for the tuple storage within `zippy`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">/// Helper to obtain the iterator types for the tuple storage within `zippy`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">template <template <typename...> class ItType, typename TupleStorageType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">template <template <typename...> class ItType, typename TupleStorageType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">          typename IndexSequence></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">          typename IndexSequence></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">struct ZippyIteratorTuple;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">struct ZippyIteratorTuple;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">/// Partial specialization for non-const tuple storage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">/// Partial specialization for non-const tuple storage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">template <template <typename...> class ItType, typename... Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">template <template <typename...> class ItType, typename... Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">          std::size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">          std::size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">struct ZippyIteratorTuple<ItType, std::tuple<Args...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">struct ZippyIteratorTuple<ItType, std::tuple<Args...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">                          std::index_sequence<Ns...>> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">                          std::index_sequence<Ns...>> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">  using type = ItType<decltype(adl_begin(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">  using type = ItType<decltype(adl_begin(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">      std::get<Ns>(declval<std::tuple<Args...> &>())))...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">      std::get<Ns>(declval<std::tuple<Args...> &>())))...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">/// Partial specialization for const tuple storage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">/// Partial specialization for const tuple storage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">template <template <typename...> class ItType, typename... Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">template <template <typename...> class ItType, typename... Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">          std::size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">          std::size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">struct ZippyIteratorTuple<ItType, const std::tuple<Args...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">struct ZippyIteratorTuple<ItType, const std::tuple<Args...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">                          std::index_sequence<Ns...>> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">                          std::index_sequence<Ns...>> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  using type = ItType<decltype(adl_begin(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  using type = ItType<decltype(adl_begin(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">      std::get<Ns>(declval<const std::tuple<Args...> &>())))...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">      std::get<Ns>(declval<const std::tuple<Args...> &>())))...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">template <template <typename...> class ItType, typename... Args> class zippy {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">template <template <typename...> class ItType, typename... Args> class zippy {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  std::tuple<Args...> storage;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  std::tuple<Args...> storage;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  using IndexSequence = std::index_sequence_for<Args...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  using IndexSequence = std::index_sequence_for<Args...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  using iterator = typename ZippyIteratorTuple<ItType, decltype(storage),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  using iterator = typename ZippyIteratorTuple<ItType, decltype(storage),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">                                               IndexSequence>::type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">                                               IndexSequence>::type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  using const_iterator =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  using const_iterator =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">      typename ZippyIteratorTuple<ItType, const decltype(storage),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">      typename ZippyIteratorTuple<ItType, const decltype(storage),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">                                  IndexSequence>::type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">                                  IndexSequence>::type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  using iterator_category = typename iterator::iterator_category;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  using iterator_category = typename iterator::iterator_category;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  using value_type = typename iterator::value_type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  using value_type = typename iterator::value_type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  using difference_type = typename iterator::difference_type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  using difference_type = typename iterator::difference_type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  using pointer = typename iterator::pointer;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  using pointer = typename iterator::pointer;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  using reference = typename iterator::reference;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  using reference = typename iterator::reference;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  using const_reference = typename const_iterator::reference;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  using const_reference = typename const_iterator::reference;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine coveredLine">  zippy(Args &&...args) : storage(std::forward<Args>(args)...) {}</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">833</td>
    <td class="codeLine coveredLine">  zippy(Args &&...args) : storage(std::forward<Args>(args)...) {}</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  const_iterator begin() const { return begin_impl(IndexSequence{}); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  const_iterator begin() const { return begin_impl(IndexSequence{}); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine coveredLine">  iterator begin() { return begin_impl(IndexSequence{}); }</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">836</td>
    <td class="codeLine coveredLine">  iterator begin() { return begin_impl(IndexSequence{}); }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  const_iterator end() const { return end_impl(IndexSequence{}); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  const_iterator end() const { return end_impl(IndexSequence{}); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine coveredLine">  iterator end() { return end_impl(IndexSequence{}); }</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">838</td>
    <td class="codeLine coveredLine">  iterator end() { return end_impl(IndexSequence{}); }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  const_iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  const_iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">    return const_iterator(adl_begin(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">    return const_iterator(adl_begin(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">845</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine coveredLine">    return iterator(adl_begin(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">846</td>
    <td class="codeLine coveredLine">    return iterator(adl_begin(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">  const_iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">  const_iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">    return const_iterator(adl_end(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">    return const_iterator(adl_end(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">853</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine coveredLine">    return iterator(adl_end(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">854</td>
    <td class="codeLine coveredLine">    return iterator(adl_end(std::get<Ns>(storage))...);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">/// zip iterator for two or more iteratable types. Iteration continues until the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">/// zip iterator for two or more iteratable types. Iteration continues until the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">/// end of the *shortest* iteratee is reached.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">/// end of the *shortest* iteratee is reached.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">                                                       Args &&...args) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">                                                       Args &&...args) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  return detail::zippy<detail::zip_shortest, T, U, Args...>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  return detail::zippy<detail::zip_shortest, T, U, Args...>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">/// zip iterator that assumes that all iteratees have the same length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">/// zip iterator that assumes that all iteratees have the same length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">/// In builds with assertions on, this assumption is checked before the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">/// In builds with assertions on, this assumption is checked before the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">/// iteration starts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">/// iteration starts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">detail::zippy<detail::zip_first, T, U, Args...> zip_equal(T &&t, U &&u,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">detail::zippy<detail::zip_first, T, U, Args...> zip_equal(T &&t, U &&u,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">                                                          Args &&...args) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">                                                          Args &&...args) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  assert(all_equal({range_size(t), range_size(u), range_size(args)...}) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  assert(all_equal({range_size(t), range_size(u), range_size(args)...}) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">         "Iteratees do not have equal length");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">         "Iteratees do not have equal length");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">/// zip iterator that, for the sake of efficiency, assumes the first iteratee to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">/// zip iterator that, for the sake of efficiency, assumes the first iteratee to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">/// be the shortest. Iteration continues until the end of the first iteratee is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">/// be the shortest. Iteration continues until the end of the first iteratee is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">/// reached. In builds with assertions on, we check that the assumption about</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">/// reached. In builds with assertions on, we check that the assumption about</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">/// the first iteratee being the shortest holds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">/// the first iteratee being the shortest holds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">                                                          Args &&...args) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">                                                          Args &&...args) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  assert(range_size(t) <= std::min({range_size(u), range_size(args)...}) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  assert(range_size(t) <= std::min({range_size(u), range_size(args)...}) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">         "First iteratee is not the shortest");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">         "First iteratee is not the shortest");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  return detail::zippy<detail::zip_first, T, U, Args...>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">template <typename Iter></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">template <typename Iter></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">Iter next_or_end(const Iter &I, const Iter &End) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">Iter next_or_end(const Iter &I, const Iter &End) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">  if (I == End)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">  if (I == End)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">    return End;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">    return End;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">  return std::next(I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">  return std::next(I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">template <typename Iter></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">template <typename Iter></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">auto deref_or_none(const Iter &I, const Iter &End) -> std::optional<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">auto deref_or_none(const Iter &I, const Iter &End) -> std::optional<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">  if (I == End)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">  if (I == End)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  return *I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  return *I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">template <typename Iter> struct ZipLongestItemType {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">template <typename Iter> struct ZipLongestItemType {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  using type = std::optional<std::remove_const_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  using type = std::optional<std::remove_const_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">      std::remove_reference_t<decltype(*std::declval<Iter>())>>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">      std::remove_reference_t<decltype(*std::declval<Iter>())>>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">template <typename... Iters> struct ZipLongestTupleType {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">template <typename... Iters> struct ZipLongestTupleType {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">class zip_longest_iterator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">class zip_longest_iterator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">    : public iterator_facade_base<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">    : public iterator_facade_base<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">          zip_longest_iterator<Iters...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">          zip_longest_iterator<Iters...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">          std::common_type_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">          std::common_type_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">              std::forward_iterator_tag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">              std::forward_iterator_tag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">              typename std::iterator_traits<Iters>::iterator_category...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">              typename std::iterator_traits<Iters>::iterator_category...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">          typename ZipLongestTupleType<Iters...>::type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">          typename ZipLongestTupleType<Iters...>::type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">          typename std::iterator_traits<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">          typename std::iterator_traits<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">              std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">              std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">          typename ZipLongestTupleType<Iters...>::type *,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">          typename ZipLongestTupleType<Iters...>::type *,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">          typename ZipLongestTupleType<Iters...>::type> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">          typename ZipLongestTupleType<Iters...>::type> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">  using value_type = typename ZipLongestTupleType<Iters...>::type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">  using value_type = typename ZipLongestTupleType<Iters...>::type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">  std::tuple<Iters...> iterators;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">  std::tuple<Iters...> iterators;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  std::tuple<Iters...> end_iterators;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  std::tuple<Iters...> end_iterators;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">  bool test(const zip_longest_iterator<Iters...> &other,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">  bool test(const zip_longest_iterator<Iters...> &other,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">            std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">            std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">    return ((std::get<Ns>(this->iterators) != std::get<Ns>(other.iterators)) ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">    return ((std::get<Ns>(this->iterators) != std::get<Ns>(other.iterators)) ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">            ...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">            ...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">    return value_type(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">    return value_type(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">    return std::tuple<Iters...>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">    return std::tuple<Iters...>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">      : iterators(std::forward<Iters>(ts.first)...),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">      : iterators(std::forward<Iters>(ts.first)...),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">        end_iterators(std::forward<Iters>(ts.second)...) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">        end_iterators(std::forward<Iters>(ts.second)...) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  value_type operator*() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  value_type operator*() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">    return deref(std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">    return deref(std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  zip_longest_iterator<Iters...> &operator++() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  zip_longest_iterator<Iters...> &operator++() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">    iterators = tup_inc(std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">    iterators = tup_inc(std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">  bool operator==(const zip_longest_iterator<Iters...> &other) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">  bool operator==(const zip_longest_iterator<Iters...> &other) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">    return !test(other, std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">    return !test(other, std::index_sequence_for<Iters...>{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">template <typename... Args> class zip_longest_range {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">template <typename... Args> class zip_longest_range {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  using iterator =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  using iterator =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">  using iterator_category = typename iterator::iterator_category;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">  using iterator_category = typename iterator::iterator_category;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  using value_type = typename iterator::value_type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  using value_type = typename iterator::value_type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">  using difference_type = typename iterator::difference_type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">  using difference_type = typename iterator::difference_type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  using pointer = typename iterator::pointer;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  using pointer = typename iterator::pointer;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  using reference = typename iterator::reference;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  using reference = typename iterator::reference;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">  std::tuple<Args...> ts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">  std::tuple<Args...> ts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">                                   adl_end(std::get<Ns>(ts)))...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">                                   adl_end(std::get<Ns>(ts)))...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">                                   adl_end(std::get<Ns>(ts)))...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">                                   adl_end(std::get<Ns>(ts)))...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">  iterator begin() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">  iterator begin() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">    return begin_impl(std::index_sequence_for<Args...>{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">    return begin_impl(std::index_sequence_for<Args...>{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">/// Iterate over two or more iterators at the same time. Iteration continues</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">/// Iterate over two or more iterators at the same time. Iteration continues</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">/// until all iterators reach the end. The std::optional only contains a value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">/// until all iterators reach the end. The std::optional only contains a value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">/// if the iterator has not reached the end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">/// if the iterator has not reached the end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">template <typename T, typename U, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">                                                     Args &&... args) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">                                                     Args &&... args) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  return detail::zip_longest_range<T, U, Args...>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  return detail::zip_longest_range<T, U, Args...>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">/// Iterator wrapper that concatenates sequences together.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">/// Iterator wrapper that concatenates sequences together.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">/// This can concatenate different iterators, even with different types, into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">/// This can concatenate different iterators, even with different types, into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">/// a single iterator provided the value types of all the concatenated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">/// a single iterator provided the value types of all the concatenated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">/// iterators expose `reference` and `pointer` types that can be converted to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">/// iterators expose `reference` and `pointer` types that can be converted to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">/// `ValueT &` and `ValueT *` respectively. It doesn't support more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">/// `ValueT &` and `ValueT *` respectively. It doesn't support more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">/// interesting/customized pointer or reference types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">/// interesting/customized pointer or reference types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">/// Currently this only supports forward or higher iterator categories as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">/// Currently this only supports forward or higher iterator categories as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">/// inputs and always exposes a forward iterator interface.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">/// inputs and always exposes a forward iterator interface.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">template <typename ValueT, typename... IterTs></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">template <typename ValueT, typename... IterTs></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">class concat_iterator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">class concat_iterator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">                                  std::forward_iterator_tag, ValueT> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">                                  std::forward_iterator_tag, ValueT> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  using BaseT = typename concat_iterator::iterator_facade_base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  using BaseT = typename concat_iterator::iterator_facade_base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  /// We store both the current and end iterators for each concatenated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  /// We store both the current and end iterators for each concatenated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">  /// sequence in a tuple of pairs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">  /// sequence in a tuple of pairs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  /// Note that something like iterator_range seems nice at first here, but the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  /// Note that something like iterator_range seems nice at first here, but the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  /// range properties are of little benefit and end up getting in the way</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  /// range properties are of little benefit and end up getting in the way</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  /// because we need to do mutation on the current iterators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  /// because we need to do mutation on the current iterators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  std::tuple<IterTs...> Begins;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  std::tuple<IterTs...> Begins;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  std::tuple<IterTs...> Ends;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  std::tuple<IterTs...> Ends;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  /// Attempts to increment a specific iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  /// Attempts to increment a specific iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">  /// Returns true if it was able to increment the iterator. Returns false if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">  /// Returns true if it was able to increment the iterator. Returns false if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  /// the iterator is already at the end iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  /// the iterator is already at the end iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine coveredLine">  template <size_t Index> bool incrementHelper() {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine coveredLine">  template <size_t Index> bool incrementHelper() {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine coveredLine">    auto &Begin = std::get<Index>(Begins);</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine coveredLine">    auto &Begin = std::get<Index>(Begins);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine coveredLine">    auto &End = std::get<Index>(Ends);</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine coveredLine">    auto &End = std::get<Index>(Ends);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine coveredLine">    if (Begin == End)</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine coveredLine">    if (Begin == End)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine coveredLine">    ++Begin;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine coveredLine">    ++Begin;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine coveredLine">    return true;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine coveredLine">    return true;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  /// Increments the first non-end iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  /// Increments the first non-end iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  /// It is an error to call this with all iterators at the end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  /// It is an error to call this with all iterators at the end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">    // Build a sequence of functions to increment each iterator if possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">    // Build a sequence of functions to increment each iterator if possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine coveredLine">    bool (concat_iterator::*IncrementHelperFns[])() = {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine coveredLine">    bool (concat_iterator::*IncrementHelperFns[])() = {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">        &concat_iterator::incrementHelper<Ns>...};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">        &concat_iterator::incrementHelper<Ns>...};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // Loop over them, and stop as soon as we succeed at incrementing one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // Loop over them, and stop as soon as we succeed at incrementing one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine coveredLine">    for (auto &IncrementHelperFn : IncrementHelperFns)</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine coveredLine">    for (auto &IncrementHelperFn : IncrementHelperFns)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine coveredLine">      if ((this->*IncrementHelperFn)())</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine coveredLine">      if ((this->*IncrementHelperFn)())</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine coveredLine">        return;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine coveredLine">        return;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">    llvm_unreachable("Attempted to increment an end concat iterator!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">    llvm_unreachable("Attempted to increment an end concat iterator!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">  /// Returns null if the specified iterator is at the end. Otherwise,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">  /// Returns null if the specified iterator is at the end. Otherwise,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  /// dereferences the iterator and returns the address of the resulting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  /// dereferences the iterator and returns the address of the resulting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">  /// reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">  /// reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine coveredLine">  template <size_t Index> ValueT *getHelper() const {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine coveredLine">  template <size_t Index> ValueT *getHelper() const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine coveredLine">    auto &Begin = std::get<Index>(Begins);</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine coveredLine">    auto &Begin = std::get<Index>(Begins);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine coveredLine">    auto &End = std::get<Index>(Ends);</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine coveredLine">    auto &End = std::get<Index>(Ends);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine coveredLine">    if (Begin == End)</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine coveredLine">    if (Begin == End)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine coveredLine">    return &*Begin;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine coveredLine">    return &*Begin;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// Finds the first non-end iterator, dereferences, and returns the resulting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// Finds the first non-end iterator, dereferences, and returns the resulting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  /// It is an error to call this with all iterators at the end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  /// It is an error to call this with all iterators at the end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">    // Build a sequence of functions to get from iterator if possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">    // Build a sequence of functions to get from iterator if possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine coveredLine">    ValueT *(concat_iterator::*GetHelperFns[])() const = {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine coveredLine">    ValueT *(concat_iterator::*GetHelperFns[])() const = {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">        &concat_iterator::getHelper<Ns>...};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">        &concat_iterator::getHelper<Ns>...};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">    // Loop over them, and return the first result we find.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">    // Loop over them, and return the first result we find.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine coveredLine">    for (auto &GetHelperFn : GetHelperFns)</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine coveredLine">    for (auto &GetHelperFn : GetHelperFns)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine coveredLine">      if (ValueT *P = (this->*GetHelperFn)())</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine coveredLine">      if (ValueT *P = (this->*GetHelperFn)())</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine coveredLine">        return *P;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine coveredLine">        return *P;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    llvm_unreachable("Attempted to get a pointer from an end concat iterator!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    llvm_unreachable("Attempted to get a pointer from an end concat iterator!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// Constructs an iterator from a sequence of ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// Constructs an iterator from a sequence of ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  /// We need the full range to know how to switch between each of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  /// We need the full range to know how to switch between each of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  /// iterators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  /// iterators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">  template <typename... RangeTs></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">  template <typename... RangeTs></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine coveredLine">  explicit concat_iterator(RangeTs &&... Ranges)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine coveredLine">  explicit concat_iterator(RangeTs &&... Ranges)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine coveredLine">      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine coveredLine">      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  using BaseT::operator++;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  using BaseT::operator++;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine coveredLine">  concat_iterator &operator++() {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine coveredLine">  concat_iterator &operator++() {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine coveredLine">    increment(std::index_sequence_for<IterTs...>());</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine coveredLine">    increment(std::index_sequence_for<IterTs...>());</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine coveredLine">    return *this;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine coveredLine">  ValueT &operator*() const {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine coveredLine">  ValueT &operator*() const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine coveredLine">    return get(std::index_sequence_for<IterTs...>());</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine coveredLine">    return get(std::index_sequence_for<IterTs...>());</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine coveredLine">  bool operator==(const concat_iterator &RHS) const {</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine coveredLine">  bool operator==(const concat_iterator &RHS) const {</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine coveredLine">    return Begins == RHS.Begins && Ends == RHS.Ends;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine coveredLine">    return Begins == RHS.Begins && Ends == RHS.Ends;</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">/// Helper to store a sequence of ranges being concatenated and access them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">/// Helper to store a sequence of ranges being concatenated and access them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">/// This is designed to facilitate providing actual storage when temporaries</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">/// This is designed to facilitate providing actual storage when temporaries</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">/// are passed into the constructor such that we can use it as part of range</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">/// are passed into the constructor such that we can use it as part of range</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">/// based for loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">/// based for loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">template <typename ValueT, typename... RangeTs> class concat_range {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">template <typename ValueT, typename... RangeTs> class concat_range {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">  using iterator =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">  using iterator =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">      concat_iterator<ValueT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">      concat_iterator<ValueT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">                      decltype(std::begin(std::declval<RangeTs &>()))...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">                      decltype(std::begin(std::declval<RangeTs &>()))...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">  std::tuple<RangeTs...> Ranges;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">  std::tuple<RangeTs...> Ranges;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">  iterator begin_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">  iterator begin_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    return iterator(std::get<Ns>(Ranges)...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    return iterator(std::get<Ns>(Ranges)...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  template <size_t... Ns></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine coveredLine">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine coveredLine">  iterator begin_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine coveredLine">    return iterator(std::get<Ns>(Ranges)...);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine coveredLine">    return iterator(std::get<Ns>(Ranges)...);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">                               std::end(std::get<Ns>(Ranges)))...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">                               std::end(std::get<Ns>(Ranges)))...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine coveredLine">  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine coveredLine">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine coveredLine">    return iterator(make_range(std::end(std::get<Ns>(Ranges)),</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine coveredLine">                               std::end(std::get<Ns>(Ranges)))...);</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine coveredLine">                               std::end(std::get<Ns>(Ranges)))...);</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine coveredLine">  concat_range(RangeTs &&... Ranges)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine coveredLine">  concat_range(RangeTs &&... Ranges)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine coveredLine">      : Ranges(std::forward<RangeTs>(Ranges)...) {}</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine coveredLine">      : Ranges(std::forward<RangeTs>(Ranges)...) {}</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  iterator begin() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  iterator begin() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine coveredLine">  iterator begin() const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine coveredLine">  iterator begin() const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine coveredLine">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine coveredLine">    return begin_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  iterator end() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  iterator end() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine coveredLine">  iterator end() const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine coveredLine">  iterator end() const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine coveredLine">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine coveredLine">    return end_impl(std::index_sequence_for<RangeTs...>{});</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">/// Concatenated range across two or more ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">/// Concatenated range across two or more ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">/// The desired value type must be explicitly specified.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">/// The desired value type must be explicitly specified.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">template <typename ValueT, typename... RangeTs></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">template <typename ValueT, typename... RangeTs></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine coveredLine">detail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine coveredLine">detail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  static_assert(sizeof...(RangeTs) > 1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  static_assert(sizeof...(RangeTs) > 1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">                "Need more than one range to concatenate!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">                "Need more than one range to concatenate!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  return detail::concat_range<ValueT, RangeTs...>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  return detail::concat_range<ValueT, RangeTs...>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine coveredLine">      std::forward<RangeTs>(Ranges)...);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine coveredLine">      std::forward<RangeTs>(Ranges)...);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">/// A utility class used to implement an iterator that contains some base object</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">/// A utility class used to implement an iterator that contains some base object</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">/// and an index. The iterator moves the index but keeps the base constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">/// and an index. The iterator moves the index but keeps the base constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">class indexed_accessor_iterator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">class indexed_accessor_iterator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">    : public llvm::iterator_facade_base<DerivedT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">    : public llvm::iterator_facade_base<DerivedT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">                                        std::random_access_iterator_tag, T,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">                                        std::random_access_iterator_tag, T,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">                                        std::ptrdiff_t, PointerT, ReferenceT> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">                                        std::ptrdiff_t, PointerT, ReferenceT> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">    assert(base == rhs.base && "incompatible iterators");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">    assert(base == rhs.base && "incompatible iterators");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">    return index - rhs.index;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">    return index - rhs.index;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">  bool operator==(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">  bool operator==(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">    return base == rhs.base && index == rhs.index;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">    return base == rhs.base && index == rhs.index;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  bool operator<(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  bool operator<(const indexed_accessor_iterator &rhs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">    assert(base == rhs.base && "incompatible iterators");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">    assert(base == rhs.base && "incompatible iterators");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">    return index < rhs.index;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">    return index < rhs.index;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  DerivedT &operator+=(ptrdiff_t offset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  DerivedT &operator+=(ptrdiff_t offset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">    this->index += offset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">    this->index += offset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">    return static_cast<DerivedT &>(*this);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">    return static_cast<DerivedT &>(*this);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  DerivedT &operator-=(ptrdiff_t offset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  DerivedT &operator-=(ptrdiff_t offset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">    this->index -= offset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">    this->index -= offset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">    return static_cast<DerivedT &>(*this);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">    return static_cast<DerivedT &>(*this);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  /// Returns the current index of the iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  /// Returns the current index of the iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  ptrdiff_t getIndex() const { return index; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  ptrdiff_t getIndex() const { return index; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// Returns the current base of the iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// Returns the current base of the iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  const BaseT &getBase() const { return base; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  const BaseT &getBase() const { return base; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  indexed_accessor_iterator(BaseT base, ptrdiff_t index)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  indexed_accessor_iterator(BaseT base, ptrdiff_t index)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">      : base(base), index(index) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">      : base(base), index(index) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  BaseT base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  BaseT base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  ptrdiff_t index;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  ptrdiff_t index;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">/// The class represents the base of a range of indexed_accessor_iterators. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">/// The class represents the base of a range of indexed_accessor_iterators. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">/// provides support for many different range functionalities, e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">/// provides support for many different range functionalities, e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">/// drop_front/slice/etc.. Derived range classes must implement the following</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">/// drop_front/slice/etc.. Derived range classes must implement the following</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">/// static methods:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">/// static methods:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">///     - Dereference an iterator pointing to the base object at the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">///     - Dereference an iterator pointing to the base object at the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">///       index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">///       index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">///     - Return a new base that is offset from the provide base by 'index'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">///     - Return a new base that is offset from the provide base by 'index'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">///       elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">///       elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">class indexed_accessor_range_base {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">class indexed_accessor_range_base {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  using RangeBaseT = indexed_accessor_range_base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  using RangeBaseT = indexed_accessor_range_base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  /// An iterator element of this range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  /// An iterator element of this range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">                                                    PointerT, ReferenceT> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">                                                    PointerT, ReferenceT> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">    // Index into this iterator, invoking a static method on the derived type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">    // Index into this iterator, invoking a static method on the derived type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">    ReferenceT operator*() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">    ReferenceT operator*() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">    iterator(BaseT owner, ptrdiff_t curIndex)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">    iterator(BaseT owner, ptrdiff_t curIndex)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">        : iterator::indexed_accessor_iterator(owner, curIndex) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">        : iterator::indexed_accessor_iterator(owner, curIndex) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">    /// Allow access to the constructor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">    /// Allow access to the constructor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">                                       ReferenceT>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">                                       ReferenceT>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">  indexed_accessor_range_base(iterator begin, iterator end)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">  indexed_accessor_range_base(iterator begin, iterator end)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">      : base(offset_base(begin.getBase(), begin.getIndex())),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">      : base(offset_base(begin.getBase(), begin.getIndex())),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">        count(end.getIndex() - begin.getIndex()) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">        count(end.getIndex() - begin.getIndex()) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  indexed_accessor_range_base(const iterator_range<iterator> &range)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  indexed_accessor_range_base(const iterator_range<iterator> &range)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">      : indexed_accessor_range_base(range.begin(), range.end()) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">      : indexed_accessor_range_base(range.begin(), range.end()) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">  indexed_accessor_range_base(BaseT base, ptrdiff_t count)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">  indexed_accessor_range_base(BaseT base, ptrdiff_t count)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">      : base(base), count(count) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">      : base(base), count(count) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  iterator begin() const { return iterator(base, 0); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  iterator begin() const { return iterator(base, 0); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  iterator end() const { return iterator(base, count); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  iterator end() const { return iterator(base, count); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  ReferenceT operator[](size_t Index) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  ReferenceT operator[](size_t Index) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">    assert(Index < size() && "invalid index for value range");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">    assert(Index < size() && "invalid index for value range");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">  ReferenceT front() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">  ReferenceT front() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">    assert(!empty() && "expected non-empty range");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">    assert(!empty() && "expected non-empty range");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">    return (*this)[0];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">    return (*this)[0];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">  ReferenceT back() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">  ReferenceT back() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">    assert(!empty() && "expected non-empty range");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">    assert(!empty() && "expected non-empty range");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">    return (*this)[size() - 1];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">    return (*this)[size() - 1];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">  /// Compare this range with another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">  /// Compare this range with another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">  template <typename OtherT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">  template <typename OtherT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">  friend bool operator==(const indexed_accessor_range_base &lhs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">  friend bool operator==(const indexed_accessor_range_base &lhs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">                         const OtherT &rhs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">                         const OtherT &rhs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">  template <typename OtherT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">  template <typename OtherT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">  friend bool operator!=(const indexed_accessor_range_base &lhs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">  friend bool operator!=(const indexed_accessor_range_base &lhs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">                         const OtherT &rhs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">                         const OtherT &rhs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">    return !(lhs == rhs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">    return !(lhs == rhs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// Return the size of this range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// Return the size of this range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">  size_t size() const { return count; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">  size_t size() const { return count; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">  /// Return if the range is empty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">  /// Return if the range is empty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  bool empty() const { return size() == 0; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  bool empty() const { return size() == 0; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  /// Drop the first N elements, and keep M elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  /// Drop the first N elements, and keep M elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  DerivedT slice(size_t n, size_t m) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  DerivedT slice(size_t n, size_t m) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">    assert(n + m <= size() && "invalid size specifiers");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">    assert(n + m <= size() && "invalid size specifiers");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">    return DerivedT(offset_base(base, n), m);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">    return DerivedT(offset_base(base, n), m);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  /// Drop the first n elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  /// Drop the first n elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  DerivedT drop_front(size_t n = 1) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  DerivedT drop_front(size_t n = 1) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">    assert(size() >= n && "Dropping more elements than exist");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">    assert(size() >= n && "Dropping more elements than exist");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">    return slice(n, size() - n);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">    return slice(n, size() - n);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">  /// Drop the last n elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">  /// Drop the last n elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">  DerivedT drop_back(size_t n = 1) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">  DerivedT drop_back(size_t n = 1) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">    assert(size() >= n && "Dropping more elements than exist");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">    assert(size() >= n && "Dropping more elements than exist");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    return DerivedT(base, size() - n);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    return DerivedT(base, size() - n);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">  /// Take the first n elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">  /// Take the first n elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">  DerivedT take_front(size_t n = 1) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">  DerivedT take_front(size_t n = 1) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">    return n < size() ? drop_back(size() - n)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">    return n < size() ? drop_back(size() - n)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">                      : static_cast<const DerivedT &>(*this);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">                      : static_cast<const DerivedT &>(*this);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">  /// Take the last n elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">  /// Take the last n elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">  DerivedT take_back(size_t n = 1) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">  DerivedT take_back(size_t n = 1) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">    return n < size() ? drop_front(size() - n)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">    return n < size() ? drop_front(size() - n)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">                      : static_cast<const DerivedT &>(*this);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">                      : static_cast<const DerivedT &>(*this);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  /// Allow conversion to any type accepting an iterator_range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  /// Allow conversion to any type accepting an iterator_range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">                                 RangeT, iterator_range<iterator>>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">                                 RangeT, iterator_range<iterator>>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">  operator RangeT() const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">  operator RangeT() const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">    return RangeT(iterator_range<iterator>(*this));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">    return RangeT(iterator_range<iterator>(*this));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">  /// Returns the base of this range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">  /// Returns the base of this range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">  const BaseT &getBase() const { return base; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">  const BaseT &getBase() const { return base; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  /// Offset the given base by the given amount.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  /// Offset the given base by the given amount.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  static BaseT offset_base(const BaseT &base, size_t n) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  static BaseT offset_base(const BaseT &base, size_t n) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">    return n == 0 ? base : DerivedT::offset_base(base, n);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">    return n == 0 ? base : DerivedT::offset_base(base, n);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">  indexed_accessor_range_base &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">  indexed_accessor_range_base &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">  operator=(const indexed_accessor_range_base &) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">  operator=(const indexed_accessor_range_base &) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  /// The base that owns the provided range of values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  /// The base that owns the provided range of values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  BaseT base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  BaseT base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// The size from the owning range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// The size from the owning range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">  ptrdiff_t count;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">  ptrdiff_t count;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">/// This class provides an implementation of a range of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">/// This class provides an implementation of a range of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">/// indexed_accessor_iterators where the base is not indexable. Ranges with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">/// indexed_accessor_iterators where the base is not indexable. Ranges with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">/// bases that are offsetable should derive from indexed_accessor_range_base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">/// bases that are offsetable should derive from indexed_accessor_range_base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">/// instead. Derived range classes are expected to implement the following</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">/// instead. Derived range classes are expected to implement the following</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">/// static method:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">/// static method:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">///     - Dereference an iterator pointing to a parent base at the given index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">///     - Dereference an iterator pointing to a parent base at the given index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">template <typename DerivedT, typename BaseT, typename T,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">          typename PointerT = T *, typename ReferenceT = T &></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">class indexed_accessor_range</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">class indexed_accessor_range</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">    : public detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">    : public detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">      : detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">      : detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">            std::make_pair(base, startIndex), count) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">            std::make_pair(base, startIndex), count) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">  using detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">  using detail::indexed_accessor_range_base<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">      ReferenceT>::indexed_accessor_range_base;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">      ReferenceT>::indexed_accessor_range_base;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  /// Returns the current base of the range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  /// Returns the current base of the range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  const BaseT &getBase() const { return this->base.first; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  const BaseT &getBase() const { return this->base.first; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">  /// Returns the current start index of the range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">  /// Returns the current start index of the range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">  ptrdiff_t getStartIndex() const { return this->base.second; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">  ptrdiff_t getStartIndex() const { return this->base.second; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  /// See `detail::indexed_accessor_range_base` for details.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  /// See `detail::indexed_accessor_range_base` for details.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">  static std::pair<BaseT, ptrdiff_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">  static std::pair<BaseT, ptrdiff_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">    // We encode the internal base as a pair of the derived base and a start</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">    // We encode the internal base as a pair of the derived base and a start</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">    // index into the derived base.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">    // index into the derived base.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">    return std::make_pair(base.first, base.second + index);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">    return std::make_pair(base.first, base.second + index);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">  /// See `detail::indexed_accessor_range_base` for details.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">  /// See `detail::indexed_accessor_range_base` for details.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">  static ReferenceT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">  static ReferenceT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">                       ptrdiff_t index) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">                       ptrdiff_t index) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">    return DerivedT::dereference(base.first, base.second + index);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">    return DerivedT::dereference(base.first, base.second + index);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">/// Return a reference to the first or second member of a reference. Otherwise,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">/// Return a reference to the first or second member of a reference. Otherwise,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">/// return a copy of the member of a temporary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">/// return a copy of the member of a temporary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">/// When passing a range whose iterators return values instead of references,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">/// When passing a range whose iterators return values instead of references,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">/// the reference must be dropped from `decltype((elt.first))`, which will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">/// the reference must be dropped from `decltype((elt.first))`, which will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">/// always be a reference, to avoid returning a reference to a temporary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">/// always be a reference, to avoid returning a reference to a temporary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">template <typename EltTy, typename FirstTy> class first_or_second_type {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">template <typename EltTy, typename FirstTy> class first_or_second_type {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">  using type = std::conditional_t<std::is_reference<EltTy>::value, FirstTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">  using type = std::conditional_t<std::is_reference<EltTy>::value, FirstTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">                                  std::remove_reference_t<FirstTy>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">                                  std::remove_reference_t<FirstTy>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">/// Given a container of pairs, return a range over the first elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">/// Given a container of pairs, return a range over the first elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  using EltTy = decltype((*std::begin(c)));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  using EltTy = decltype((*std::begin(c)));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">  return llvm::map_range(std::forward<ContainerTy>(c),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">  return llvm::map_range(std::forward<ContainerTy>(c),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">                         [](EltTy elt) -> typename detail::first_or_second_type<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">                         [](EltTy elt) -> typename detail::first_or_second_type<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">                                           EltTy, decltype((elt.first))>::type {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">                                           EltTy, decltype((elt.first))>::type {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">                           return elt.first;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">                           return elt.first;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">                         });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">                         });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">/// Given a container of pairs, return a range over the second elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">/// Given a container of pairs, return a range over the second elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">  using EltTy = decltype((*std::begin(c)));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">  using EltTy = decltype((*std::begin(c)));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">  return llvm::map_range(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">  return llvm::map_range(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">      std::forward<ContainerTy>(c),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">      std::forward<ContainerTy>(c),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">      [](EltTy elt) -></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">      [](EltTy elt) -></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">      typename detail::first_or_second_type<EltTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">      typename detail::first_or_second_type<EltTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">                                            decltype((elt.second))>::type {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">                                            decltype((elt.second))>::type {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">        return elt.second;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">        return elt.second;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">//     Extra additions to <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">//     Extra additions to <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">/// Function object to check whether the first component of a container</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">/// Function object to check whether the first component of a container</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">/// first component of another container.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">/// first component of another container.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">struct less_first {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">struct less_first {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine coveredLine">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine coveredLine">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine coveredLine">    return std::less<>()(std::get<0>(lhs), std::get<0>(rhs));</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine coveredLine">    return std::less<>()(std::get<0>(lhs), std::get<0>(rhs));</td>
    <td class="lineNumber">12</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">/// Function object to check whether the second component of a container</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">/// Function object to check whether the second component of a container</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">/// supported by std::get (like std::pair and std::tuple) compares less than the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">/// second component of another container.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">/// second component of another container.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">struct less_second {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">struct less_second {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  template <typename T> bool operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">    return std::less<>()(std::get<1>(lhs), std::get<1>(rhs));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">    return std::less<>()(std::get<1>(lhs), std::get<1>(rhs));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">/// \brief Function object to apply a binary function to the first component of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">/// \brief Function object to apply a binary function to the first component of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">/// a std::pair.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">/// a std::pair.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">template<typename FuncTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">template<typename FuncTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">struct on_first {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">struct on_first {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">  FuncTy func;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">  FuncTy func;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">  decltype(auto) operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">  decltype(auto) operator()(const T &lhs, const T &rhs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">    return func(lhs.first, rhs.first);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">    return func(lhs.first, rhs.first);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">/// Utility type to build an inheritance chain that makes it easy to rank</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">/// Utility type to build an inheritance chain that makes it easy to rank</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">/// overload candidates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">/// overload candidates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">template <int N> struct rank : rank<N - 1> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">template <int N> struct rank : rank<N - 1> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">template <> struct rank<0> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">template <> struct rank<0> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">/// traits class for checking whether type T is one of any of the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">/// traits class for checking whether type T is one of any of the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">/// types in the variadic list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">/// types in the variadic list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">template <typename T, typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">template <typename T, typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">using is_one_of = std::disjunction<std::is_same<T, Ts>...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">/// traits class for checking whether type T is a base class for all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">/// traits class for checking whether type T is a base class for all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">///  the given types in the variadic list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">///  the given types in the variadic list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">template <typename T, typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">template <typename T, typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">template <typename... Ts> struct Visitor;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">template <typename... Ts> struct Visitor;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">template <typename HeadT, typename... TailTs></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">template <typename HeadT, typename... TailTs></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">  using remove_cvref_t<HeadT>::operator();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">  using remove_cvref_t<HeadT>::operator();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  using Visitor<TailTs...>::operator();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  using Visitor<TailTs...>::operator();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  explicit constexpr Visitor(HeadT &&Head)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  explicit constexpr Visitor(HeadT &&Head)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">  using remove_cvref_t<HeadT>::operator();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">  using remove_cvref_t<HeadT>::operator();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">/// Returns an opaquely-typed Callable object whose operator() overload set is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">/// Returns an opaquely-typed Callable object whose operator() overload set is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">/// the sum of the operator() overload sets of each CallableT in CallableTs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">/// the sum of the operator() overload sets of each CallableT in CallableTs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">/// The type of the returned object derives from each CallableT in CallableTs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">/// The type of the returned object derives from each CallableT in CallableTs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">/// The returned object is constructed by invoking the appropriate copy or move</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">/// The returned object is constructed by invoking the appropriate copy or move</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">/// constructor of each CallableT, as selected by overload resolution on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">/// constructor of each CallableT, as selected by overload resolution on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">/// corresponding argument to makeVisitor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">/// corresponding argument to makeVisitor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">/// Example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">/// Example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">/// auto visitor = makeVisitor([](auto) { return "unhandled type"; },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">/// auto visitor = makeVisitor([](auto) { return "unhandled type"; },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">///                            [](int i) { return "int"; },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">///                            [](int i) { return "int"; },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">///                            [](std::string s) { return "str"; });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">///                            [](std::string s) { return "str"; });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">/// auto a = visitor(42);    // `a` is now "int".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">/// auto a = visitor(42);    // `a` is now "int".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">/// auto b = visitor("foo"); // `b` is now "str".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">/// auto b = visitor("foo"); // `b` is now "str".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">/// auto c = visitor(3.14f); // `c` is now "unhandled type".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">/// auto c = visitor(3.14f); // `c` is now "unhandled type".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">/// Example of making a visitor with a lambda which captures a move-only type:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">/// Example of making a visitor with a lambda which captures a move-only type:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">/// std::unique_ptr<FooHandler> FH = /* ... */;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">/// std::unique_ptr<FooHandler> FH = /* ... */;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">/// auto visitor = makeVisitor(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">/// auto visitor = makeVisitor(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">///     [FH{std::move(FH)}](Foo F) { return FH->handle(F); },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">///     [FH{std::move(FH)}](Foo F) { return FH->handle(F); },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">///     [](int i) { return i; },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">///     [](int i) { return i; },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">///     [](std::string s) { return atoi(s); });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">///     [](std::string s) { return atoi(s); });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">template <typename... CallableTs></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">template <typename... CallableTs></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">//     Extra additions to <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">//     Extra additions to <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">// We have a copy here so that LLVM behaves the same when using different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">// We have a copy here so that LLVM behaves the same when using different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">// standard libraries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">// standard libraries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">template <class Iterator, class RNG></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">template <class Iterator, class RNG></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">void shuffle(Iterator first, Iterator last, RNG &&g) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">void shuffle(Iterator first, Iterator last, RNG &&g) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">  // It would be better to use a std::uniform_int_distribution,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">  // It would be better to use a std::uniform_int_distribution,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // but that would be stdlib dependent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // but that would be stdlib dependent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  typedef</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  typedef</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">      typename std::iterator_traits<Iterator>::difference_type difference_type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">      typename std::iterator_traits<Iterator>::difference_type difference_type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">  for (auto size = last - first; size > 1; ++first, (void)--size) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">  for (auto size = last - first; size > 1; ++first, (void)--size) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">    difference_type offset = g() % size;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">    difference_type offset = g() % size;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">    // Avoid self-assignment due to incorrect assertions in libstdc++</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">    // Avoid self-assignment due to incorrect assertions in libstdc++</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">    if (offset != difference_type(0))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">    if (offset != difference_type(0))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">      std::iter_swap(first, first + offset);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">      std::iter_swap(first, first + offset);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">/// Adapt std::less<T> for array_pod_sort.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">/// Adapt std::less<T> for array_pod_sort.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">template<typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">template<typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine coveredLine">inline int array_pod_sort_comparator(const void *P1, const void *P2) {</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">inline int array_pod_sort_comparator(const void *P1, const void *P2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine coveredLine">  if (std::less<T>()(*reinterpret_cast<const T*>(P1),</td>
    <td class="lineNumber">39</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">  if (std::less<T>()(*reinterpret_cast<const T*>(P1),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">                     *reinterpret_cast<const T*>(P2)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">                     *reinterpret_cast<const T*>(P2)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine coveredLine">    return -1;</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine coveredLine">  if (std::less<T>()(*reinterpret_cast<const T*>(P2),</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">  if (std::less<T>()(*reinterpret_cast<const T*>(P2),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">                     *reinterpret_cast<const T*>(P1)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">                     *reinterpret_cast<const T*>(P1)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine coveredLine">    return 1;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">    return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">/// get_array_pod_sort_comparator - This is an internal helper function used to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">/// get_array_pod_sort_comparator - This is an internal helper function used to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">/// get type deduction of T right.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">/// get type deduction of T right.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">template<typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">template<typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine coveredLine">inline int (*get_array_pod_sort_comparator(const T &))</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">inline int (*get_array_pod_sort_comparator(const T &))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">             (const void*, const void*) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">             (const void*, const void*) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine coveredLine">  return array_pod_sort_comparator<T>;</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">  return array_pod_sort_comparator<T>;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">inline unsigned presortShuffleEntropy() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">inline unsigned presortShuffleEntropy() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">  static unsigned Result(std::random_device{}());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">  static unsigned Result(std::random_device{}());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">  return Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">template <class IteratorTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">template <class IteratorTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">inline void presortShuffle(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">inline void presortShuffle(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">  std::mt19937 Generator(presortShuffleEntropy());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">  std::mt19937 Generator(presortShuffleEntropy());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">  llvm::shuffle(Start, End, Generator);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">  llvm::shuffle(Start, End, Generator);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">/// array_pod_sort - This sorts an array with the specified start and end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">/// array_pod_sort - This sorts an array with the specified start and end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">/// extent.  This is just like std::sort, except that it calls qsort instead of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">/// extent.  This is just like std::sort, except that it calls qsort instead of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">/// using an inlined template.  qsort is slightly slower than std::sort, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">/// using an inlined template.  qsort is slightly slower than std::sort, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">/// most sorts are not performance critical in LLVM and std::sort has to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">/// most sorts are not performance critical in LLVM and std::sort has to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">/// template instantiated for each type, leading to significant measured code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">/// template instantiated for each type, leading to significant measured code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">/// bloat.  This function should generally be used instead of std::sort where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">/// bloat.  This function should generally be used instead of std::sort where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">/// possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">/// possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">/// This function assumes that you have simple POD-like types that can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">/// This function assumes that you have simple POD-like types that can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">/// compared with std::less and can be moved with memcpy.  If this isn't true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">/// compared with std::less and can be moved with memcpy.  If this isn't true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">/// you should use std::sort.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">/// you should use std::sort.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">/// NOTE: If qsort_r were portable, we could allow a custom comparator and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">/// NOTE: If qsort_r were portable, we could allow a custom comparator and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">/// default to std::less.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">/// default to std::less.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">template<class IteratorTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">template<class IteratorTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine coveredLine">inline void array_pod_sort(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">23</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine coveredLine">inline void array_pod_sort(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">  // Don't inefficiently call qsort with one element or trigger undefined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">  // Don't inefficiently call qsort with one element or trigger undefined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">  // behavior with an empty sequence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">  // behavior with an empty sequence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine coveredLine">  auto NElts = End - Start;</td>
    <td class="lineNumber">23</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine coveredLine">  auto NElts = End - Start;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine coveredLine">  if (NElts <= 1) return;</td>
    <td class="lineNumber">23</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine coveredLine">  if (NElts <= 1) return;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine coveredLine">  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">template <class IteratorTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">template <class IteratorTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine coveredLine">inline void array_pod_sort(</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine coveredLine">inline void array_pod_sort(</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">    IteratorTy Start, IteratorTy End,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">    IteratorTy Start, IteratorTy End,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">    int (*Compare)(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">    int (*Compare)(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">        const typename std::iterator_traits<IteratorTy>::value_type *,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">        const typename std::iterator_traits<IteratorTy>::value_type *,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">        const typename std::iterator_traits<IteratorTy>::value_type *)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">        const typename std::iterator_traits<IteratorTy>::value_type *)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">  // Don't inefficiently call qsort with one element or trigger undefined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">  // Don't inefficiently call qsort with one element or trigger undefined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  // behavior with an empty sequence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  // behavior with an empty sequence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine coveredLine">  auto NElts = End - Start;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine coveredLine">  auto NElts = End - Start;</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine coveredLine">  if (NElts <= 1) return;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine coveredLine">  if (NElts <= 1) return;</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine coveredLine">  qsort(&*Start, NElts, sizeof(*Start),</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine coveredLine">  qsort(&*Start, NElts, sizeof(*Start),</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">        reinterpret_cast<int (*)(const void *, const void *)>(Compare));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">        reinterpret_cast<int (*)(const void *, const void *)>(Compare));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">// We can use qsort if the iterator type is a pointer and the underlying value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">// We can use qsort if the iterator type is a pointer and the underlying value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">// is trivially copyable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">// is trivially copyable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">using sort_trivially_copyable = std::conjunction<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">using sort_trivially_copyable = std::conjunction<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">    std::is_pointer<T>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">    std::is_pointer<T>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">// Provide wrappers to std::sort which shuffle the elements before sorting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">// Provide wrappers to std::sort which shuffle the elements before sorting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">// to help uncover non-deterministic behavior (PR35135).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">// to help uncover non-deterministic behavior (PR35135).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">template <typename IteratorTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">template <typename IteratorTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine coveredLine">inline void sort(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">inline void sort(IteratorTy Start, IteratorTy End) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  if constexpr (detail::sort_trivially_copyable<IteratorTy>::value) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  if constexpr (detail::sort_trivially_copyable<IteratorTy>::value) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">    // Forward trivially copyable types to array_pod_sort. This avoids a large</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">    // Forward trivially copyable types to array_pod_sort. This avoids a large</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">    // amount of code bloat for a minor performance hit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">    // amount of code bloat for a minor performance hit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine coveredLine">    array_pod_sort(Start, End);</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">    array_pod_sort(Start, End);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">    detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">    detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">    std::sort(Start, End);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">    std::sort(Start, End);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine coveredLine">template <typename Container> inline void sort(Container &&C) {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">template <typename Container> inline void sort(Container &&C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine coveredLine">  llvm::sort(adl_begin(C), adl_end(C));</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">  llvm::sort(adl_begin(C), adl_end(C));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">template <typename IteratorTy, typename Compare></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">template <typename IteratorTy, typename Compare></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine coveredLine">inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine coveredLine">inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">#ifdef EXPENSIVE_CHECKS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  detail::presortShuffle<IteratorTy>(Start, End);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine coveredLine">  std::sort(Start, End, Comp);</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine coveredLine">  std::sort(Start, End, Comp);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">template <typename Container, typename Compare></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">template <typename Container, typename Compare></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine coveredLine">inline void sort(Container &&C, Compare Comp) {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine coveredLine">inline void sort(Container &&C, Compare Comp) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine coveredLine">  llvm::sort(adl_begin(C), adl_end(C), Comp);</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine coveredLine">  llvm::sort(adl_begin(C), adl_end(C), Comp);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">/// Get the size of a range. This is a wrapper function around std::distance</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">/// Get the size of a range. This is a wrapper function around std::distance</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">/// which is only enabled when the operation is O(1).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">/// which is only enabled when the operation is O(1).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">template <typename R></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">template <typename R></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">auto size(R &&Range,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">auto size(R &&Range,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">          std::enable_if_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">          std::enable_if_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">              std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">              std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">                              typename std::iterator_traits<decltype(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">                              typename std::iterator_traits<decltype(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">                                  Range.begin())>::iterator_category>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">                                  Range.begin())>::iterator_category>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">              void> * = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">              void> * = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">  return std::distance(Range.begin(), Range.end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">  return std::distance(Range.begin(), Range.end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">template <typename Range></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">template <typename Range></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">using check_has_free_function_size =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">using check_has_free_function_size =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">    decltype(adl_size(std::declval<Range &>()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">    decltype(adl_size(std::declval<Range &>()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">template <typename Range></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">template <typename Range></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">static constexpr bool HasFreeFunctionSize =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">static constexpr bool HasFreeFunctionSize =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">    is_detected<check_has_free_function_size, Range>::value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">    is_detected<check_has_free_function_size, Range>::value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">/// Returns the size of the \p Range, i.e., the number of elements. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">/// Returns the size of the \p Range, i.e., the number of elements. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">/// implementation takes inspiration from `std::ranges::size` from C++20 and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">/// implementation takes inspiration from `std::ranges::size` from C++20 and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">/// delegates the size check to `adl_size` or `std::distance`, in this order of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">/// delegates the size check to `adl_size` or `std::distance`, in this order of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">/// preference. Unlike `llvm::size`, this function does *not* guarantee O(1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">/// preference. Unlike `llvm::size`, this function does *not* guarantee O(1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">/// running time, and is intended to be used in generic code that does not know</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">/// running time, and is intended to be used in generic code that does not know</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">/// the exact range type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">/// the exact range type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">template <typename R> constexpr size_t range_size(R &&Range) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">template <typename R> constexpr size_t range_size(R &&Range) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">  if constexpr (detail::HasFreeFunctionSize<R>)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">  if constexpr (detail::HasFreeFunctionSize<R>)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">    return adl_size(Range);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">    return adl_size(Range);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">    return static_cast<size_t>(std::distance(adl_begin(Range), adl_end(Range)));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">    return static_cast<size_t>(std::distance(adl_begin(Range), adl_end(Range)));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">/// Provide wrappers to std::for_each which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">/// Provide wrappers to std::for_each which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">template <typename R, typename UnaryFunction></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">template <typename R, typename UnaryFunction></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">UnaryFunction for_each(R &&Range, UnaryFunction F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">UnaryFunction for_each(R &&Range, UnaryFunction F) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">  return std::for_each(adl_begin(Range), adl_end(Range), F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">  return std::for_each(adl_begin(Range), adl_end(Range), F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">/// Provide wrappers to std::all_of which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">/// Provide wrappers to std::all_of which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine coveredLine">bool all_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine coveredLine">bool all_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine coveredLine">  return std::all_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine coveredLine">  return std::all_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">/// Provide wrappers to std::any_of which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">/// Provide wrappers to std::any_of which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine coveredLine">bool any_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">79</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine coveredLine">bool any_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">76</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine coveredLine">  return std::any_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">79</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine coveredLine">  return std::any_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">76</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">/// Provide wrappers to std::none_of which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">/// Provide wrappers to std::none_of which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine coveredLine">bool none_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine coveredLine">bool none_of(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine coveredLine">  return std::none_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">12</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine coveredLine">  return std::none_of(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">/// Provide wrappers to std::find which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">/// Provide wrappers to std::find which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine coveredLine">template <typename R, typename T> auto find(R &&Range, const T &Val) {</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine coveredLine">template <typename R, typename T> auto find(R &&Range, const T &Val) {</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine coveredLine">  return std::find(adl_begin(Range), adl_end(Range), Val);</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine coveredLine">  return std::find(adl_begin(Range), adl_end(Range), Val);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">/// Provide wrappers to std::find_if which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">/// Provide wrappers to std::find_if which take ranges instead of having to pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">/// begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine coveredLine">auto find_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine coveredLine">auto find_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine coveredLine">  return std::find_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine coveredLine">  return std::find_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">auto find_if_not(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">auto find_if_not(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  return std::find_if_not(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  return std::find_if_not(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">/// Provide wrappers to std::remove_if which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">/// Provide wrappers to std::remove_if which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">auto remove_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">auto remove_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  return std::remove_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  return std::remove_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">/// Provide wrappers to std::copy_if which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">/// Provide wrappers to std::copy_if which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">template <typename R, typename OutputIt, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">template <typename R, typename OutputIt, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">/// Return the single value in \p Range that satisfies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">/// Return the single value in \p Range that satisfies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">/// \p P(<member of \p Range> *, AllowRepeats)->T * returning nullptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">/// \p P(<member of \p Range> *, AllowRepeats)->T * returning nullptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">/// when no values or multiple values were found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">/// when no values or multiple values were found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">/// When \p AllowRepeats is true, multiple values that compare equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">/// When \p AllowRepeats is true, multiple values that compare equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">/// are allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">/// are allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">template <typename T, typename R, typename Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">template <typename T, typename R, typename Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">T *find_singleton(R &&Range, Predicate P, bool AllowRepeats = false) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">T *find_singleton(R &&Range, Predicate P, bool AllowRepeats = false) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">  T *RC = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">  T *RC = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  for (auto *A : Range) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  for (auto *A : Range) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">    if (T *PRC = P(A, AllowRepeats)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">    if (T *PRC = P(A, AllowRepeats)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">      if (RC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">      if (RC) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">        if (!AllowRepeats || PRC != RC)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">        if (!AllowRepeats || PRC != RC)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">          return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">          return nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">        RC = PRC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">        RC = PRC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">  return RC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">  return RC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">/// Return a pair consisting of the single value in \p Range that satisfies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">/// Return a pair consisting of the single value in \p Range that satisfies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">/// \p P(<member of \p Range> *, AllowRepeats)->std::pair<T*, bool> returning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">/// \p P(<member of \p Range> *, AllowRepeats)->std::pair<T*, bool> returning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">/// nullptr when no values or multiple values were found, and a bool indicating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">/// nullptr when no values or multiple values were found, and a bool indicating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">/// whether multiple values were found to cause the nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">/// whether multiple values were found to cause the nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">/// When \p AllowRepeats is true, multiple values that compare equal are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">/// When \p AllowRepeats is true, multiple values that compare equal are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">/// allowed.  The predicate \p P returns a pair<T *, bool> where T is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">/// allowed.  The predicate \p P returns a pair<T *, bool> where T is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">/// singleton while the bool indicates whether multiples have already been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">/// singleton while the bool indicates whether multiples have already been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">/// found.  It is expected that first will be nullptr when second is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">/// found.  It is expected that first will be nullptr when second is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">/// This allows using find_singleton_nested within the predicate \P.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">/// This allows using find_singleton_nested within the predicate \P.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">template <typename T, typename R, typename Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">template <typename T, typename R, typename Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">std::pair<T *, bool> find_singleton_nested(R &&Range, Predicate P,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">std::pair<T *, bool> find_singleton_nested(R &&Range, Predicate P,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">                                           bool AllowRepeats = false) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">                                           bool AllowRepeats = false) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">  T *RC = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">  T *RC = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">  for (auto *A : Range) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">  for (auto *A : Range) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">    std::pair<T *, bool> PRC = P(A, AllowRepeats);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">    std::pair<T *, bool> PRC = P(A, AllowRepeats);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">    if (PRC.second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">    if (PRC.second) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">      assert(PRC.first == nullptr &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">      assert(PRC.first == nullptr &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">             "Inconsistent return values in find_singleton_nested.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">             "Inconsistent return values in find_singleton_nested.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">      return PRC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">      return PRC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">    if (PRC.first) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">    if (PRC.first) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">      if (RC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">      if (RC) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">        if (!AllowRepeats || PRC.first != RC)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">        if (!AllowRepeats || PRC.first != RC)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">          return {nullptr, true};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">          return {nullptr, true};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">      } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">        RC = PRC.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">        RC = PRC.first;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">  return {RC, false};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">  return {RC, false};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">template <typename R, typename OutputIt></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">template <typename R, typename OutputIt></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine coveredLine">OutputIt copy(R &&Range, OutputIt Out) {</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine coveredLine">OutputIt copy(R &&Range, OutputIt Out) {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine coveredLine">  return std::copy(adl_begin(Range), adl_end(Range), Out);</td>
    <td class="lineNumber">10</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine coveredLine">  return std::copy(adl_begin(Range), adl_end(Range), Out);</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">/// Provide wrappers to std::replace_copy_if which take ranges instead of having</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">/// Provide wrappers to std::replace_copy_if which take ranges instead of having</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">/// to pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">/// to pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">template <typename R, typename OutputIt, typename UnaryPredicate, typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">template <typename R, typename OutputIt, typename UnaryPredicate, typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">OutputIt replace_copy_if(R &&Range, OutputIt Out, UnaryPredicate P,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">OutputIt replace_copy_if(R &&Range, OutputIt Out, UnaryPredicate P,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">                         const T &NewValue) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">                         const T &NewValue) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">  return std::replace_copy_if(adl_begin(Range), adl_end(Range), Out, P,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">  return std::replace_copy_if(adl_begin(Range), adl_end(Range), Out, P,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">                              NewValue);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">                              NewValue);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">/// Provide wrappers to std::replace_copy which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">/// Provide wrappers to std::replace_copy which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">template <typename R, typename OutputIt, typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">template <typename R, typename OutputIt, typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">OutputIt replace_copy(R &&Range, OutputIt Out, const T &OldValue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">OutputIt replace_copy(R &&Range, OutputIt Out, const T &OldValue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">                      const T &NewValue) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">                      const T &NewValue) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">  return std::replace_copy(adl_begin(Range), adl_end(Range), Out, OldValue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">  return std::replace_copy(adl_begin(Range), adl_end(Range), Out, OldValue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">                           NewValue);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">                           NewValue);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">/// Provide wrappers to std::move which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">/// Provide wrappers to std::move which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">template <typename R, typename OutputIt></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">template <typename R, typename OutputIt></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">OutputIt move(R &&Range, OutputIt Out) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">OutputIt move(R &&Range, OutputIt Out) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">  return std::move(adl_begin(Range), adl_end(Range), Out);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">  return std::move(adl_begin(Range), adl_end(Range), Out);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">template <typename Range, typename Element></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">template <typename Range, typename Element></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">using check_has_member_contains_t =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">using check_has_member_contains_t =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">    decltype(std::declval<Range &>().contains(std::declval<const Element &>()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">    decltype(std::declval<Range &>().contains(std::declval<const Element &>()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">template <typename Range, typename Element></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">template <typename Range, typename Element></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">static constexpr bool HasMemberContains =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">static constexpr bool HasMemberContains =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">    is_detected<check_has_member_contains_t, Range, Element>::value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">    is_detected<check_has_member_contains_t, Range, Element>::value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">template <typename Range, typename Element></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">template <typename Range, typename Element></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">using check_has_member_find_t =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">using check_has_member_find_t =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">    decltype(std::declval<Range &>().find(std::declval<const Element &>()) !=</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">    decltype(std::declval<Range &>().find(std::declval<const Element &>()) !=</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">             std::declval<Range &>().end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">             std::declval<Range &>().end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">template <typename Range, typename Element></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">template <typename Range, typename Element></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">static constexpr bool HasMemberFind =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">static constexpr bool HasMemberFind =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">    is_detected<check_has_member_find_t, Range, Element>::value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">    is_detected<check_has_member_find_t, Range, Element>::value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">/// Returns true if \p Element is found in \p Range. Delegates the check to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">/// Returns true if \p Element is found in \p Range. Delegates the check to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">/// either `.contains(Element)`, `.find(Element)`, or `std::find`, in this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">/// either `.contains(Element)`, `.find(Element)`, or `std::find`, in this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">/// order of preference. This is intended as the canonical way to check if an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">/// order of preference. This is intended as the canonical way to check if an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">/// element exists in a range in generic code or range type that does not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">/// element exists in a range in generic code or range type that does not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">/// expose a `.contains(Element)` member.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">/// expose a `.contains(Element)` member.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">template <typename R, typename E></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">template <typename R, typename E></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine coveredLine">bool is_contained(R &&Range, const E &Element) {</td>
    <td class="lineNumber">2349</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine coveredLine">bool is_contained(R &&Range, const E &Element) {</td>
    <td class="lineNumber">2344</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  if constexpr (detail::HasMemberContains<R, E>)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  if constexpr (detail::HasMemberContains<R, E>)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">    return Range.contains(Element);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">    return Range.contains(Element);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">  else if constexpr (detail::HasMemberFind<R, E>)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">  else if constexpr (detail::HasMemberFind<R, E>)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">    return Range.find(Element) != Range.end();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">    return Range.find(Element) != Range.end();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine coveredLine">    return std::find(adl_begin(Range), adl_end(Range), Element) !=</td>
    <td class="lineNumber">2349</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine coveredLine">    return std::find(adl_begin(Range), adl_end(Range), Element) !=</td>
    <td class="lineNumber">2344</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine coveredLine">           adl_end(Range);</td>
    <td class="lineNumber">2349</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine coveredLine">           adl_end(Range);</td>
    <td class="lineNumber">2344</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">/// Returns true iff \p Element exists in \p Set. This overload takes \p Set as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">/// Returns true iff \p Element exists in \p Set. This overload takes \p Set as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">/// an initializer list and is `constexpr`-friendly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">/// an initializer list and is `constexpr`-friendly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">template <typename T, typename E></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">template <typename T, typename E></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">constexpr bool is_contained(std::initializer_list<T> Set, const E &Element) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">constexpr bool is_contained(std::initializer_list<T> Set, const E &Element) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">  // TODO: Use std::find when we switch to C++20.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">  // TODO: Use std::find when we switch to C++20.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  for (const T &V : Set)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  for (const T &V : Set)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">    if (V == Element)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">    if (V == Element)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">/// are sorted with respect to a comparator \p C.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">/// are sorted with respect to a comparator \p C.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine coveredLine">template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine coveredLine">template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine coveredLine">  return std::is_sorted(adl_begin(Range), adl_end(Range), C);</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine coveredLine">  return std::is_sorted(adl_begin(Range), adl_end(Range), C);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">/// Wrapper function around std::is_sorted to check if elements in a range \p R</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">/// are sorted in non-descending order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">/// are sorted in non-descending order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine coveredLine">template <typename R> bool is_sorted(R &&Range) {</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine coveredLine">template <typename R> bool is_sorted(R &&Range) {</td>
    <td class="lineNumber">14</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine coveredLine">  return std::is_sorted(adl_begin(Range), adl_end(Range));</td>
    <td class="lineNumber">17</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine coveredLine">  return std::is_sorted(adl_begin(Range), adl_end(Range));</td>
    <td class="lineNumber">14</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">/// Wrapper function around std::count to count the number of times an element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">/// Wrapper function around std::count to count the number of times an element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">/// \p Element occurs in the given range \p Range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">/// \p Element occurs in the given range \p Range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine coveredLine">template <typename R, typename E> auto count(R &&Range, const E &Element) {</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine coveredLine">template <typename R, typename E> auto count(R &&Range, const E &Element) {</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine coveredLine">  return std::count(adl_begin(Range), adl_end(Range), Element);</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine coveredLine">  return std::count(adl_begin(Range), adl_end(Range), Element);</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">/// Wrapper function around std::count_if to count the number of times an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">/// Wrapper function around std::count_if to count the number of times an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">/// element satisfying a given predicate occurs in a range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">/// element satisfying a given predicate occurs in a range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine coveredLine">auto count_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">33</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine coveredLine">auto count_if(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">7</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine coveredLine">  return std::count_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">33</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine coveredLine">  return std::count_if(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">7</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">/// Wrapper function around std::transform to apply a function to a range and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">/// Wrapper function around std::transform to apply a function to a range and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">/// store the result elsewhere.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">/// store the result elsewhere.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">template <typename R, typename OutputIt, typename UnaryFunction></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">template <typename R, typename OutputIt, typename UnaryFunction></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">/// Provide wrappers to std::partition which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">/// Provide wrappers to std::partition which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">template <typename R, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">auto partition(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">auto partition(R &&Range, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">  return std::partition(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">  return std::partition(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">/// Provide wrappers to std::lower_bound which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">/// Provide wrappers to std::lower_bound which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine coveredLine">template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {</td>
    <td class="lineNumber">28</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine coveredLine">template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine coveredLine">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">28</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine coveredLine">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine coveredLine">                          std::forward<T>(Value));</td>
    <td class="lineNumber">48</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine coveredLine">                          std::forward<T>(Value));</td>
    <td class="lineNumber">48</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">template <typename R, typename T, typename Compare></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">template <typename R, typename T, typename Compare></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine coveredLine">auto lower_bound(R &&Range, T &&Value, Compare C) {</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine coveredLine">auto lower_bound(R &&Range, T &&Value, Compare C) {</td>
    <td class="lineNumber">25</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine coveredLine">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">24</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine coveredLine">  return std::lower_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">25</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine coveredLine">                          std::forward<T>(Value), C);</td>
    <td class="lineNumber">48</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine coveredLine">                          std::forward<T>(Value), C);</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">/// Provide wrappers to std::upper_bound which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">/// Provide wrappers to std::upper_bound which take ranges instead of having to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">/// pass begin/end explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine coveredLine">template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine coveredLine">template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine coveredLine">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine coveredLine">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine coveredLine">                          std::forward<T>(Value));</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine coveredLine">                          std::forward<T>(Value));</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">template <typename R, typename T, typename Compare></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">template <typename R, typename T, typename Compare></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">auto upper_bound(R &&Range, T &&Value, Compare C) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">auto upper_bound(R &&Range, T &&Value, Compare C) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">  return std::upper_bound(adl_begin(Range), adl_end(Range),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">                          std::forward<T>(Value), C);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">                          std::forward<T>(Value), C);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">template <typename R></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">template <typename R></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">void stable_sort(R &&Range) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">void stable_sort(R &&Range) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">  std::stable_sort(adl_begin(Range), adl_end(Range));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">  std::stable_sort(adl_begin(Range), adl_end(Range));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">template <typename R, typename Compare></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">template <typename R, typename Compare></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">void stable_sort(R &&Range, Compare C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">void stable_sort(R &&Range, Compare C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">  std::stable_sort(adl_begin(Range), adl_end(Range), C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">  std::stable_sort(adl_begin(Range), adl_end(Range), C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">/// Binary search for the first iterator in a range where a predicate is false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">/// Binary search for the first iterator in a range where a predicate is false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">/// Requires that C is always true below some limit, and always false above it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">/// Requires that C is always true below some limit, and always false above it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">template <typename R, typename Predicate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">template <typename R, typename Predicate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">          typename Val = decltype(*adl_begin(std::declval<R>()))></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">          typename Val = decltype(*adl_begin(std::declval<R>()))></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine coveredLine">auto partition_point(R &&Range, Predicate P) {</td>
    <td class="lineNumber">51</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine coveredLine">auto partition_point(R &&Range, Predicate P) {</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine coveredLine">  return std::partition_point(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">51</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine coveredLine">  return std::partition_point(adl_begin(Range), adl_end(Range), P);</td>
    <td class="lineNumber">50</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">template<typename Range, typename Predicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">template<typename Range, typename Predicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">auto unique(Range &&R, Predicate P) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">auto unique(Range &&R, Predicate P) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">  return std::unique(adl_begin(R), adl_end(R), P);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">  return std::unique(adl_begin(R), adl_end(R), P);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">/// Wrapper function around std::equal to detect if pair-wise elements between</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">/// Wrapper function around std::equal to detect if pair-wise elements between</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">/// two ranges are the same.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">/// two ranges are the same.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">                    adl_end(RRange));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">                    adl_end(RRange));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">/// Returns true if all elements in Range are equal or when the Range is empty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">/// Returns true if all elements in Range are equal or when the Range is empty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">template <typename R> bool all_equal(R &&Range) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">template <typename R> bool all_equal(R &&Range) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  auto Begin = adl_begin(Range);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  auto Begin = adl_begin(Range);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">  auto End = adl_end(Range);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">  auto End = adl_end(Range);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  return Begin == End || std::equal(Begin + 1, End, Begin);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  return Begin == End || std::equal(Begin + 1, End, Begin);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">/// Returns true if all Values in the initializer lists are equal or the list</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">/// Returns true if all Values in the initializer lists are equal or the list</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">// is empty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">// is empty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">template <typename T> bool all_equal(std::initializer_list<T> Values) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">template <typename T> bool all_equal(std::initializer_list<T> Values) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">  return all_equal<std::initializer_list<T>>(std::move(Values));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">  return all_equal<std::initializer_list<T>>(std::move(Values));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">/// Provide a container algorithm similar to C++ Library Fundamentals v2's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">/// Provide a container algorithm similar to C++ Library Fundamentals v2's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">/// `erase_if` which is equivalent to:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">/// `erase_if` which is equivalent to:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">///   C.erase(remove_if(C, pred), C.end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">///   C.erase(remove_if(C, pred), C.end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">/// This version works for any container with an erase method call accepting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">/// This version works for any container with an erase method call accepting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">/// two iterators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">/// two iterators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">template <typename Container, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">template <typename Container, typename UnaryPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">void erase_if(Container &C, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">void erase_if(Container &C, UnaryPredicate P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">  C.erase(remove_if(C, P), C.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">  C.erase(remove_if(C, P), C.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">/// Wrapper function to remove a value from a container:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">/// Wrapper function to remove a value from a container:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">/// C.erase(remove(C.begin(), C.end(), V), C.end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">/// C.erase(remove(C.begin(), C.end(), V), C.end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">template <typename Container, typename ValueType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">template <typename Container, typename ValueType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine coveredLine">void erase_value(Container &C, ValueType V) {</td>
    <td class="lineNumber">142</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine coveredLine">void erase_value(Container &C, ValueType V) {</td>
    <td class="lineNumber">138</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine coveredLine">  C.erase(std::remove(C.begin(), C.end(), V), C.end());</td>
    <td class="lineNumber">142</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine coveredLine">  C.erase(std::remove(C.begin(), C.end(), V), C.end());</td>
    <td class="lineNumber">138</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">142</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">138</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">/// Wrapper function to append a range to a container.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">/// Wrapper function to append a range to a container.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">/// C.insert(C.end(), R.begin(), R.end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">/// C.insert(C.end(), R.begin(), R.end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">template <typename Container, typename Range></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">template <typename Container, typename Range></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine coveredLine">inline void append_range(Container &C, Range &&R) {</td>
    <td class="lineNumber">29</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine coveredLine">inline void append_range(Container &C, Range &&R) {</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine coveredLine">  C.insert(C.end(), adl_begin(R), adl_end(R));</td>
    <td class="lineNumber">29</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine coveredLine">  C.insert(C.end(), adl_begin(R), adl_end(R));</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">29</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">/// the range [ValIt, ValEnd) (which is not from the same container).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">/// the range [ValIt, ValEnd) (which is not from the same container).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">template<typename Container, typename RandomAccessIterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">template<typename Container, typename RandomAccessIterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">void replace(Container &Cont, typename Container::iterator ContIt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">void replace(Container &Cont, typename Container::iterator ContIt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">             typename Container::iterator ContEnd, RandomAccessIterator ValIt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">             typename Container::iterator ContEnd, RandomAccessIterator ValIt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">             RandomAccessIterator ValEnd) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">             RandomAccessIterator ValEnd) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">    if (ValIt == ValEnd) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">    if (ValIt == ValEnd) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">      Cont.erase(ContIt, ContEnd);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">      Cont.erase(ContIt, ContEnd);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">    } else if (ContIt == ContEnd) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">    } else if (ContIt == ContEnd) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">      Cont.insert(ContIt, ValIt, ValEnd);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">      Cont.insert(ContIt, ValIt, ValEnd);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">    *ContIt++ = *ValIt++;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">    *ContIt++ = *ValIt++;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">/// the range R.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">/// the range R.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">template<typename Container, typename Range = std::initializer_list<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">template<typename Container, typename Range = std::initializer_list<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">                                 typename Container::value_type>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">                                 typename Container::value_type>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">void replace(Container &Cont, typename Container::iterator ContIt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">void replace(Container &Cont, typename Container::iterator ContIt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">             typename Container::iterator ContEnd, Range R) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">             typename Container::iterator ContEnd, Range R) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">  replace(Cont, ContIt, ContEnd, R.begin(), R.end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">  replace(Cont, ContIt, ContEnd, R.begin(), R.end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">/// An STL-style algorithm similar to std::for_each that applies a second</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">/// An STL-style algorithm similar to std::for_each that applies a second</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">/// functor between every pair of elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">/// functor between every pair of elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">/// This provides the control flow logic to, for example, print a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">/// This provides the control flow logic to, for example, print a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">/// comma-separated list:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">/// comma-separated list:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">///   interleave(names.begin(), names.end(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">///   interleave(names.begin(), names.end(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">///              [&](StringRef name) { os << name; },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">///              [&](StringRef name) { os << name; },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">///              [&] { os << ", "; });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">///              [&] { os << ", "; });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">template <typename ForwardIterator, typename UnaryFunctor,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">template <typename ForwardIterator, typename UnaryFunctor,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">          typename NullaryFunctor,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">          typename NullaryFunctor,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">          typename = std::enable_if_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">          typename = std::enable_if_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">inline void interleave(ForwardIterator begin, ForwardIterator end,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">inline void interleave(ForwardIterator begin, ForwardIterator end,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">                       UnaryFunctor each_fn, NullaryFunctor between_fn) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">                       UnaryFunctor each_fn, NullaryFunctor between_fn) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">  if (begin == end)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">  if (begin == end)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">  each_fn(*begin);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">  each_fn(*begin);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">  ++begin;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">  ++begin;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">  for (; begin != end; ++begin) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">  for (; begin != end; ++begin) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">    between_fn();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">    between_fn();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">    each_fn(*begin);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">    each_fn(*begin);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">template <typename Container, typename UnaryFunctor, typename NullaryFunctor,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">template <typename Container, typename UnaryFunctor, typename NullaryFunctor,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">          typename = std::enable_if_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">          typename = std::enable_if_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">              !std::is_constructible<StringRef, UnaryFunctor>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">              !std::is_constructible<StringRef, NullaryFunctor>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">inline void interleave(const Container &c, UnaryFunctor each_fn,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">inline void interleave(const Container &c, UnaryFunctor each_fn,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">                       NullaryFunctor between_fn) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">                       NullaryFunctor between_fn) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">  interleave(c.begin(), c.end(), each_fn, between_fn);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">  interleave(c.begin(), c.end(), each_fn, between_fn);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">/// Overload of interleave for the common case of string separator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">/// Overload of interleave for the common case of string separator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">                       const StringRef &separator) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">                       const StringRef &separator) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">template <typename Container, typename StreamT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">template <typename Container, typename StreamT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">inline void interleave(const Container &c, StreamT &os,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">inline void interleave(const Container &c, StreamT &os,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">                       const StringRef &separator) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">                       const StringRef &separator) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  interleave(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  interleave(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">      c, os, [&](const T &a) { os << a; }, separator);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">      c, os, [&](const T &a) { os << a; }, separator);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">template <typename Container, typename UnaryFunctor, typename StreamT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">inline void interleaveComma(const Container &c, StreamT &os,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">inline void interleaveComma(const Container &c, StreamT &os,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">                            UnaryFunctor each_fn) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">                            UnaryFunctor each_fn) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  interleave(c, os, each_fn, ", ");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  interleave(c, os, each_fn, ", ");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">template <typename Container, typename StreamT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">template <typename Container, typename StreamT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">          typename T = detail::ValueOfRange<Container>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">inline void interleaveComma(const Container &c, StreamT &os) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">inline void interleaveComma(const Container &c, StreamT &os) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">  interleaveComma(c, os, [&](const T &a) { os << a; });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">  interleaveComma(c, os, [&](const T &a) { os << a; });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">//     Extra additions to <memory></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">//     Extra additions to <memory></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">struct FreeDeleter {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">struct FreeDeleter {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">  void operator()(void* v) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">  void operator()(void* v) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">    ::free(v);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">    ::free(v);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">template<typename First, typename Second></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">template<typename First, typename Second></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">struct pair_hash {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">struct pair_hash {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">  size_t operator()(const std::pair<First, Second> &P) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">  size_t operator()(const std::pair<First, Second> &P) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">/// Binary functor that adapts to any other binary functor after dereferencing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">/// Binary functor that adapts to any other binary functor after dereferencing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">/// operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">/// operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">template <typename T> struct deref {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">template <typename T> struct deref {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">  T func;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">  T func;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">  // Could be further improved to cope with non-derivable functors and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">  // Could be further improved to cope with non-derivable functors and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">  // non-binary functors (should be a variadic template member function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">  // non-binary functors (should be a variadic template member function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  // operator()).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  // operator()).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">    assert(lhs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">    assert(lhs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">    assert(rhs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">    assert(rhs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">    return func(*lhs, *rhs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">    return func(*lhs, *rhs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">/// Tuple-like type for `zip_enumerator` dereference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">/// Tuple-like type for `zip_enumerator` dereference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">template <typename... Refs> struct enumerator_result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">template <typename... Refs> struct enumerator_result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">using EnumeratorTupleType = enumerator_result<decltype(*declval<Iters>())...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">using EnumeratorTupleType = enumerator_result<decltype(*declval<Iters>())...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">/// Zippy iterator that uses the second iterator for comparisons. For the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">/// Zippy iterator that uses the second iterator for comparisons. For the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">/// increment to be safe, the second range has to be the shortest.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">/// increment to be safe, the second range has to be the shortest.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">/// Returns `enumerator_result` on dereference to provide `.index()` and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">/// Returns `enumerator_result` on dereference to provide `.index()` and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">/// `.value()` member functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">/// `.value()` member functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">/// Note: Because the dereference operator returns `enumerator_result` as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">/// Note: Because the dereference operator returns `enumerator_result` as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">/// value instead of a reference and does not strictly conform to the C++17's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">/// value instead of a reference and does not strictly conform to the C++17's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">/// definition of forward iterator. However, it satisfies all the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">/// definition of forward iterator. However, it satisfies all the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">/// forward_iterator requirements that the `zip_common` and `zippy` depend on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">/// forward_iterator requirements that the `zip_common` and `zippy` depend on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">/// and fully conforms to the C++20 definition of forward iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">/// and fully conforms to the C++20 definition of forward iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">/// This is similar to `std::vector<bool>::iterator` that returns bit reference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">/// This is similar to `std::vector<bool>::iterator` that returns bit reference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">/// wrappers on dereference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">/// wrappers on dereference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">template <typename... Iters></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">struct zip_enumerator : zip_common<zip_enumerator<Iters...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">struct zip_enumerator : zip_common<zip_enumerator<Iters...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">                                   EnumeratorTupleType<Iters...>, Iters...> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">                                   EnumeratorTupleType<Iters...>, Iters...> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">  static_assert(sizeof...(Iters) >= 2, "Expected at least two iteratees");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">  static_assert(sizeof...(Iters) >= 2, "Expected at least two iteratees");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">  using zip_common<zip_enumerator<Iters...>, EnumeratorTupleType<Iters...>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">  using zip_common<zip_enumerator<Iters...>, EnumeratorTupleType<Iters...>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">                   Iters...>::zip_common;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">                   Iters...>::zip_common;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine coveredLine">  bool operator==(const zip_enumerator &Other) const {</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine coveredLine">  bool operator==(const zip_enumerator &Other) const {</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine coveredLine">    return std::get<1>(this->iterators) == std::get<1>(Other.iterators);</td>
    <td class="lineNumber">20</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine coveredLine">    return std::get<1>(this->iterators) == std::get<1>(Other.iterators);</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">template <typename... Refs> struct enumerator_result<std::size_t, Refs...> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">template <typename... Refs> struct enumerator_result<std::size_t, Refs...> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">  static constexpr std::size_t NumRefs = sizeof...(Refs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">  static constexpr std::size_t NumRefs = sizeof...(Refs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">  static_assert(NumRefs != 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">  static_assert(NumRefs != 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">  // `NumValues` includes the index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">  // `NumValues` includes the index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">  static constexpr std::size_t NumValues = NumRefs + 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">  static constexpr std::size_t NumValues = NumRefs + 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">  // Tuple type whose element types are references for each `Ref`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">  // Tuple type whose element types are references for each `Ref`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">  using range_reference_tuple = std::tuple<Refs...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">  using range_reference_tuple = std::tuple<Refs...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">  // Tuple type who elements are references to all values, including both</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">  // Tuple type who elements are references to all values, including both</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">  // the index and `Refs` reference types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">  // the index and `Refs` reference types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">  using value_reference_tuple = std::tuple<std::size_t, Refs...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">  using value_reference_tuple = std::tuple<std::size_t, Refs...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine coveredLine">  enumerator_result(std::size_t Index, Refs &&...Rs)</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine coveredLine">  enumerator_result(std::size_t Index, Refs &&...Rs)</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine coveredLine">      : Idx(Index), Storage(std::forward<Refs>(Rs)...) {}</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine coveredLine">      : Idx(Index), Storage(std::forward<Refs>(Rs)...) {}</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">  /// Returns the 0-based index of the current position within the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">  /// Returns the 0-based index of the current position within the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">  /// input range(s).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">  /// input range(s).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine coveredLine">  std::size_t index() const { return Idx; }</td>
    <td class="lineNumber">13</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine coveredLine">  std::size_t index() const { return Idx; }</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">  /// Returns the value(s) for the current iterator. This does not include the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">  /// Returns the value(s) for the current iterator. This does not include the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">  /// index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">  /// index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine coveredLine">  decltype(auto) value() const {</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine coveredLine">  decltype(auto) value() const {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">    if constexpr (NumRefs == 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">    if constexpr (NumRefs == 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine coveredLine">      return std::get<0>(Storage);</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine coveredLine">      return std::get<0>(Storage);</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">      return Storage;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">      return Storage;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">  /// Returns the value at index `I`. This case covers the index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">  /// Returns the value at index `I`. This case covers the index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">  template <std::size_t I, typename = std::enable_if_t<I == 0>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">  template <std::size_t I, typename = std::enable_if_t<I == 0>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  friend std::size_t get(const enumerator_result &Result) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  friend std::size_t get(const enumerator_result &Result) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">    return Result.Idx;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">    return Result.Idx;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">  /// Returns the value at index `I`. This case covers references to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">  /// Returns the value at index `I`. This case covers references to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">  /// iteratees.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">  /// iteratees.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">  template <std::size_t I, typename = std::enable_if_t<I != 0>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">  template <std::size_t I, typename = std::enable_if_t<I != 0>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">  friend decltype(auto) get(const enumerator_result &Result) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">  friend decltype(auto) get(const enumerator_result &Result) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">    // Note: This is a separate function from the other `get`, instead of an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">    // Note: This is a separate function from the other `get`, instead of an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">    // `if constexpr` case, to work around an MSVC 19.31.31XXX compiler</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">    // `if constexpr` case, to work around an MSVC 19.31.31XXX compiler</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">    // (Visual Studio 2022 17.1) return type deduction bug.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">    // (Visual Studio 2022 17.1) return type deduction bug.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">    return std::get<I - 1>(Result.Storage);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">    return std::get<I - 1>(Result.Storage);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">  template <typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">  template <typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">  friend bool operator==(const enumerator_result &Result,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">  friend bool operator==(const enumerator_result &Result,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">                         const std::tuple<std::size_t, Ts...> &Other) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">                         const std::tuple<std::size_t, Ts...> &Other) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">    static_assert(NumRefs == sizeof...(Ts), "Size mismatch");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">    static_assert(NumRefs == sizeof...(Ts), "Size mismatch");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">    if (Result.Idx != std::get<0>(Other))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">    if (Result.Idx != std::get<0>(Other))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">    return Result.is_value_equal(Other, std::make_index_sequence<NumRefs>{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">    return Result.is_value_equal(Other, std::make_index_sequence<NumRefs>{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  template <typename Tuple, std::size_t... Idx></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  template <typename Tuple, std::size_t... Idx></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">  bool is_value_equal(const Tuple &Other, std::index_sequence<Idx...>) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">  bool is_value_equal(const Tuple &Other, std::index_sequence<Idx...>) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return ((std::get<Idx>(Storage) == std::get<Idx + 1>(Other)) && ...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    return ((std::get<Idx>(Storage) == std::get<Idx + 1>(Other)) && ...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">  std::size_t Idx;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">  std::size_t Idx;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">  // Make this tuple mutable to avoid casts that obfuscate const-correctness</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">  // Make this tuple mutable to avoid casts that obfuscate const-correctness</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  // issues. Const-correctness of references is taken care of by `zippy` that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  // issues. Const-correctness of references is taken care of by `zippy` that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">  // defines const-non and const iterator types that will propagate down to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">  // defines const-non and const iterator types that will propagate down to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">  // `enumerator_result`'s `Refs`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">  // `enumerator_result`'s `Refs`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">  //  Note that unlike the results of `zip*` functions, `enumerate`'s result are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">  //  Note that unlike the results of `zip*` functions, `enumerate`'s result are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">  //  supposed to be modifiable even when defined as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">  //  supposed to be modifiable even when defined as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">  // `const`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">  // `const`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">  mutable range_reference_tuple Storage;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">  mutable range_reference_tuple Storage;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">/// Infinite stream of increasing 0-based `size_t` indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">/// Infinite stream of increasing 0-based `size_t` indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">struct index_stream {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">struct index_stream {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">  struct iterator : iterator_facade_base<iterator, std::forward_iterator_tag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">  struct iterator : iterator_facade_base<iterator, std::forward_iterator_tag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">                                         const iterator> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">                                         const iterator> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine coveredLine">    iterator &operator++() {</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine coveredLine">    iterator &operator++() {</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine coveredLine">      assert(Index != std::numeric_limits<std::size_t>::max() &&</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine coveredLine">      assert(Index != std::numeric_limits<std::size_t>::max() &&</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">             "Attempting to increment end iterator");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">             "Attempting to increment end iterator");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine coveredLine">      ++Index;</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine coveredLine">      ++Index;</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine coveredLine">      return *this;</td>
    <td class="lineNumber">11</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine coveredLine">      return *this;</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">    // Note: This dereference operator returns a value instead of a reference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">    // Note: This dereference operator returns a value instead of a reference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">    // and does not strictly conform to the C++17's definition of forward</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">    // and does not strictly conform to the C++17's definition of forward</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">    // iterator. However, it satisfies all the forward_iterator requirements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">    // iterator. However, it satisfies all the forward_iterator requirements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">    // that the `zip_common` depends on and fully conforms to the C++20</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">    // that the `zip_common` depends on and fully conforms to the C++20</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">    // definition of forward iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">    // definition of forward iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine coveredLine">    std::size_t operator*() const { return Index; }</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine coveredLine">    std::size_t operator*() const { return Index; }</td>
    <td class="lineNumber">10</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">    friend bool operator==(const iterator &Lhs, const iterator &Rhs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">    friend bool operator==(const iterator &Lhs, const iterator &Rhs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">      return Lhs.Index == Rhs.Index;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">      return Lhs.Index == Rhs.Index;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">    std::size_t Index = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">    std::size_t Index = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine coveredLine">  iterator begin() const { return {}; }</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine coveredLine">  iterator begin() const { return {}; }</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine coveredLine">  iterator end() const {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine coveredLine">  iterator end() const {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">    // We approximate 'infinity' with the max size_t value, which should be good</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">    // We approximate 'infinity' with the max size_t value, which should be good</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">    // enough to index over any container.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">    // enough to index over any container.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine coveredLine">    iterator It;</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine coveredLine">    iterator It;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine coveredLine">    It.Index = std::numeric_limits<std::size_t>::max();</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine coveredLine">    It.Index = std::numeric_limits<std::size_t>::max();</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine coveredLine">    return It;</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine coveredLine">    return It;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">/// Given two or more input ranges, returns a new range whose values are are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">/// Given two or more input ranges, returns a new range whose values are are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">/// tuples (A, B, C, ...), such that A is the 0-based index of the item in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">/// tuples (A, B, C, ...), such that A is the 0-based index of the item in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">/// sequence, and B, C, ..., are the values from the original input ranges. All</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">/// sequence, and B, C, ..., are the values from the original input ranges. All</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">/// input ranges are required to have equal lengths. Note that the returned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">/// input ranges are required to have equal lengths. Note that the returned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">/// iterator allows for the values (B, C, ...) to be modified.  Example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">/// iterator allows for the values (B, C, ...) to be modified.  Example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">/// ```c++</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">/// ```c++</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">/// std::vector<char> Letters = {'A', 'B', 'C', 'D'};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">/// std::vector<char> Letters = {'A', 'B', 'C', 'D'};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">/// std::vector<int> Vals = {10, 11, 12, 13};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">/// std::vector<int> Vals = {10, 11, 12, 13};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">/// for (auto [Index, Letter, Value] : enumerate(Letters, Vals)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">/// for (auto [Index, Letter, Value] : enumerate(Letters, Vals)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">///   printf("Item %zu - %c: %d\n", Index, Letter, Value);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">///   printf("Item %zu - %c: %d\n", Index, Letter, Value);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">///   Value -= 10;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">///   Value -= 10;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">/// }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">/// }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">/// Output:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">/// Output:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">///   Item 0 - A: 10</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">///   Item 0 - A: 10</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">///   Item 1 - B: 11</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">///   Item 1 - B: 11</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">///   Item 2 - C: 12</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">///   Item 2 - C: 12</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">///   Item 3 - D: 13</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">///   Item 3 - D: 13</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">/// or using an iterator:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">/// or using an iterator:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">/// ```c++</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">/// ```c++</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">/// for (auto it : enumerate(Vals)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">/// for (auto it : enumerate(Vals)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">///   it.value() += 10;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">///   it.value() += 10;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">///   printf("Item %zu: %d\n", it.index(), it.value());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">///   printf("Item %zu: %d\n", it.index(), it.value());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">/// }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">/// }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">/// Output:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">/// Output:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">///   Item 0: 20</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">///   Item 0: 20</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">///   Item 1: 21</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">///   Item 1: 21</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">///   Item 2: 22</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">///   Item 2: 22</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">///   Item 3: 23</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">///   Item 3: 23</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">template <typename FirstRange, typename... RestRanges></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">template <typename FirstRange, typename... RestRanges></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine coveredLine">auto enumerate(FirstRange &&First, RestRanges &&...Rest) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine coveredLine">auto enumerate(FirstRange &&First, RestRanges &&...Rest) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">  if constexpr (sizeof...(Rest) != 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">  if constexpr (sizeof...(Rest) != 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">    // Note: Create an array instead of an initializer list to work around an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">    // Note: Create an array instead of an initializer list to work around an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">    // Apple clang 14 compiler bug.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">    // Apple clang 14 compiler bug.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">    size_t sizes[] = {range_size(First), range_size(Rest)...};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">    size_t sizes[] = {range_size(First), range_size(Rest)...};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">    assert(all_equal(sizes) && "Ranges have different length");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">    assert(all_equal(sizes) && "Ranges have different length");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">  using enumerator = detail::zippy<detail::zip_enumerator, detail::index_stream,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">  using enumerator = detail::zippy<detail::zip_enumerator, detail::index_stream,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">                                   FirstRange, RestRanges...>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">                                   FirstRange, RestRanges...>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">  return enumerator(detail::index_stream{}, std::forward<FirstRange>(First),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">  return enumerator(detail::index_stream{}, std::forward<FirstRange>(First),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine coveredLine">                    std::forward<RestRanges>(Rest)...);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine coveredLine">                    std::forward<RestRanges>(Rest)...);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">template <typename Predicate, typename... Args></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">template <typename Predicate, typename... Args></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">  auto z = zip(args...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">  auto z = zip(args...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">  auto it = z.begin();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">  auto it = z.begin();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">  auto end = z.end();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">  auto end = z.end();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">  while (it != end) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">  while (it != end) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">    if (!std::apply([&](auto &&...args) { return P(args...); }, *it))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">    if (!std::apply([&](auto &&...args) { return P(args...); }, *it))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">    ++it;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">    ++it;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">  return it.all_equals(end);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">  return it.all_equals(end);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">// Just an adaptor to switch the order of argument and have the predicate before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">// Just an adaptor to switch the order of argument and have the predicate before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">// the zipped inputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">// the zipped inputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">template <typename... ArgsThenPredicate, size_t... InputIndexes></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">template <typename... ArgsThenPredicate, size_t... InputIndexes></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">bool all_of_zip_predicate_last(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">bool all_of_zip_predicate_last(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">    std::tuple<ArgsThenPredicate...> argsThenPredicate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">    std::tuple<ArgsThenPredicate...> argsThenPredicate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">    std::index_sequence<InputIndexes...>) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">    std::index_sequence<InputIndexes...>) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">  auto constexpr OutputIndex =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">  auto constexpr OutputIndex =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">      std::tuple_size<decltype(argsThenPredicate)>::value - 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">      std::tuple_size<decltype(argsThenPredicate)>::value - 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">                             std::get<InputIndexes>(argsThenPredicate)...);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">                             std::get<InputIndexes>(argsThenPredicate)...);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">} // end namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">/// Compare two zipped ranges using the provided predicate (as last argument).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">/// Compare two zipped ranges using the provided predicate (as last argument).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">/// Return true if all elements satisfy the predicate and false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">/// Return true if all elements satisfy the predicate and false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">//  Return false if the zipped iterator aren't all at end (size mismatch).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">//  Return false if the zipped iterator aren't all at end (size mismatch).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">template <typename... ArgsAndPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">template <typename... ArgsAndPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">  return detail::all_of_zip_predicate_last(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">  return detail::all_of_zip_predicate_last(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">      std::forward_as_tuple(argsAndPredicate...),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">      std::forward_as_tuple(argsAndPredicate...),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">/// time. Not meant for use with random-access iterators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">/// time. Not meant for use with random-access iterators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">/// Can optionally take a predicate to filter lazily some items.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">/// Can optionally take a predicate to filter lazily some items.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">template <typename IterTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">template <typename IterTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">bool hasNItems(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">bool hasNItems(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">    Pred &&ShouldBeCounted =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">    Pred &&ShouldBeCounted =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">    std::enable_if_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">    std::enable_if_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">        !std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">        !std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">                         typename std::iterator_traits<std::remove_reference_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">                         typename std::iterator_traits<std::remove_reference_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">                             decltype(Begin)>>::iterator_category>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">                             decltype(Begin)>>::iterator_category>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">        void> * = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">        void> * = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">  for (; N; ++Begin) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">  for (; N; ++Begin) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">    if (Begin == End)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">    if (Begin == End)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">      return false; // Too few.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">      return false; // Too few.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">    N -= ShouldBeCounted(*Begin);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">    N -= ShouldBeCounted(*Begin);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">  for (; Begin != End; ++Begin)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">  for (; Begin != End; ++Begin)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">    if (ShouldBeCounted(*Begin))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">    if (ShouldBeCounted(*Begin))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">      return false; // Too many.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">      return false; // Too many.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">/// time. Not meant for use with random-access iterators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">/// time. Not meant for use with random-access iterators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">/// Can optionally take a predicate to lazily filter some items.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">/// Can optionally take a predicate to lazily filter some items.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">template <typename IterTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">template <typename IterTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">bool hasNItemsOrMore(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">bool hasNItemsOrMore(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">    Pred &&ShouldBeCounted =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">    Pred &&ShouldBeCounted =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">        [](const decltype(*std::declval<IterTy>()) &) { return true; },</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">    std::enable_if_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">    std::enable_if_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">        !std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">        !std::is_base_of<std::random_access_iterator_tag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">                         typename std::iterator_traits<std::remove_reference_t<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">                         typename std::iterator_traits<std::remove_reference_t<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">                             decltype(Begin)>>::iterator_category>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">                             decltype(Begin)>>::iterator_category>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">        void> * = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">        void> * = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">  for (; N; ++Begin) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">  for (; N; ++Begin) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">    if (Begin == End)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">    if (Begin == End)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">      return false; // Too few.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">      return false; // Too few.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">    N -= ShouldBeCounted(*Begin);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">    N -= ShouldBeCounted(*Begin);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">/// Returns true if the sequence [Begin, End) has N or less items. Can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">/// Returns true if the sequence [Begin, End) has N or less items. Can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">/// optionally take a predicate to lazily filter some items.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">/// optionally take a predicate to lazily filter some items.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">template <typename IterTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">template <typename IterTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">bool hasNItemsOrLess(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">bool hasNItemsOrLess(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">    IterTy &&Begin, IterTy &&End, unsigned N,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">    }) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">    }) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">  assert(N != std::numeric_limits<unsigned>::max());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">  assert(N != std::numeric_limits<unsigned>::max());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">/// Returns true if the given container has exactly N items</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">/// Returns true if the given container has exactly N items</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">  return hasNItems(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">  return hasNItems(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">/// Returns true if the given container has N or more items</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">/// Returns true if the given container has N or more items</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">template <typename ContainerTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">template <typename ContainerTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">  return hasNItemsOrMore(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">  return hasNItemsOrMore(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">/// Returns true if the given container has N or less items</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">/// Returns true if the given container has N or less items</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">template <typename ContainerTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">template <typename ContainerTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">  return hasNItemsOrLess(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">  return hasNItemsOrLess(std::begin(C), std::end(C), N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">/// Returns a raw pointer that represents the same address as the argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">/// Returns a raw pointer that represents the same address as the argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">/// This implementation can be removed once we move to C++20 where it's defined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">/// This implementation can be removed once we move to C++20 where it's defined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">/// as std::to_address().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">/// as std::to_address().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">/// The std::pointer_traits<>::to_address(p) variations of these overloads has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">/// The std::pointer_traits<>::to_address(p) variations of these overloads has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">/// not been implemented.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">/// not been implemented.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">template <class T> constexpr T *to_address(T *P) { return P; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">template <class T> constexpr T *to_address(T *P) { return P; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">namespace std {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">namespace std {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">template <typename... Refs></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">template <typename... Refs></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">struct tuple_size<llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">struct tuple_size<llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">    : std::integral_constant<std::size_t, sizeof...(Refs)> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">    : std::integral_constant<std::size_t, sizeof...(Refs)> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">template <std::size_t I, typename... Refs></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">template <std::size_t I, typename... Refs></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">struct tuple_element<I, llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">struct tuple_element<I, llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">template <std::size_t I, typename... Refs></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">template <std::size_t I, typename... Refs></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">struct tuple_element<I, const llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">struct tuple_element<I, const llvm::detail::enumerator_result<Refs...>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">    : std::tuple_element<I, std::tuple<Refs...>> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">} // namespace std</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">} // namespace std</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">#endif // LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">#endif // LLVM_ADT_STLEXTRAS_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>