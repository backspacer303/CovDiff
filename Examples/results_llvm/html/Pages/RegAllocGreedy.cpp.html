<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>RegAllocGreedy.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- RegAllocGreedy.cpp - greedy register allocator ---------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file defines the RAGreedy function pass for register allocation in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// optimized builds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "RegAllocGreedy.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "AllocationOrder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "InterferenceCache.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "LiveDebugVariables.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "RegAllocBase.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "RegAllocEvictionAdvisor.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "RegAllocPriorityAdvisor.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "SpillPlacement.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "SplitKit.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/ADT/BitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/ADT/IndexedMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/ADT/SmallSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/ADT/StringRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/CodeGen/CalcSpillWeights.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/CodeGen/EdgeBundles.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/CodeGen/LiveInterval.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/CodeGen/LiveIntervalUnion.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/CodeGen/LiveIntervals.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/CodeGen/LiveRangeEdit.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/CodeGen/LiveRegMatrix.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/CodeGen/LiveStacks.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/CodeGen/MachineBlockFrequencyInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/CodeGen/MachineDominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/CodeGen/MachineFrameInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/CodeGen/MachineOptimizationRemarkEmitter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include "llvm/CodeGen/RegAllocRegistry.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include "llvm/CodeGen/SlotIndexes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include "llvm/CodeGen/Spiller.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">#include "llvm/CodeGen/VirtRegMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#include "llvm/IR/DebugInfoMetadata.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">#include "llvm/IR/LLVMContext.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">#include "llvm/MC/MCRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">#include "llvm/Support/BlockFrequency.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">#include "llvm/Support/BranchProbability.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">#include "llvm/Support/MathExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">#include "llvm/Support/Timer.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">#define DEBUG_TYPE "regalloc"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">STATISTIC(NumGlobalSplits, "Number of split global live ranges");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">STATISTIC(NumLocalSplits,  "Number of split local live ranges");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">STATISTIC(NumEvicted,      "Number of interferences evicted");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">static cl::opt<SplitEditor::ComplementSpillMode> SplitSpillMode(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">    "split-spill-mode", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">    cl::desc("Spill mode for splitting live ranges"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">    cl::values(clEnumValN(SplitEditor::SM_Partition, "default", "Default"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">               clEnumValN(SplitEditor::SM_Size, "size", "Optimize for size"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">               clEnumValN(SplitEditor::SM_Speed, "speed", "Optimize for speed")),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">    cl::init(SplitEditor::SM_Speed));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">static cl::opt<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">LastChanceRecoloringMaxDepth("lcr-max-depth", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">                             cl::desc("Last chance recoloring max depth"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">                             cl::init(5));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">static cl::opt<unsigned> LastChanceRecoloringMaxInterference(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">    "lcr-max-interf", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">    cl::desc("Last chance recoloring maximum number of considered"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">             " interference at a time"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">    cl::init(8));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">static cl::opt<bool> ExhaustiveSearch(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">    "exhaustive-register-search", cl::NotHidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">    cl::desc("Exhaustive Search for registers bypassing the depth "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">             "and interference cutoffs of last chance recoloring"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">    cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">static cl::opt<bool> EnableDeferredSpilling(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">    "enable-deferred-spilling", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">    cl::desc("Instead of spilling a variable right away, defer the actual "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">             "code insertion to the end of the allocation. That way the "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">             "allocator might still find a suitable coloring for this "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">             "variable because of other evicted variables."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">    cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">// FIXME: Find a good default for this flag and remove the flag.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">static cl::opt<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">CSRFirstTimeCost("regalloc-csr-first-time-cost",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">              cl::desc("Cost for first time use of callee-saved register."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">              cl::init(0), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">static cl::opt<unsigned long> GrowRegionComplexityBudget(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">    "grow-region-complexity-budget",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">    cl::desc("growRegion() does not scale with the number of BB edges, so "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">             "limit its budget and bail out once we reach the limit."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">    cl::init(10000), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">static cl::opt<bool> GreedyRegClassPriorityTrumpsGlobalness(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">    "greedy-regclass-priority-trumps-globalness",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">    cl::desc("Change the greedy register allocator's live range priority "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">             "calculation to make the AllocationPriority of the register class "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">             "more important then whether the range is global"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">    cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">static cl::opt<bool> GreedyReverseLocalAssignment(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">    "greedy-reverse-local-assignment",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">    cl::desc("Reverse allocation order of local live ranges, such that "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">             "shorter local live ranges will tend to be allocated first"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">    cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">static RegisterRegAlloc greedyRegAlloc("greedy", "greedy register allocator",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">                                       createGreedyRegisterAllocator);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">char RAGreedy::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">char &llvm::RAGreedyID = RAGreedy::ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(RAGreedy, "greedy",</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">                "Greedy Register Allocator", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveDebugVariables)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(SlotIndexes)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(RegisterCoalescer)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineScheduler)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveStacks)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(VirtRegMap)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveRegMatrix)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(EdgeBundles)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(SpillPlacement)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineOptimizationRemarkEmitterPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(RegAllocEvictionAdvisorAnalysis)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(RegAllocPriorityAdvisorAnalysis)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="coveredLine">INITIALIZE_PASS_END(RAGreedy, "greedy",</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">                "Greedy Register Allocator", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">const char *const RAGreedy::StageName[] = {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">    "RS_New",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">    "RS_Assign",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">    "RS_Split",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">    "RS_Split2",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">    "RS_Spill",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">    "RS_Memory",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">    "RS_Done"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">// Hysteresis to use when comparing floats.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">// This helps stabilize decisions based on float comparisons.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">const float Hysteresis = (2007 / 2048.0f); // 0.97998046875</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="coveredLine">FunctionPass* llvm::createGreedyRegisterAllocator() {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="coveredLine">  return new RAGreedy();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">FunctionPass *llvm::createGreedyRegisterAllocator(RegClassFilterFunc Ftor) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">  return new RAGreedy(Ftor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="coveredLine">RAGreedy::RAGreedy(RegClassFilterFunc F):</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  MachineFunctionPass(ID),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="coveredLine">  RegAllocBase(F) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="coveredLine">}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="coveredLine">void RAGreedy::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="coveredLine">  AU.setPreservesCFG();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="coveredLine">  AU.addRequired<MachineBlockFrequencyInfo>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="coveredLine">  AU.addPreserved<MachineBlockFrequencyInfo>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="coveredLine">  AU.addRequired<LiveIntervals>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="coveredLine">  AU.addPreserved<LiveIntervals>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="coveredLine">  AU.addRequired<SlotIndexes>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="coveredLine">  AU.addPreserved<SlotIndexes>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="coveredLine">  AU.addRequired<LiveDebugVariables>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="coveredLine">  AU.addPreserved<LiveDebugVariables>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="coveredLine">  AU.addRequired<LiveStacks>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="coveredLine">  AU.addPreserved<LiveStacks>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="coveredLine">  AU.addRequired<MachineDominatorTree>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="coveredLine">  AU.addPreserved<MachineDominatorTree>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="coveredLine">  AU.addRequired<MachineLoopInfo>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="coveredLine">  AU.addPreserved<MachineLoopInfo>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="coveredLine">  AU.addRequired<VirtRegMap>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="coveredLine">  AU.addPreserved<VirtRegMap>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="coveredLine">  AU.addRequired<LiveRegMatrix>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="coveredLine">  AU.addPreserved<LiveRegMatrix>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="coveredLine">  AU.addRequired<EdgeBundles>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="coveredLine">  AU.addRequired<SpillPlacement>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="coveredLine">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="coveredLine">  AU.addRequired<RegAllocEvictionAdvisorAnalysis>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="coveredLine">  AU.addRequired<RegAllocPriorityAdvisorAnalysis>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="coveredLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="coveredLine">}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">//                     LiveRangeEdit delegate methods</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">bool RAGreedy::LRE_CanEraseVirtReg(Register VirtReg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  if (VRM->hasPhys(VirtReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">    Matrix->unassign(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">    aboutToRemoveInterval(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  // Unassigned virtreg is probably in the priority queue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  // RegAllocBase will erase it after dequeueing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  // Nonetheless, clear the live-range so that the debug</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">  // dump will show the right state for that VirtReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">  LI.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="uncoveredLine">void RAGreedy::LRE_WillShrinkVirtReg(Register VirtReg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">  if (!VRM->hasPhys(VirtReg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  // Register is assigned, put it back on the queue for reassignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="uncoveredLine">  Matrix->unassign(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">  RegAllocBase::enqueue(&LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">void RAGreedy::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">  ExtraInfo->LRE_DidCloneVirtReg(New, Old);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">void RAGreedy::ExtraRegInfo::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">  // Cloning a register we haven't even heard about yet?  Just ignore it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">  if (!Info.inBounds(Old))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  // LRE may clone a virtual register because dead code elimination causes it to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  // be split into connected components. The new components are much smaller</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  // than the original, so they should get a new chance at being assigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  // same stage as the parent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="uncoveredLine">  Info[Old].Stage = RS_Assign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">  Info.grow(New.id());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="uncoveredLine">  Info[New] = Info[Old];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="coveredLine">void RAGreedy::releaseMemory() {</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="coveredLine">  SpillerInstance.reset();</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="coveredLine">  GlobalCand.clear();</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="coveredLine">}</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="coveredLine">void RAGreedy::enqueueImpl(const LiveInterval *LI) { enqueue(Queue, LI); }</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="coveredLine">void RAGreedy::enqueue(PQueue &CurQueue, const LiveInterval *LI) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">  // Prioritize live ranges by size, assigning larger ranges first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">  // The queue holds (size, reg) pairs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="coveredLine">  const Register Reg = LI->reg();</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="coveredLine">  assert(Reg.isVirtual() && "Can only enqueue virtual registers");</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="coveredLine">  auto Stage = ExtraInfo->getOrInitStage(Reg);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="coveredLine">  if (Stage == RS_New) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="coveredLine">    Stage = RS_Assign;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="coveredLine">    ExtraInfo->setStage(Reg, Stage);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="coveredLine">  unsigned Ret = PriorityAdvisor->getPriority(*LI);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  // The virtual register number is a tie breaker for same-sized ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">  // Give lower vreg numbers higher priority to assign them first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="coveredLine">  CurQueue.push(std::make_pair(Ret, ~Reg));</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="coveredLine">}</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="coveredLine">unsigned DefaultPriorityAdvisor::getPriority(const LiveInterval &LI) const {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="coveredLine">  const unsigned Size = LI.getSize();</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="coveredLine">  const Register Reg = LI.reg();</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">  unsigned Prio;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="coveredLine">  LiveRangeStage Stage = RA.getExtraInfo().getStage(LI);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="coveredLine">  if (Stage == RS_Split) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">    // Unsplit ranges that couldn't be allocated immediately are deferred until</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">    // everything else has been allocated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">    Prio = Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="coveredLine">  } else if (Stage == RS_Memory) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">    // Memory operand should be considered last.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">    // Change the priority such that Memory operand are assigned in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">    // the reverse order that they came in.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">    // TODO: Make this a member variable and probably do something about hints.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">    static unsigned MemOp = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">    Prio = MemOp++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">    // Giant live ranges fall back to the global assignment heuristic, which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">    // prevents excessive spilling in pathological cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="coveredLine">    const TargetRegisterClass &RC = *MRI->getRegClass(Reg);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="coveredLine">    bool ForceGlobal = RC.GlobalPriority ||</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="coveredLine">                       (!ReverseLocalAssignment &&</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="coveredLine">                        (Size / SlotIndex::InstrDist) ></td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="coveredLine">                            (2 * RegClassInfo.getNumAllocatableRegs(&RC)));</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="coveredLine">    unsigned GlobalBit = 0;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="coveredLine">    if (Stage == RS_Assign && !ForceGlobal && !LI.empty() &&</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="coveredLine">        LIS->intervalIsInOneMBB(LI)) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">      // Allocate original local ranges in linear instruction order. Since they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">      // are singly defined, this produces optimal coloring in the absence of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">      // global interference and other constraints.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="coveredLine">      if (!ReverseLocalAssignment)</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="coveredLine">        Prio = LI.beginIndex().getApproxInstrDistance(Indexes->getLastIndex());</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">      else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">        // Allocating bottom up may allow many short LRGs to be assigned first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">        // to one of the cheap registers. This could be much faster for very</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">        // large blocks on targets with many physical registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">        Prio = Indexes->getZeroIndex().getApproxInstrDistance(LI.endIndex());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">      // Allocate global and split ranges in long->short order. Long ranges that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">      // don't fit should be spilled (or split) ASAP so they don't create</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">      // interference.  Mark a bit to prioritize global above local ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">      Prio = Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">      GlobalBit = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">    // Priority bit layout:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">    // 31 RS_Assign priority</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">    // 30 Preference priority</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">    // if (RegClassPriorityTrumpsGlobalness)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">    //   29-25 AllocPriority</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">    //   24 GlobalBit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">    // else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">    //   29 Global bit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">    //   28-24 AllocPriority</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">    // 0-23 Size/Instr distance</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">    // Clamp the size to fit with the priority masking scheme</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="coveredLine">    Prio = std::min(Prio, (unsigned)maxUIntN(24));</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="coveredLine">    assert(isUInt<5>(RC.AllocationPriority) && "allocation priority overflow");</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="coveredLine">    if (RegClassPriorityTrumpsGlobalness)</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="uncoveredLine">      Prio |= RC.AllocationPriority << 25 | GlobalBit << 24;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="coveredLine">      Prio |= GlobalBit << 29 | RC.AllocationPriority << 24;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">    // Mark a higher bit to prioritize global and local above RS_Split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="coveredLine">    Prio |= (1u << 31);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">    // Boost ranges that have a physical register hint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="coveredLine">    if (VRM->hasKnownPreference(Reg))</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="coveredLine">      Prio |= (1u << 30);</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="coveredLine">  return Prio;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="coveredLine">const LiveInterval *RAGreedy::dequeue() { return dequeue(Queue); }</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="coveredLine">const LiveInterval *RAGreedy::dequeue(PQueue &CurQueue) {</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="coveredLine">  if (CurQueue.empty())</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="coveredLine">    return nullptr;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="coveredLine">  LiveInterval *LI = &LIS->getInterval(~CurQueue.top().second);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="coveredLine">  CurQueue.pop();</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="coveredLine">  return LI;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">//                            Direct Assignment</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">/// tryAssign - Try to assign VirtReg to an available register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="coveredLine">MCRegister RAGreedy::tryAssign(const LiveInterval &VirtReg,</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">                               AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">                               SmallVectorImpl<Register> &NewVRegs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">                               const SmallVirtRegSet &FixedRegisters) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="coveredLine">  MCRegister PhysReg;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="coveredLine">  for (auto I = Order.begin(), E = Order.end(); I != E && !PhysReg; ++I) {</td>
    <td>28</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="coveredLine">    assert(*I);</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="coveredLine">    if (!Matrix->checkInterference(VirtReg, *I)) {</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="coveredLine">      if (I.isHint())</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="coveredLine">        return *I;</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="coveredLine">        PhysReg = *I;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="coveredLine">  if (!PhysReg.isValid())</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">    return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  // PhysReg is available, but there may be a better choice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">  // If we missed a simple hint, try to cheaply evict interference from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">  // preferred register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="coveredLine">  if (Register Hint = MRI->getSimpleHint(VirtReg.reg()))</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">    if (Order.isHint(Hint)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">      MCRegister PhysHint = Hint.asMCReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "missed hint " << printReg(PhysHint, TRI) << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">      if (EvictAdvisor->canEvictHintInterference(VirtReg, PhysHint,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">                                                 FixedRegisters)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">        evictInterference(VirtReg, PhysHint, NewVRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">        return PhysHint;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">      // Record the missed hint, we may be able to recover</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">      // at the end if the surrounding allocation changed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">      SetOfBrokenHints.insert(&VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  // Try to evict interference from a cheaper alternative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="coveredLine">  uint8_t Cost = RegCosts[PhysReg];</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  // Most registers have 0 additional cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="coveredLine">  if (!Cost)</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="coveredLine">    return PhysReg;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << " is available at cost "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">                    << (unsigned)Cost << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">  MCRegister CheapReg = tryEvict(VirtReg, Order, NewVRegs, Cost, FixedRegisters);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">  return CheapReg ? CheapReg : PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">//                         Interference eviction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">bool RegAllocEvictionAdvisor::canReassign(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">                                          MCRegister FromReg) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">  auto HasRegUnitInterference = [&](MCRegUnit Unit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">    // Instantiate a "subquery", not to be confused with the Queries array.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">    LiveIntervalUnion::Query SubQ(VirtReg, Matrix->getLiveUnions()[Unit]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">    return SubQ.checkInterference();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">  for (MCRegister Reg :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">       AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">    if (Reg == FromReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">    // If no units have interference, reassignment is possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">    if (none_of(TRI->regunits(Reg), HasRegUnitInterference)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "can reassign: " << VirtReg << " from "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">                        << printReg(FromReg, TRI) << " to "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">                        << printReg(Reg, TRI) << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">/// evictInterference - Evict any interferring registers that prevent VirtReg</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">/// from being assigned to Physreg. This assumes that canEvictInterference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">/// returned true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">void RAGreedy::evictInterference(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">                                 MCRegister PhysReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">  // Make sure that VirtReg has a cascade number, and assign that cascade</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  // number to every evicted register. These live ranges than then only be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  // evicted by a newer cascade, preventing infinite loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">  unsigned Cascade = ExtraInfo->getOrAssignNewCascade(VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "evicting " << printReg(PhysReg, TRI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">                    << " interference: Cascade " << Cascade << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  // Collect all interfering virtregs first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">  SmallVector<const LiveInterval *, 8> Intfs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">    // We usually have the interfering VRegs cached so collectInterferingVRegs()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">    // should be fast, we may need to recalculate if when different physregs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">    // overlap the same register unit so we had different SubRanges queried</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">    // against it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="uncoveredLine">    ArrayRef<const LiveInterval *> IVR = Q.interferingVRegs();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">    Intfs.append(IVR.begin(), IVR.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">  // Evict them second. This will invalidate the queries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">  for (const LiveInterval *Intf : Intfs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">    // The same VirtReg may be present in multiple RegUnits. Skip duplicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">    if (!VRM->hasPhys(Intf->reg()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">    Matrix->unassign(*Intf);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">    assert((ExtraInfo->getCascade(Intf->reg()) < Cascade ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">            VirtReg.isSpillable() < Intf->isSpillable()) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">           "Cannot decrease cascade number, illegal eviction");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">    ExtraInfo->setCascade(Intf->reg(), Cascade);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">    ++NumEvicted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">    NewVRegs.push_back(Intf->reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">/// Returns true if the given \p PhysReg is a callee saved register and has not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">/// been used for allocation yet.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">bool RegAllocEvictionAdvisor::isUnusedCalleeSavedReg(MCRegister PhysReg) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">  MCRegister CSR = RegClassInfo.getLastCalleeSavedAlias(PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">  if (!CSR)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">  return !Matrix->isPhysRegUsed(PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">std::optional<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">RegAllocEvictionAdvisor::getOrderLimit(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">                                       const AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">                                       unsigned CostPerUseLimit) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="uncoveredLine">  unsigned OrderLimit = Order.getOrder().size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">  if (CostPerUseLimit < uint8_t(~0u)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">    // Check of any registers in RC are below CostPerUseLimit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">    const TargetRegisterClass *RC = MRI->getRegClass(VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">    uint8_t MinCost = RegClassInfo.getMinCost(RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">    if (MinCost >= CostPerUseLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << TRI->getRegClassName(RC) << " minimum cost = "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">                        << MinCost << ", no cheaper registers to be found.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">      return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">    // It is normal for register classes to have a long tail of registers with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">    // the same cost. We don't need to look at them if they're too expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">    if (RegCosts[Order.getOrder().back()] >= CostPerUseLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">      OrderLimit = RegClassInfo.getLastCostChange(RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Only trying the first " << OrderLimit</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">                        << " regs.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="uncoveredLine">  return OrderLimit;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">bool RegAllocEvictionAdvisor::canAllocatePhysReg(unsigned CostPerUseLimit,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">                                                 MCRegister PhysReg) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="uncoveredLine">  if (RegCosts[PhysReg] >= CostPerUseLimit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">  // The first use of a callee-saved register in a function has cost 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">  // Don't start using a CSR when the CostPerUseLimit is low.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="uncoveredLine">  if (CostPerUseLimit == 1 && isUnusedCalleeSavedReg(PhysReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">    LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">        dbgs() << printReg(PhysReg, TRI) << " would clobber CSR "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">               << printReg(RegClassInfo.getLastCalleeSavedAlias(PhysReg), TRI)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">               << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">/// tryEvict - Try to evict all interferences for a physreg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">/// @param  VirtReg Currently unassigned virtual register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">/// @param  Order   Physregs to try.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">/// @return         Physreg to assign VirtReg, or 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">MCRegister RAGreedy::tryEvict(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">                              AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">                              SmallVectorImpl<Register> &NewVRegs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">                              uint8_t CostPerUseLimit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">                              const SmallVirtRegSet &FixedRegisters) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  NamedRegionTimer T("evict", "Evict", TimerGroupName, TimerGroupDescription,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">                     TimePassesIsEnabled);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  MCRegister BestPhys = EvictAdvisor->tryFindEvictionCandidate(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">      VirtReg, Order, CostPerUseLimit, FixedRegisters);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">  if (BestPhys.isValid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">    evictInterference(VirtReg, BestPhys, NewVRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">  return BestPhys;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">//                              Region Splitting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">/// addSplitConstraints - Fill out the SplitConstraints vector based on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">/// interference pattern in Physreg and its aliases. Add the constraints to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">/// SpillPlacement and return the static cost of this split in Cost, assuming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">/// that all preferences in SplitConstraints are met.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">/// Return false if there are no bundles with positive bias.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">bool RAGreedy::addSplitConstraints(InterferenceCache::Cursor Intf,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">                                   BlockFrequency &Cost) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">  // Reset interference dependent info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">  SplitConstraints.resize(UseBlocks.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  BlockFrequency StaticCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">    BC.Number = BI.MBB->getNumber();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">    Intf.moveToBlock(BC.Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="uncoveredLine">    BC.Entry = BI.LiveIn ? SpillPlacement::PrefReg : SpillPlacement::DontCare;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">    BC.Exit = (BI.LiveOut &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">               !LIS->getInstructionFromIndex(BI.LastInstr)->isImplicitDef())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">                  ? SpillPlacement::PrefReg</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">                  : SpillPlacement::DontCare;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">    BC.ChangesValue = BI.FirstDef.isValid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">    if (!Intf.hasInterference())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">    // Number of spill code instructions to insert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">    unsigned Ins = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">    // Interference for the live-in value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">    if (BI.LiveIn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">      if (Intf.first() <= Indexes->getMBBStartIdx(BC.Number)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">        BC.Entry = SpillPlacement::MustSpill;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">        ++Ins;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">      } else if (Intf.first() < BI.FirstInstr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">        BC.Entry = SpillPlacement::PrefSpill;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">        ++Ins;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">      } else if (Intf.first() < BI.LastInstr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">        ++Ins;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">      // Abort if the spill cannot be inserted at the MBB' start</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">      if (((BC.Entry == SpillPlacement::MustSpill) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">           (BC.Entry == SpillPlacement::PrefSpill)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">          SlotIndex::isEarlierInstr(BI.FirstInstr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">                                    SA->getFirstSplitPoint(BC.Number)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">    // Interference for the live-out value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">    if (BI.LiveOut) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">      if (Intf.last() >= SA->getLastSplitPoint(BC.Number)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">        BC.Exit = SpillPlacement::MustSpill;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">        ++Ins;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">      } else if (Intf.last() > BI.LastInstr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">        BC.Exit = SpillPlacement::PrefSpill;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">        ++Ins;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">      } else if (Intf.last() > BI.FirstInstr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">        ++Ins;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">    // Accumulate the total frequency of inserted spill code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">    while (Ins--)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">      StaticCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">  Cost = StaticCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  // Add constraints for use-blocks. Note that these are the only constraints</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">  // that may add a positive bias, it is downhill from here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">  SpillPlacer->addConstraints(SplitConstraints);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">  return SpillPlacer->scanActiveBundles();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">/// addThroughConstraints - Add constraints and links to SpillPlacer from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">/// live-through blocks in Blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">bool RAGreedy::addThroughConstraints(InterferenceCache::Cursor Intf,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">                                     ArrayRef<unsigned> Blocks) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">  const unsigned GroupSize = 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">  SpillPlacement::BlockConstraint BCS[GroupSize];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">  unsigned TBS[GroupSize];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">  unsigned B = 0, T = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">  for (unsigned Number : Blocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">    Intf.moveToBlock(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">    if (!Intf.hasInterference()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">      assert(T < GroupSize && "Array overflow");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">      TBS[T] = Number;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="uncoveredLine">      if (++T == GroupSize) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="uncoveredLine">        SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">        T = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">    assert(B < GroupSize && "Array overflow");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">    BCS[B].Number = Number;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">    // Abort if the spill cannot be inserted at the MBB' start</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">    MachineBasicBlock *MBB = MF->getBlockNumbered(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">    auto FirstNonDebugInstr = MBB->getFirstNonDebugInstr();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">    if (FirstNonDebugInstr != MBB->end() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">        SlotIndex::isEarlierInstr(LIS->getInstructionIndex(*FirstNonDebugInstr),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">                                  SA->getFirstSplitPoint(Number)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">    // Interference for the live-in value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">    if (Intf.first() <= Indexes->getMBBStartIdx(Number))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="uncoveredLine">      BCS[B].Entry = SpillPlacement::MustSpill;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">      BCS[B].Entry = SpillPlacement::PrefSpill;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">    // Interference for the live-out value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">    if (Intf.last() >= SA->getLastSplitPoint(Number))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">      BCS[B].Exit = SpillPlacement::MustSpill;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">      BCS[B].Exit = SpillPlacement::PrefSpill;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">    if (++B == GroupSize) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">      SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">      B = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">  SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">  SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">bool RAGreedy::growRegion(GlobalSplitCandidate &Cand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">  // Keep track of through blocks that have not been added to SpillPlacer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">  BitVector Todo = SA->getThroughBlocks();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">  SmallVectorImpl<unsigned> &ActiveBlocks = Cand.ActiveBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">  unsigned AddedTo = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">  unsigned Visited = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">  unsigned long Budget = GrowRegionComplexityBudget;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">    ArrayRef<unsigned> NewBundles = SpillPlacer->getRecentPositive();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">    // Find new through blocks in the periphery of PrefRegBundles.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">    for (unsigned Bundle : NewBundles) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">      // Look at all blocks connected to Bundle in the full graph.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">      ArrayRef<unsigned> Blocks = Bundles->getBlocks(Bundle);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">      // Limit compilation time by bailing out after we use all our budget.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="uncoveredLine">      if (Blocks.size() >= Budget)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">      Budget -= Blocks.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">      for (unsigned Block : Blocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">        if (!Todo.test(Block))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">        Todo.reset(Block);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">        // This is a new through block. Add it to SpillPlacer later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">        ActiveBlocks.push_back(Block);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">        ++Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">    // Any new blocks to add?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">    if (ActiveBlocks.size() == AddedTo)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">    // Compute through constraints from the interference, or assume that all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">    // through blocks prefer spilling when forming compact regions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">    auto NewBlocks = ArrayRef(ActiveBlocks).slice(AddedTo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">    if (Cand.PhysReg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">      if (!addThroughConstraints(Cand.Intf, NewBlocks))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">      // Provide a strong negative bias on through blocks to prevent unwanted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">      // liveness on loop backedges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">      SpillPlacer->addPrefSpill(NewBlocks, /* Strong= */ true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">    AddedTo = ActiveBlocks.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">    // Perhaps iterating can enable more bundles?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">    SpillPlacer->iterate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << ", v=" << Visited);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">/// calcCompactRegion - Compute the set of edge bundles that should be live</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">/// when splitting the current live range into compact regions.  Compact</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">/// regions can be computed without looking at interference.  They are the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">/// regions formed by removing all the live-through blocks from the live range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">/// Returns false if the current live range is already compact, or if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">/// compact regions would form single block regions anyway.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">bool RAGreedy::calcCompactRegion(GlobalSplitCandidate &Cand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">  // Without any through blocks, the live range is already compact.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">  if (!SA->getNumThroughBlocks())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">  // Compact regions don't correspond to any physreg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="uncoveredLine">  Cand.reset(IntfCache, MCRegister::NoRegister);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Compact region bundles");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">  // Use the spill placer to determine the live bundles. GrowRegion pretends</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">  // that all the through blocks have interference when PhysReg is unset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">  SpillPlacer->prepare(Cand.LiveBundles);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">  // The static split cost will be zero since Cand.Intf reports no interference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">  BlockFrequency Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">  if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">  if (!growRegion(Cand)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">  SpillPlacer->finish();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">  if (!Cand.LiveBundles.any()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">    for (int I : Cand.LiveBundles.set_bits())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">      dbgs() << " EB#" << I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">    dbgs() << ".\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">/// calcSpillCost - Compute how expensive it would be to split the live range in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">/// SA around all use blocks instead of forming bundle regions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">BlockFrequency RAGreedy::calcSpillCost() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">  BlockFrequency Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">    unsigned Number = BI.MBB->getNumber();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">    // We normally only need one spill instruction - a load or a store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">    Cost += SpillPlacer->getBlockFrequency(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">    // Unless the value is redefined in the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">    if (BI.LiveIn && BI.LiveOut && BI.FirstDef)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">      Cost += SpillPlacer->getBlockFrequency(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">  return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">/// calcGlobalSplitCost - Return the global split cost of following the split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">/// pattern in LiveBundles. This cost should be added to the local cost of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">/// interference pattern in SplitConstraints.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">BlockFrequency RAGreedy::calcGlobalSplitCost(GlobalSplitCandidate &Cand,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">                                             const AllocationOrder &Order) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">  BlockFrequency GlobalCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">  const BitVector &LiveBundles = Cand.LiveBundles;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">    bool RegIn  = LiveBundles[Bundles->getBundle(BC.Number, false)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">    bool RegOut = LiveBundles[Bundles->getBundle(BC.Number, true)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">    unsigned Ins = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">    Cand.Intf.moveToBlock(BC.Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">    if (BI.LiveIn)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">      Ins += RegIn != (BC.Entry == SpillPlacement::PrefReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">    if (BI.LiveOut)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">      Ins += RegOut != (BC.Exit == SpillPlacement::PrefReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="uncoveredLine">    while (Ins--)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">      GlobalCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">  for (unsigned Number : Cand.ActiveBlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">    bool RegIn  = LiveBundles[Bundles->getBundle(Number, false)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">    bool RegOut = LiveBundles[Bundles->getBundle(Number, true)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">    if (!RegIn && !RegOut)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">    if (RegIn && RegOut) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">      // We need double spill code if this block has interference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">      Cand.Intf.moveToBlock(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">      if (Cand.Intf.hasInterference()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">    // live-in / stack-out or stack-in live-out.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">    GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">  return GlobalCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">/// splitAroundRegion - Split the current live range around the regions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">/// determined by BundleCand and GlobalCand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">/// Before calling this function, GlobalCand and BundleCand must be initialized</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">/// so each bundle is assigned to a valid candidate, or NoCand for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">/// stack-bound bundles.  The shared SA/SE SplitAnalysis and SplitEditor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">/// objects must be initialized for the current live range, and intervals</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">/// created for the used candidates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">/// @param LREdit    The LiveRangeEdit object handling the current split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">/// @param UsedCands List of used GlobalCand entries. Every BundleCand value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">///                  must appear in this list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">void RAGreedy::splitAroundRegion(LiveRangeEdit &LREdit,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">                                 ArrayRef<unsigned> UsedCands) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">  // These are the intervals created for new global ranges. We may create more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">  // intervals for local ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="uncoveredLine">  const unsigned NumGlobalIntvs = LREdit.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "splitAroundRegion with " << NumGlobalIntvs</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">                    << " globals.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">  assert(NumGlobalIntvs && "No global intervals configured");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">  // Isolate even single instructions when dealing with a proper sub-class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">  // That guarantees register class inflation for the stack interval because it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">  // is all copies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">  Register Reg = SA->getParent().reg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="uncoveredLine">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">  // First handle all the blocks with uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">    unsigned Number = BI.MBB->getNumber();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">    unsigned IntvIn = 0, IntvOut = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">    SlotIndex IntfIn, IntfOut;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">    if (BI.LiveIn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">      if (CandIn != NoCand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">        IntvIn = Cand.IntvIdx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">        Cand.Intf.moveToBlock(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">        IntfIn = Cand.Intf.first();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">    if (BI.LiveOut) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">      if (CandOut != NoCand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">        IntvOut = Cand.IntvIdx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">        Cand.Intf.moveToBlock(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">        IntfOut = Cand.Intf.last();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">    // Create separate intervals for isolated blocks with multiple uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="uncoveredLine">    if (!IntvIn && !IntvOut) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << printMBBReference(*BI.MBB) << " isolated.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">      if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">        SE->splitSingleBlock(BI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">    if (IntvIn && IntvOut)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">    else if (IntvIn)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">      SE->splitRegInBlock(BI, IntvIn, IntfIn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">      SE->splitRegOutBlock(BI, IntvOut, IntfOut);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">  // Handle live-through blocks. The relevant live-through blocks are stored in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">  // the ActiveBlocks list with each candidate. We need to filter out</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">  // duplicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">  BitVector Todo = SA->getThroughBlocks();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="uncoveredLine">  for (unsigned UsedCand : UsedCands) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">    ArrayRef<unsigned> Blocks = GlobalCand[UsedCand].ActiveBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">    for (unsigned Number : Blocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">      if (!Todo.test(Number))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">      Todo.reset(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">      unsigned IntvIn = 0, IntvOut = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="uncoveredLine">      SlotIndex IntfIn, IntfOut;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="uncoveredLine">      if (CandIn != NoCand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="uncoveredLine">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">        IntvIn = Cand.IntvIdx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">        Cand.Intf.moveToBlock(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">        IntfIn = Cand.Intf.first();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">      if (CandOut != NoCand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">        IntvOut = Cand.IntvIdx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">        Cand.Intf.moveToBlock(Number);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">        IntfOut = Cand.Intf.last();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="uncoveredLine">      if (!IntvIn && !IntvOut)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">  ++NumGlobalSplits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">  SE->finish(&IntvMap);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">  unsigned OrigBlocks = SA->getNumLiveBlocks();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  // Sort out the new intervals created by splitting. We get four kinds:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">  // - Remainder intervals should not be split again.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">  // - Candidate intervals can be assigned to Cand.PhysReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  // - Block-local splits are candidates for local splitting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">  // - DCE leftovers should go back on the queue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">    const LiveInterval &Reg = LIS->getInterval(LREdit.get(I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">    // Ignore old intervals from DCE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">    if (ExtraInfo->getOrInitStage(Reg.reg()) != RS_New)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">    // Remainder interval. Don't try splitting again, spill if it doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">    // allocate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">    if (IntvMap[I] == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">      ExtraInfo->setStage(Reg, RS_Spill);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">    // Global intervals. Allow repeated splitting as long as the number of live</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">    // blocks is strictly decreasing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">    if (IntvMap[I] < NumGlobalIntvs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="uncoveredLine">      if (SA->countLiveBlocks(&Reg) >= OrigBlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "Main interval covers the same " << OrigBlocks</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">                          << " blocks as original.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">        // Don't allow repeated splitting as a safe guard against looping.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">        ExtraInfo->setStage(Reg, RS_Split2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">    // Other intervals are treated as new. This includes local intervals created</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">    // for blocks with multiple uses, and anything created by DCE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">  if (VerifyEnabled)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">    MF->verify(this, "After splitting live range around region");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">MCRegister RAGreedy::tryRegionSplit(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">                                    AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">                                    SmallVectorImpl<Register> &NewVRegs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">  if (!TRI->shouldRegionSplitForVirtReg(*MF, VirtReg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="uncoveredLine">    return MCRegister::NoRegister;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">  unsigned NumCands = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="uncoveredLine">  BlockFrequency SpillCost = calcSpillCost();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">  BlockFrequency BestCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  // Check if we can split this live range around a compact region.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="uncoveredLine">  bool HasCompact = calcCompactRegion(GlobalCand.front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">  if (HasCompact) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">    // Yes, keep GlobalCand[0] as the compact region candidate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">    NumCands = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">    BestCost = BlockFrequency::getMaxFrequency();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">    // No benefit from the compact region, our fallback will be per-block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">    // splitting. Make sure we find a solution that is cheaper than spilling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="uncoveredLine">    BestCost = SpillCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Cost of isolating all blocks = ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">               MBFI->printBlockFreq(dbgs(), BestCost) << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">  unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">                                               NumCands, false /*IgnoreCSR*/);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  // No solutions found, fall back to single block splitting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">  if (!HasCompact && BestCand == NoCand)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">    return MCRegister::NoRegister;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">  return doRegionSplit(VirtReg, BestCand, HasCompact, NewVRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="uncoveredLine">unsigned RAGreedy::calculateRegionSplitCost(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">                                            AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">                                            BlockFrequency &BestCost,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">                                            unsigned &NumCands,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">                                            bool IgnoreCSR) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">  unsigned BestCand = NoCand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="uncoveredLine">  for (MCPhysReg PhysReg : Order) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">    assert(PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">    if (IgnoreCSR && EvictAdvisor->isUnusedCalleeSavedReg(PhysReg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">    // Discard bad candidates before we run out of interference cache cursors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">    // This will only affect register classes with a lot of registers (>32).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">    if (NumCands == IntfCache.getMaxCursors()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">      unsigned WorstCount = ~0u;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">      unsigned Worst = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">      for (unsigned CandIndex = 0; CandIndex != NumCands; ++CandIndex) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">        if (CandIndex == BestCand || !GlobalCand[CandIndex].PhysReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">        unsigned Count = GlobalCand[CandIndex].LiveBundles.count();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">        if (Count < WorstCount) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">          Worst = CandIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">          WorstCount = Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">      --NumCands;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">      GlobalCand[Worst] = GlobalCand[NumCands];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">      if (BestCand == NumCands)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">        BestCand = Worst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">    if (GlobalCand.size() <= NumCands)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">      GlobalCand.resize(NumCands+1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">    GlobalSplitCandidate &Cand = GlobalCand[NumCands];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">    Cand.reset(IntfCache, PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">    SpillPlacer->prepare(Cand.LiveBundles);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">    BlockFrequency Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">    if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tno positive bundles\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tstatic = ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">               MBFI->printBlockFreq(dbgs(), Cost));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">    if (Cost >= BestCost) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">      LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">        if (BestCand == NoCand)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">          dbgs() << " worse than no bundles\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">        else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">          dbgs() << " worse than "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">                 << printReg(GlobalCand[BestCand].PhysReg, TRI) << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">    if (!growRegion(Cand)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">    SpillPlacer->finish();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">    // No live bundles, defer to splitSingleBlocks().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">    if (!Cand.LiveBundles.any()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << " no bundles.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">    Cost += calcGlobalSplitCost(Cand, Order);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="uncoveredLine">    LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">      dbgs() << ", total = ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">      MBFI->printBlockFreq(dbgs(), Cost) << " with bundles";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">      for (int I : Cand.LiveBundles.set_bits())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">        dbgs() << " EB#" << I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">      dbgs() << ".\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">    if (Cost < BestCost) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">      BestCand = NumCands;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="uncoveredLine">      BestCost = Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="uncoveredLine">    ++NumCands;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">  return BestCand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">unsigned RAGreedy::doRegionSplit(const LiveInterval &VirtReg, unsigned BestCand,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">                                 bool HasCompact,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">  SmallVector<unsigned, 8> UsedCands;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">  // Prepare split editor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">  SE->reset(LREdit, SplitSpillMode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">  // Assign all edge bundles to the preferred candidate, or NoCand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">  BundleCand.assign(Bundles->getNumBundles(), NoCand);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">  // Assign bundles for the best candidate region.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">  if (BestCand != NoCand) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">    GlobalSplitCandidate &Cand = GlobalCand[BestCand];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">    if (unsigned B = Cand.getBundles(BundleCand, BestCand)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="uncoveredLine">      UsedCands.push_back(BestCand);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">      Cand.IntvIdx = SE->openIntv();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Split for " << printReg(Cand.PhysReg, TRI) << " in "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">                        << B << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">      (void)B;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">  // Assign bundles for the compact region.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">  if (HasCompact) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">    GlobalSplitCandidate &Cand = GlobalCand.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">    assert(!Cand.PhysReg && "Compact region has no physreg");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">    if (unsigned B = Cand.getBundles(BundleCand, 0)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">      UsedCands.push_back(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">      Cand.IntvIdx = SE->openIntv();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Split for compact region in " << B</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">                        << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">      (void)B;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">  splitAroundRegion(LREdit, UsedCands);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="">//                            Per-Block Splitting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="">/// tryBlockSplit - Split a global live range around every block with uses. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">/// creates a lot of local live ranges, that will be split by tryLocalSplit if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">/// they don't allocate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="uncoveredLine">unsigned RAGreedy::tryBlockSplit(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">                                 AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">  assert(&SA->getParent() == &VirtReg && "Live range wasn't analyzed");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">  Register Reg = VirtReg.reg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">  SE->reset(LREdit, SplitSpillMode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">    if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">      SE->splitSingleBlock(BI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">  // No blocks were split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="uncoveredLine">  if (LREdit.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">  // We did split for some blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="uncoveredLine">  SE->finish(&IntvMap);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">  // Tell LiveDebugVariables about the new ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="uncoveredLine">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  // Sort out the new intervals created by splitting. The remainder interval</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">  // goes straight to spilling, the new local ranges get to stay RS_New.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">    const LiveInterval &LI = LIS->getInterval(LREdit.get(I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="uncoveredLine">    if (ExtraInfo->getOrInitStage(LI.reg()) == RS_New && IntvMap[I] == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">      ExtraInfo->setStage(LI, RS_Spill);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">  if (VerifyEnabled)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">    MF->verify(this, "After splitting live range around basic blocks");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">//                         Per-Instruction Splitting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">/// Get the number of allocatable registers that match the constraints of \p Reg</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">/// on \p MI and that are also in \p SuperRC.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">static unsigned getNumAllocatableRegsForConstraints(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">    const MachineInstr *MI, Register Reg, const TargetRegisterClass *SuperRC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">    const TargetInstrInfo *TII, const TargetRegisterInfo *TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">    const RegisterClassInfo &RCI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="uncoveredLine">  assert(SuperRC && "Invalid register class");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">  const TargetRegisterClass *ConstrainedRC =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="uncoveredLine">      MI->getRegClassConstraintEffectForVReg(Reg, SuperRC, TII, TRI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">                                             /* ExploreBundle */ true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">  if (!ConstrainedRC)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="uncoveredLine">  return RCI.getNumAllocatableRegs(ConstrainedRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="uncoveredLine">static LaneBitmask getInstReadLaneMask(const MachineRegisterInfo &MRI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">                                       const TargetRegisterInfo &TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">                                       const MachineInstr &MI, Register Reg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="uncoveredLine">  LaneBitmask Mask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">  for (const MachineOperand &MO : MI.operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">    if (!MO.isReg() || MO.getReg() != Reg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">    unsigned SubReg = MO.getSubReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">    if (SubReg == 0 && MO.isUse()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">      Mask |= MRI.getMaxLaneMaskForVReg(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">    LaneBitmask SubRegMask = TRI.getSubRegIndexLaneMask(SubReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">    if (MO.isDef()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">      if (!MO.isUndef())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">        Mask |= ~SubRegMask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">      Mask |= SubRegMask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="uncoveredLine">  return Mask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">/// Return true if \p MI at \P Use reads a subset of the lanes live in \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">/// VirtReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="uncoveredLine">static bool readsLaneSubset(const MachineRegisterInfo &MRI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">                            const MachineInstr *MI, const LiveInterval &VirtReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">                            const TargetRegisterInfo *TRI, SlotIndex Use) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  // Early check the common case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">  if (MI->isCopy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="uncoveredLine">      MI->getOperand(0).getSubReg() == MI->getOperand(1).getSubReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">  // FIXME: We're only considering uses, but should be consider defs too?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="uncoveredLine">  LaneBitmask ReadMask = getInstReadLaneMask(MRI, *TRI, *MI, VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="uncoveredLine">  LaneBitmask LiveAtMask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">  for (const LiveInterval::SubRange &S : VirtReg.subranges()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">    if (S.liveAt(Use))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="uncoveredLine">      LiveAtMask |= S.LaneMask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">  // If the live lanes aren't different from the lanes used by the instruction,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">  // this doesn't help.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">  return (ReadMask & ~(LiveAtMask & TRI->getCoveringLanes())).any();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">/// tryInstructionSplit - Split a live range around individual instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">/// This is normally not worthwhile since the spiller is doing essentially the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">/// same thing. However, when the live range is in a constrained register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">/// class, it may help to insert copies such that parts of the live range can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">/// be moved to a larger register class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">/// This is similar to spilling to a larger register class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">unsigned RAGreedy::tryInstructionSplit(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">                                       AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">                                       SmallVectorImpl<Register> &NewVRegs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">  // There is no point to this if there are no larger sub-classes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="uncoveredLine">  bool SplitSubClass = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="uncoveredLine">  if (!RegClassInfo.isProperSubClass(CurRC)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="uncoveredLine">    if (!VirtReg.hasSubRanges())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="uncoveredLine">      return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="uncoveredLine">    SplitSubClass = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">  // Always enable split spill mode, since we're effectively spilling to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">  // register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">  SE->reset(LREdit, SplitEditor::SM_Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">  if (Uses.size() <= 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Split around " << Uses.size()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">                    << " individual instrs.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">  const TargetRegisterClass *SuperRC =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">      TRI->getLargestLegalSuperClass(CurRC, *MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">  unsigned SuperRCNumAllocatableRegs =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="uncoveredLine">      RegClassInfo.getNumAllocatableRegs(SuperRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">  // Split around every non-copy instruction if this split will relax</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">  // the constraints on the virtual register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="">  // Otherwise, splitting just inserts uncoalescable copies that do not help</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">  // the allocation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">  for (const SlotIndex Use : Uses) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">    if (const MachineInstr *MI = Indexes->getInstructionFromIndex(Use)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">      if (MI->isFullCopy() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">          (SplitSubClass &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="">           SuperRCNumAllocatableRegs ==</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">               getNumAllocatableRegsForConstraints(MI, VirtReg.reg(), SuperRC,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">                                                   TII, TRI, RegClassInfo)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">          // TODO: Handle split for subranges with subclass constraints?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">          (!SplitSubClass && VirtReg.hasSubRanges() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">           !readsLaneSubset(*MRI, MI, VirtReg, TRI, Use))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "    skip:\t" << Use << '\t' << *MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">    SE->openIntv();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">    SlotIndex SegStart = SE->enterIntvBefore(Use);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="uncoveredLine">    SlotIndex SegStop = SE->leaveIntvAfter(Use);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">    SE->useIntv(SegStart, SegStop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="uncoveredLine">  if (LREdit.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "All uses were copies.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">  SE->finish(&IntvMap);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">  // Assign all new registers to RS_Spill. This was the last chance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">  ExtraInfo->setStage(LREdit.begin(), LREdit.end(), RS_Spill);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">//                             Local Splitting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">/// calcGapWeights - Compute the maximum spill weight that needs to be evicted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">/// in order to use PhysReg between two entries in SA->UseSlots.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">/// GapWeight[I] represents the gap between UseSlots[I] and UseSlots[I + 1].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">void RAGreedy::calcGapWeights(MCRegister PhysReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">                              SmallVectorImpl<float> &GapWeight) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="uncoveredLine">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">  const unsigned NumGaps = Uses.size()-1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">  // Start and end points for the interference check.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">  SlotIndex StartIdx =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">    BI.LiveIn ? BI.FirstInstr.getBaseIndex() : BI.FirstInstr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">  SlotIndex StopIdx =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="uncoveredLine">    BI.LiveOut ? BI.LastInstr.getBoundaryIndex() : BI.LastInstr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">  GapWeight.assign(NumGaps, 0.0f);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">  // Add interference from each overlapping register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">    if (!Matrix->query(const_cast<LiveInterval &>(SA->getParent()), Unit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">             .checkInterference())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">    // We know that VirtReg is a continuous interval from FirstInstr to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">    // LastInstr, so we don't need InterferenceQuery.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">    // Interference that overlaps an instruction is counted in both gaps</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">    // surrounding the instruction. The exception is interference before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">    // StartIdx and after StopIdx.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">    LiveIntervalUnion::SegmentIter IntI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="uncoveredLine">        Matrix->getLiveUnions()[Unit].find(StartIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="uncoveredLine">    for (unsigned Gap = 0; IntI.valid() && IntI.start() < StopIdx; ++IntI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">      // Skip the gaps before IntI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="uncoveredLine">      while (Uses[Gap+1].getBoundaryIndex() < IntI.start())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">        if (++Gap == NumGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="uncoveredLine">      if (Gap == NumGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">      // Update the gaps covered by IntI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">      const float weight = IntI.value()->weight();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="uncoveredLine">      for (; Gap != NumGaps; ++Gap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="uncoveredLine">        GapWeight[Gap] = std::max(GapWeight[Gap], weight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="uncoveredLine">        if (Uses[Gap+1].getBaseIndex() >= IntI.stop())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">      if (Gap == NumGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">  // Add fixed interference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="uncoveredLine">    const LiveRange &LR = LIS->getRegUnit(Unit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">    LiveRange::const_iterator I = LR.find(StartIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="uncoveredLine">    LiveRange::const_iterator E = LR.end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">    // Same loop as above. Mark any overlapped gaps as HUGE_VALF.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="uncoveredLine">    for (unsigned Gap = 0; I != E && I->start < StopIdx; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="uncoveredLine">      while (Uses[Gap+1].getBoundaryIndex() < I->start)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">        if (++Gap == NumGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">      if (Gap == NumGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="uncoveredLine">      for (; Gap != NumGaps; ++Gap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="uncoveredLine">        GapWeight[Gap] = huge_valf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">        if (Uses[Gap+1].getBaseIndex() >= I->end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">      if (Gap == NumGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">/// tryLocalSplit - Try to split VirtReg into smaller intervals inside its only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">/// basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">unsigned RAGreedy::tryLocalSplit(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">                                 AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">  // TODO: the function currently only handles a single UseBlock; it should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">  // possible to generalize.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">  if (SA->getUseBlocks().size() != 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">  // Note that it is possible to have an interval that is live-in or live-out</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">  // while only covering a single block - A phi-def can use undef values from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">  // predecessors, and the block could be a single-block loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">  // We don't bother doing anything clever about such a case, we simply assume</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">  // that the interval is continuous from FirstInstr to LastInstr. We should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">  // make sure that we don't do anything illegal to such an interval, though.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="uncoveredLine">  if (Uses.size() <= 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">  const unsigned NumGaps = Uses.size()-1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">  LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">    dbgs() << "tryLocalSplit: ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">    for (const auto &Use : Uses)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">      dbgs() << ' ' << Use;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">    dbgs() << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="">  // If VirtReg is live across any register mask operands, compute a list of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">  // gaps with register masks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="uncoveredLine">  SmallVector<unsigned, 8> RegMaskGaps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">  if (Matrix->checkRegMaskInterference(VirtReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">    // Get regmask slots for the whole block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">    ArrayRef<SlotIndex> RMS = LIS->getRegMaskSlotsInBlock(BI.MBB->getNumber());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << RMS.size() << " regmasks in block:");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">    // Constrain to VirtReg's live range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">    unsigned RI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">        llvm::lower_bound(RMS, Uses.front().getRegSlot()) - RMS.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">    unsigned RE = RMS.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">    for (unsigned I = 0; I != NumGaps && RI != RE; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">      // Look for Uses[I] <= RMS <= Uses[I + 1].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">      assert(!SlotIndex::isEarlierInstr(RMS[RI], Uses[I]));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="uncoveredLine">      if (SlotIndex::isEarlierInstr(Uses[I + 1], RMS[RI]))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">      // Skip a regmask on the same instruction as the last use. It doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">      // overlap the live range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">      if (SlotIndex::isSameInstr(Uses[I + 1], RMS[RI]) && I + 1 == NumGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << ' ' << RMS[RI] << ':' << Uses[I] << '-'</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">                        << Uses[I + 1]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">      RegMaskGaps.push_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">      // Advance ri to the next gap. A regmask on one of the uses counts in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">      // both gaps.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">      while (RI != RE && SlotIndex::isEarlierInstr(RMS[RI], Uses[I + 1]))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">        ++RI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">  // Since we allow local split results to be split again, there is a risk of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">  // creating infinite loops. It is tempting to require that the new live</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">  // ranges have less instructions than the original. That would guarantee</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">  // convergence, but it is too strict. A live range with 3 instructions can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">  // split 2+3 (including the COPY), and we want to allow that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="">  // Instead we use these rules:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">  // 1. Allow any split for ranges with getStage() < RS_Split2. (Except for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">  //    noop split, of course).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">  // 2. Require progress be made for ranges with getStage() == RS_Split2. All</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">  //    the new ranges must have fewer instructions than before the split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="">  // 3. New ranges with the same number of instructions are marked RS_Split2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">  //    smaller ranges are marked RS_New.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="">  // These rules allow a 3 -> 2+3 split once, which we need. They also prevent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">  // excessive splitting and infinite loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">  bool ProgressRequired = ExtraInfo->getStage(VirtReg) >= RS_Split2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="">  // Best split candidate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">  unsigned BestBefore = NumGaps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">  unsigned BestAfter = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="uncoveredLine">  float BestDiff = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">  const float blockFreq =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="uncoveredLine">    SpillPlacer->getBlockFrequency(BI.MBB->getNumber()).getFrequency() *</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="uncoveredLine">    (1.0f / MBFI->getEntryFreq());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">  SmallVector<float, 8> GapWeight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">  for (MCPhysReg PhysReg : Order) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="uncoveredLine">    assert(PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">    // Keep track of the largest spill weight that would need to be evicted in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">    // order to make use of PhysReg between UseSlots[I] and UseSlots[I + 1].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">    calcGapWeights(PhysReg, GapWeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="">    // Remove any gaps with regmask clobbers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="uncoveredLine">    if (Matrix->checkRegMaskInterference(VirtReg, PhysReg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">      for (unsigned I = 0, E = RegMaskGaps.size(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="uncoveredLine">        GapWeight[RegMaskGaps[I]] = huge_valf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">    // Try to find the best sequence of gaps to close.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">    // The new spill weight must be larger than any gap interference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="">    // We will split before Uses[SplitBefore] and after Uses[SplitAfter].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="uncoveredLine">    unsigned SplitBefore = 0, SplitAfter = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">    // MaxGap should always be max(GapWeight[SplitBefore..SplitAfter-1]).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">    // It is the spill weight that needs to be evicted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="uncoveredLine">    float MaxGap = GapWeight[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">    while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">      // Live before/after split?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="uncoveredLine">      const bool LiveBefore = SplitBefore != 0 || BI.LiveIn;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">      const bool LiveAfter = SplitAfter != NumGaps || BI.LiveOut;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << ' ' << Uses[SplitBefore]</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">                        << '-' << Uses[SplitAfter] << " I=" << MaxGap);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">      // Stop before the interval gets so big we wouldn't be making progress.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">      if (!LiveBefore && !LiveAfter) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << " all\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="">      // Should the interval be extended or shrunk?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">      bool Shrink = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">      // How many gaps would the new range have?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">      unsigned NewGaps = LiveBefore + SplitAfter - SplitBefore + LiveAfter;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">      // Legally, without causing looping?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="uncoveredLine">      bool Legal = !ProgressRequired || NewGaps < NumGaps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">      if (Legal && MaxGap < huge_valf) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">        // Estimate the new spill weight. Each instruction reads or writes the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">        // register. Conservatively assume there are no read-modify-write</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">        // instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">        //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">        // Try to guess the size of the new interval.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">        const float EstWeight = normalizeSpillWeight(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">            blockFreq * (NewGaps + 1),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="uncoveredLine">            Uses[SplitBefore].distance(Uses[SplitAfter]) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="uncoveredLine">                (LiveBefore + LiveAfter) * SlotIndex::InstrDist,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">            1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">        // Would this split be possible to allocate?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="">        // Never allocate all gaps, we wouldn't be making progress.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << " w=" << EstWeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="uncoveredLine">        if (EstWeight * Hysteresis >= MaxGap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">          Shrink = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">          float Diff = EstWeight - MaxGap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">          if (Diff > BestDiff) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="uncoveredLine">            LLVM_DEBUG(dbgs() << " (best)");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="uncoveredLine">            BestDiff = Hysteresis * Diff;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">            BestBefore = SplitBefore;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">            BestAfter = SplitAfter;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">      // Try to shrink.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">      if (Shrink) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="uncoveredLine">        if (++SplitBefore < SplitAfter) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs() << " shrink\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="">          // Recompute the max when necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">          if (GapWeight[SplitBefore - 1] >= MaxGap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="uncoveredLine">            MaxGap = GapWeight[SplitBefore];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">            for (unsigned I = SplitBefore + 1; I != SplitAfter; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">              MaxGap = std::max(MaxGap, GapWeight[I]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="uncoveredLine">        MaxGap = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">      // Try to extend the interval.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">      if (SplitAfter >= NumGaps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << " end\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << " extend\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">      MaxGap = std::max(MaxGap, GapWeight[SplitAfter++]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="">  // Didn't find any candidates?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="uncoveredLine">  if (BestBefore == NumGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Best local split range: " << Uses[BestBefore] << '-'</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="">                    << Uses[BestAfter] << ", " << BestDiff << ", "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">                    << (BestAfter - BestBefore + 1) << " instrs\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="uncoveredLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="uncoveredLine">  SE->reset(LREdit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">  SE->openIntv();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">  SlotIndex SegStart = SE->enterIntvBefore(Uses[BestBefore]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">  SlotIndex SegStop  = SE->leaveIntvAfter(Uses[BestAfter]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">  SE->useIntv(SegStart, SegStop);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="uncoveredLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">  SE->finish(&IntvMap);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="uncoveredLine">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">  // If the new range has the same number of instructions as before, mark it as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="">  // RS_Split2 so the next split will be forced to make progress. Otherwise,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">  // leave the new intervals as RS_New so they can compete.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="uncoveredLine">  bool LiveBefore = BestBefore != 0 || BI.LiveIn;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="uncoveredLine">  bool LiveAfter = BestAfter != NumGaps || BI.LiveOut;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">  unsigned NewGaps = LiveBefore + BestAfter - BestBefore + LiveAfter;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">  if (NewGaps >= NumGaps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Tagging non-progress ranges:");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">    assert(!ProgressRequired && "Didn't make progress when it was required.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="uncoveredLine">    for (unsigned I = 0, E = IntvMap.size(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="uncoveredLine">      if (IntvMap[I] == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">        ExtraInfo->setStage(LIS->getInterval(LREdit.get(I)), RS_Split2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << ' ' << printReg(LREdit.get(I)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">  ++NumLocalSplits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">//                          Live Range Splitting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="">/// trySplit - Try to split VirtReg or one of its interferences, making it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="">/// assignable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">/// @return Physreg when VirtReg may be assigned and/or new NewVRegs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="uncoveredLine">unsigned RAGreedy::trySplit(const LiveInterval &VirtReg, AllocationOrder &Order,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">                            SmallVectorImpl<Register> &NewVRegs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="">                            const SmallVirtRegSet &FixedRegisters) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">  // Ranges must be Split2 or less.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">  if (ExtraInfo->getStage(VirtReg) >= RS_Spill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">  // Local intervals are handled separately.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">  if (LIS->intervalIsInOneMBB(VirtReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="">    NamedRegionTimer T("local_split", "Local Splitting", TimerGroupName,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">                       TimerGroupDescription, TimePassesIsEnabled);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">    SA->analyze(&VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="uncoveredLine">    Register PhysReg = tryLocalSplit(VirtReg, Order, NewVRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="uncoveredLine">    if (PhysReg || !NewVRegs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="uncoveredLine">      return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">    return tryInstructionSplit(VirtReg, Order, NewVRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">  NamedRegionTimer T("global_split", "Global Splitting", TimerGroupName,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="uncoveredLine">                     TimerGroupDescription, TimePassesIsEnabled);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">  SA->analyze(&VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">  // First try to split around a region spanning multiple blocks. RS_Split2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">  // ranges already made dubious progress with region splitting, so they go</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="">  // straight to single block splitting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">  if (ExtraInfo->getStage(VirtReg) < RS_Split2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="uncoveredLine">    MCRegister PhysReg = tryRegionSplit(VirtReg, Order, NewVRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="uncoveredLine">    if (PhysReg || !NewVRegs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">      return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">  // Then isolate blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">  return tryBlockSplit(VirtReg, Order, NewVRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">//                          Last Chance Recoloring</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">/// Return true if \p reg has any tied def operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="uncoveredLine">static bool hasTiedDef(MachineRegisterInfo *MRI, unsigned reg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">  for (const MachineOperand &MO : MRI->def_operands(reg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="uncoveredLine">    if (MO.isTied())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="">/// Return true if the existing assignment of \p Intf overlaps, but is not the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">/// same, as \p PhysReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="uncoveredLine">static bool assignedRegPartiallyOverlaps(const TargetRegisterInfo &TRI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">                                         const VirtRegMap &VRM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="">                                         MCRegister PhysReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="">                                         const LiveInterval &Intf) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">  MCRegister AssignedReg = VRM.getPhys(Intf.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">  if (PhysReg == AssignedReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">  return TRI.regsOverlap(PhysReg, AssignedReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">/// mayRecolorAllInterferences - Check if the virtual registers that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">/// interfere with \p VirtReg on \p PhysReg (or one of its aliases) may be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">/// recolored to free \p PhysReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">/// When true is returned, \p RecoloringCandidates has been augmented with all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">/// the live intervals that need to be recolored in order to free \p PhysReg</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">/// for \p VirtReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">/// recolored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">bool RAGreedy::mayRecolorAllInterferences(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">    MCRegister PhysReg, const LiveInterval &VirtReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">    SmallLISet &RecoloringCandidates, const SmallVirtRegSet &FixedRegisters) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="uncoveredLine">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="">    // If there is LastChanceRecoloringMaxInterference or more interferences,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="">    // chances are one would not be recolorable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="uncoveredLine">    if (Q.interferingVRegs(LastChanceRecoloringMaxInterference).size() >=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="uncoveredLine">            LastChanceRecoloringMaxInterference &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">        !ExhaustiveSearch) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Early abort: too many interferences.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="uncoveredLine">      CutOffInfo |= CO_Interf;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">    for (const LiveInterval *Intf : reverse(Q.interferingVRegs())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">      // If Intf is done and sits on the same register class as VirtReg, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">      // would not be recolorable as it is in the same state as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">      // VirtReg. However there are at least two exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="">      // If VirtReg has tied defs and Intf doesn't, then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">      // there is still a point in examining if it can be recolorable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">      // Additionally, if the register class has overlapping tuple members, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">      // may still be recolorable using a different tuple. This is more likely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">      // if the existing assignment aliases with the candidate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">      if (((ExtraInfo->getStage(*Intf) == RS_Done &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">            MRI->getRegClass(Intf->reg()) == CurRC &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="uncoveredLine">            !assignedRegPartiallyOverlaps(*TRI, *VRM, PhysReg, *Intf)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">           !(hasTiedDef(MRI, VirtReg.reg()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">             !hasTiedDef(MRI, Intf->reg()))) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">          FixedRegisters.count(Intf->reg())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">        LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">            dbgs() << "Early abort: the interference is not recolorable.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="uncoveredLine">      RecoloringCandidates.insert(Intf);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">/// its interferences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">/// Last chance recoloring chooses a color for \p VirtReg and recolors every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">/// virtual register that was using it. The recoloring process may recursively</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">/// use the last chance recoloring. Therefore, when a virtual register has been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">/// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">/// be last-chance-recolored again during this recoloring "session".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">/// E.g.,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">/// Let</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">/// vA can use {R1, R2    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="">/// vB can use {    R2, R3}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="">/// vC can use {R1        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">/// Where vA, vB, and vC cannot be split anymore (they are reloads for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="">/// instance) and they all interfere.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">/// vA is assigned R1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="">/// vB is assigned R2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="">/// vC tries to evict vA but vA is already done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="">/// Regular register allocation fails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="">/// Last chance recoloring kicks in:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="">/// vC does as if vA was evicted => vC uses R1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">/// vC is marked as fixed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="">/// vA needs to find a color.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">/// None are available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">/// vA cannot evict vC: vC is a fixed virtual register now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">/// vA does as if vB was evicted => vA uses R2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">/// vB needs to find a color.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="">/// R3 is available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">/// Recoloring => vC = R1, vA = R2, vB = R3</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">/// \p Order defines the preferred allocation order for \p VirtReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">/// \p NewRegs will contain any new virtual register that have been created</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">/// (split, spill) during the process and that must be assigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">/// recolored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">/// \p RecolorStack tracks the original assignments of successfully recolored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="">/// registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">/// \p Depth gives the current depth of the last chance recoloring.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">/// \return a physical register that can be used for VirtReg or ~0u if none</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="">/// exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">unsigned RAGreedy::tryLastChanceRecoloring(const LiveInterval &VirtReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">                                           AllocationOrder &Order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">                                           SmallVectorImpl<Register> &NewVRegs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">                                           SmallVirtRegSet &FixedRegisters,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">                                           RecoloringStack &RecolorStack,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">                                           unsigned Depth) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">  if (!TRI->shouldUseLastChanceRecoloringForVirtReg(*MF, VirtReg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="uncoveredLine">    return ~0u;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Try last chance recoloring for " << VirtReg << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">  const ssize_t EntryStackSize = RecolorStack.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="">  // Ranges must be Done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">  assert((ExtraInfo->getStage(VirtReg) >= RS_Done || !VirtReg.isSpillable()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">         "Last chance recoloring should really be last chance");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">  // Set the max depth to LastChanceRecoloringMaxDepth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">  // We may want to reconsider that if we end up with a too large search space</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="">  // for target with hundreds of registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="">  // Indeed, in that case we may want to cut the search space earlier.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">  if (Depth >= LastChanceRecoloringMaxDepth && !ExhaustiveSearch) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Abort because max depth has been reached.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">    CutOffInfo |= CO_Depth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="uncoveredLine">    return ~0u;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">  // Set of Live intervals that will need to be recolored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">  SmallLISet RecoloringCandidates;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">  // Mark VirtReg as fixed, i.e., it will not be recolored pass this point in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">  // this recoloring "session".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">  assert(!FixedRegisters.count(VirtReg.reg()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">  FixedRegisters.insert(VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">  SmallVector<Register, 4> CurrentNewVRegs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">  for (MCRegister PhysReg : Order) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="uncoveredLine">    assert(PhysReg.isValid());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Try to assign: " << VirtReg << " to "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="">                      << printReg(PhysReg, TRI) << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="uncoveredLine">    RecoloringCandidates.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="uncoveredLine">    CurrentNewVRegs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">    // It is only possible to recolor virtual register interference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="uncoveredLine">    if (Matrix->checkInterference(VirtReg, PhysReg) ></td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">        LiveRegMatrix::IK_VirtReg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="uncoveredLine">      LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">          dbgs() << "Some interferences are not with virtual registers.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">    // Early give up on this PhysReg if it is obvious we cannot recolor all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">    // the interferences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="uncoveredLine">    if (!mayRecolorAllInterferences(PhysReg, VirtReg, RecoloringCandidates,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">                                    FixedRegisters)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Some interferences cannot be recolored.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">    // RecoloringCandidates contains all the virtual registers that interfere</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="">    // with VirtReg on PhysReg (or one of its aliases). Enqueue them for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="">    // recoloring and perform the actual recoloring.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">    PQueue RecoloringQueue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">    for (const LiveInterval *RC : RecoloringCandidates) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">      Register ItVirtReg = RC->reg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">      enqueue(RecoloringQueue, RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">      assert(VRM->hasPhys(ItVirtReg) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">             "Interferences are supposed to be with allocated variables");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="">      // Record the current allocation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">      RecolorStack.push_back(std::make_pair(RC, VRM->getPhys(ItVirtReg)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="">      // unset the related struct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">      Matrix->unassign(*RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">    // Do as if VirtReg was assigned to PhysReg so that the underlying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">    // recoloring has the right information about the interferes and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">    // available colors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="uncoveredLine">    Matrix->assign(VirtReg, PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="">    // Save the current recoloring state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">    // If we cannot recolor all the interferences, we will have to start again</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">    // at this point for the next physical register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="uncoveredLine">    SmallVirtRegSet SaveFixedRegisters(FixedRegisters);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">    if (tryRecoloringCandidates(RecoloringQueue, CurrentNewVRegs,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">                                FixedRegisters, RecolorStack, Depth)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="">      // Push the queued vregs into the main queue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="uncoveredLine">      for (Register NewVReg : CurrentNewVRegs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="uncoveredLine">        NewVRegs.push_back(NewVReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">      // Do not mess up with the global assignment process.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="">      // I.e., VirtReg must be unassigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">      Matrix->unassign(VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="uncoveredLine">      return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Fail to assign: " << VirtReg << " to "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">                      << printReg(PhysReg, TRI) << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="">    // The recoloring attempt failed, undo the changes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="uncoveredLine">    FixedRegisters = SaveFixedRegisters;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="uncoveredLine">    Matrix->unassign(VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">    // For a newly created vreg which is also in RecoloringCandidates,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">    // don't add it to NewVRegs because its physical register will be restored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">    // below. Other vregs in CurrentNewVRegs are created by calling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">    // selectOrSplit and should be added into NewVRegs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="uncoveredLine">    for (Register R : CurrentNewVRegs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="uncoveredLine">      if (RecoloringCandidates.count(&LIS->getInterval(R)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">      NewVRegs.push_back(R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">    // Roll back our unsuccessful recoloring. Also roll back any successful</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="">    // recolorings in any recursive recoloring attempts, since it's possible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="">    // they would have introduced conflicts with assignments we will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">    // restoring further up the stack. Perform all unassignments prior to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="">    // reassigning, since sub-recolorings may have conflicted with the registers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">    // we are going to restore to their original assignments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">    for (ssize_t I = RecolorStack.size() - 1; I >= EntryStackSize; --I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">      const LiveInterval *LI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="uncoveredLine">      MCRegister PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="uncoveredLine">      if (VRM->hasPhys(LI->reg()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">        Matrix->unassign(*LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">    for (size_t I = EntryStackSize; I != RecolorStack.size(); ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">      const LiveInterval *LI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="uncoveredLine">      MCRegister PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="uncoveredLine">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">      if (!LI->empty() && !MRI->reg_nodbg_empty(LI->reg()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="uncoveredLine">        Matrix->assign(*LI, PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="">    // Pop the stack of recoloring attempts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="uncoveredLine">    RecolorStack.resize(EntryStackSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">  // Last chance recoloring did not worked either, give up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="uncoveredLine">  return ~0u;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">/// tryRecoloringCandidates - Try to assign a new color to every register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">/// in \RecoloringQueue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">/// \p NewRegs will contain any new virtual register created during the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">/// recoloring process.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">/// \p FixedRegisters[in/out] contains all the registers that have been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="">/// recolored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">/// \return true if all virtual registers in RecoloringQueue were successfully</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">/// recolored, false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="uncoveredLine">bool RAGreedy::tryRecoloringCandidates(PQueue &RecoloringQueue,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">                                       SmallVectorImpl<Register> &NewVRegs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">                                       SmallVirtRegSet &FixedRegisters,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">                                       RecoloringStack &RecolorStack,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">                                       unsigned Depth) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="uncoveredLine">  while (!RecoloringQueue.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="uncoveredLine">    const LiveInterval *LI = dequeue(RecoloringQueue);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Try to recolor: " << *LI << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">    MCRegister PhysReg = selectOrSplitImpl(*LI, NewVRegs, FixedRegisters,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">                                           RecolorStack, Depth + 1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">    // When splitting happens, the live-range may actually be empty.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">    // In that case, this is okay to continue the recoloring even</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="">    // if we did not find an alternative color for it. Indeed,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="">    // there will not be anything to color for LI in the end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">    if (PhysReg == ~0u || (!PhysReg && !LI->empty()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="uncoveredLine">    if (!PhysReg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="uncoveredLine">      assert(LI->empty() && "Only empty live-range do not require a register");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="">                        << " succeeded. Empty LI.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">                      << " succeeded with: " << printReg(PhysReg, TRI) << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">    Matrix->assign(*LI, PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">    FixedRegisters.insert(LI->reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">//                            Main Entry Point</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="coveredLine">MCRegister RAGreedy::selectOrSplit(const LiveInterval &VirtReg,</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">                                   SmallVectorImpl<Register> &NewVRegs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="coveredLine">  CutOffInfo = CO_None;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="coveredLine">  LLVMContext &Ctx = MF->getFunction().getContext();</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="coveredLine">  SmallVirtRegSet FixedRegisters;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="coveredLine">  RecoloringStack RecolorStack;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="">  MCRegister Reg =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="coveredLine">      selectOrSplitImpl(VirtReg, NewVRegs, FixedRegisters, RecolorStack);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="coveredLine">  if (Reg == ~0U && (CutOffInfo != CO_None)) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="uncoveredLine">    uint8_t CutOffEncountered = CutOffInfo & (CO_Depth | CO_Interf);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="uncoveredLine">    if (CutOffEncountered == CO_Depth)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="uncoveredLine">      Ctx.emitError("register allocation failed: maximum depth for recoloring "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="">                    "reached. Use -fexhaustive-register-search to skip "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">                    "cutoffs");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="uncoveredLine">    else if (CutOffEncountered == CO_Interf)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="uncoveredLine">      Ctx.emitError("register allocation failed: maximum interference for "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="">                    "recoloring reached. Use -fexhaustive-register-search "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="">                    "to skip cutoffs");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">    else if (CutOffEncountered == (CO_Depth | CO_Interf))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="uncoveredLine">      Ctx.emitError("register allocation failed: maximum interference and "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="">                    "depth for recoloring reached. Use "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">                    "-fexhaustive-register-search to skip cutoffs");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="coveredLine">  return Reg;</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="coveredLine">}</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="">/// Using a CSR for the first time has a cost because it causes push|pop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="">/// to be added to prologue|epilogue. Splitting a cold section of the live</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="">/// range can have lower cost than using the CSR for the first time;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">/// Spilling a live range in the cold path can have lower cost than using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">/// the CSR for the first time. Returns the physical register if we decide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">/// to use the CSR; otherwise return 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">MCRegister RAGreedy::tryAssignCSRFirstTime(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">    const LiveInterval &VirtReg, AllocationOrder &Order, MCRegister PhysReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="">    uint8_t &CostPerUseLimit, SmallVectorImpl<Register> &NewVRegs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="uncoveredLine">  if (ExtraInfo->getStage(VirtReg) == RS_Spill && VirtReg.isSpillable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">    // We choose spill over using the CSR for the first time if the spill cost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">    // is lower than CSRCost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="uncoveredLine">    SA->analyze(&VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="uncoveredLine">    if (calcSpillCost() >= CSRCost)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">      return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="">    // We are going to spill, set CostPerUseLimit to 1 to make sure that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="">    // we will not use a callee-saved register in tryEvict.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="uncoveredLine">    CostPerUseLimit = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">  if (ExtraInfo->getStage(VirtReg) < RS_Split) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="">    // We choose pre-splitting over using the CSR for the first time if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">    // the cost of splitting is lower than CSRCost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="uncoveredLine">    SA->analyze(&VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">    unsigned NumCands = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">    BlockFrequency BestCost = CSRCost; // Don't modify CSRCost.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="uncoveredLine">    unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="">                                                 NumCands, true /*IgnoreCSR*/);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="uncoveredLine">    if (BestCand == NoCand)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">      // Use the CSR if we can't find a region split below CSRCost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">      return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">    // Perform the actual pre-splitting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="uncoveredLine">    doRegionSplit(VirtReg, BestCand, false/*HasCompact*/, NewVRegs);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="uncoveredLine">  return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">void RAGreedy::aboutToRemoveInterval(const LiveInterval &LI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">  // Do not keep invalid information around.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="uncoveredLine">  SetOfBrokenHints.remove(&LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="coveredLine">void RAGreedy::initializeCSRCost() {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">  // We use the larger one out of the command-line option and the value report</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">  // by TRI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="coveredLine">  CSRCost = BlockFrequency(</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="coveredLine">      std::max((unsigned)CSRFirstTimeCost, TRI->getCSRFirstUseCost()));</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="coveredLine">  if (!CSRCost.getFrequency())</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="coveredLine">    return;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">  // Raw cost is relative to Entry == 2^14; scale it appropriately.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="uncoveredLine">  uint64_t ActualEntry = MBFI->getEntryFreq();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="uncoveredLine">  if (!ActualEntry) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="uncoveredLine">    CSRCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="uncoveredLine">  uint64_t FixedEntry = 1 << 14;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="uncoveredLine">  if (ActualEntry < FixedEntry)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="uncoveredLine">    CSRCost *= BranchProbability(ActualEntry, FixedEntry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">  else if (ActualEntry <= UINT32_MAX)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="">    // Invert the fraction and divide.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="uncoveredLine">    CSRCost /= BranchProbability(FixedEntry, ActualEntry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">    // Can't use BranchProbability in general, since it takes 32-bit numbers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="uncoveredLine">    CSRCost = CSRCost.getFrequency() * (ActualEntry / FixedEntry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="">/// Collect the hint info for \p Reg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">/// The results are stored into \p Out.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">/// \p Out is not cleared before being populated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="uncoveredLine">void RAGreedy::collectHintInfo(Register Reg, HintsInfo &Out) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="uncoveredLine">  for (const MachineInstr &Instr : MRI->reg_nodbg_instructions(Reg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="uncoveredLine">    if (!Instr.isFullCopy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">    // Look for the other end of the copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="uncoveredLine">    Register OtherReg = Instr.getOperand(0).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="uncoveredLine">    if (OtherReg == Reg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="uncoveredLine">      OtherReg = Instr.getOperand(1).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="uncoveredLine">      if (OtherReg == Reg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="">    // Get the current assignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">    MCRegister OtherPhysReg =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">        OtherReg.isPhysical() ? OtherReg.asMCReg() : VRM->getPhys(OtherReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="">    // Push the collected information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="uncoveredLine">    Out.push_back(HintInfo(MBFI->getBlockFreq(Instr.getParent()), OtherReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">                           OtherPhysReg));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="">/// Using the given \p List, compute the cost of the broken hints if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="">/// \p PhysReg was used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="">/// \return The cost of \p List for \p PhysReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="uncoveredLine">BlockFrequency RAGreedy::getBrokenHintFreq(const HintsInfo &List,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="">                                           MCRegister PhysReg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="uncoveredLine">  BlockFrequency Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="uncoveredLine">  for (const HintInfo &Info : List) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="uncoveredLine">    if (Info.PhysReg != PhysReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="uncoveredLine">      Cost += Info.Freq;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">  return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="">/// Using the register assigned to \p VirtReg, try to recolor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">/// all the live ranges that are copy-related with \p VirtReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">/// The recoloring is then propagated to all the live-ranges that have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="">/// been recolored and so on, until no more copies can be coalesced or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">/// it is not profitable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="">/// For a given live range, profitability is determined by the sum of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="">/// frequencies of the non-identity copies it would introduce with the old</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="">/// and new register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">void RAGreedy::tryHintRecoloring(const LiveInterval &VirtReg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="">  // We have a broken hint, check if it is possible to fix it by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">  // reusing PhysReg for the copy-related live-ranges. Indeed, we evicted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">  // some register and PhysReg may be available for the other live-ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="uncoveredLine">  SmallSet<Register, 4> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">  SmallVector<unsigned, 2> RecoloringCandidates;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="uncoveredLine">  HintsInfo Info;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="uncoveredLine">  Register Reg = VirtReg.reg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">  MCRegister PhysReg = VRM->getPhys(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="">  // Start the recoloring algorithm from the input live-interval, then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="">  // it will propagate to the ones that are copy-related with it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">  Visited.insert(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">  RecoloringCandidates.push_back(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Trying to reconcile hints for: " << printReg(Reg, TRI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="">                    << '(' << printReg(PhysReg, TRI) << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="">  do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="uncoveredLine">    Reg = RecoloringCandidates.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="">    // We cannot recolor physical register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">    if (Reg.isPhysical())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="">    // This may be a skipped class</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="uncoveredLine">    if (!VRM->hasPhys(Reg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="uncoveredLine">      assert(!ShouldAllocateClass(*TRI, *MRI->getRegClass(Reg)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">             "We have an unallocated variable which should have been handled");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">    // Get the live interval mapped with this virtual register to be able</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="">    // to check for the interference with the new color.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="uncoveredLine">    LiveInterval &LI = LIS->getInterval(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">    MCRegister CurrPhys = VRM->getPhys(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">    // Check that the new color matches the register class constraints and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="">    // that it is free for this live range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="uncoveredLine">    if (CurrPhys != PhysReg && (!MRI->getRegClass(Reg)->contains(PhysReg) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="uncoveredLine">                                Matrix->checkInterference(LI, PhysReg)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << printReg(Reg, TRI) << '(' << printReg(CurrPhys, TRI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">                      << ") is recolorable.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">    // Gather the hint info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="uncoveredLine">    Info.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="uncoveredLine">    collectHintInfo(Reg, Info);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">    // Check if recoloring the live-range will increase the cost of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="">    // non-identity copies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">    if (CurrPhys != PhysReg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Checking profitability:\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">      BlockFrequency OldCopiesCost = getBrokenHintFreq(Info, CurrPhys);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="uncoveredLine">      BlockFrequency NewCopiesCost = getBrokenHintFreq(Info, PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "Old Cost: " << OldCopiesCost.getFrequency()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="">                        << "\nNew Cost: " << NewCopiesCost.getFrequency()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">                        << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">      if (OldCopiesCost < NewCopiesCost) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "=> Not profitable.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">      // At this point, the cost is either cheaper or equal. If it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="">      // equal, we consider this is profitable because it may expose</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">      // more recoloring opportunities.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "=> Profitable.\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">      // Recolor the live-range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="uncoveredLine">      Matrix->unassign(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">      Matrix->assign(LI, PhysReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="">    // Push all copy-related live-ranges to keep reconciling the broken</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">    // hints.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="uncoveredLine">    for (const HintInfo &HI : Info) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="uncoveredLine">      if (Visited.insert(HI.Reg).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="uncoveredLine">        RecoloringCandidates.push_back(HI.Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="uncoveredLine">  } while (!RecoloringCandidates.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">/// Try to recolor broken hints.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="">/// Broken hints may be repaired by recoloring when an evicted variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">/// freed up a register for a larger live-range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="">/// Consider the following example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">/// BB1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">///   a =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="">///   b =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">/// BB2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">///   ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="">///   = b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="">///   = a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="">/// Let us assume b gets split:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="">/// BB1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="">///   a =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="">///   b =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">/// BB2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">///   c = b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">///   ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">///   d = c</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">///   = d</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="">///   = a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="">/// Because of how the allocation work, b, c, and d may be assigned different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="">/// colors. Now, if a gets evicted later:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">/// BB1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="">///   a =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="">///   st a, SpillSlot</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="">///   b =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="">/// BB2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="">///   c = b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="">///   ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="">///   d = c</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="">///   = d</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="">///   e = ld SpillSlot</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="">///   = e</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="">/// This is likely that we can assign the same register for b, c, and d,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="">/// getting rid of 2 copies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="coveredLine">void RAGreedy::tryHintsRecoloring() {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="coveredLine">  for (const LiveInterval *LI : SetOfBrokenHints) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="uncoveredLine">    assert(LI->reg().isVirtual() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">           "Recoloring is possible only for virtual registers");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">    // Some dead defs may be around (e.g., because of debug uses).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="">    // Ignore those.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="uncoveredLine">    if (!VRM->hasPhys(LI->reg()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="uncoveredLine">    tryHintRecoloring(*LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="coveredLine">}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="coveredLine">MCRegister RAGreedy::selectOrSplitImpl(const LiveInterval &VirtReg,</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">                                       SmallVectorImpl<Register> &NewVRegs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="">                                       SmallVirtRegSet &FixedRegisters,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="">                                       RecoloringStack &RecolorStack,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="">                                       unsigned Depth) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="coveredLine">  uint8_t CostPerUseLimit = uint8_t(~0u);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="">  // First try assigning a free register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">  auto Order =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="coveredLine">      AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix);</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="coveredLine">  if (MCRegister PhysReg =</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="coveredLine">          tryAssign(VirtReg, Order, NewVRegs, FixedRegisters)) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">    // When NewVRegs is not empty, we may have made decisions such as evicting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="">    // a virtual register, go with the earlier decisions and use the physical</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="">    // register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="coveredLine">    if (CSRCost.getFrequency() &&</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="coveredLine">        EvictAdvisor->isUnusedCalleeSavedReg(PhysReg) && NewVRegs.empty()) {</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="uncoveredLine">      MCRegister CSRReg = tryAssignCSRFirstTime(VirtReg, Order, PhysReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="">                                                CostPerUseLimit, NewVRegs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="uncoveredLine">      if (CSRReg || !NewVRegs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">        // Return now if we decide to use a CSR or create new vregs due to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="">        // pre-splitting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="uncoveredLine">        return CSRReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="coveredLine">      return PhysReg;</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="uncoveredLine">  LiveRangeStage Stage = ExtraInfo->getStage(VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << StageName[Stage] << " Cascade "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">                    << ExtraInfo->getCascade(VirtReg.reg()) << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="">  // Try to evict a less worthy live range, but only for ranges from the primary</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="">  // queue. The RS_Split ranges already failed to do this, and they should not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="">  // get a second chance until they have been split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="uncoveredLine">  if (Stage != RS_Split)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="uncoveredLine">    if (Register PhysReg =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="">            tryEvict(VirtReg, Order, NewVRegs, CostPerUseLimit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="uncoveredLine">                     FixedRegisters)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="uncoveredLine">      Register Hint = MRI->getSimpleHint(VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="">      // If VirtReg has a hint and that hint is broken record this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="">      // virtual register as a recoloring candidate for broken hint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="">      // Indeed, since we evicted a variable in its neighborhood it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">      // likely we can at least partially recolor some of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="">      // copy-related live-ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="uncoveredLine">      if (Hint && Hint != PhysReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="uncoveredLine">        SetOfBrokenHints.insert(&VirtReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="uncoveredLine">      return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="uncoveredLine">  assert((NewVRegs.empty() || Depth) && "Cannot append to existing NewVRegs");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="">  // The first time we see a live range, don't try to split or spill.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">  // Wait until the second time, when all smaller ranges have been allocated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="">  // This gives a better picture of the interference to split around.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="uncoveredLine">  if (Stage < RS_Split) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="uncoveredLine">    ExtraInfo->setStage(VirtReg, RS_Split);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "wait for second round\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="uncoveredLine">    NewVRegs.push_back(VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="uncoveredLine">  if (Stage < RS_Spill) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="">    // Try splitting VirtReg or interferences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="uncoveredLine">    unsigned NewVRegSizeBefore = NewVRegs.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">    Register PhysReg = trySplit(VirtReg, Order, NewVRegs, FixedRegisters);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="uncoveredLine">    if (PhysReg || (NewVRegs.size() - NewVRegSizeBefore))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="uncoveredLine">      return PhysReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="">  // If we couldn't allocate a register from spilling, there is probably some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="">  // invalid inline assembly. The base class will report it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">  if (Stage >= RS_Done || !VirtReg.isSpillable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="">    return tryLastChanceRecoloring(VirtReg, Order, NewVRegs, FixedRegisters,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">                                   RecolorStack, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="">  // Finally spill VirtReg itself.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="uncoveredLine">  if ((EnableDeferredSpilling ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="uncoveredLine">       TRI->shouldUseDeferredSpillingForVirtReg(*MF, VirtReg)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">      ExtraInfo->getStage(VirtReg) < RS_Memory) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="">    // TODO: This is experimental and in particular, we do not model</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="">    // the live range splitting done by spilling correctly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">    // We would need a deep integration with the spiller to do the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">    // right thing here. Anyway, that is still good for early testing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="uncoveredLine">    ExtraInfo->setStage(VirtReg, RS_Memory);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Do as if this register is in memory\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="uncoveredLine">    NewVRegs.push_back(VirtReg.reg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="">    NamedRegionTimer T("spill", "Spiller", TimerGroupName,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">                       TimerGroupDescription, TimePassesIsEnabled);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">    LiveRangeEdit LRE(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">    spiller().spill(LRE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="uncoveredLine">    ExtraInfo->setStage(NewVRegs.begin(), NewVRegs.end(), RS_Done);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="">    // Tell LiveDebugVariables about the new ranges. Ranges not being covered by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="">    // the new regs are kept in LDV (still mapping to the old register), until</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="">    // we rewrite spilled locations in LDV at a later stage.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="uncoveredLine">    DebugVars->splitRegister(VirtReg.reg(), LRE.regs(), *LIS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="uncoveredLine">    if (VerifyEnabled)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="uncoveredLine">      MF->verify(this, "After spilling");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="">  // The live virtual register requesting allocation was spilled, so tell</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="">  // the caller not to allocate anything during this round.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="uncoveredLine">  return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="coveredLine">}</td>
    <td>16</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">void RAGreedy::RAGreedyStats::report(MachineOptimizationRemarkMissed &R) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="">  using namespace ore;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="uncoveredLine">  if (Spills) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="uncoveredLine">    R << NV("NumSpills", Spills) << " spills ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="uncoveredLine">    R << NV("TotalSpillsCost", SpillsCost) << " total spills cost ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="uncoveredLine">  if (FoldedSpills) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="uncoveredLine">    R << NV("NumFoldedSpills", FoldedSpills) << " folded spills ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="uncoveredLine">    R << NV("TotalFoldedSpillsCost", FoldedSpillsCost)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="uncoveredLine">      << " total folded spills cost ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">  if (Reloads) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="uncoveredLine">    R << NV("NumReloads", Reloads) << " reloads ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="uncoveredLine">    R << NV("TotalReloadsCost", ReloadsCost) << " total reloads cost ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="uncoveredLine">  if (FoldedReloads) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="uncoveredLine">    R << NV("NumFoldedReloads", FoldedReloads) << " folded reloads ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="uncoveredLine">    R << NV("TotalFoldedReloadsCost", FoldedReloadsCost)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="uncoveredLine">      << " total folded reloads cost ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="uncoveredLine">  if (ZeroCostFoldedReloads)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="uncoveredLine">    R << NV("NumZeroCostFoldedReloads", ZeroCostFoldedReloads)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="uncoveredLine">      << " zero cost folded reloads ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="uncoveredLine">  if (Copies) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="uncoveredLine">    R << NV("NumVRCopies", Copies) << " virtual registers copies ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="uncoveredLine">    R << NV("TotalCopiesCost", CopiesCost) << " total copies cost ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="uncoveredLine">RAGreedy::RAGreedyStats RAGreedy::computeStats(MachineBasicBlock &MBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="uncoveredLine">  RAGreedyStats Stats;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="uncoveredLine">  const MachineFrameInfo &MFI = MF->getFrameInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="">  int FI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="uncoveredLine">  auto isSpillSlotAccess = [&MFI](const MachineMemOperand *A) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="uncoveredLine">    return MFI.isSpillSlotObjectIndex(cast<FixedStackPseudoSourceValue>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="uncoveredLine">        A->getPseudoValue())->getFrameIndex());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="uncoveredLine">  auto isPatchpointInstr = [](const MachineInstr &MI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="uncoveredLine">    return MI.getOpcode() == TargetOpcode::PATCHPOINT ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="uncoveredLine">           MI.getOpcode() == TargetOpcode::STACKMAP ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="uncoveredLine">           MI.getOpcode() == TargetOpcode::STATEPOINT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="uncoveredLine">  for (MachineInstr &MI : MBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="uncoveredLine">    if (MI.isCopy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="uncoveredLine">      const MachineOperand &Dest = MI.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="uncoveredLine">      const MachineOperand &Src = MI.getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="uncoveredLine">      Register SrcReg = Src.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="uncoveredLine">      Register DestReg = Dest.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">      // Only count `COPY`s with a virtual register as source or destination.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="uncoveredLine">      if (SrcReg.isVirtual() || DestReg.isVirtual()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="uncoveredLine">        if (SrcReg.isVirtual()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="uncoveredLine">          SrcReg = VRM->getPhys(SrcReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="uncoveredLine">          if (SrcReg && Src.getSubReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="uncoveredLine">            SrcReg = TRI->getSubReg(SrcReg, Src.getSubReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="uncoveredLine">        if (DestReg.isVirtual()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="uncoveredLine">          DestReg = VRM->getPhys(DestReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="uncoveredLine">          if (DestReg && Dest.getSubReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="uncoveredLine">            DestReg = TRI->getSubReg(DestReg, Dest.getSubReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="uncoveredLine">        if (SrcReg != DestReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="uncoveredLine">          ++Stats.Copies;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="uncoveredLine">    SmallVector<const MachineMemOperand *, 2> Accesses;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="uncoveredLine">    if (TII->isLoadFromStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="uncoveredLine">      ++Stats.Reloads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="uncoveredLine">    if (TII->isStoreToStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="uncoveredLine">      ++Stats.Spills;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="uncoveredLine">    if (TII->hasLoadFromStackSlot(MI, Accesses) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="uncoveredLine">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="uncoveredLine">      if (!isPatchpointInstr(MI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="uncoveredLine">        Stats.FoldedReloads += Accesses.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="">      // For statepoint there may be folded and zero cost folded stack reloads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="">      std::pair<unsigned, unsigned> NonZeroCostRange =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="uncoveredLine">          TII->getPatchpointUnfoldableRange(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="uncoveredLine">      SmallSet<unsigned, 16> FoldedReloads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="uncoveredLine">      SmallSet<unsigned, 16> ZeroCostFoldedReloads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="uncoveredLine">      for (unsigned Idx = 0, E = MI.getNumOperands(); Idx < E; ++Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="uncoveredLine">        MachineOperand &MO = MI.getOperand(Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="uncoveredLine">        if (!MO.isFI() || !MFI.isSpillSlotObjectIndex(MO.getIndex()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="uncoveredLine">        if (Idx >= NonZeroCostRange.first && Idx < NonZeroCostRange.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="uncoveredLine">          FoldedReloads.insert(MO.getIndex());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="">        else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="uncoveredLine">          ZeroCostFoldedReloads.insert(MO.getIndex());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="">      // If stack slot is used in folded reload it is not zero cost then.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="uncoveredLine">      for (unsigned Slot : FoldedReloads)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="uncoveredLine">        ZeroCostFoldedReloads.erase(Slot);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="uncoveredLine">      Stats.FoldedReloads += FoldedReloads.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="uncoveredLine">      Stats.ZeroCostFoldedReloads += ZeroCostFoldedReloads.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="uncoveredLine">    Accesses.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="uncoveredLine">    if (TII->hasStoreToStackSlot(MI, Accesses) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="uncoveredLine">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="uncoveredLine">      Stats.FoldedSpills += Accesses.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="">  // Set cost of collected statistic by multiplication to relative frequency of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="">  // this basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="uncoveredLine">  float RelFreq = MBFI->getBlockFreqRelativeToEntryBlock(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="uncoveredLine">  Stats.ReloadsCost = RelFreq * Stats.Reloads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="uncoveredLine">  Stats.FoldedReloadsCost = RelFreq * Stats.FoldedReloads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="uncoveredLine">  Stats.SpillsCost = RelFreq * Stats.Spills;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="uncoveredLine">  Stats.FoldedSpillsCost = RelFreq * Stats.FoldedSpills;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">  Stats.CopiesCost = RelFreq * Stats.Copies;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">  return Stats;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="uncoveredLine">RAGreedy::RAGreedyStats RAGreedy::reportStats(MachineLoop *L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="uncoveredLine">  RAGreedyStats Stats;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="">  // Sum up the spill and reloads in subloops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="uncoveredLine">  for (MachineLoop *SubLoop : *L)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="uncoveredLine">    Stats.add(reportStats(SubLoop));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="uncoveredLine">  for (MachineBasicBlock *MBB : L->getBlocks())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="">    // Handle blocks that were not included in subloops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="uncoveredLine">    if (Loops->getLoopFor(MBB) == L)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="uncoveredLine">      Stats.add(computeStats(*MBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="uncoveredLine">  if (!Stats.isEmpty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="">    using namespace ore;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="uncoveredLine">    ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "LoopSpillReloadCopies",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="uncoveredLine">                                        L->getStartLoc(), L->getHeader());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="uncoveredLine">      Stats.report(R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="uncoveredLine">      R << "generated in loop";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">      return R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="">    });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="uncoveredLine">  return Stats;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="coveredLine">void RAGreedy::reportStats() {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="coveredLine">  if (!ORE->allowExtraAnalysis(DEBUG_TYPE))</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="coveredLine">    return;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="uncoveredLine">  RAGreedyStats Stats;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="uncoveredLine">  for (MachineLoop *L : *Loops)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="uncoveredLine">    Stats.add(reportStats(L));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="">  // Process non-loop blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="uncoveredLine">  for (MachineBasicBlock &MBB : *MF)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="uncoveredLine">    if (!Loops->getLoopFor(&MBB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="uncoveredLine">      Stats.add(computeStats(MBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="uncoveredLine">  if (!Stats.isEmpty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="">    using namespace ore;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="uncoveredLine">    ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="uncoveredLine">      DebugLoc Loc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="uncoveredLine">      if (auto *SP = MF->getFunction().getSubprogram())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="uncoveredLine">        Loc = DILocation::get(SP->getContext(), SP->getLine(), 1, SP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "SpillReloadCopies", Loc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="uncoveredLine">                                        &MF->front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="uncoveredLine">      Stats.report(R);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="uncoveredLine">      R << "generated in function";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="uncoveredLine">      return R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="uncoveredLine">    });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="coveredLine">bool RAGreedy::hasVirtRegAlloc() {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="coveredLine">  for (unsigned I = 0, E = MRI->getNumVirtRegs(); I != E; ++I) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="coveredLine">    Register Reg = Register::index2VirtReg(I);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="coveredLine">    if (MRI->reg_nodbg_empty(Reg))</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="coveredLine">    const TargetRegisterClass *RC = MRI->getRegClass(Reg);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="coveredLine">    if (!RC)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="coveredLine">    if (ShouldAllocateClass(*TRI, *RC))</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="coveredLine">      return true;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="coveredLine">bool RAGreedy::runOnMachineFunction(MachineFunction &mf) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="coveredLine">  LLVM_DEBUG(dbgs() << "********** GREEDY REGISTER ALLOCATION **********\n"</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="">                    << "********** Function: " << mf.getName() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="coveredLine">  MF = &mf;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="coveredLine">  TII = MF->getSubtarget().getInstrInfo();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="coveredLine">  if (VerifyEnabled)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="uncoveredLine">    MF->verify(this, "Before greedy register allocator");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="coveredLine">  RegAllocBase::init(getAnalysis<VirtRegMap>(),</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="">                     getAnalysis<LiveIntervals>(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="">                     getAnalysis<LiveRegMatrix>());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="">  // Early return if there is no virtual register to be allocated to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="">  // physical register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="coveredLine">  if (!hasVirtRegAlloc())</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="coveredLine">  Indexes = &getAnalysis<SlotIndexes>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="coveredLine">  MBFI = &getAnalysis<MachineBlockFrequencyInfo>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="coveredLine">  DomTree = &getAnalysis<MachineDominatorTree>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="coveredLine">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="coveredLine">  Loops = &getAnalysis<MachineLoopInfo>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="coveredLine">  Bundles = &getAnalysis<EdgeBundles>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="coveredLine">  SpillPlacer = &getAnalysis<SpillPlacement>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="coveredLine">  DebugVars = &getAnalysis<LiveDebugVariables>();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="coveredLine">  initializeCSRCost();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="coveredLine">  RegCosts = TRI->getRegisterCosts(*MF);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="coveredLine">  RegClassPriorityTrumpsGlobalness =</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="coveredLine">      GreedyRegClassPriorityTrumpsGlobalness.getNumOccurrences()</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="coveredLine">          ? GreedyRegClassPriorityTrumpsGlobalness</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="coveredLine">          : TRI->regClassPriorityTrumpsGlobalness(*MF);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="coveredLine">  ReverseLocalAssignment = GreedyReverseLocalAssignment.getNumOccurrences()</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="coveredLine">                               ? GreedyReverseLocalAssignment</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="coveredLine">                               : TRI->reverseLocalAssignment();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="coveredLine">  ExtraInfo.emplace();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="">  EvictAdvisor =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="coveredLine">      getAnalysis<RegAllocEvictionAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="">  PriorityAdvisor =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="coveredLine">      getAnalysis<RegAllocPriorityAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="coveredLine">  VRAI = std::make_unique<VirtRegAuxInfo>(*MF, *LIS, *VRM, *Loops, *MBFI);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="coveredLine">  SpillerInstance.reset(createInlineSpiller(*this, *MF, *VRM, *VRAI));</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="coveredLine">  VRAI->calculateSpillWeightsAndHints();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="coveredLine">  LLVM_DEBUG(LIS->dump());</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="coveredLine">  SA.reset(new SplitAnalysis(*VRM, *LIS, *Loops));</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="coveredLine">  SE.reset(new SplitEditor(*SA, *LIS, *VRM, *DomTree, *MBFI, *VRAI));</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="coveredLine">  IntfCache.init(MF, Matrix->getLiveUnions(), Indexes, LIS, TRI);</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="coveredLine">  GlobalCand.resize(32);  // This will grow as needed.</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="coveredLine">  SetOfBrokenHints.clear();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="coveredLine">  allocatePhysRegs();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="coveredLine">  tryHintsRecoloring();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="coveredLine">  if (VerifyEnabled)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="uncoveredLine">    MF->verify(this, "Before post optimization");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="coveredLine">  postOptimization();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="coveredLine">  reportStats();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="coveredLine">  releaseMemory();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="coveredLine">  return true;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL26initializeRAGreedyPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm22initializeRAGreedyPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29createGreedyRegisterAllocatorEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29createGreedyRegisterAllocatorESt8functionIFbRKNS_18TargetRegisterInfoERKNS_19TargetRegisterClassEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedyC2ESt8functionIFbRKNS_18TargetRegisterInfoERKNS_19TargetRegisterClassEEE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm8RAGreedy16getAnalysisUsageERNS_13AnalysisUsageE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy19LRE_CanEraseVirtRegENS_8RegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy21LRE_WillShrinkVirtRegENS_8RegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy19LRE_DidCloneVirtRegENS_8RegisterES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy12ExtraRegInfo19LRE_DidCloneVirtRegENS_8RegisterES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy13releaseMemoryEv</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy11enqueueImplEPKNS_12LiveIntervalE</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy7enqueueERSt14priority_queueISt4pairIjjESt6vectorIS3_SaIS3_EESt4lessIS3_EEPKNS_12LiveIntervalE</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm22DefaultPriorityAdvisor11getPriorityERKNS_12LiveIntervalE</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy7dequeueEv</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy7dequeueERSt14priority_queueISt4pairIjjESt6vectorIS3_SaIS3_EESt4lessIS3_EE</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy9tryAssignERKNS_12LiveIntervalERNS_15AllocationOrderERNS_15SmallVectorImplINS_8RegisterEEERKNS_8SmallSetIS7_Lj16ESt4lessIS7_EEE</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23RegAllocEvictionAdvisor11canReassignERKNS_12LiveIntervalENS_10MCRegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK4llvm23RegAllocEvictionAdvisor11canReassignERKNS_12LiveIntervalENS_10MCRegisterEENKUljE_clEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy17evictInterferenceERKNS_12LiveIntervalENS_10MCRegisterERNS_15SmallVectorImplINS_8RegisterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23RegAllocEvictionAdvisor22isUnusedCalleeSavedRegENS_10MCRegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23RegAllocEvictionAdvisor13getOrderLimitERKNS_12LiveIntervalERKNS_15AllocationOrderEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm23RegAllocEvictionAdvisor18canAllocatePhysRegEjNS_10MCRegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy8tryEvictERKNS_12LiveIntervalERNS_15AllocationOrderERNS_15SmallVectorImplINS_8RegisterEEEhRKNS_8SmallSetIS7_Lj16ESt4lessIS7_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy19addSplitConstraintsENS_17InterferenceCache6CursorERNS_14BlockFrequencyE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy21addThroughConstraintsENS_17InterferenceCache6CursorENS_8ArrayRefIjEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy10growRegionERNS0_20GlobalSplitCandidateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy17calcCompactRegionERNS0_20GlobalSplitCandidateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy13calcSpillCostEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy19calcGlobalSplitCostERNS0_20GlobalSplitCandidateERKNS_15AllocationOrderE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy17splitAroundRegionERNS_13LiveRangeEditENS_8ArrayRefIjEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy14tryRegionSplitERKNS_12LiveIntervalERNS_15AllocationOrderERNS_15SmallVectorImplINS_8RegisterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy24calculateRegionSplitCostERKNS_12LiveIntervalERNS_15AllocationOrderERNS_14BlockFrequencyERjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy13doRegionSplitERKNS_12LiveIntervalEjbRNS_15SmallVectorImplINS_8RegisterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy13tryBlockSplitERKNS_12LiveIntervalERNS_15AllocationOrderERNS_15SmallVectorImplINS_8RegisterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL35getNumAllocatableRegsForConstraintsPKN4llvm12MachineInstrENS_8RegisterEPKNS_19TargetRegisterClassEPKNS_15TargetInstrInfoEPKNS_18TargetRegisterInfoERKNS_17RegisterClassInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL19getInstReadLaneMaskRKN4llvm19MachineRegisterInfoERKNS_18TargetRegisterInfoERKNS_12MachineInstrENS_8RegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15readsLaneSubsetRKN4llvm19MachineRegisterInfoEPKNS_12MachineInstrERKNS_12LiveIntervalEPKNS_18TargetRegisterInfoENS_9SlotIndexE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy19tryInstructionSplitERKNS_12LiveIntervalERNS_15AllocationOrderERNS_15SmallVectorImplINS_8RegisterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy14calcGapWeightsENS_10MCRegisterERNS_15SmallVectorImplIfEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy13tryLocalSplitERKNS_12LiveIntervalERNS_15AllocationOrderERNS_15SmallVectorImplINS_8RegisterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy8trySplitERKNS_12LiveIntervalERNS_15AllocationOrderERNS_15SmallVectorImplINS_8RegisterEEERKNS_8SmallSetIS7_Lj16ESt4lessIS7_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL10hasTiedDefPN4llvm19MachineRegisterInfoEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL28assignedRegPartiallyOverlapsRKN4llvm18TargetRegisterInfoERKNS_10VirtRegMapENS_10MCRegisterERKNS_12LiveIntervalE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy26mayRecolorAllInterferencesENS_10MCRegisterERKNS_12LiveIntervalERNS_14SmallSetVectorIPS3_Lj4EEERKNS_8SmallSetINS_8RegisterELj16ESt4lessISA_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy23tryLastChanceRecoloringERKNS_12LiveIntervalERNS_15AllocationOrderERNS_15SmallVectorImplINS_8RegisterEEERNS_8SmallSetIS7_Lj16ESt4lessIS7_EEERNS_11SmallVectorISt4pairIPS2_NS_10MCRegisterEELj8EEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy23tryRecoloringCandidatesERSt14priority_queueISt4pairIjjESt6vectorIS3_SaIS3_EESt4lessIS3_EERNS_15SmallVectorImplINS_8RegisterEEERNS_8SmallSetISC_Lj16ES7_ISC_EEERNS_11SmallVectorIS2_IPKNS_12LiveIntervalENS_10MCRegisterEELj8EEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy13selectOrSplitERKNS_12LiveIntervalERNS_15SmallVectorImplINS_8RegisterEEE</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy21tryAssignCSRFirstTimeERKNS_12LiveIntervalERNS_15AllocationOrderENS_10MCRegisterERhRNS_15SmallVectorImplINS_8RegisterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy21aboutToRemoveIntervalERKNS_12LiveIntervalE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy17initializeCSRCostEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy15collectHintInfoENS_8RegisterERNS_11SmallVectorINS0_8HintInfoELj4EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy17getBrokenHintFreqERKNS_11SmallVectorINS0_8HintInfoELj4EEENS_10MCRegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy17tryHintRecoloringERKNS_12LiveIntervalE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy18tryHintsRecoloringEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy17selectOrSplitImplERKNS_12LiveIntervalERNS_15SmallVectorImplINS_8RegisterEEERNS_8SmallSetIS5_Lj16ESt4lessIS5_EEERNS_11SmallVectorISt4pairIPS2_NS_10MCRegisterEELj8EEEj</td>
    <td class="numberOfCalls">16</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy13RAGreedyStats6reportERNS_31MachineOptimizationRemarkMissedE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy12computeStatsERNS_17MachineBasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8RAGreedy12computeStatsERNS_17MachineBasicBlockEENKUlPKNS_17MachineMemOperandEE_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8RAGreedy12computeStatsERNS_17MachineBasicBlockEENKUlRKNS_12MachineInstrEE0_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy11reportStatsEPNS_11MachineLoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8RAGreedy11reportStatsEPNS_11MachineLoopEENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy11reportStatsEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8RAGreedy11reportStatsEvENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy15hasVirtRegAllocEv</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8RAGreedy20runOnMachineFunctionERNS_15MachineFunctionE</td>
    <td class="numberOfCalls">2</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- RegAllocGreedy.cpp - greedy register allocator ---------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- RegAllocGreedy.cpp - greedy register allocator ---------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file defines the RAGreedy function pass for register allocation in</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file defines the RAGreedy function pass for register allocation in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// optimized builds.</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// optimized builds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">12</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline"></td>
    <td class="lineNumber">13</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "RegAllocGreedy.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "RegAllocGreedy.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "AllocationOrder.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "AllocationOrder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "InterferenceCache.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "InterferenceCache.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "LiveDebugVariables.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "LiveDebugVariables.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "RegAllocBase.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "RegAllocBase.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "RegAllocEvictionAdvisor.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "RegAllocEvictionAdvisor.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "RegAllocPriorityAdvisor.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "RegAllocPriorityAdvisor.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "SpillPlacement.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "SpillPlacement.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "SplitKit.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "SplitKit.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/IndexedMap.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/IndexedMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Analysis/AliasAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/CodeGen/CalcSpillWeights.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/CodeGen/CalcSpillWeights.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/CodeGen/EdgeBundles.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/CodeGen/EdgeBundles.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/CodeGen/LiveInterval.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/CodeGen/LiveInterval.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/CodeGen/LiveIntervalUnion.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/CodeGen/LiveIntervalUnion.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/CodeGen/LiveIntervals.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/CodeGen/LiveIntervals.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/CodeGen/LiveRangeEdit.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/CodeGen/LiveRangeEdit.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/CodeGen/LiveRegMatrix.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/CodeGen/LiveRegMatrix.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/CodeGen/LiveStacks.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/CodeGen/LiveStacks.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBlockFrequencyInfo.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBlockFrequencyInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/CodeGen/MachineDominators.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/CodeGen/MachineDominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFrameInfo.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFrameInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOperand.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOptimizationRemarkEmitter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/CodeGen/RegAllocRegistry.h"</td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/CodeGen/RegAllocRegistry.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/CodeGen/SlotIndexes.h"</td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/CodeGen/SlotIndexes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/CodeGen/Spiller.h"</td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/CodeGen/Spiller.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/CodeGen/VirtRegMap.h"</td>
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/CodeGen/VirtRegMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/IR/DebugInfoMetadata.h"</td>
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/IR/DebugInfoMetadata.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">63</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">#include "llvm/MC/MCRegisterInfo.h"</td>
    <td class="lineNumber">64</td>
    <td class="codeline">#include "llvm/MC/MCRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">65</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">#include "llvm/Support/BlockFrequency.h"</td>
    <td class="lineNumber">66</td>
    <td class="codeline">#include "llvm/Support/BlockFrequency.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">67</td>
    <td class="codeline">#include "llvm/Support/BranchProbability.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">68</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">69</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">70</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">#include "llvm/Support/Timer.h"</td>
    <td class="lineNumber">71</td>
    <td class="codeline">#include "llvm/Support/Timer.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">72</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">73</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">74</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">75</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">76</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">78</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline"></td>
    <td class="lineNumber">79</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">#define DEBUG_TYPE "regalloc"</td>
    <td class="lineNumber">80</td>
    <td class="codeline">#define DEBUG_TYPE "regalloc"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">STATISTIC(NumGlobalSplits, "Number of split global live ranges");</td>
    <td class="lineNumber">82</td>
    <td class="codeline">STATISTIC(NumGlobalSplits, "Number of split global live ranges");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">STATISTIC(NumLocalSplits,  "Number of split local live ranges");</td>
    <td class="lineNumber">83</td>
    <td class="codeline">STATISTIC(NumLocalSplits,  "Number of split local live ranges");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">STATISTIC(NumEvicted,      "Number of interferences evicted");</td>
    <td class="lineNumber">84</td>
    <td class="codeline">STATISTIC(NumEvicted,      "Number of interferences evicted");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">static cl::opt<SplitEditor::ComplementSpillMode> SplitSpillMode(</td>
    <td class="lineNumber">86</td>
    <td class="codeline">static cl::opt<SplitEditor::ComplementSpillMode> SplitSpillMode(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">    "split-spill-mode", cl::Hidden,</td>
    <td class="lineNumber">87</td>
    <td class="codeline">    "split-spill-mode", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">    cl::desc("Spill mode for splitting live ranges"),</td>
    <td class="lineNumber">88</td>
    <td class="codeline">    cl::desc("Spill mode for splitting live ranges"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">    cl::values(clEnumValN(SplitEditor::SM_Partition, "default", "Default"),</td>
    <td class="lineNumber">89</td>
    <td class="codeline">    cl::values(clEnumValN(SplitEditor::SM_Partition, "default", "Default"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">               clEnumValN(SplitEditor::SM_Size, "size", "Optimize for size"),</td>
    <td class="lineNumber">90</td>
    <td class="codeline">               clEnumValN(SplitEditor::SM_Size, "size", "Optimize for size"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">               clEnumValN(SplitEditor::SM_Speed, "speed", "Optimize for speed")),</td>
    <td class="lineNumber">91</td>
    <td class="codeline">               clEnumValN(SplitEditor::SM_Speed, "speed", "Optimize for speed")),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">    cl::init(SplitEditor::SM_Speed));</td>
    <td class="lineNumber">92</td>
    <td class="codeline">    cl::init(SplitEditor::SM_Speed));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline"></td>
    <td class="lineNumber">93</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">static cl::opt<unsigned></td>
    <td class="lineNumber">94</td>
    <td class="codeline">static cl::opt<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">LastChanceRecoloringMaxDepth("lcr-max-depth", cl::Hidden,</td>
    <td class="lineNumber">95</td>
    <td class="codeline">LastChanceRecoloringMaxDepth("lcr-max-depth", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">                             cl::desc("Last chance recoloring max depth"),</td>
    <td class="lineNumber">96</td>
    <td class="codeline">                             cl::desc("Last chance recoloring max depth"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">                             cl::init(5));</td>
    <td class="lineNumber">97</td>
    <td class="codeline">                             cl::init(5));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">static cl::opt<unsigned> LastChanceRecoloringMaxInterference(</td>
    <td class="lineNumber">99</td>
    <td class="codeline">static cl::opt<unsigned> LastChanceRecoloringMaxInterference(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">    "lcr-max-interf", cl::Hidden,</td>
    <td class="lineNumber">100</td>
    <td class="codeline">    "lcr-max-interf", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">    cl::desc("Last chance recoloring maximum number of considered"</td>
    <td class="lineNumber">101</td>
    <td class="codeline">    cl::desc("Last chance recoloring maximum number of considered"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">             " interference at a time"),</td>
    <td class="lineNumber">102</td>
    <td class="codeline">             " interference at a time"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">    cl::init(8));</td>
    <td class="lineNumber">103</td>
    <td class="codeline">    cl::init(8));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline"></td>
    <td class="lineNumber">104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">static cl::opt<bool> ExhaustiveSearch(</td>
    <td class="lineNumber">105</td>
    <td class="codeline">static cl::opt<bool> ExhaustiveSearch(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">    "exhaustive-register-search", cl::NotHidden,</td>
    <td class="lineNumber">106</td>
    <td class="codeline">    "exhaustive-register-search", cl::NotHidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">    cl::desc("Exhaustive Search for registers bypassing the depth "</td>
    <td class="lineNumber">107</td>
    <td class="codeline">    cl::desc("Exhaustive Search for registers bypassing the depth "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">             "and interference cutoffs of last chance recoloring"),</td>
    <td class="lineNumber">108</td>
    <td class="codeline">             "and interference cutoffs of last chance recoloring"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">    cl::Hidden);</td>
    <td class="lineNumber">109</td>
    <td class="codeline">    cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
    <td class="lineNumber">110</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">static cl::opt<bool> EnableDeferredSpilling(</td>
    <td class="lineNumber">111</td>
    <td class="codeline">static cl::opt<bool> EnableDeferredSpilling(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">    "enable-deferred-spilling", cl::Hidden,</td>
    <td class="lineNumber">112</td>
    <td class="codeline">    "enable-deferred-spilling", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">    cl::desc("Instead of spilling a variable right away, defer the actual "</td>
    <td class="lineNumber">113</td>
    <td class="codeline">    cl::desc("Instead of spilling a variable right away, defer the actual "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">             "code insertion to the end of the allocation. That way the "</td>
    <td class="lineNumber">114</td>
    <td class="codeline">             "code insertion to the end of the allocation. That way the "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">             "allocator might still find a suitable coloring for this "</td>
    <td class="lineNumber">115</td>
    <td class="codeline">             "allocator might still find a suitable coloring for this "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">             "variable because of other evicted variables."),</td>
    <td class="lineNumber">116</td>
    <td class="codeline">             "variable because of other evicted variables."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">    cl::init(false));</td>
    <td class="lineNumber">117</td>
    <td class="codeline">    cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline"></td>
    <td class="lineNumber">118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">// FIXME: Find a good default for this flag and remove the flag.</td>
    <td class="lineNumber">119</td>
    <td class="codeline">// FIXME: Find a good default for this flag and remove the flag.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">static cl::opt<unsigned></td>
    <td class="lineNumber">120</td>
    <td class="codeline">static cl::opt<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">CSRFirstTimeCost("regalloc-csr-first-time-cost",</td>
    <td class="lineNumber">121</td>
    <td class="codeline">CSRFirstTimeCost("regalloc-csr-first-time-cost",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">              cl::desc("Cost for first time use of callee-saved register."),</td>
    <td class="lineNumber">122</td>
    <td class="codeline">              cl::desc("Cost for first time use of callee-saved register."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">              cl::init(0), cl::Hidden);</td>
    <td class="lineNumber">123</td>
    <td class="codeline">              cl::init(0), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline"></td>
    <td class="lineNumber">124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">static cl::opt<unsigned long> GrowRegionComplexityBudget(</td>
    <td class="lineNumber">125</td>
    <td class="codeline">static cl::opt<unsigned long> GrowRegionComplexityBudget(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">    "grow-region-complexity-budget",</td>
    <td class="lineNumber">126</td>
    <td class="codeline">    "grow-region-complexity-budget",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">    cl::desc("growRegion() does not scale with the number of BB edges, so "</td>
    <td class="lineNumber">127</td>
    <td class="codeline">    cl::desc("growRegion() does not scale with the number of BB edges, so "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">             "limit its budget and bail out once we reach the limit."),</td>
    <td class="lineNumber">128</td>
    <td class="codeline">             "limit its budget and bail out once we reach the limit."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">    cl::init(10000), cl::Hidden);</td>
    <td class="lineNumber">129</td>
    <td class="codeline">    cl::init(10000), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">static cl::opt<bool> GreedyRegClassPriorityTrumpsGlobalness(</td>
    <td class="lineNumber">131</td>
    <td class="codeline">static cl::opt<bool> GreedyRegClassPriorityTrumpsGlobalness(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">    "greedy-regclass-priority-trumps-globalness",</td>
    <td class="lineNumber">132</td>
    <td class="codeline">    "greedy-regclass-priority-trumps-globalness",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    cl::desc("Change the greedy register allocator's live range priority "</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    cl::desc("Change the greedy register allocator's live range priority "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">             "calculation to make the AllocationPriority of the register class "</td>
    <td class="lineNumber">134</td>
    <td class="codeline">             "calculation to make the AllocationPriority of the register class "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">             "more important then whether the range is global"),</td>
    <td class="lineNumber">135</td>
    <td class="codeline">             "more important then whether the range is global"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">    cl::Hidden);</td>
    <td class="lineNumber">136</td>
    <td class="codeline">    cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">static cl::opt<bool> GreedyReverseLocalAssignment(</td>
    <td class="lineNumber">138</td>
    <td class="codeline">static cl::opt<bool> GreedyReverseLocalAssignment(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">    "greedy-reverse-local-assignment",</td>
    <td class="lineNumber">139</td>
    <td class="codeline">    "greedy-reverse-local-assignment",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">    cl::desc("Reverse allocation order of local live ranges, such that "</td>
    <td class="lineNumber">140</td>
    <td class="codeline">    cl::desc("Reverse allocation order of local live ranges, such that "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">             "shorter local live ranges will tend to be allocated first"),</td>
    <td class="lineNumber">141</td>
    <td class="codeline">             "shorter local live ranges will tend to be allocated first"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    cl::Hidden);</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline"></td>
    <td class="lineNumber">143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">static RegisterRegAlloc greedyRegAlloc("greedy", "greedy register allocator",</td>
    <td class="lineNumber">144</td>
    <td class="codeline">static RegisterRegAlloc greedyRegAlloc("greedy", "greedy register allocator",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">                                       createGreedyRegisterAllocator);</td>
    <td class="lineNumber">145</td>
    <td class="codeline">                                       createGreedyRegisterAllocator);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline"></td>
    <td class="lineNumber">146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">char RAGreedy::ID = 0;</td>
    <td class="lineNumber">147</td>
    <td class="codeline">char RAGreedy::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">char &llvm::RAGreedyID = RAGreedy::ID;</td>
    <td class="lineNumber">148</td>
    <td class="codeline">char &llvm::RAGreedyID = RAGreedy::ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(RAGreedy, "greedy",</td>
    <td class="lineNumber">150</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(RAGreedy, "greedy",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">                "Greedy Register Allocator", false, false)</td>
    <td class="lineNumber">151</td>
    <td class="codeline">                "Greedy Register Allocator", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveDebugVariables)</td>
    <td class="lineNumber">152</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveDebugVariables)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(SlotIndexes)</td>
    <td class="lineNumber">153</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(SlotIndexes)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
    <td class="lineNumber">154</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(RegisterCoalescer)</td>
    <td class="lineNumber">155</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(RegisterCoalescer)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineScheduler)</td>
    <td class="lineNumber">156</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineScheduler)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveStacks)</td>
    <td class="lineNumber">157</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveStacks)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
    <td class="lineNumber">158</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
    <td class="lineNumber">159</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(VirtRegMap)</td>
    <td class="lineNumber">160</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(VirtRegMap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveRegMatrix)</td>
    <td class="lineNumber">161</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LiveRegMatrix)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(EdgeBundles)</td>
    <td class="lineNumber">162</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(EdgeBundles)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(SpillPlacement)</td>
    <td class="lineNumber">163</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(SpillPlacement)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineOptimizationRemarkEmitterPass)</td>
    <td class="lineNumber">164</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(MachineOptimizationRemarkEmitterPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(RegAllocEvictionAdvisorAnalysis)</td>
    <td class="lineNumber">165</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(RegAllocEvictionAdvisorAnalysis)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(RegAllocPriorityAdvisorAnalysis)</td>
    <td class="lineNumber">166</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(RegAllocPriorityAdvisorAnalysis)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">INITIALIZE_PASS_END(RAGreedy, "greedy",</td>
    <td class="lineNumber">167</td>
    <td class="codeline">INITIALIZE_PASS_END(RAGreedy, "greedy",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">                "Greedy Register Allocator", false, false)</td>
    <td class="lineNumber">168</td>
    <td class="codeline">                "Greedy Register Allocator", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline"></td>
    <td class="lineNumber">169</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">170</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">const char *const RAGreedy::StageName[] = {</td>
    <td class="lineNumber">171</td>
    <td class="codeline">const char *const RAGreedy::StageName[] = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">    "RS_New",</td>
    <td class="lineNumber">172</td>
    <td class="codeline">    "RS_New",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    "RS_Assign",</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    "RS_Assign",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">    "RS_Split",</td>
    <td class="lineNumber">174</td>
    <td class="codeline">    "RS_Split",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">    "RS_Split2",</td>
    <td class="lineNumber">175</td>
    <td class="codeline">    "RS_Split2",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">    "RS_Spill",</td>
    <td class="lineNumber">176</td>
    <td class="codeline">    "RS_Spill",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">    "RS_Memory",</td>
    <td class="lineNumber">177</td>
    <td class="codeline">    "RS_Memory",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">    "RS_Done"</td>
    <td class="lineNumber">178</td>
    <td class="codeline">    "RS_Done"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">};</td>
    <td class="lineNumber">179</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">180</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">// Hysteresis to use when comparing floats.</td>
    <td class="lineNumber">182</td>
    <td class="codeline">// Hysteresis to use when comparing floats.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">// This helps stabilize decisions based on float comparisons.</td>
    <td class="lineNumber">183</td>
    <td class="codeline">// This helps stabilize decisions based on float comparisons.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">const float Hysteresis = (2007 / 2048.0f); // 0.97998046875</td>
    <td class="lineNumber">184</td>
    <td class="codeline">const float Hysteresis = (2007 / 2048.0f); // 0.97998046875</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">FunctionPass* llvm::createGreedyRegisterAllocator() {</td>
    <td class="lineNumber">186</td>
    <td class="codeline">FunctionPass* llvm::createGreedyRegisterAllocator() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  return new RAGreedy();</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  return new RAGreedy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">}</td>
    <td class="lineNumber">188</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">FunctionPass *llvm::createGreedyRegisterAllocator(RegClassFilterFunc Ftor) {</td>
    <td class="lineNumber">190</td>
    <td class="codeline">FunctionPass *llvm::createGreedyRegisterAllocator(RegClassFilterFunc Ftor) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  return new RAGreedy(Ftor);</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  return new RAGreedy(Ftor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">}</td>
    <td class="lineNumber">192</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline"></td>
    <td class="lineNumber">193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">RAGreedy::RAGreedy(RegClassFilterFunc F):</td>
    <td class="lineNumber">194</td>
    <td class="codeline">RAGreedy::RAGreedy(RegClassFilterFunc F):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  MachineFunctionPass(ID),</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  MachineFunctionPass(ID),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  RegAllocBase(F) {</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  RegAllocBase(F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">}</td>
    <td class="lineNumber">197</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">void RAGreedy::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">199</td>
    <td class="codeline">void RAGreedy::getAnalysisUsage(AnalysisUsage &AU) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">  AU.setPreservesCFG();</td>
    <td class="lineNumber">200</td>
    <td class="codeline">  AU.setPreservesCFG();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  AU.addRequired<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  AU.addRequired<MachineBlockFrequencyInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  AU.addPreserved<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  AU.addPreserved<MachineBlockFrequencyInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  AU.addRequired<LiveIntervals>();</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  AU.addRequired<LiveIntervals>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  AU.addPreserved<LiveIntervals>();</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  AU.addPreserved<LiveIntervals>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  AU.addRequired<SlotIndexes>();</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  AU.addRequired<SlotIndexes>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  AU.addPreserved<SlotIndexes>();</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  AU.addPreserved<SlotIndexes>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  AU.addRequired<LiveDebugVariables>();</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  AU.addRequired<LiveDebugVariables>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  AU.addPreserved<LiveDebugVariables>();</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  AU.addPreserved<LiveDebugVariables>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  AU.addRequired<LiveStacks>();</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  AU.addRequired<LiveStacks>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  AU.addPreserved<LiveStacks>();</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  AU.addPreserved<LiveStacks>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  AU.addRequired<MachineDominatorTree>();</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  AU.addRequired<MachineDominatorTree>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  AU.addPreserved<MachineDominatorTree>();</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  AU.addPreserved<MachineDominatorTree>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  AU.addRequired<MachineLoopInfo>();</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  AU.addRequired<MachineLoopInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  AU.addPreserved<MachineLoopInfo>();</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  AU.addPreserved<MachineLoopInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  AU.addRequired<VirtRegMap>();</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  AU.addRequired<VirtRegMap>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  AU.addPreserved<VirtRegMap>();</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  AU.addPreserved<VirtRegMap>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  AU.addRequired<LiveRegMatrix>();</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  AU.addRequired<LiveRegMatrix>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  AU.addPreserved<LiveRegMatrix>();</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  AU.addPreserved<LiveRegMatrix>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  AU.addRequired<EdgeBundles>();</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  AU.addRequired<EdgeBundles>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  AU.addRequired<SpillPlacement>();</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  AU.addRequired<SpillPlacement>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  AU.addRequired<RegAllocEvictionAdvisorAnalysis>();</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  AU.addRequired<RegAllocEvictionAdvisorAnalysis>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  AU.addRequired<RegAllocPriorityAdvisorAnalysis>();</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  AU.addRequired<RegAllocPriorityAdvisorAnalysis>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  MachineFunctionPass::getAnalysisUsage(AU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">}</td>
    <td class="lineNumber">225</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline"></td>
    <td class="lineNumber">226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">227</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">//                     LiveRangeEdit delegate methods</td>
    <td class="lineNumber">228</td>
    <td class="codeline">//                     LiveRangeEdit delegate methods</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">229</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">bool RAGreedy::LRE_CanEraseVirtReg(Register VirtReg) {</td>
    <td class="lineNumber">231</td>
    <td class="codeline">bool RAGreedy::LRE_CanEraseVirtReg(Register VirtReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  if (VRM->hasPhys(VirtReg)) {</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  if (VRM->hasPhys(VirtReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">    Matrix->unassign(LI);</td>
    <td class="lineNumber">234</td>
    <td class="codeline">    Matrix->unassign(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">    aboutToRemoveInterval(LI);</td>
    <td class="lineNumber">235</td>
    <td class="codeline">    aboutToRemoveInterval(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  // Unassigned virtreg is probably in the priority queue.</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  // Unassigned virtreg is probably in the priority queue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  // RegAllocBase will erase it after dequeueing.</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  // RegAllocBase will erase it after dequeueing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  // Nonetheless, clear the live-range so that the debug</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  // Nonetheless, clear the live-range so that the debug</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  // dump will show the right state for that VirtReg.</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  // dump will show the right state for that VirtReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  LI.clear();</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  LI.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">}</td>
    <td class="lineNumber">244</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">void RAGreedy::LRE_WillShrinkVirtReg(Register VirtReg) {</td>
    <td class="lineNumber">246</td>
    <td class="codeline">void RAGreedy::LRE_WillShrinkVirtReg(Register VirtReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  if (!VRM->hasPhys(VirtReg))</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  if (!VRM->hasPhys(VirtReg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  // Register is assigned, put it back on the queue for reassignment.</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  // Register is assigned, put it back on the queue for reassignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  Matrix->unassign(LI);</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  Matrix->unassign(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  RegAllocBase::enqueue(&LI);</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  RegAllocBase::enqueue(&LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">}</td>
    <td class="lineNumber">254</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline"></td>
    <td class="lineNumber">255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">void RAGreedy::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
    <td class="lineNumber">256</td>
    <td class="codeline">void RAGreedy::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  ExtraInfo->LRE_DidCloneVirtReg(New, Old);</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  ExtraInfo->LRE_DidCloneVirtReg(New, Old);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">}</td>
    <td class="lineNumber">258</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">void RAGreedy::ExtraRegInfo::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
    <td class="lineNumber">260</td>
    <td class="codeline">void RAGreedy::ExtraRegInfo::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">  // Cloning a register we haven't even heard about yet?  Just ignore it.</td>
    <td class="lineNumber">261</td>
    <td class="codeline">  // Cloning a register we haven't even heard about yet?  Just ignore it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  if (!Info.inBounds(Old))</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  if (!Info.inBounds(Old))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">263</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  // LRE may clone a virtual register because dead code elimination causes it to</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  // LRE may clone a virtual register because dead code elimination causes it to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  // be split into connected components. The new components are much smaller</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  // be split into connected components. The new components are much smaller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  // than the original, so they should get a new chance at being assigned.</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  // than the original, so they should get a new chance at being assigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  // same stage as the parent.</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  // same stage as the parent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  Info[Old].Stage = RS_Assign;</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  Info[Old].Stage = RS_Assign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  Info.grow(New.id());</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  Info.grow(New.id());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  Info[New] = Info[Old];</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  Info[New] = Info[Old];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">}</td>
    <td class="lineNumber">272</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">void RAGreedy::releaseMemory() {</td>
    <td class="lineNumber">274</td>
    <td class="codeline">void RAGreedy::releaseMemory() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  SpillerInstance.reset();</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  SpillerInstance.reset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  GlobalCand.clear();</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  GlobalCand.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">}</td>
    <td class="lineNumber">277</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">void RAGreedy::enqueueImpl(const LiveInterval *LI) { enqueue(Queue, LI); }</td>
    <td class="lineNumber">279</td>
    <td class="codeline">void RAGreedy::enqueueImpl(const LiveInterval *LI) { enqueue(Queue, LI); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline"></td>
    <td class="lineNumber">280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">void RAGreedy::enqueue(PQueue &CurQueue, const LiveInterval *LI) {</td>
    <td class="lineNumber">281</td>
    <td class="codeline">void RAGreedy::enqueue(PQueue &CurQueue, const LiveInterval *LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  // Prioritize live ranges by size, assigning larger ranges first.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  // Prioritize live ranges by size, assigning larger ranges first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  // The queue holds (size, reg) pairs.</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  // The queue holds (size, reg) pairs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  const Register Reg = LI->reg();</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  const Register Reg = LI->reg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  assert(Reg.isVirtual() && "Can only enqueue virtual registers");</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  assert(Reg.isVirtual() && "Can only enqueue virtual registers");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  auto Stage = ExtraInfo->getOrInitStage(Reg);</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  auto Stage = ExtraInfo->getOrInitStage(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  if (Stage == RS_New) {</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  if (Stage == RS_New) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    Stage = RS_Assign;</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    Stage = RS_Assign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    ExtraInfo->setStage(Reg, Stage);</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    ExtraInfo->setStage(Reg, Stage);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  unsigned Ret = PriorityAdvisor->getPriority(*LI);</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  unsigned Ret = PriorityAdvisor->getPriority(*LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline"></td>
    <td class="lineNumber">294</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  // The virtual register number is a tie breaker for same-sized ranges.</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  // The virtual register number is a tie breaker for same-sized ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  // Give lower vreg numbers higher priority to assign them first.</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  // Give lower vreg numbers higher priority to assign them first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  CurQueue.push(std::make_pair(Ret, ~Reg));</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  CurQueue.push(std::make_pair(Ret, ~Reg));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">}</td>
    <td class="lineNumber">298</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">unsigned DefaultPriorityAdvisor::getPriority(const LiveInterval &LI) const {</td>
    <td class="lineNumber">300</td>
    <td class="codeline">unsigned DefaultPriorityAdvisor::getPriority(const LiveInterval &LI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  const unsigned Size = LI.getSize();</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  const unsigned Size = LI.getSize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  const Register Reg = LI.reg();</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  const Register Reg = LI.reg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  unsigned Prio;</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  unsigned Prio;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  LiveRangeStage Stage = RA.getExtraInfo().getStage(LI);</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  LiveRangeStage Stage = RA.getExtraInfo().getStage(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  if (Stage == RS_Split) {</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  if (Stage == RS_Split) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    // Unsplit ranges that couldn't be allocated immediately are deferred until</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    // Unsplit ranges that couldn't be allocated immediately are deferred until</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    // everything else has been allocated.</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    // everything else has been allocated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">    Prio = Size;</td>
    <td class="lineNumber">309</td>
    <td class="codeline">    Prio = Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  } else if (Stage == RS_Memory) {</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  } else if (Stage == RS_Memory) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    // Memory operand should be considered last.</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    // Memory operand should be considered last.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    // Change the priority such that Memory operand are assigned in</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    // Change the priority such that Memory operand are assigned in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    // the reverse order that they came in.</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    // the reverse order that they came in.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">    // TODO: Make this a member variable and probably do something about hints.</td>
    <td class="lineNumber">314</td>
    <td class="codeline">    // TODO: Make this a member variable and probably do something about hints.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">    static unsigned MemOp = 0;</td>
    <td class="lineNumber">315</td>
    <td class="codeline">    static unsigned MemOp = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">    Prio = MemOp++;</td>
    <td class="lineNumber">316</td>
    <td class="codeline">    Prio = MemOp++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">    // Giant live ranges fall back to the global assignment heuristic, which</td>
    <td class="lineNumber">318</td>
    <td class="codeline">    // Giant live ranges fall back to the global assignment heuristic, which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">    // prevents excessive spilling in pathological cases.</td>
    <td class="lineNumber">319</td>
    <td class="codeline">    // prevents excessive spilling in pathological cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    const TargetRegisterClass &RC = *MRI->getRegClass(Reg);</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    const TargetRegisterClass &RC = *MRI->getRegClass(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    bool ForceGlobal = RC.GlobalPriority ||</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    bool ForceGlobal = RC.GlobalPriority ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">                       (!ReverseLocalAssignment &&</td>
    <td class="lineNumber">322</td>
    <td class="codeline">                       (!ReverseLocalAssignment &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">                        (Size / SlotIndex::InstrDist) ></td>
    <td class="lineNumber">323</td>
    <td class="codeline">                        (Size / SlotIndex::InstrDist) ></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">                            (2 * RegClassInfo.getNumAllocatableRegs(&RC)));</td>
    <td class="lineNumber">324</td>
    <td class="codeline">                            (2 * RegClassInfo.getNumAllocatableRegs(&RC)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">    unsigned GlobalBit = 0;</td>
    <td class="lineNumber">325</td>
    <td class="codeline">    unsigned GlobalBit = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">    if (Stage == RS_Assign && !ForceGlobal && !LI.empty() &&</td>
    <td class="lineNumber">327</td>
    <td class="codeline">    if (Stage == RS_Assign && !ForceGlobal && !LI.empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">        LIS->intervalIsInOneMBB(LI)) {</td>
    <td class="lineNumber">328</td>
    <td class="codeline">        LIS->intervalIsInOneMBB(LI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">      // Allocate original local ranges in linear instruction order. Since they</td>
    <td class="lineNumber">329</td>
    <td class="codeline">      // Allocate original local ranges in linear instruction order. Since they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">      // are singly defined, this produces optimal coloring in the absence of</td>
    <td class="lineNumber">330</td>
    <td class="codeline">      // are singly defined, this produces optimal coloring in the absence of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">      // global interference and other constraints.</td>
    <td class="lineNumber">331</td>
    <td class="codeline">      // global interference and other constraints.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">      if (!ReverseLocalAssignment)</td>
    <td class="lineNumber">332</td>
    <td class="codeline">      if (!ReverseLocalAssignment)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">        Prio = LI.beginIndex().getApproxInstrDistance(Indexes->getLastIndex());</td>
    <td class="lineNumber">333</td>
    <td class="codeline">        Prio = LI.beginIndex().getApproxInstrDistance(Indexes->getLastIndex());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">      else {</td>
    <td class="lineNumber">334</td>
    <td class="codeline">      else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">        // Allocating bottom up may allow many short LRGs to be assigned first</td>
    <td class="lineNumber">335</td>
    <td class="codeline">        // Allocating bottom up may allow many short LRGs to be assigned first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">        // to one of the cheap registers. This could be much faster for very</td>
    <td class="lineNumber">336</td>
    <td class="codeline">        // to one of the cheap registers. This could be much faster for very</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">        // large blocks on targets with many physical registers.</td>
    <td class="lineNumber">337</td>
    <td class="codeline">        // large blocks on targets with many physical registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">        Prio = Indexes->getZeroIndex().getApproxInstrDistance(LI.endIndex());</td>
    <td class="lineNumber">338</td>
    <td class="codeline">        Prio = Indexes->getZeroIndex().getApproxInstrDistance(LI.endIndex());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">339</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">      // Allocate global and split ranges in long->short order. Long ranges that</td>
    <td class="lineNumber">341</td>
    <td class="codeline">      // Allocate global and split ranges in long->short order. Long ranges that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">      // don't fit should be spilled (or split) ASAP so they don't create</td>
    <td class="lineNumber">342</td>
    <td class="codeline">      // don't fit should be spilled (or split) ASAP so they don't create</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">      // interference.  Mark a bit to prioritize global above local ranges.</td>
    <td class="lineNumber">343</td>
    <td class="codeline">      // interference.  Mark a bit to prioritize global above local ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">      Prio = Size;</td>
    <td class="lineNumber">344</td>
    <td class="codeline">      Prio = Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">      GlobalBit = 1;</td>
    <td class="lineNumber">345</td>
    <td class="codeline">      GlobalBit = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline"></td>
    <td class="lineNumber">347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    // Priority bit layout:</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    // Priority bit layout:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">    // 31 RS_Assign priority</td>
    <td class="lineNumber">349</td>
    <td class="codeline">    // 31 RS_Assign priority</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">    // 30 Preference priority</td>
    <td class="lineNumber">350</td>
    <td class="codeline">    // 30 Preference priority</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    // if (RegClassPriorityTrumpsGlobalness)</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    // if (RegClassPriorityTrumpsGlobalness)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">    //   29-25 AllocPriority</td>
    <td class="lineNumber">352</td>
    <td class="codeline">    //   29-25 AllocPriority</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">    //   24 GlobalBit</td>
    <td class="lineNumber">353</td>
    <td class="codeline">    //   24 GlobalBit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">    // else</td>
    <td class="lineNumber">354</td>
    <td class="codeline">    // else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">    //   29 Global bit</td>
    <td class="lineNumber">355</td>
    <td class="codeline">    //   29 Global bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">    //   28-24 AllocPriority</td>
    <td class="lineNumber">356</td>
    <td class="codeline">    //   28-24 AllocPriority</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">    // 0-23 Size/Instr distance</td>
    <td class="lineNumber">357</td>
    <td class="codeline">    // 0-23 Size/Instr distance</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline"></td>
    <td class="lineNumber">358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">    // Clamp the size to fit with the priority masking scheme</td>
    <td class="lineNumber">359</td>
    <td class="codeline">    // Clamp the size to fit with the priority masking scheme</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    Prio = std::min(Prio, (unsigned)maxUIntN(24));</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    Prio = std::min(Prio, (unsigned)maxUIntN(24));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    assert(isUInt<5>(RC.AllocationPriority) && "allocation priority overflow");</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    assert(isUInt<5>(RC.AllocationPriority) && "allocation priority overflow");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">    if (RegClassPriorityTrumpsGlobalness)</td>
    <td class="lineNumber">363</td>
    <td class="codeline">    if (RegClassPriorityTrumpsGlobalness)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">      Prio |= RC.AllocationPriority << 25 | GlobalBit << 24;</td>
    <td class="lineNumber">364</td>
    <td class="codeline">      Prio |= RC.AllocationPriority << 25 | GlobalBit << 24;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">      Prio |= GlobalBit << 29 | RC.AllocationPriority << 24;</td>
    <td class="lineNumber">366</td>
    <td class="codeline">      Prio |= GlobalBit << 29 | RC.AllocationPriority << 24;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">    // Mark a higher bit to prioritize global and local above RS_Split.</td>
    <td class="lineNumber">368</td>
    <td class="codeline">    // Mark a higher bit to prioritize global and local above RS_Split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">    Prio |= (1u << 31);</td>
    <td class="lineNumber">369</td>
    <td class="codeline">    Prio |= (1u << 31);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">    // Boost ranges that have a physical register hint.</td>
    <td class="lineNumber">371</td>
    <td class="codeline">    // Boost ranges that have a physical register hint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">    if (VRM->hasKnownPreference(Reg))</td>
    <td class="lineNumber">372</td>
    <td class="codeline">    if (VRM->hasKnownPreference(Reg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">      Prio |= (1u << 30);</td>
    <td class="lineNumber">373</td>
    <td class="codeline">      Prio |= (1u << 30);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline"></td>
    <td class="lineNumber">375</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  return Prio;</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  return Prio;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">}</td>
    <td class="lineNumber">377</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">const LiveInterval *RAGreedy::dequeue() { return dequeue(Queue); }</td>
    <td class="lineNumber">379</td>
    <td class="codeline">const LiveInterval *RAGreedy::dequeue() { return dequeue(Queue); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">const LiveInterval *RAGreedy::dequeue(PQueue &CurQueue) {</td>
    <td class="lineNumber">381</td>
    <td class="codeline">const LiveInterval *RAGreedy::dequeue(PQueue &CurQueue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  if (CurQueue.empty())</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  if (CurQueue.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">383</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  LiveInterval *LI = &LIS->getInterval(~CurQueue.top().second);</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  LiveInterval *LI = &LIS->getInterval(~CurQueue.top().second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  CurQueue.pop();</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  CurQueue.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  return LI;</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  return LI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">}</td>
    <td class="lineNumber">387</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">389</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">//                            Direct Assignment</td>
    <td class="lineNumber">390</td>
    <td class="codeline">//                            Direct Assignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">391</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline"></td>
    <td class="lineNumber">392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">/// tryAssign - Try to assign VirtReg to an available register.</td>
    <td class="lineNumber">393</td>
    <td class="codeline">/// tryAssign - Try to assign VirtReg to an available register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">MCRegister RAGreedy::tryAssign(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">394</td>
    <td class="codeline">MCRegister RAGreedy::tryAssign(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">                               AllocationOrder &Order,</td>
    <td class="lineNumber">395</td>
    <td class="codeline">                               AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">                               SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">396</td>
    <td class="codeline">                               SmallVectorImpl<Register> &NewVRegs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">                               const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">397</td>
    <td class="codeline">                               const SmallVirtRegSet &FixedRegisters) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  MCRegister PhysReg;</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  MCRegister PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  for (auto I = Order.begin(), E = Order.end(); I != E && !PhysReg; ++I) {</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  for (auto I = Order.begin(), E = Order.end(); I != E && !PhysReg; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">    assert(*I);</td>
    <td class="lineNumber">400</td>
    <td class="codeline">    assert(*I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">    if (!Matrix->checkInterference(VirtReg, *I)) {</td>
    <td class="lineNumber">401</td>
    <td class="codeline">    if (!Matrix->checkInterference(VirtReg, *I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">      if (I.isHint())</td>
    <td class="lineNumber">402</td>
    <td class="codeline">      if (I.isHint())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">        return *I;</td>
    <td class="lineNumber">403</td>
    <td class="codeline">        return *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">404</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">        PhysReg = *I;</td>
    <td class="lineNumber">405</td>
    <td class="codeline">        PhysReg = *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  if (!PhysReg.isValid())</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  if (!PhysReg.isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">    return PhysReg;</td>
    <td class="lineNumber">409</td>
    <td class="codeline">    return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
    <td class="lineNumber">410</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  // PhysReg is available, but there may be a better choice.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  // PhysReg is available, but there may be a better choice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline"></td>
    <td class="lineNumber">412</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  // If we missed a simple hint, try to cheaply evict interference from the</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  // If we missed a simple hint, try to cheaply evict interference from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  // preferred register.</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  // preferred register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  if (Register Hint = MRI->getSimpleHint(VirtReg.reg()))</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  if (Register Hint = MRI->getSimpleHint(VirtReg.reg()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">    if (Order.isHint(Hint)) {</td>
    <td class="lineNumber">416</td>
    <td class="codeline">    if (Order.isHint(Hint)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">      MCRegister PhysHint = Hint.asMCReg();</td>
    <td class="lineNumber">417</td>
    <td class="codeline">      MCRegister PhysHint = Hint.asMCReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "missed hint " << printReg(PhysHint, TRI) << '\n');</td>
    <td class="lineNumber">418</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "missed hint " << printReg(PhysHint, TRI) << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
    <td class="lineNumber">419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">      if (EvictAdvisor->canEvictHintInterference(VirtReg, PhysHint,</td>
    <td class="lineNumber">420</td>
    <td class="codeline">      if (EvictAdvisor->canEvictHintInterference(VirtReg, PhysHint,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">                                                 FixedRegisters)) {</td>
    <td class="lineNumber">421</td>
    <td class="codeline">                                                 FixedRegisters)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">        evictInterference(VirtReg, PhysHint, NewVRegs);</td>
    <td class="lineNumber">422</td>
    <td class="codeline">        evictInterference(VirtReg, PhysHint, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">        return PhysHint;</td>
    <td class="lineNumber">423</td>
    <td class="codeline">        return PhysHint;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">424</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">      // Record the missed hint, we may be able to recover</td>
    <td class="lineNumber">425</td>
    <td class="codeline">      // Record the missed hint, we may be able to recover</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">      // at the end if the surrounding allocation changed.</td>
    <td class="lineNumber">426</td>
    <td class="codeline">      // at the end if the surrounding allocation changed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">      SetOfBrokenHints.insert(&VirtReg);</td>
    <td class="lineNumber">427</td>
    <td class="codeline">      SetOfBrokenHints.insert(&VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">428</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  // Try to evict interference from a cheaper alternative.</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  // Try to evict interference from a cheaper alternative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  uint8_t Cost = RegCosts[PhysReg];</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  uint8_t Cost = RegCosts[PhysReg];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  // Most registers have 0 additional cost.</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  // Most registers have 0 additional cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  if (!Cost)</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  if (!Cost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">    return PhysReg;</td>
    <td class="lineNumber">435</td>
    <td class="codeline">    return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << " is available at cost "</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << " is available at cost "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">                    << (unsigned)Cost << '\n');</td>
    <td class="lineNumber">438</td>
    <td class="codeline">                    << (unsigned)Cost << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  MCRegister CheapReg = tryEvict(VirtReg, Order, NewVRegs, Cost, FixedRegisters);</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  MCRegister CheapReg = tryEvict(VirtReg, Order, NewVRegs, Cost, FixedRegisters);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  return CheapReg ? CheapReg : PhysReg;</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  return CheapReg ? CheapReg : PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">}</td>
    <td class="lineNumber">441</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline"></td>
    <td class="lineNumber">442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">443</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">//                         Interference eviction</td>
    <td class="lineNumber">444</td>
    <td class="codeline">//                         Interference eviction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">445</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">bool RegAllocEvictionAdvisor::canReassign(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">447</td>
    <td class="codeline">bool RegAllocEvictionAdvisor::canReassign(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">                                          MCRegister FromReg) const {</td>
    <td class="lineNumber">448</td>
    <td class="codeline">                                          MCRegister FromReg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  auto HasRegUnitInterference = [&](MCRegUnit Unit) {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  auto HasRegUnitInterference = [&](MCRegUnit Unit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">    // Instantiate a "subquery", not to be confused with the Queries array.</td>
    <td class="lineNumber">450</td>
    <td class="codeline">    // Instantiate a "subquery", not to be confused with the Queries array.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">    LiveIntervalUnion::Query SubQ(VirtReg, Matrix->getLiveUnions()[Unit]);</td>
    <td class="lineNumber">451</td>
    <td class="codeline">    LiveIntervalUnion::Query SubQ(VirtReg, Matrix->getLiveUnions()[Unit]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">    return SubQ.checkInterference();</td>
    <td class="lineNumber">452</td>
    <td class="codeline">    return SubQ.checkInterference();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  for (MCRegister Reg :</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  for (MCRegister Reg :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">       AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix)) {</td>
    <td class="lineNumber">456</td>
    <td class="codeline">       AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    if (Reg == FromReg)</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    if (Reg == FromReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">458</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">    // If no units have interference, reassignment is possible.</td>
    <td class="lineNumber">459</td>
    <td class="codeline">    // If no units have interference, reassignment is possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">    if (none_of(TRI->regunits(Reg), HasRegUnitInterference)) {</td>
    <td class="lineNumber">460</td>
    <td class="codeline">    if (none_of(TRI->regunits(Reg), HasRegUnitInterference)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "can reassign: " << VirtReg << " from "</td>
    <td class="lineNumber">461</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "can reassign: " << VirtReg << " from "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">                        << printReg(FromReg, TRI) << " to "</td>
    <td class="lineNumber">462</td>
    <td class="codeline">                        << printReg(FromReg, TRI) << " to "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">                        << printReg(Reg, TRI) << '\n');</td>
    <td class="lineNumber">463</td>
    <td class="codeline">                        << printReg(Reg, TRI) << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">464</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">465</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">}</td>
    <td class="lineNumber">468</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">/// evictInterference - Evict any interferring registers that prevent VirtReg</td>
    <td class="lineNumber">470</td>
    <td class="codeline">/// evictInterference - Evict any interferring registers that prevent VirtReg</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">/// from being assigned to Physreg. This assumes that canEvictInterference</td>
    <td class="lineNumber">471</td>
    <td class="codeline">/// from being assigned to Physreg. This assumes that canEvictInterference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">/// returned true.</td>
    <td class="lineNumber">472</td>
    <td class="codeline">/// returned true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">void RAGreedy::evictInterference(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">473</td>
    <td class="codeline">void RAGreedy::evictInterference(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">                                 MCRegister PhysReg,</td>
    <td class="lineNumber">474</td>
    <td class="codeline">                                 MCRegister PhysReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">475</td>
    <td class="codeline">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  // Make sure that VirtReg has a cascade number, and assign that cascade</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  // Make sure that VirtReg has a cascade number, and assign that cascade</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  // number to every evicted register. These live ranges than then only be</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  // number to every evicted register. These live ranges than then only be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  // evicted by a newer cascade, preventing infinite loops.</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  // evicted by a newer cascade, preventing infinite loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  unsigned Cascade = ExtraInfo->getOrAssignNewCascade(VirtReg.reg());</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  unsigned Cascade = ExtraInfo->getOrAssignNewCascade(VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "evicting " << printReg(PhysReg, TRI)</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "evicting " << printReg(PhysReg, TRI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">                    << " interference: Cascade " << Cascade << '\n');</td>
    <td class="lineNumber">482</td>
    <td class="codeline">                    << " interference: Cascade " << Cascade << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  // Collect all interfering virtregs first.</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  // Collect all interfering virtregs first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  SmallVector<const LiveInterval *, 8> Intfs;</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  SmallVector<const LiveInterval *, 8> Intfs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
    <td class="lineNumber">487</td>
    <td class="codeline">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">    // We usually have the interfering VRegs cached so collectInterferingVRegs()</td>
    <td class="lineNumber">488</td>
    <td class="codeline">    // We usually have the interfering VRegs cached so collectInterferingVRegs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">    // should be fast, we may need to recalculate if when different physregs</td>
    <td class="lineNumber">489</td>
    <td class="codeline">    // should be fast, we may need to recalculate if when different physregs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">    // overlap the same register unit so we had different SubRanges queried</td>
    <td class="lineNumber">490</td>
    <td class="codeline">    // overlap the same register unit so we had different SubRanges queried</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">    // against it.</td>
    <td class="lineNumber">491</td>
    <td class="codeline">    // against it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">    ArrayRef<const LiveInterval *> IVR = Q.interferingVRegs();</td>
    <td class="lineNumber">492</td>
    <td class="codeline">    ArrayRef<const LiveInterval *> IVR = Q.interferingVRegs();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">    Intfs.append(IVR.begin(), IVR.end());</td>
    <td class="lineNumber">493</td>
    <td class="codeline">    Intfs.append(IVR.begin(), IVR.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  // Evict them second. This will invalidate the queries.</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  // Evict them second. This will invalidate the queries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  for (const LiveInterval *Intf : Intfs) {</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  for (const LiveInterval *Intf : Intfs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">    // The same VirtReg may be present in multiple RegUnits. Skip duplicates.</td>
    <td class="lineNumber">498</td>
    <td class="codeline">    // The same VirtReg may be present in multiple RegUnits. Skip duplicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    if (!VRM->hasPhys(Intf->reg()))</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    if (!VRM->hasPhys(Intf->reg()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">500</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">    Matrix->unassign(*Intf);</td>
    <td class="lineNumber">502</td>
    <td class="codeline">    Matrix->unassign(*Intf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">    assert((ExtraInfo->getCascade(Intf->reg()) < Cascade ||</td>
    <td class="lineNumber">503</td>
    <td class="codeline">    assert((ExtraInfo->getCascade(Intf->reg()) < Cascade ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">            VirtReg.isSpillable() < Intf->isSpillable()) &&</td>
    <td class="lineNumber">504</td>
    <td class="codeline">            VirtReg.isSpillable() < Intf->isSpillable()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">           "Cannot decrease cascade number, illegal eviction");</td>
    <td class="lineNumber">505</td>
    <td class="codeline">           "Cannot decrease cascade number, illegal eviction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">    ExtraInfo->setCascade(Intf->reg(), Cascade);</td>
    <td class="lineNumber">506</td>
    <td class="codeline">    ExtraInfo->setCascade(Intf->reg(), Cascade);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    ++NumEvicted;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    ++NumEvicted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">    NewVRegs.push_back(Intf->reg());</td>
    <td class="lineNumber">508</td>
    <td class="codeline">    NewVRegs.push_back(Intf->reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">}</td>
    <td class="lineNumber">510</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">/// Returns true if the given \p PhysReg is a callee saved register and has not</td>
    <td class="lineNumber">512</td>
    <td class="codeline">/// Returns true if the given \p PhysReg is a callee saved register and has not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">/// been used for allocation yet.</td>
    <td class="lineNumber">513</td>
    <td class="codeline">/// been used for allocation yet.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">bool RegAllocEvictionAdvisor::isUnusedCalleeSavedReg(MCRegister PhysReg) const {</td>
    <td class="lineNumber">514</td>
    <td class="codeline">bool RegAllocEvictionAdvisor::isUnusedCalleeSavedReg(MCRegister PhysReg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  MCRegister CSR = RegClassInfo.getLastCalleeSavedAlias(PhysReg);</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  MCRegister CSR = RegClassInfo.getLastCalleeSavedAlias(PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  if (!CSR)</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  if (!CSR)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">517</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline"></td>
    <td class="lineNumber">518</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  return !Matrix->isPhysRegUsed(PhysReg);</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  return !Matrix->isPhysRegUsed(PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">}</td>
    <td class="lineNumber">520</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline"></td>
    <td class="lineNumber">521</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">std::optional<unsigned></td>
    <td class="lineNumber">522</td>
    <td class="codeline">std::optional<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">RegAllocEvictionAdvisor::getOrderLimit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">523</td>
    <td class="codeline">RegAllocEvictionAdvisor::getOrderLimit(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">                                       const AllocationOrder &Order,</td>
    <td class="lineNumber">524</td>
    <td class="codeline">                                       const AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">                                       unsigned CostPerUseLimit) const {</td>
    <td class="lineNumber">525</td>
    <td class="codeline">                                       unsigned CostPerUseLimit) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  unsigned OrderLimit = Order.getOrder().size();</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  unsigned OrderLimit = Order.getOrder().size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline"></td>
    <td class="lineNumber">527</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  if (CostPerUseLimit < uint8_t(~0u)) {</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  if (CostPerUseLimit < uint8_t(~0u)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">    // Check of any registers in RC are below CostPerUseLimit.</td>
    <td class="lineNumber">529</td>
    <td class="codeline">    // Check of any registers in RC are below CostPerUseLimit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    const TargetRegisterClass *RC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    const TargetRegisterClass *RC = MRI->getRegClass(VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">    uint8_t MinCost = RegClassInfo.getMinCost(RC);</td>
    <td class="lineNumber">531</td>
    <td class="codeline">    uint8_t MinCost = RegClassInfo.getMinCost(RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    if (MinCost >= CostPerUseLimit) {</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    if (MinCost >= CostPerUseLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << TRI->getRegClassName(RC) << " minimum cost = "</td>
    <td class="lineNumber">533</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << TRI->getRegClassName(RC) << " minimum cost = "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">                        << MinCost << ", no cheaper registers to be found.\n");</td>
    <td class="lineNumber">534</td>
    <td class="codeline">                        << MinCost << ", no cheaper registers to be found.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">      return std::nullopt;</td>
    <td class="lineNumber">535</td>
    <td class="codeline">      return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">536</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
    <td class="lineNumber">537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">    // It is normal for register classes to have a long tail of registers with</td>
    <td class="lineNumber">538</td>
    <td class="codeline">    // It is normal for register classes to have a long tail of registers with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    // the same cost. We don't need to look at them if they're too expensive.</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    // the same cost. We don't need to look at them if they're too expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">    if (RegCosts[Order.getOrder().back()] >= CostPerUseLimit) {</td>
    <td class="lineNumber">540</td>
    <td class="codeline">    if (RegCosts[Order.getOrder().back()] >= CostPerUseLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">      OrderLimit = RegClassInfo.getLastCostChange(RC);</td>
    <td class="lineNumber">541</td>
    <td class="codeline">      OrderLimit = RegClassInfo.getLastCostChange(RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Only trying the first " << OrderLimit</td>
    <td class="lineNumber">542</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Only trying the first " << OrderLimit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">                        << " regs.\n");</td>
    <td class="lineNumber">543</td>
    <td class="codeline">                        << " regs.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">544</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  return OrderLimit;</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  return OrderLimit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">}</td>
    <td class="lineNumber">547</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline"></td>
    <td class="lineNumber">548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">bool RegAllocEvictionAdvisor::canAllocatePhysReg(unsigned CostPerUseLimit,</td>
    <td class="lineNumber">549</td>
    <td class="codeline">bool RegAllocEvictionAdvisor::canAllocatePhysReg(unsigned CostPerUseLimit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">                                                 MCRegister PhysReg) const {</td>
    <td class="lineNumber">550</td>
    <td class="codeline">                                                 MCRegister PhysReg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  if (RegCosts[PhysReg] >= CostPerUseLimit)</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  if (RegCosts[PhysReg] >= CostPerUseLimit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">552</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">  // The first use of a callee-saved register in a function has cost 1.</td>
    <td class="lineNumber">553</td>
    <td class="codeline">  // The first use of a callee-saved register in a function has cost 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  // Don't start using a CSR when the CostPerUseLimit is low.</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  // Don't start using a CSR when the CostPerUseLimit is low.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  if (CostPerUseLimit == 1 && isUnusedCalleeSavedReg(PhysReg)) {</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  if (CostPerUseLimit == 1 && isUnusedCalleeSavedReg(PhysReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">    LLVM_DEBUG(</td>
    <td class="lineNumber">556</td>
    <td class="codeline">    LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">        dbgs() << printReg(PhysReg, TRI) << " would clobber CSR "</td>
    <td class="lineNumber">557</td>
    <td class="codeline">        dbgs() << printReg(PhysReg, TRI) << " would clobber CSR "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">               << printReg(RegClassInfo.getLastCalleeSavedAlias(PhysReg), TRI)</td>
    <td class="lineNumber">558</td>
    <td class="codeline">               << printReg(RegClassInfo.getLastCalleeSavedAlias(PhysReg), TRI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">               << '\n');</td>
    <td class="lineNumber">559</td>
    <td class="codeline">               << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">562</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">}</td>
    <td class="lineNumber">563</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline"></td>
    <td class="lineNumber">564</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">/// tryEvict - Try to evict all interferences for a physreg.</td>
    <td class="lineNumber">565</td>
    <td class="codeline">/// tryEvict - Try to evict all interferences for a physreg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">/// @param  VirtReg Currently unassigned virtual register.</td>
    <td class="lineNumber">566</td>
    <td class="codeline">/// @param  VirtReg Currently unassigned virtual register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">/// @param  Order   Physregs to try.</td>
    <td class="lineNumber">567</td>
    <td class="codeline">/// @param  Order   Physregs to try.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">/// @return         Physreg to assign VirtReg, or 0.</td>
    <td class="lineNumber">568</td>
    <td class="codeline">/// @return         Physreg to assign VirtReg, or 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">MCRegister RAGreedy::tryEvict(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">569</td>
    <td class="codeline">MCRegister RAGreedy::tryEvict(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">                              AllocationOrder &Order,</td>
    <td class="lineNumber">570</td>
    <td class="codeline">                              AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">                              SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">571</td>
    <td class="codeline">                              SmallVectorImpl<Register> &NewVRegs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">                              uint8_t CostPerUseLimit,</td>
    <td class="lineNumber">572</td>
    <td class="codeline">                              uint8_t CostPerUseLimit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">                              const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">573</td>
    <td class="codeline">                              const SmallVirtRegSet &FixedRegisters) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  NamedRegionTimer T("evict", "Evict", TimerGroupName, TimerGroupDescription,</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  NamedRegionTimer T("evict", "Evict", TimerGroupName, TimerGroupDescription,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">                     TimePassesIsEnabled);</td>
    <td class="lineNumber">575</td>
    <td class="codeline">                     TimePassesIsEnabled);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  MCRegister BestPhys = EvictAdvisor->tryFindEvictionCandidate(</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  MCRegister BestPhys = EvictAdvisor->tryFindEvictionCandidate(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">      VirtReg, Order, CostPerUseLimit, FixedRegisters);</td>
    <td class="lineNumber">578</td>
    <td class="codeline">      VirtReg, Order, CostPerUseLimit, FixedRegisters);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  if (BestPhys.isValid())</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  if (BestPhys.isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">    evictInterference(VirtReg, BestPhys, NewVRegs);</td>
    <td class="lineNumber">580</td>
    <td class="codeline">    evictInterference(VirtReg, BestPhys, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  return BestPhys;</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  return BestPhys;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">}</td>
    <td class="lineNumber">582</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline"></td>
    <td class="lineNumber">583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">584</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">//                              Region Splitting</td>
    <td class="lineNumber">585</td>
    <td class="codeline">//                              Region Splitting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">586</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">/// addSplitConstraints - Fill out the SplitConstraints vector based on the</td>
    <td class="lineNumber">588</td>
    <td class="codeline">/// addSplitConstraints - Fill out the SplitConstraints vector based on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">/// interference pattern in Physreg and its aliases. Add the constraints to</td>
    <td class="lineNumber">589</td>
    <td class="codeline">/// interference pattern in Physreg and its aliases. Add the constraints to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">/// SpillPlacement and return the static cost of this split in Cost, assuming</td>
    <td class="lineNumber">590</td>
    <td class="codeline">/// SpillPlacement and return the static cost of this split in Cost, assuming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">/// that all preferences in SplitConstraints are met.</td>
    <td class="lineNumber">591</td>
    <td class="codeline">/// that all preferences in SplitConstraints are met.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">/// Return false if there are no bundles with positive bias.</td>
    <td class="lineNumber">592</td>
    <td class="codeline">/// Return false if there are no bundles with positive bias.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">bool RAGreedy::addSplitConstraints(InterferenceCache::Cursor Intf,</td>
    <td class="lineNumber">593</td>
    <td class="codeline">bool RAGreedy::addSplitConstraints(InterferenceCache::Cursor Intf,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">                                   BlockFrequency &Cost) {</td>
    <td class="lineNumber">594</td>
    <td class="codeline">                                   BlockFrequency &Cost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline"></td>
    <td class="lineNumber">596</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">  // Reset interference dependent info.</td>
    <td class="lineNumber">597</td>
    <td class="codeline">  // Reset interference dependent info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  SplitConstraints.resize(UseBlocks.size());</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  SplitConstraints.resize(UseBlocks.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  BlockFrequency StaticCost = 0;</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  BlockFrequency StaticCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
    <td class="lineNumber">601</td>
    <td class="codeline">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
    <td class="lineNumber">602</td>
    <td class="codeline">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline"></td>
    <td class="lineNumber">603</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">    BC.Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">604</td>
    <td class="codeline">    BC.Number = BI.MBB->getNumber();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    Intf.moveToBlock(BC.Number);</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    Intf.moveToBlock(BC.Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    BC.Entry = BI.LiveIn ? SpillPlacement::PrefReg : SpillPlacement::DontCare;</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    BC.Entry = BI.LiveIn ? SpillPlacement::PrefReg : SpillPlacement::DontCare;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    BC.Exit = (BI.LiveOut &&</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    BC.Exit = (BI.LiveOut &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">               !LIS->getInstructionFromIndex(BI.LastInstr)->isImplicitDef())</td>
    <td class="lineNumber">608</td>
    <td class="codeline">               !LIS->getInstructionFromIndex(BI.LastInstr)->isImplicitDef())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">                  ? SpillPlacement::PrefReg</td>
    <td class="lineNumber">609</td>
    <td class="codeline">                  ? SpillPlacement::PrefReg</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">                  : SpillPlacement::DontCare;</td>
    <td class="lineNumber">610</td>
    <td class="codeline">                  : SpillPlacement::DontCare;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    BC.ChangesValue = BI.FirstDef.isValid();</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    BC.ChangesValue = BI.FirstDef.isValid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline"></td>
    <td class="lineNumber">612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">    if (!Intf.hasInterference())</td>
    <td class="lineNumber">613</td>
    <td class="codeline">    if (!Intf.hasInterference())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">614</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline"></td>
    <td class="lineNumber">615</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">    // Number of spill code instructions to insert.</td>
    <td class="lineNumber">616</td>
    <td class="codeline">    // Number of spill code instructions to insert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">    unsigned Ins = 0;</td>
    <td class="lineNumber">617</td>
    <td class="codeline">    unsigned Ins = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">    // Interference for the live-in value.</td>
    <td class="lineNumber">619</td>
    <td class="codeline">    // Interference for the live-in value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">    if (BI.LiveIn) {</td>
    <td class="lineNumber">620</td>
    <td class="codeline">    if (BI.LiveIn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">      if (Intf.first() <= Indexes->getMBBStartIdx(BC.Number)) {</td>
    <td class="lineNumber">621</td>
    <td class="codeline">      if (Intf.first() <= Indexes->getMBBStartIdx(BC.Number)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">        BC.Entry = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">622</td>
    <td class="codeline">        BC.Entry = SpillPlacement::MustSpill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">        ++Ins;</td>
    <td class="lineNumber">623</td>
    <td class="codeline">        ++Ins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">      } else if (Intf.first() < BI.FirstInstr) {</td>
    <td class="lineNumber">624</td>
    <td class="codeline">      } else if (Intf.first() < BI.FirstInstr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">        BC.Entry = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">625</td>
    <td class="codeline">        BC.Entry = SpillPlacement::PrefSpill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">        ++Ins;</td>
    <td class="lineNumber">626</td>
    <td class="codeline">        ++Ins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">      } else if (Intf.first() < BI.LastInstr) {</td>
    <td class="lineNumber">627</td>
    <td class="codeline">      } else if (Intf.first() < BI.LastInstr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">        ++Ins;</td>
    <td class="lineNumber">628</td>
    <td class="codeline">        ++Ins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">629</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">      // Abort if the spill cannot be inserted at the MBB' start</td>
    <td class="lineNumber">631</td>
    <td class="codeline">      // Abort if the spill cannot be inserted at the MBB' start</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">      if (((BC.Entry == SpillPlacement::MustSpill) ||</td>
    <td class="lineNumber">632</td>
    <td class="codeline">      if (((BC.Entry == SpillPlacement::MustSpill) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">           (BC.Entry == SpillPlacement::PrefSpill)) &&</td>
    <td class="lineNumber">633</td>
    <td class="codeline">           (BC.Entry == SpillPlacement::PrefSpill)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">          SlotIndex::isEarlierInstr(BI.FirstInstr,</td>
    <td class="lineNumber">634</td>
    <td class="codeline">          SlotIndex::isEarlierInstr(BI.FirstInstr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">                                    SA->getFirstSplitPoint(BC.Number)))</td>
    <td class="lineNumber">635</td>
    <td class="codeline">                                    SA->getFirstSplitPoint(BC.Number)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">636</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">637</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">    // Interference for the live-out value.</td>
    <td class="lineNumber">639</td>
    <td class="codeline">    // Interference for the live-out value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    if (BI.LiveOut) {</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    if (BI.LiveOut) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">      if (Intf.last() >= SA->getLastSplitPoint(BC.Number)) {</td>
    <td class="lineNumber">641</td>
    <td class="codeline">      if (Intf.last() >= SA->getLastSplitPoint(BC.Number)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">        BC.Exit = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">642</td>
    <td class="codeline">        BC.Exit = SpillPlacement::MustSpill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">        ++Ins;</td>
    <td class="lineNumber">643</td>
    <td class="codeline">        ++Ins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">      } else if (Intf.last() > BI.LastInstr) {</td>
    <td class="lineNumber">644</td>
    <td class="codeline">      } else if (Intf.last() > BI.LastInstr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">        BC.Exit = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">645</td>
    <td class="codeline">        BC.Exit = SpillPlacement::PrefSpill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">        ++Ins;</td>
    <td class="lineNumber">646</td>
    <td class="codeline">        ++Ins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">      } else if (Intf.last() > BI.FirstInstr) {</td>
    <td class="lineNumber">647</td>
    <td class="codeline">      } else if (Intf.last() > BI.FirstInstr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">        ++Ins;</td>
    <td class="lineNumber">648</td>
    <td class="codeline">        ++Ins;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">649</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">650</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    // Accumulate the total frequency of inserted spill code.</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    // Accumulate the total frequency of inserted spill code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">    while (Ins--)</td>
    <td class="lineNumber">653</td>
    <td class="codeline">    while (Ins--)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">      StaticCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
    <td class="lineNumber">654</td>
    <td class="codeline">      StaticCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  Cost = StaticCost;</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  Cost = StaticCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  // Add constraints for use-blocks. Note that these are the only constraints</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  // Add constraints for use-blocks. Note that these are the only constraints</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  // that may add a positive bias, it is downhill from here.</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  // that may add a positive bias, it is downhill from here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  SpillPlacer->addConstraints(SplitConstraints);</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  SpillPlacer->addConstraints(SplitConstraints);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  return SpillPlacer->scanActiveBundles();</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  return SpillPlacer->scanActiveBundles();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">}</td>
    <td class="lineNumber">662</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">/// addThroughConstraints - Add constraints and links to SpillPlacer from the</td>
    <td class="lineNumber">664</td>
    <td class="codeline">/// addThroughConstraints - Add constraints and links to SpillPlacer from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">/// live-through blocks in Blocks.</td>
    <td class="lineNumber">665</td>
    <td class="codeline">/// live-through blocks in Blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">bool RAGreedy::addThroughConstraints(InterferenceCache::Cursor Intf,</td>
    <td class="lineNumber">666</td>
    <td class="codeline">bool RAGreedy::addThroughConstraints(InterferenceCache::Cursor Intf,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">                                     ArrayRef<unsigned> Blocks) {</td>
    <td class="lineNumber">667</td>
    <td class="codeline">                                     ArrayRef<unsigned> Blocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  const unsigned GroupSize = 8;</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  const unsigned GroupSize = 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  SpillPlacement::BlockConstraint BCS[GroupSize];</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  SpillPlacement::BlockConstraint BCS[GroupSize];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  unsigned TBS[GroupSize];</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  unsigned TBS[GroupSize];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">  unsigned B = 0, T = 0;</td>
    <td class="lineNumber">671</td>
    <td class="codeline">  unsigned B = 0, T = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  for (unsigned Number : Blocks) {</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  for (unsigned Number : Blocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">    Intf.moveToBlock(Number);</td>
    <td class="lineNumber">674</td>
    <td class="codeline">    Intf.moveToBlock(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">    if (!Intf.hasInterference()) {</td>
    <td class="lineNumber">676</td>
    <td class="codeline">    if (!Intf.hasInterference()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">      assert(T < GroupSize && "Array overflow");</td>
    <td class="lineNumber">677</td>
    <td class="codeline">      assert(T < GroupSize && "Array overflow");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">      TBS[T] = Number;</td>
    <td class="lineNumber">678</td>
    <td class="codeline">      TBS[T] = Number;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">      if (++T == GroupSize) {</td>
    <td class="lineNumber">679</td>
    <td class="codeline">      if (++T == GroupSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">        SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
    <td class="lineNumber">680</td>
    <td class="codeline">        SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">        T = 0;</td>
    <td class="lineNumber">681</td>
    <td class="codeline">        T = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">682</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">683</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">684</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">    assert(B < GroupSize && "Array overflow");</td>
    <td class="lineNumber">686</td>
    <td class="codeline">    assert(B < GroupSize && "Array overflow");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    BCS[B].Number = Number;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    BCS[B].Number = Number;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">    // Abort if the spill cannot be inserted at the MBB' start</td>
    <td class="lineNumber">689</td>
    <td class="codeline">    // Abort if the spill cannot be inserted at the MBB' start</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">    MachineBasicBlock *MBB = MF->getBlockNumbered(Number);</td>
    <td class="lineNumber">690</td>
    <td class="codeline">    MachineBasicBlock *MBB = MF->getBlockNumbered(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">    auto FirstNonDebugInstr = MBB->getFirstNonDebugInstr();</td>
    <td class="lineNumber">691</td>
    <td class="codeline">    auto FirstNonDebugInstr = MBB->getFirstNonDebugInstr();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">    if (FirstNonDebugInstr != MBB->end() &&</td>
    <td class="lineNumber">692</td>
    <td class="codeline">    if (FirstNonDebugInstr != MBB->end() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">        SlotIndex::isEarlierInstr(LIS->getInstructionIndex(*FirstNonDebugInstr),</td>
    <td class="lineNumber">693</td>
    <td class="codeline">        SlotIndex::isEarlierInstr(LIS->getInstructionIndex(*FirstNonDebugInstr),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">                                  SA->getFirstSplitPoint(Number)))</td>
    <td class="lineNumber">694</td>
    <td class="codeline">                                  SA->getFirstSplitPoint(Number)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">695</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">    // Interference for the live-in value.</td>
    <td class="lineNumber">696</td>
    <td class="codeline">    // Interference for the live-in value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    if (Intf.first() <= Indexes->getMBBStartIdx(Number))</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    if (Intf.first() <= Indexes->getMBBStartIdx(Number))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">      BCS[B].Entry = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">698</td>
    <td class="codeline">      BCS[B].Entry = SpillPlacement::MustSpill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">699</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">      BCS[B].Entry = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">700</td>
    <td class="codeline">      BCS[B].Entry = SpillPlacement::PrefSpill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline"></td>
    <td class="lineNumber">701</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">    // Interference for the live-out value.</td>
    <td class="lineNumber">702</td>
    <td class="codeline">    // Interference for the live-out value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    if (Intf.last() >= SA->getLastSplitPoint(Number))</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    if (Intf.last() >= SA->getLastSplitPoint(Number))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">      BCS[B].Exit = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">704</td>
    <td class="codeline">      BCS[B].Exit = SpillPlacement::MustSpill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">      BCS[B].Exit = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">706</td>
    <td class="codeline">      BCS[B].Exit = SpillPlacement::PrefSpill;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">    if (++B == GroupSize) {</td>
    <td class="lineNumber">708</td>
    <td class="codeline">    if (++B == GroupSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">      SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
    <td class="lineNumber">709</td>
    <td class="codeline">      SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">      B = 0;</td>
    <td class="lineNumber">710</td>
    <td class="codeline">      B = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">711</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline"></td>
    <td class="lineNumber">713</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">  SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
    <td class="lineNumber">715</td>
    <td class="codeline">  SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">}</td>
    <td class="lineNumber">717</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline"></td>
    <td class="lineNumber">718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">bool RAGreedy::growRegion(GlobalSplitCandidate &Cand) {</td>
    <td class="lineNumber">719</td>
    <td class="codeline">bool RAGreedy::growRegion(GlobalSplitCandidate &Cand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  // Keep track of through blocks that have not been added to SpillPlacer.</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  // Keep track of through blocks that have not been added to SpillPlacer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  BitVector Todo = SA->getThroughBlocks();</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  BitVector Todo = SA->getThroughBlocks();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  SmallVectorImpl<unsigned> &ActiveBlocks = Cand.ActiveBlocks;</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  SmallVectorImpl<unsigned> &ActiveBlocks = Cand.ActiveBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  unsigned AddedTo = 0;</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  unsigned AddedTo = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">724</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  unsigned Visited = 0;</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  unsigned Visited = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">726</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline"></td>
    <td class="lineNumber">727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">  unsigned long Budget = GrowRegionComplexityBudget;</td>
    <td class="lineNumber">728</td>
    <td class="codeline">  unsigned long Budget = GrowRegionComplexityBudget;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  while (true) {</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">    ArrayRef<unsigned> NewBundles = SpillPlacer->getRecentPositive();</td>
    <td class="lineNumber">730</td>
    <td class="codeline">    ArrayRef<unsigned> NewBundles = SpillPlacer->getRecentPositive();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">    // Find new through blocks in the periphery of PrefRegBundles.</td>
    <td class="lineNumber">731</td>
    <td class="codeline">    // Find new through blocks in the periphery of PrefRegBundles.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">    for (unsigned Bundle : NewBundles) {</td>
    <td class="lineNumber">732</td>
    <td class="codeline">    for (unsigned Bundle : NewBundles) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">      // Look at all blocks connected to Bundle in the full graph.</td>
    <td class="lineNumber">733</td>
    <td class="codeline">      // Look at all blocks connected to Bundle in the full graph.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">      ArrayRef<unsigned> Blocks = Bundles->getBlocks(Bundle);</td>
    <td class="lineNumber">734</td>
    <td class="codeline">      ArrayRef<unsigned> Blocks = Bundles->getBlocks(Bundle);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">      // Limit compilation time by bailing out after we use all our budget.</td>
    <td class="lineNumber">735</td>
    <td class="codeline">      // Limit compilation time by bailing out after we use all our budget.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">      if (Blocks.size() >= Budget)</td>
    <td class="lineNumber">736</td>
    <td class="codeline">      if (Blocks.size() >= Budget)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">737</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">      Budget -= Blocks.size();</td>
    <td class="lineNumber">738</td>
    <td class="codeline">      Budget -= Blocks.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">      for (unsigned Block : Blocks) {</td>
    <td class="lineNumber">739</td>
    <td class="codeline">      for (unsigned Block : Blocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">        if (!Todo.test(Block))</td>
    <td class="lineNumber">740</td>
    <td class="codeline">        if (!Todo.test(Block))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">741</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">        Todo.reset(Block);</td>
    <td class="lineNumber">742</td>
    <td class="codeline">        Todo.reset(Block);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">        // This is a new through block. Add it to SpillPlacer later.</td>
    <td class="lineNumber">743</td>
    <td class="codeline">        // This is a new through block. Add it to SpillPlacer later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">        ActiveBlocks.push_back(Block);</td>
    <td class="lineNumber">744</td>
    <td class="codeline">        ActiveBlocks.push_back(Block);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">745</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">        ++Visited;</td>
    <td class="lineNumber">746</td>
    <td class="codeline">        ++Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">747</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">748</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">749</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    // Any new blocks to add?</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    // Any new blocks to add?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    if (ActiveBlocks.size() == AddedTo)</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    if (ActiveBlocks.size() == AddedTo)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">752</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline"></td>
    <td class="lineNumber">753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    // Compute through constraints from the interference, or assume that all</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    // Compute through constraints from the interference, or assume that all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">    // through blocks prefer spilling when forming compact regions.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">    // through blocks prefer spilling when forming compact regions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">    auto NewBlocks = ArrayRef(ActiveBlocks).slice(AddedTo);</td>
    <td class="lineNumber">756</td>
    <td class="codeline">    auto NewBlocks = ArrayRef(ActiveBlocks).slice(AddedTo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">    if (Cand.PhysReg) {</td>
    <td class="lineNumber">757</td>
    <td class="codeline">    if (Cand.PhysReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">      if (!addThroughConstraints(Cand.Intf, NewBlocks))</td>
    <td class="lineNumber">758</td>
    <td class="codeline">      if (!addThroughConstraints(Cand.Intf, NewBlocks))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">759</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">760</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">      // Provide a strong negative bias on through blocks to prevent unwanted</td>
    <td class="lineNumber">761</td>
    <td class="codeline">      // Provide a strong negative bias on through blocks to prevent unwanted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">      // liveness on loop backedges.</td>
    <td class="lineNumber">762</td>
    <td class="codeline">      // liveness on loop backedges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">      SpillPlacer->addPrefSpill(NewBlocks, /* Strong= */ true);</td>
    <td class="lineNumber">763</td>
    <td class="codeline">      SpillPlacer->addPrefSpill(NewBlocks, /* Strong= */ true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">    AddedTo = ActiveBlocks.size();</td>
    <td class="lineNumber">764</td>
    <td class="codeline">    AddedTo = ActiveBlocks.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline"></td>
    <td class="lineNumber">765</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    // Perhaps iterating can enable more bundles?</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    // Perhaps iterating can enable more bundles?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">    SpillPlacer->iterate();</td>
    <td class="lineNumber">767</td>
    <td class="codeline">    SpillPlacer->iterate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">768</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << ", v=" << Visited);</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << ", v=" << Visited);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">770</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">}</td>
    <td class="lineNumber">771</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline"></td>
    <td class="lineNumber">772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">/// calcCompactRegion - Compute the set of edge bundles that should be live</td>
    <td class="lineNumber">773</td>
    <td class="codeline">/// calcCompactRegion - Compute the set of edge bundles that should be live</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">/// when splitting the current live range into compact regions.  Compact</td>
    <td class="lineNumber">774</td>
    <td class="codeline">/// when splitting the current live range into compact regions.  Compact</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">/// regions can be computed without looking at interference.  They are the</td>
    <td class="lineNumber">775</td>
    <td class="codeline">/// regions can be computed without looking at interference.  They are the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">/// regions formed by removing all the live-through blocks from the live range.</td>
    <td class="lineNumber">776</td>
    <td class="codeline">/// regions formed by removing all the live-through blocks from the live range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">///</td>
    <td class="lineNumber">777</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">/// Returns false if the current live range is already compact, or if the</td>
    <td class="lineNumber">778</td>
    <td class="codeline">/// Returns false if the current live range is already compact, or if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">/// compact regions would form single block regions anyway.</td>
    <td class="lineNumber">779</td>
    <td class="codeline">/// compact regions would form single block regions anyway.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">bool RAGreedy::calcCompactRegion(GlobalSplitCandidate &Cand) {</td>
    <td class="lineNumber">780</td>
    <td class="codeline">bool RAGreedy::calcCompactRegion(GlobalSplitCandidate &Cand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">  // Without any through blocks, the live range is already compact.</td>
    <td class="lineNumber">781</td>
    <td class="codeline">  // Without any through blocks, the live range is already compact.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  if (!SA->getNumThroughBlocks())</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  if (!SA->getNumThroughBlocks())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">783</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">  // Compact regions don't correspond to any physreg.</td>
    <td class="lineNumber">785</td>
    <td class="codeline">  // Compact regions don't correspond to any physreg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  Cand.reset(IntfCache, MCRegister::NoRegister);</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  Cand.reset(IntfCache, MCRegister::NoRegister);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline"></td>
    <td class="lineNumber">787</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Compact region bundles");</td>
    <td class="lineNumber">788</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Compact region bundles");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  // Use the spill placer to determine the live bundles. GrowRegion pretends</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  // Use the spill placer to determine the live bundles. GrowRegion pretends</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  // that all the through blocks have interference when PhysReg is unset.</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  // that all the through blocks have interference when PhysReg is unset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  SpillPlacer->prepare(Cand.LiveBundles);</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  SpillPlacer->prepare(Cand.LiveBundles);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline"></td>
    <td class="lineNumber">793</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  // The static split cost will be zero since Cand.Intf reports no interference.</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  // The static split cost will be zero since Cand.Intf reports no interference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">  BlockFrequency Cost;</td>
    <td class="lineNumber">795</td>
    <td class="codeline">  BlockFrequency Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">  if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
    <td class="lineNumber">796</td>
    <td class="codeline">  if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
    <td class="lineNumber">797</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">798</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">799</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">  if (!growRegion(Cand)) {</td>
    <td class="lineNumber">801</td>
    <td class="codeline">  if (!growRegion(Cand)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
    <td class="lineNumber">802</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">803</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
    <td class="lineNumber">805</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  SpillPlacer->finish();</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  SpillPlacer->finish();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  if (!Cand.LiveBundles.any()) {</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  if (!Cand.LiveBundles.any()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
    <td class="lineNumber">809</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">810</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
    <td class="lineNumber">812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">    for (int I : Cand.LiveBundles.set_bits())</td>
    <td class="lineNumber">814</td>
    <td class="codeline">    for (int I : Cand.LiveBundles.set_bits())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">      dbgs() << " EB#" << I;</td>
    <td class="lineNumber">815</td>
    <td class="codeline">      dbgs() << " EB#" << I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">    dbgs() << ".\n";</td>
    <td class="lineNumber">816</td>
    <td class="codeline">    dbgs() << ".\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">}</td>
    <td class="lineNumber">819</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline"></td>
    <td class="lineNumber">820</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">/// calcSpillCost - Compute how expensive it would be to split the live range in</td>
    <td class="lineNumber">821</td>
    <td class="codeline">/// calcSpillCost - Compute how expensive it would be to split the live range in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">/// SA around all use blocks instead of forming bundle regions.</td>
    <td class="lineNumber">822</td>
    <td class="codeline">/// SA around all use blocks instead of forming bundle regions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">BlockFrequency RAGreedy::calcSpillCost() {</td>
    <td class="lineNumber">823</td>
    <td class="codeline">BlockFrequency RAGreedy::calcSpillCost() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  BlockFrequency Cost = 0;</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  BlockFrequency Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">    unsigned Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">827</td>
    <td class="codeline">    unsigned Number = BI.MBB->getNumber();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    // We normally only need one spill instruction - a load or a store.</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    // We normally only need one spill instruction - a load or a store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">    Cost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">829</td>
    <td class="codeline">    Cost += SpillPlacer->getBlockFrequency(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">    // Unless the value is redefined in the block.</td>
    <td class="lineNumber">831</td>
    <td class="codeline">    // Unless the value is redefined in the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">    if (BI.LiveIn && BI.LiveOut && BI.FirstDef)</td>
    <td class="lineNumber">832</td>
    <td class="codeline">    if (BI.LiveIn && BI.LiveOut && BI.FirstDef)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">      Cost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">833</td>
    <td class="codeline">      Cost += SpillPlacer->getBlockFrequency(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  return Cost;</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">}</td>
    <td class="lineNumber">836</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline"></td>
    <td class="lineNumber">837</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">/// calcGlobalSplitCost - Return the global split cost of following the split</td>
    <td class="lineNumber">838</td>
    <td class="codeline">/// calcGlobalSplitCost - Return the global split cost of following the split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">/// pattern in LiveBundles. This cost should be added to the local cost of the</td>
    <td class="lineNumber">839</td>
    <td class="codeline">/// pattern in LiveBundles. This cost should be added to the local cost of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">/// interference pattern in SplitConstraints.</td>
    <td class="lineNumber">840</td>
    <td class="codeline">/// interference pattern in SplitConstraints.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">///</td>
    <td class="lineNumber">841</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">BlockFrequency RAGreedy::calcGlobalSplitCost(GlobalSplitCandidate &Cand,</td>
    <td class="lineNumber">842</td>
    <td class="codeline">BlockFrequency RAGreedy::calcGlobalSplitCost(GlobalSplitCandidate &Cand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">                                             const AllocationOrder &Order) {</td>
    <td class="lineNumber">843</td>
    <td class="codeline">                                             const AllocationOrder &Order) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  BlockFrequency GlobalCost = 0;</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  BlockFrequency GlobalCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  const BitVector &LiveBundles = Cand.LiveBundles;</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  const BitVector &LiveBundles = Cand.LiveBundles;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
    <td class="lineNumber">848</td>
    <td class="codeline">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
    <td class="lineNumber">849</td>
    <td class="codeline">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">    bool RegIn  = LiveBundles[Bundles->getBundle(BC.Number, false)];</td>
    <td class="lineNumber">850</td>
    <td class="codeline">    bool RegIn  = LiveBundles[Bundles->getBundle(BC.Number, false)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">    bool RegOut = LiveBundles[Bundles->getBundle(BC.Number, true)];</td>
    <td class="lineNumber">851</td>
    <td class="codeline">    bool RegOut = LiveBundles[Bundles->getBundle(BC.Number, true)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">    unsigned Ins = 0;</td>
    <td class="lineNumber">852</td>
    <td class="codeline">    unsigned Ins = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline"></td>
    <td class="lineNumber">853</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">    Cand.Intf.moveToBlock(BC.Number);</td>
    <td class="lineNumber">854</td>
    <td class="codeline">    Cand.Intf.moveToBlock(BC.Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">    if (BI.LiveIn)</td>
    <td class="lineNumber">856</td>
    <td class="codeline">    if (BI.LiveIn)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">      Ins += RegIn != (BC.Entry == SpillPlacement::PrefReg);</td>
    <td class="lineNumber">857</td>
    <td class="codeline">      Ins += RegIn != (BC.Entry == SpillPlacement::PrefReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">    if (BI.LiveOut)</td>
    <td class="lineNumber">858</td>
    <td class="codeline">    if (BI.LiveOut)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">      Ins += RegOut != (BC.Exit == SpillPlacement::PrefReg);</td>
    <td class="lineNumber">859</td>
    <td class="codeline">      Ins += RegOut != (BC.Exit == SpillPlacement::PrefReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">    while (Ins--)</td>
    <td class="lineNumber">860</td>
    <td class="codeline">    while (Ins--)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">      GlobalCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
    <td class="lineNumber">861</td>
    <td class="codeline">      GlobalCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline"></td>
    <td class="lineNumber">863</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  for (unsigned Number : Cand.ActiveBlocks) {</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  for (unsigned Number : Cand.ActiveBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    bool RegIn  = LiveBundles[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    bool RegIn  = LiveBundles[Bundles->getBundle(Number, false)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    bool RegOut = LiveBundles[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    bool RegOut = LiveBundles[Bundles->getBundle(Number, true)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    if (!RegIn && !RegOut)</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    if (!RegIn && !RegOut)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">868</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">    if (RegIn && RegOut) {</td>
    <td class="lineNumber">869</td>
    <td class="codeline">    if (RegIn && RegOut) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">      // We need double spill code if this block has interference.</td>
    <td class="lineNumber">870</td>
    <td class="codeline">      // We need double spill code if this block has interference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">      Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">871</td>
    <td class="codeline">      Cand.Intf.moveToBlock(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">      if (Cand.Intf.hasInterference()) {</td>
    <td class="lineNumber">872</td>
    <td class="codeline">      if (Cand.Intf.hasInterference()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">873</td>
    <td class="codeline">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">874</td>
    <td class="codeline">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">875</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">876</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">877</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">    // live-in / stack-out or stack-in live-out.</td>
    <td class="lineNumber">878</td>
    <td class="codeline">    // live-in / stack-out or stack-in live-out.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">    GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">879</td>
    <td class="codeline">    GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">880</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">  return GlobalCost;</td>
    <td class="lineNumber">881</td>
    <td class="codeline">  return GlobalCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">}</td>
    <td class="lineNumber">882</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">/// splitAroundRegion - Split the current live range around the regions</td>
    <td class="lineNumber">884</td>
    <td class="codeline">/// splitAroundRegion - Split the current live range around the regions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">/// determined by BundleCand and GlobalCand.</td>
    <td class="lineNumber">885</td>
    <td class="codeline">/// determined by BundleCand and GlobalCand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">///</td>
    <td class="lineNumber">886</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">/// Before calling this function, GlobalCand and BundleCand must be initialized</td>
    <td class="lineNumber">887</td>
    <td class="codeline">/// Before calling this function, GlobalCand and BundleCand must be initialized</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">/// so each bundle is assigned to a valid candidate, or NoCand for the</td>
    <td class="lineNumber">888</td>
    <td class="codeline">/// so each bundle is assigned to a valid candidate, or NoCand for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">/// stack-bound bundles.  The shared SA/SE SplitAnalysis and SplitEditor</td>
    <td class="lineNumber">889</td>
    <td class="codeline">/// stack-bound bundles.  The shared SA/SE SplitAnalysis and SplitEditor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">/// objects must be initialized for the current live range, and intervals</td>
    <td class="lineNumber">890</td>
    <td class="codeline">/// objects must be initialized for the current live range, and intervals</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">/// created for the used candidates.</td>
    <td class="lineNumber">891</td>
    <td class="codeline">/// created for the used candidates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">///</td>
    <td class="lineNumber">892</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">/// @param LREdit    The LiveRangeEdit object handling the current split.</td>
    <td class="lineNumber">893</td>
    <td class="codeline">/// @param LREdit    The LiveRangeEdit object handling the current split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">/// @param UsedCands List of used GlobalCand entries. Every BundleCand value</td>
    <td class="lineNumber">894</td>
    <td class="codeline">/// @param UsedCands List of used GlobalCand entries. Every BundleCand value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">///                  must appear in this list.</td>
    <td class="lineNumber">895</td>
    <td class="codeline">///                  must appear in this list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">void RAGreedy::splitAroundRegion(LiveRangeEdit &LREdit,</td>
    <td class="lineNumber">896</td>
    <td class="codeline">void RAGreedy::splitAroundRegion(LiveRangeEdit &LREdit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">                                 ArrayRef<unsigned> UsedCands) {</td>
    <td class="lineNumber">897</td>
    <td class="codeline">                                 ArrayRef<unsigned> UsedCands) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">  // These are the intervals created for new global ranges. We may create more</td>
    <td class="lineNumber">898</td>
    <td class="codeline">  // These are the intervals created for new global ranges. We may create more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">  // intervals for local ranges.</td>
    <td class="lineNumber">899</td>
    <td class="codeline">  // intervals for local ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">  const unsigned NumGlobalIntvs = LREdit.size();</td>
    <td class="lineNumber">900</td>
    <td class="codeline">  const unsigned NumGlobalIntvs = LREdit.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "splitAroundRegion with " << NumGlobalIntvs</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "splitAroundRegion with " << NumGlobalIntvs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">                    << " globals.\n");</td>
    <td class="lineNumber">902</td>
    <td class="codeline">                    << " globals.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">  assert(NumGlobalIntvs && "No global intervals configured");</td>
    <td class="lineNumber">903</td>
    <td class="codeline">  assert(NumGlobalIntvs && "No global intervals configured");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  // Isolate even single instructions when dealing with a proper sub-class.</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  // Isolate even single instructions when dealing with a proper sub-class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">  // That guarantees register class inflation for the stack interval because it</td>
    <td class="lineNumber">906</td>
    <td class="codeline">  // That guarantees register class inflation for the stack interval because it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  // is all copies.</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  // is all copies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  Register Reg = SA->getParent().reg();</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  Register Reg = SA->getParent().reg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
    <td class="lineNumber">909</td>
    <td class="codeline">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
    <td class="lineNumber">910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  // First handle all the blocks with uses.</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  // First handle all the blocks with uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">913</td>
    <td class="codeline">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">    unsigned Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">914</td>
    <td class="codeline">    unsigned Number = BI.MBB->getNumber();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">    unsigned IntvIn = 0, IntvOut = 0;</td>
    <td class="lineNumber">915</td>
    <td class="codeline">    unsigned IntvIn = 0, IntvOut = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">    SlotIndex IntfIn, IntfOut;</td>
    <td class="lineNumber">916</td>
    <td class="codeline">    SlotIndex IntfIn, IntfOut;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">    if (BI.LiveIn) {</td>
    <td class="lineNumber">917</td>
    <td class="codeline">    if (BI.LiveIn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">918</td>
    <td class="codeline">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">      if (CandIn != NoCand) {</td>
    <td class="lineNumber">919</td>
    <td class="codeline">      if (CandIn != NoCand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
    <td class="lineNumber">920</td>
    <td class="codeline">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">        IntvIn = Cand.IntvIdx;</td>
    <td class="lineNumber">921</td>
    <td class="codeline">        IntvIn = Cand.IntvIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">922</td>
    <td class="codeline">        Cand.Intf.moveToBlock(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">        IntfIn = Cand.Intf.first();</td>
    <td class="lineNumber">923</td>
    <td class="codeline">        IntfIn = Cand.Intf.first();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">924</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">925</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">    if (BI.LiveOut) {</td>
    <td class="lineNumber">926</td>
    <td class="codeline">    if (BI.LiveOut) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">927</td>
    <td class="codeline">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">      if (CandOut != NoCand) {</td>
    <td class="lineNumber">928</td>
    <td class="codeline">      if (CandOut != NoCand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
    <td class="lineNumber">929</td>
    <td class="codeline">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">        IntvOut = Cand.IntvIdx;</td>
    <td class="lineNumber">930</td>
    <td class="codeline">        IntvOut = Cand.IntvIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">931</td>
    <td class="codeline">        Cand.Intf.moveToBlock(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">        IntfOut = Cand.Intf.last();</td>
    <td class="lineNumber">932</td>
    <td class="codeline">        IntfOut = Cand.Intf.last();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">933</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">934</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline"></td>
    <td class="lineNumber">935</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">    // Create separate intervals for isolated blocks with multiple uses.</td>
    <td class="lineNumber">936</td>
    <td class="codeline">    // Create separate intervals for isolated blocks with multiple uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">    if (!IntvIn && !IntvOut) {</td>
    <td class="lineNumber">937</td>
    <td class="codeline">    if (!IntvIn && !IntvOut) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << printMBBReference(*BI.MBB) << " isolated.\n");</td>
    <td class="lineNumber">938</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << printMBBReference(*BI.MBB) << " isolated.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">      if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
    <td class="lineNumber">939</td>
    <td class="codeline">      if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">        SE->splitSingleBlock(BI);</td>
    <td class="lineNumber">940</td>
    <td class="codeline">        SE->splitSingleBlock(BI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">941</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">942</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">    if (IntvIn && IntvOut)</td>
    <td class="lineNumber">944</td>
    <td class="codeline">    if (IntvIn && IntvOut)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
    <td class="lineNumber">945</td>
    <td class="codeline">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">    else if (IntvIn)</td>
    <td class="lineNumber">946</td>
    <td class="codeline">    else if (IntvIn)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">      SE->splitRegInBlock(BI, IntvIn, IntfIn);</td>
    <td class="lineNumber">947</td>
    <td class="codeline">      SE->splitRegInBlock(BI, IntvIn, IntfIn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">948</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">      SE->splitRegOutBlock(BI, IntvOut, IntfOut);</td>
    <td class="lineNumber">949</td>
    <td class="codeline">      SE->splitRegOutBlock(BI, IntvOut, IntfOut);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">950</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline"></td>
    <td class="lineNumber">951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">  // Handle live-through blocks. The relevant live-through blocks are stored in</td>
    <td class="lineNumber">952</td>
    <td class="codeline">  // Handle live-through blocks. The relevant live-through blocks are stored in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">  // the ActiveBlocks list with each candidate. We need to filter out</td>
    <td class="lineNumber">953</td>
    <td class="codeline">  // the ActiveBlocks list with each candidate. We need to filter out</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">  // duplicates.</td>
    <td class="lineNumber">954</td>
    <td class="codeline">  // duplicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">  BitVector Todo = SA->getThroughBlocks();</td>
    <td class="lineNumber">955</td>
    <td class="codeline">  BitVector Todo = SA->getThroughBlocks();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">  for (unsigned UsedCand : UsedCands) {</td>
    <td class="lineNumber">956</td>
    <td class="codeline">  for (unsigned UsedCand : UsedCands) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">    ArrayRef<unsigned> Blocks = GlobalCand[UsedCand].ActiveBlocks;</td>
    <td class="lineNumber">957</td>
    <td class="codeline">    ArrayRef<unsigned> Blocks = GlobalCand[UsedCand].ActiveBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">    for (unsigned Number : Blocks) {</td>
    <td class="lineNumber">958</td>
    <td class="codeline">    for (unsigned Number : Blocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">      if (!Todo.test(Number))</td>
    <td class="lineNumber">959</td>
    <td class="codeline">      if (!Todo.test(Number))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">960</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">      Todo.reset(Number);</td>
    <td class="lineNumber">961</td>
    <td class="codeline">      Todo.reset(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
    <td class="lineNumber">962</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">      unsigned IntvIn = 0, IntvOut = 0;</td>
    <td class="lineNumber">963</td>
    <td class="codeline">      unsigned IntvIn = 0, IntvOut = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">      SlotIndex IntfIn, IntfOut;</td>
    <td class="lineNumber">964</td>
    <td class="codeline">      SlotIndex IntfIn, IntfOut;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">966</td>
    <td class="codeline">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">      if (CandIn != NoCand) {</td>
    <td class="lineNumber">967</td>
    <td class="codeline">      if (CandIn != NoCand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
    <td class="lineNumber">968</td>
    <td class="codeline">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">        IntvIn = Cand.IntvIdx;</td>
    <td class="lineNumber">969</td>
    <td class="codeline">        IntvIn = Cand.IntvIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">970</td>
    <td class="codeline">        Cand.Intf.moveToBlock(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">        IntfIn = Cand.Intf.first();</td>
    <td class="lineNumber">971</td>
    <td class="codeline">        IntfIn = Cand.Intf.first();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">972</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">974</td>
    <td class="codeline">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">      if (CandOut != NoCand) {</td>
    <td class="lineNumber">975</td>
    <td class="codeline">      if (CandOut != NoCand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
    <td class="lineNumber">976</td>
    <td class="codeline">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">        IntvOut = Cand.IntvIdx;</td>
    <td class="lineNumber">977</td>
    <td class="codeline">        IntvOut = Cand.IntvIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">978</td>
    <td class="codeline">        Cand.Intf.moveToBlock(Number);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">        IntfOut = Cand.Intf.last();</td>
    <td class="lineNumber">979</td>
    <td class="codeline">        IntfOut = Cand.Intf.last();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">980</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">      if (!IntvIn && !IntvOut)</td>
    <td class="lineNumber">981</td>
    <td class="codeline">      if (!IntvIn && !IntvOut)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">982</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
    <td class="lineNumber">983</td>
    <td class="codeline">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">984</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">985</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline"></td>
    <td class="lineNumber">986</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">  ++NumGlobalSplits;</td>
    <td class="lineNumber">987</td>
    <td class="codeline">  ++NumGlobalSplits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
    <td class="lineNumber">988</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  SmallVector<unsigned, 8> IntvMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  SE->finish(&IntvMap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
    <td class="lineNumber">991</td>
    <td class="codeline">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">  unsigned OrigBlocks = SA->getNumLiveBlocks();</td>
    <td class="lineNumber">993</td>
    <td class="codeline">  unsigned OrigBlocks = SA->getNumLiveBlocks();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline"></td>
    <td class="lineNumber">994</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  // Sort out the new intervals created by splitting. We get four kinds:</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  // Sort out the new intervals created by splitting. We get four kinds:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  // - Remainder intervals should not be split again.</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  // - Remainder intervals should not be split again.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  // - Candidate intervals can be assigned to Cand.PhysReg.</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  // - Candidate intervals can be assigned to Cand.PhysReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  // - Block-local splits are candidates for local splitting.</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  // - Block-local splits are candidates for local splitting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">  // - DCE leftovers should go back on the queue.</td>
    <td class="lineNumber">999</td>
    <td class="codeline">  // - DCE leftovers should go back on the queue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">    const LiveInterval &Reg = LIS->getInterval(LREdit.get(I));</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">    const LiveInterval &Reg = LIS->getInterval(LREdit.get(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline"></td>
    <td class="lineNumber">1002</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">    // Ignore old intervals from DCE.</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">    // Ignore old intervals from DCE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    if (ExtraInfo->getOrInitStage(Reg.reg()) != RS_New)</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    if (ExtraInfo->getOrInitStage(Reg.reg()) != RS_New)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline"></td>
    <td class="lineNumber">1006</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">    // Remainder interval. Don't try splitting again, spill if it doesn't</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">    // Remainder interval. Don't try splitting again, spill if it doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">    // allocate.</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">    // allocate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">    if (IntvMap[I] == 0) {</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">    if (IntvMap[I] == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">      ExtraInfo->setStage(Reg, RS_Spill);</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">      ExtraInfo->setStage(Reg, RS_Spill);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline"></td>
    <td class="lineNumber">1013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">    // Global intervals. Allow repeated splitting as long as the number of live</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">    // Global intervals. Allow repeated splitting as long as the number of live</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    // blocks is strictly decreasing.</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    // blocks is strictly decreasing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">    if (IntvMap[I] < NumGlobalIntvs) {</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">    if (IntvMap[I] < NumGlobalIntvs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">      if (SA->countLiveBlocks(&Reg) >= OrigBlocks) {</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">      if (SA->countLiveBlocks(&Reg) >= OrigBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Main interval covers the same " << OrigBlocks</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Main interval covers the same " << OrigBlocks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">                          << " blocks as original.\n");</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">                          << " blocks as original.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">        // Don't allow repeated splitting as a safe guard against looping.</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">        // Don't allow repeated splitting as a safe guard against looping.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">        ExtraInfo->setStage(Reg, RS_Split2);</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">        ExtraInfo->setStage(Reg, RS_Split2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline"></td>
    <td class="lineNumber">1025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">    // Other intervals are treated as new. This includes local intervals created</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">    // Other intervals are treated as new. This includes local intervals created</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">    // for blocks with multiple uses, and anything created by DCE.</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">    // for blocks with multiple uses, and anything created by DCE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline"></td>
    <td class="lineNumber">1029</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">  if (VerifyEnabled)</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">  if (VerifyEnabled)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">    MF->verify(this, "After splitting live range around region");</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">    MF->verify(this, "After splitting live range around region");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">MCRegister RAGreedy::tryRegionSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">MCRegister RAGreedy::tryRegionSplit(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">                                    AllocationOrder &Order,</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">                                    AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">                                    SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">                                    SmallVectorImpl<Register> &NewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">  if (!TRI->shouldRegionSplitForVirtReg(*MF, VirtReg))</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">  if (!TRI->shouldRegionSplitForVirtReg(*MF, VirtReg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">    return MCRegister::NoRegister;</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">    return MCRegister::NoRegister;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  unsigned NumCands = 0;</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  unsigned NumCands = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  BlockFrequency SpillCost = calcSpillCost();</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  BlockFrequency SpillCost = calcSpillCost();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  BlockFrequency BestCost;</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  BlockFrequency BestCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline"></td>
    <td class="lineNumber">1042</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  // Check if we can split this live range around a compact region.</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  // Check if we can split this live range around a compact region.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  bool HasCompact = calcCompactRegion(GlobalCand.front());</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  bool HasCompact = calcCompactRegion(GlobalCand.front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  if (HasCompact) {</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  if (HasCompact) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">    // Yes, keep GlobalCand[0] as the compact region candidate.</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">    // Yes, keep GlobalCand[0] as the compact region candidate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">    NumCands = 1;</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">    NumCands = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">    BestCost = BlockFrequency::getMaxFrequency();</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">    BestCost = BlockFrequency::getMaxFrequency();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">    // No benefit from the compact region, our fallback will be per-block</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">    // No benefit from the compact region, our fallback will be per-block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">    // splitting. Make sure we find a solution that is cheaper than spilling.</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">    // splitting. Make sure we find a solution that is cheaper than spilling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">    BestCost = SpillCost;</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">    BestCost = SpillCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Cost of isolating all blocks = ";</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Cost of isolating all blocks = ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">               MBFI->printBlockFreq(dbgs(), BestCost) << '\n');</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">               MBFI->printBlockFreq(dbgs(), BestCost) << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline"></td>
    <td class="lineNumber">1056</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">                                               NumCands, false /*IgnoreCSR*/);</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">                                               NumCands, false /*IgnoreCSR*/);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline"></td>
    <td class="lineNumber">1059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  // No solutions found, fall back to single block splitting.</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  // No solutions found, fall back to single block splitting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  if (!HasCompact && BestCand == NoCand)</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  if (!HasCompact && BestCand == NoCand)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">    return MCRegister::NoRegister;</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">    return MCRegister::NoRegister;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  return doRegionSplit(VirtReg, BestCand, HasCompact, NewVRegs);</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  return doRegionSplit(VirtReg, BestCand, HasCompact, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">unsigned RAGreedy::calculateRegionSplitCost(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">unsigned RAGreedy::calculateRegionSplitCost(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">                                            AllocationOrder &Order,</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">                                            AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">                                            BlockFrequency &BestCost,</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">                                            BlockFrequency &BestCost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">                                            unsigned &NumCands,</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">                                            unsigned &NumCands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">                                            bool IgnoreCSR) {</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">                                            bool IgnoreCSR) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  unsigned BestCand = NoCand;</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  unsigned BestCand = NoCand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">  for (MCPhysReg PhysReg : Order) {</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">  for (MCPhysReg PhysReg : Order) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    assert(PhysReg);</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    assert(PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">    if (IgnoreCSR && EvictAdvisor->isUnusedCalleeSavedReg(PhysReg))</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">    if (IgnoreCSR && EvictAdvisor->isUnusedCalleeSavedReg(PhysReg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline"></td>
    <td class="lineNumber">1077</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">    // Discard bad candidates before we run out of interference cache cursors.</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">    // Discard bad candidates before we run out of interference cache cursors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">    // This will only affect register classes with a lot of registers (>32).</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">    // This will only affect register classes with a lot of registers (>32).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">    if (NumCands == IntfCache.getMaxCursors()) {</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">    if (NumCands == IntfCache.getMaxCursors()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">      unsigned WorstCount = ~0u;</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">      unsigned WorstCount = ~0u;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">      unsigned Worst = 0;</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">      unsigned Worst = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">      for (unsigned CandIndex = 0; CandIndex != NumCands; ++CandIndex) {</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">      for (unsigned CandIndex = 0; CandIndex != NumCands; ++CandIndex) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">        if (CandIndex == BestCand || !GlobalCand[CandIndex].PhysReg)</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">        if (CandIndex == BestCand || !GlobalCand[CandIndex].PhysReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">        unsigned Count = GlobalCand[CandIndex].LiveBundles.count();</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">        unsigned Count = GlobalCand[CandIndex].LiveBundles.count();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">        if (Count < WorstCount) {</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">        if (Count < WorstCount) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">          Worst = CandIndex;</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">          Worst = CandIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">          WorstCount = Count;</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">          WorstCount = Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">      --NumCands;</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">      --NumCands;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">      GlobalCand[Worst] = GlobalCand[NumCands];</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">      GlobalCand[Worst] = GlobalCand[NumCands];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">      if (BestCand == NumCands)</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">      if (BestCand == NumCands)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">        BestCand = Worst;</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">        BestCand = Worst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline"></td>
    <td class="lineNumber">1097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">    if (GlobalCand.size() <= NumCands)</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">    if (GlobalCand.size() <= NumCands)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">      GlobalCand.resize(NumCands+1);</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">      GlobalCand.resize(NumCands+1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">    GlobalSplitCandidate &Cand = GlobalCand[NumCands];</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">    GlobalSplitCandidate &Cand = GlobalCand[NumCands];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    Cand.reset(IntfCache, PhysReg);</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    Cand.reset(IntfCache, PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline"></td>
    <td class="lineNumber">1102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">    SpillPlacer->prepare(Cand.LiveBundles);</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">    SpillPlacer->prepare(Cand.LiveBundles);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">    BlockFrequency Cost;</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">    BlockFrequency Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">    if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">    if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tno positive bundles\n");</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tno positive bundles\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tstatic = ";</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tstatic = ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">               MBFI->printBlockFreq(dbgs(), Cost));</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">               MBFI->printBlockFreq(dbgs(), Cost));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">    if (Cost >= BestCost) {</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">    if (Cost >= BestCost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">      LLVM_DEBUG({</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">      LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">        if (BestCand == NoCand)</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">        if (BestCand == NoCand)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">          dbgs() << " worse than no bundles\n";</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">          dbgs() << " worse than no bundles\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">        else</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">        else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">          dbgs() << " worse than "</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">          dbgs() << " worse than "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">                 << printReg(GlobalCand[BestCand].PhysReg, TRI) << '\n';</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">                 << printReg(GlobalCand[BestCand].PhysReg, TRI) << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">    if (!growRegion(Cand)) {</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">    if (!growRegion(Cand)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline"></td>
    <td class="lineNumber">1125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">    SpillPlacer->finish();</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">    SpillPlacer->finish();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline"></td>
    <td class="lineNumber">1127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">    // No live bundles, defer to splitSingleBlocks().</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">    // No live bundles, defer to splitSingleBlocks().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">    if (!Cand.LiveBundles.any()) {</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">    if (!Cand.LiveBundles.any()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << " no bundles.\n");</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << " no bundles.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline"></td>
    <td class="lineNumber">1133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">    Cost += calcGlobalSplitCost(Cand, Order);</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">    Cost += calcGlobalSplitCost(Cand, Order);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    LLVM_DEBUG({</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">      dbgs() << ", total = ";</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">      dbgs() << ", total = ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">      MBFI->printBlockFreq(dbgs(), Cost) << " with bundles";</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">      MBFI->printBlockFreq(dbgs(), Cost) << " with bundles";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">      for (int I : Cand.LiveBundles.set_bits())</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">      for (int I : Cand.LiveBundles.set_bits())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">        dbgs() << " EB#" << I;</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">        dbgs() << " EB#" << I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">      dbgs() << ".\n";</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">      dbgs() << ".\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">    if (Cost < BestCost) {</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">    if (Cost < BestCost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">      BestCand = NumCands;</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">      BestCand = NumCands;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">      BestCost = Cost;</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">      BestCost = Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    ++NumCands;</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    ++NumCands;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  return BestCand;</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  return BestCand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">unsigned RAGreedy::doRegionSplit(const LiveInterval &VirtReg, unsigned BestCand,</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">unsigned RAGreedy::doRegionSplit(const LiveInterval &VirtReg, unsigned BestCand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">                                 bool HasCompact,</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">                                 bool HasCompact,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  SmallVector<unsigned, 8> UsedCands;</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  SmallVector<unsigned, 8> UsedCands;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  // Prepare split editor.</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  // Prepare split editor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  SE->reset(LREdit, SplitSpillMode);</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  SE->reset(LREdit, SplitSpillMode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  // Assign all edge bundles to the preferred candidate, or NoCand.</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  // Assign all edge bundles to the preferred candidate, or NoCand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">  BundleCand.assign(Bundles->getNumBundles(), NoCand);</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">  BundleCand.assign(Bundles->getNumBundles(), NoCand);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline"></td>
    <td class="lineNumber">1162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  // Assign bundles for the best candidate region.</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  // Assign bundles for the best candidate region.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">  if (BestCand != NoCand) {</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">  if (BestCand != NoCand) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">    GlobalSplitCandidate &Cand = GlobalCand[BestCand];</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">    GlobalSplitCandidate &Cand = GlobalCand[BestCand];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">    if (unsigned B = Cand.getBundles(BundleCand, BestCand)) {</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">    if (unsigned B = Cand.getBundles(BundleCand, BestCand)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">      UsedCands.push_back(BestCand);</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">      UsedCands.push_back(BestCand);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">      Cand.IntvIdx = SE->openIntv();</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">      Cand.IntvIdx = SE->openIntv();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Split for " << printReg(Cand.PhysReg, TRI) << " in "</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Split for " << printReg(Cand.PhysReg, TRI) << " in "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">                        << B << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">                        << B << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">      (void)B;</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">      (void)B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline"></td>
    <td class="lineNumber">1174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  // Assign bundles for the compact region.</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  // Assign bundles for the compact region.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">  if (HasCompact) {</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">  if (HasCompact) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">    GlobalSplitCandidate &Cand = GlobalCand.front();</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">    GlobalSplitCandidate &Cand = GlobalCand.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">    assert(!Cand.PhysReg && "Compact region has no physreg");</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">    assert(!Cand.PhysReg && "Compact region has no physreg");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">    if (unsigned B = Cand.getBundles(BundleCand, 0)) {</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">    if (unsigned B = Cand.getBundles(BundleCand, 0)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">      UsedCands.push_back(0);</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">      UsedCands.push_back(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">      Cand.IntvIdx = SE->openIntv();</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">      Cand.IntvIdx = SE->openIntv();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Split for compact region in " << B</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Split for compact region in " << B</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">                        << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">                        << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">      (void)B;</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">      (void)B;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline"></td>
    <td class="lineNumber">1187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  splitAroundRegion(LREdit, UsedCands);</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  splitAroundRegion(LREdit, UsedCands);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">//                            Per-Block Splitting</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">//                            Per-Block Splitting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline"></td>
    <td class="lineNumber">1195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">/// tryBlockSplit - Split a global live range around every block with uses. This</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">/// tryBlockSplit - Split a global live range around every block with uses. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">/// creates a lot of local live ranges, that will be split by tryLocalSplit if</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">/// creates a lot of local live ranges, that will be split by tryLocalSplit if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">/// they don't allocate.</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">/// they don't allocate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">unsigned RAGreedy::tryBlockSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">unsigned RAGreedy::tryBlockSplit(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">                                 AllocationOrder &Order,</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">                                 AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  assert(&SA->getParent() == &VirtReg && "Live range wasn't analyzed");</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  assert(&SA->getParent() == &VirtReg && "Live range wasn't analyzed");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">  Register Reg = VirtReg.reg();</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">  Register Reg = VirtReg.reg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">  SE->reset(LREdit, SplitSpillMode);</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">  SE->reset(LREdit, SplitSpillMode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">    if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">    if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">      SE->splitSingleBlock(BI);</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">      SE->splitSingleBlock(BI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  // No blocks were split.</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  // No blocks were split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  if (LREdit.empty())</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  if (LREdit.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  // We did split for some blocks.</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  // We did split for some blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  SmallVector<unsigned, 8> IntvMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  SE->finish(&IntvMap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  // Tell LiveDebugVariables about the new ranges.</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  // Tell LiveDebugVariables about the new ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline"></td>
    <td class="lineNumber">1222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  // Sort out the new intervals created by splitting. The remainder interval</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  // Sort out the new intervals created by splitting. The remainder interval</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  // goes straight to spilling, the new local ranges get to stay RS_New.</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  // goes straight to spilling, the new local ranges get to stay RS_New.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">    const LiveInterval &LI = LIS->getInterval(LREdit.get(I));</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">    const LiveInterval &LI = LIS->getInterval(LREdit.get(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">    if (ExtraInfo->getOrInitStage(LI.reg()) == RS_New && IntvMap[I] == 0)</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">    if (ExtraInfo->getOrInitStage(LI.reg()) == RS_New && IntvMap[I] == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">      ExtraInfo->setStage(LI, RS_Spill);</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">      ExtraInfo->setStage(LI, RS_Spill);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline"></td>
    <td class="lineNumber">1230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  if (VerifyEnabled)</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  if (VerifyEnabled)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">    MF->verify(this, "After splitting live range around basic blocks");</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">    MF->verify(this, "After splitting live range around basic blocks");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline"></td>
    <td class="lineNumber">1235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">//                         Per-Instruction Splitting</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">//                         Per-Instruction Splitting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
    <td class="lineNumber">1239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">/// Get the number of allocatable registers that match the constraints of \p Reg</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">/// Get the number of allocatable registers that match the constraints of \p Reg</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">/// on \p MI and that are also in \p SuperRC.</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">/// on \p MI and that are also in \p SuperRC.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">static unsigned getNumAllocatableRegsForConstraints(</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">static unsigned getNumAllocatableRegsForConstraints(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">    const MachineInstr *MI, Register Reg, const TargetRegisterClass *SuperRC,</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">    const MachineInstr *MI, Register Reg, const TargetRegisterClass *SuperRC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">    const TargetInstrInfo *TII, const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">    const TargetInstrInfo *TII, const TargetRegisterInfo *TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">    const RegisterClassInfo &RCI) {</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">    const RegisterClassInfo &RCI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">  assert(SuperRC && "Invalid register class");</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">  assert(SuperRC && "Invalid register class");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline"></td>
    <td class="lineNumber">1247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  const TargetRegisterClass *ConstrainedRC =</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  const TargetRegisterClass *ConstrainedRC =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">      MI->getRegClassConstraintEffectForVReg(Reg, SuperRC, TII, TRI,</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">      MI->getRegClassConstraintEffectForVReg(Reg, SuperRC, TII, TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">                                             /* ExploreBundle */ true);</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">                                             /* ExploreBundle */ true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  if (!ConstrainedRC)</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  if (!ConstrainedRC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  return RCI.getNumAllocatableRegs(ConstrainedRC);</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  return RCI.getNumAllocatableRegs(ConstrainedRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline"></td>
    <td class="lineNumber">1255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">static LaneBitmask getInstReadLaneMask(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">static LaneBitmask getInstReadLaneMask(const MachineRegisterInfo &MRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">                                       const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">                                       const TargetRegisterInfo &TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">                                       const MachineInstr &MI, Register Reg) {</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">                                       const MachineInstr &MI, Register Reg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  LaneBitmask Mask;</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  LaneBitmask Mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  for (const MachineOperand &MO : MI.operands()) {</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  for (const MachineOperand &MO : MI.operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">    if (!MO.isReg() || MO.getReg() != Reg)</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">    if (!MO.isReg() || MO.getReg() != Reg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline"></td>
    <td class="lineNumber">1263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">    unsigned SubReg = MO.getSubReg();</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">    unsigned SubReg = MO.getSubReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">    if (SubReg == 0 && MO.isUse()) {</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">    if (SubReg == 0 && MO.isUse()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">      Mask |= MRI.getMaxLaneMaskForVReg(Reg);</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">      Mask |= MRI.getMaxLaneMaskForVReg(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">    LaneBitmask SubRegMask = TRI.getSubRegIndexLaneMask(SubReg);</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">    LaneBitmask SubRegMask = TRI.getSubRegIndexLaneMask(SubReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">    if (MO.isDef()) {</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">    if (MO.isDef()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">      if (!MO.isUndef())</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">      if (!MO.isUndef())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">        Mask |= ~SubRegMask;</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">        Mask |= ~SubRegMask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">      Mask |= SubRegMask;</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">      Mask |= SubRegMask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  return Mask;</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  return Mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline"></td>
    <td class="lineNumber">1280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">/// Return true if \p MI at \P Use reads a subset of the lanes live in \p</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">/// Return true if \p MI at \P Use reads a subset of the lanes live in \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">/// VirtReg.</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">/// VirtReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">static bool readsLaneSubset(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">static bool readsLaneSubset(const MachineRegisterInfo &MRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">                            const MachineInstr *MI, const LiveInterval &VirtReg,</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">                            const MachineInstr *MI, const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">                            const TargetRegisterInfo *TRI, SlotIndex Use) {</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">                            const TargetRegisterInfo *TRI, SlotIndex Use) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  // Early check the common case.</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  // Early check the common case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  if (MI->isCopy() &&</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  if (MI->isCopy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">      MI->getOperand(0).getSubReg() == MI->getOperand(1).getSubReg())</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">      MI->getOperand(0).getSubReg() == MI->getOperand(1).getSubReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline"></td>
    <td class="lineNumber">1290</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">  // FIXME: We're only considering uses, but should be consider defs too?</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">  // FIXME: We're only considering uses, but should be consider defs too?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">  LaneBitmask ReadMask = getInstReadLaneMask(MRI, *TRI, *MI, VirtReg.reg());</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">  LaneBitmask ReadMask = getInstReadLaneMask(MRI, *TRI, *MI, VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">  LaneBitmask LiveAtMask;</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">  LaneBitmask LiveAtMask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">  for (const LiveInterval::SubRange &S : VirtReg.subranges()) {</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">  for (const LiveInterval::SubRange &S : VirtReg.subranges()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">    if (S.liveAt(Use))</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">    if (S.liveAt(Use))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">      LiveAtMask |= S.LaneMask;</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">      LiveAtMask |= S.LaneMask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline"></td>
    <td class="lineNumber">1299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">  // If the live lanes aren't different from the lanes used by the instruction,</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">  // If the live lanes aren't different from the lanes used by the instruction,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">  // this doesn't help.</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">  // this doesn't help.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">  return (ReadMask & ~(LiveAtMask & TRI->getCoveringLanes())).any();</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">  return (ReadMask & ~(LiveAtMask & TRI->getCoveringLanes())).any();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline"></td>
    <td class="lineNumber">1304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">/// tryInstructionSplit - Split a live range around individual instructions.</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">/// tryInstructionSplit - Split a live range around individual instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">/// This is normally not worthwhile since the spiller is doing essentially the</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">/// This is normally not worthwhile since the spiller is doing essentially the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">/// same thing. However, when the live range is in a constrained register</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">/// same thing. However, when the live range is in a constrained register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">/// class, it may help to insert copies such that parts of the live range can</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">/// class, it may help to insert copies such that parts of the live range can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">/// be moved to a larger register class.</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">/// be moved to a larger register class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">/// This is similar to spilling to a larger register class.</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">/// This is similar to spilling to a larger register class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">unsigned RAGreedy::tryInstructionSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">unsigned RAGreedy::tryInstructionSplit(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">                                       AllocationOrder &Order,</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">                                       AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">                                       SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">                                       SmallVectorImpl<Register> &NewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  // There is no point to this if there are no larger sub-classes.</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  // There is no point to this if there are no larger sub-classes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  bool SplitSubClass = true;</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  bool SplitSubClass = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  if (!RegClassInfo.isProperSubClass(CurRC)) {</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  if (!RegClassInfo.isProperSubClass(CurRC)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">    if (!VirtReg.hasSubRanges())</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">    if (!VirtReg.hasSubRanges())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">      return 0;</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">      return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">    SplitSubClass = false;</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">    SplitSubClass = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">  // Always enable split spill mode, since we're effectively spilling to a</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">  // Always enable split spill mode, since we're effectively spilling to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">  // register.</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">  // register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">  SE->reset(LREdit, SplitEditor::SM_Size);</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">  SE->reset(LREdit, SplitEditor::SM_Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">  if (Uses.size() <= 1)</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">  if (Uses.size() <= 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline"></td>
    <td class="lineNumber">1333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Split around " << Uses.size()</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Split around " << Uses.size()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">                    << " individual instrs.\n");</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">                    << " individual instrs.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline"></td>
    <td class="lineNumber">1336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  const TargetRegisterClass *SuperRC =</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  const TargetRegisterClass *SuperRC =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">      TRI->getLargestLegalSuperClass(CurRC, *MF);</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">      TRI->getLargestLegalSuperClass(CurRC, *MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">  unsigned SuperRCNumAllocatableRegs =</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">  unsigned SuperRCNumAllocatableRegs =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">      RegClassInfo.getNumAllocatableRegs(SuperRC);</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">      RegClassInfo.getNumAllocatableRegs(SuperRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  // Split around every non-copy instruction if this split will relax</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  // Split around every non-copy instruction if this split will relax</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  // the constraints on the virtual register.</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  // the constraints on the virtual register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">  // Otherwise, splitting just inserts uncoalescable copies that do not help</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">  // Otherwise, splitting just inserts uncoalescable copies that do not help</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">  // the allocation.</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">  // the allocation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">  for (const SlotIndex Use : Uses) {</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">  for (const SlotIndex Use : Uses) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">    if (const MachineInstr *MI = Indexes->getInstructionFromIndex(Use)) {</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">    if (const MachineInstr *MI = Indexes->getInstructionFromIndex(Use)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">      if (MI->isFullCopy() ||</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">      if (MI->isFullCopy() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">          (SplitSubClass &&</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">          (SplitSubClass &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">           SuperRCNumAllocatableRegs ==</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">           SuperRCNumAllocatableRegs ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">               getNumAllocatableRegsForConstraints(MI, VirtReg.reg(), SuperRC,</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">               getNumAllocatableRegsForConstraints(MI, VirtReg.reg(), SuperRC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">                                                   TII, TRI, RegClassInfo)) ||</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">                                                   TII, TRI, RegClassInfo)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">          // TODO: Handle split for subranges with subclass constraints?</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">          // TODO: Handle split for subranges with subclass constraints?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">          (!SplitSubClass && VirtReg.hasSubRanges() &&</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">          (!SplitSubClass && VirtReg.hasSubRanges() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">           !readsLaneSubset(*MRI, MI, VirtReg, TRI, Use))) {</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">           !readsLaneSubset(*MRI, MI, VirtReg, TRI, Use))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "    skip:\t" << Use << '\t' << *MI);</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "    skip:\t" << Use << '\t' << *MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">    SE->openIntv();</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">    SE->openIntv();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">    SlotIndex SegStart = SE->enterIntvBefore(Use);</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">    SlotIndex SegStart = SE->enterIntvBefore(Use);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">    SlotIndex SegStop = SE->leaveIntvAfter(Use);</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">    SlotIndex SegStop = SE->leaveIntvAfter(Use);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">    SE->useIntv(SegStart, SegStop);</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">    SE->useIntv(SegStart, SegStop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">  if (LREdit.empty()) {</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">  if (LREdit.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "All uses were copies.\n");</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "All uses were copies.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline"></td>
    <td class="lineNumber">1369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  SmallVector<unsigned, 8> IntvMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  SE->finish(&IntvMap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">  // Assign all new registers to RS_Spill. This was the last chance.</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">  // Assign all new registers to RS_Spill. This was the last chance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  ExtraInfo->setStage(LREdit.begin(), LREdit.end(), RS_Spill);</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  ExtraInfo->setStage(LREdit.begin(), LREdit.end(), RS_Spill);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline"></td>
    <td class="lineNumber">1377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">//                             Local Splitting</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">//                             Local Splitting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline"></td>
    <td class="lineNumber">1381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">/// calcGapWeights - Compute the maximum spill weight that needs to be evicted</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">/// calcGapWeights - Compute the maximum spill weight that needs to be evicted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">/// in order to use PhysReg between two entries in SA->UseSlots.</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">/// in order to use PhysReg between two entries in SA->UseSlots.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">/// GapWeight[I] represents the gap between UseSlots[I] and UseSlots[I + 1].</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">/// GapWeight[I] represents the gap between UseSlots[I] and UseSlots[I + 1].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">void RAGreedy::calcGapWeights(MCRegister PhysReg,</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">void RAGreedy::calcGapWeights(MCRegister PhysReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">                              SmallVectorImpl<float> &GapWeight) {</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">                              SmallVectorImpl<float> &GapWeight) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  const unsigned NumGaps = Uses.size()-1;</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  const unsigned NumGaps = Uses.size()-1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  // Start and end points for the interference check.</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  // Start and end points for the interference check.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">  SlotIndex StartIdx =</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">  SlotIndex StartIdx =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">    BI.LiveIn ? BI.FirstInstr.getBaseIndex() : BI.FirstInstr;</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">    BI.LiveIn ? BI.FirstInstr.getBaseIndex() : BI.FirstInstr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  SlotIndex StopIdx =</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  SlotIndex StopIdx =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">    BI.LiveOut ? BI.LastInstr.getBoundaryIndex() : BI.LastInstr;</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">    BI.LiveOut ? BI.LastInstr.getBoundaryIndex() : BI.LastInstr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  GapWeight.assign(NumGaps, 0.0f);</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  GapWeight.assign(NumGaps, 0.0f);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline"></td>
    <td class="lineNumber">1401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  // Add interference from each overlapping register.</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  // Add interference from each overlapping register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">    if (!Matrix->query(const_cast<LiveInterval &>(SA->getParent()), Unit)</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">    if (!Matrix->query(const_cast<LiveInterval &>(SA->getParent()), Unit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">             .checkInterference())</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">             .checkInterference())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline"></td>
    <td class="lineNumber">1407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">    // We know that VirtReg is a continuous interval from FirstInstr to</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">    // We know that VirtReg is a continuous interval from FirstInstr to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">    // LastInstr, so we don't need InterferenceQuery.</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">    // LastInstr, so we don't need InterferenceQuery.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">    // Interference that overlaps an instruction is counted in both gaps</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">    // Interference that overlaps an instruction is counted in both gaps</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">    // surrounding the instruction. The exception is interference before</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">    // surrounding the instruction. The exception is interference before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">    // StartIdx and after StopIdx.</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">    // StartIdx and after StopIdx.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">    LiveIntervalUnion::SegmentIter IntI =</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">    LiveIntervalUnion::SegmentIter IntI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">        Matrix->getLiveUnions()[Unit].find(StartIdx);</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">        Matrix->getLiveUnions()[Unit].find(StartIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">    for (unsigned Gap = 0; IntI.valid() && IntI.start() < StopIdx; ++IntI) {</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">    for (unsigned Gap = 0; IntI.valid() && IntI.start() < StopIdx; ++IntI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">      // Skip the gaps before IntI.</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">      // Skip the gaps before IntI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">      while (Uses[Gap+1].getBoundaryIndex() < IntI.start())</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">      while (Uses[Gap+1].getBoundaryIndex() < IntI.start())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">        if (++Gap == NumGaps)</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">        if (++Gap == NumGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">      if (Gap == NumGaps)</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">      if (Gap == NumGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline"></td>
    <td class="lineNumber">1424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">      // Update the gaps covered by IntI.</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">      // Update the gaps covered by IntI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">      const float weight = IntI.value()->weight();</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">      const float weight = IntI.value()->weight();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">      for (; Gap != NumGaps; ++Gap) {</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">      for (; Gap != NumGaps; ++Gap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">        GapWeight[Gap] = std::max(GapWeight[Gap], weight);</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">        GapWeight[Gap] = std::max(GapWeight[Gap], weight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">        if (Uses[Gap+1].getBaseIndex() >= IntI.stop())</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">        if (Uses[Gap+1].getBaseIndex() >= IntI.stop())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">      if (Gap == NumGaps)</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">      if (Gap == NumGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline"></td>
    <td class="lineNumber">1436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">  // Add fixed interference.</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">  // Add fixed interference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">    const LiveRange &LR = LIS->getRegUnit(Unit);</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">    const LiveRange &LR = LIS->getRegUnit(Unit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">    LiveRange::const_iterator I = LR.find(StartIdx);</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">    LiveRange::const_iterator I = LR.find(StartIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">    LiveRange::const_iterator E = LR.end();</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">    LiveRange::const_iterator E = LR.end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline"></td>
    <td class="lineNumber">1442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">    // Same loop as above. Mark any overlapped gaps as HUGE_VALF.</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">    // Same loop as above. Mark any overlapped gaps as HUGE_VALF.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">    for (unsigned Gap = 0; I != E && I->start < StopIdx; ++I) {</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">    for (unsigned Gap = 0; I != E && I->start < StopIdx; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">      while (Uses[Gap+1].getBoundaryIndex() < I->start)</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">      while (Uses[Gap+1].getBoundaryIndex() < I->start)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">        if (++Gap == NumGaps)</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">        if (++Gap == NumGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">      if (Gap == NumGaps)</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">      if (Gap == NumGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">      for (; Gap != NumGaps; ++Gap) {</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">      for (; Gap != NumGaps; ++Gap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">        GapWeight[Gap] = huge_valf;</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">        GapWeight[Gap] = huge_valf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">        if (Uses[Gap+1].getBaseIndex() >= I->end)</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">        if (Uses[Gap+1].getBaseIndex() >= I->end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">      if (Gap == NumGaps)</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">      if (Gap == NumGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline"></td>
    <td class="lineNumber">1461</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">/// tryLocalSplit - Try to split VirtReg into smaller intervals inside its only</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">/// tryLocalSplit - Try to split VirtReg into smaller intervals inside its only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">/// basic block.</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">/// basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">unsigned RAGreedy::tryLocalSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">unsigned RAGreedy::tryLocalSplit(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">                                 AllocationOrder &Order,</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">                                 AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  // TODO: the function currently only handles a single UseBlock; it should be</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  // TODO: the function currently only handles a single UseBlock; it should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  // possible to generalize.</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  // possible to generalize.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">  if (SA->getUseBlocks().size() != 1)</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">  if (SA->getUseBlocks().size() != 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline"></td>
    <td class="lineNumber">1472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline"></td>
    <td class="lineNumber">1474</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">  // Note that it is possible to have an interval that is live-in or live-out</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">  // Note that it is possible to have an interval that is live-in or live-out</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  // while only covering a single block - A phi-def can use undef values from</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  // while only covering a single block - A phi-def can use undef values from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">  // predecessors, and the block could be a single-block loop.</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">  // predecessors, and the block could be a single-block loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">  // We don't bother doing anything clever about such a case, we simply assume</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">  // We don't bother doing anything clever about such a case, we simply assume</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">  // that the interval is continuous from FirstInstr to LastInstr. We should</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">  // that the interval is continuous from FirstInstr to LastInstr. We should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  // make sure that we don't do anything illegal to such an interval, though.</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  // make sure that we don't do anything illegal to such an interval, though.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  if (Uses.size() <= 2)</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  if (Uses.size() <= 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">  const unsigned NumGaps = Uses.size()-1;</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">  const unsigned NumGaps = Uses.size()-1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline"></td>
    <td class="lineNumber">1486</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">  LLVM_DEBUG({</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">  LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">    dbgs() << "tryLocalSplit: ";</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">    dbgs() << "tryLocalSplit: ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">    for (const auto &Use : Uses)</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">    for (const auto &Use : Uses)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">      dbgs() << ' ' << Use;</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">      dbgs() << ' ' << Use;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">    dbgs() << '\n';</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">    dbgs() << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline"></td>
    <td class="lineNumber">1493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  // If VirtReg is live across any register mask operands, compute a list of</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  // If VirtReg is live across any register mask operands, compute a list of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">  // gaps with register masks.</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">  // gaps with register masks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  SmallVector<unsigned, 8> RegMaskGaps;</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  SmallVector<unsigned, 8> RegMaskGaps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  if (Matrix->checkRegMaskInterference(VirtReg)) {</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  if (Matrix->checkRegMaskInterference(VirtReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">    // Get regmask slots for the whole block.</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">    // Get regmask slots for the whole block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">    ArrayRef<SlotIndex> RMS = LIS->getRegMaskSlotsInBlock(BI.MBB->getNumber());</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">    ArrayRef<SlotIndex> RMS = LIS->getRegMaskSlotsInBlock(BI.MBB->getNumber());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << RMS.size() << " regmasks in block:");</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << RMS.size() << " regmasks in block:");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">    // Constrain to VirtReg's live range.</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">    // Constrain to VirtReg's live range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">    unsigned RI =</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">    unsigned RI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">        llvm::lower_bound(RMS, Uses.front().getRegSlot()) - RMS.begin();</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">        llvm::lower_bound(RMS, Uses.front().getRegSlot()) - RMS.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">    unsigned RE = RMS.size();</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">    unsigned RE = RMS.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">    for (unsigned I = 0; I != NumGaps && RI != RE; ++I) {</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">    for (unsigned I = 0; I != NumGaps && RI != RE; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">      // Look for Uses[I] <= RMS <= Uses[I + 1].</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">      // Look for Uses[I] <= RMS <= Uses[I + 1].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">      assert(!SlotIndex::isEarlierInstr(RMS[RI], Uses[I]));</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">      assert(!SlotIndex::isEarlierInstr(RMS[RI], Uses[I]));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">      if (SlotIndex::isEarlierInstr(Uses[I + 1], RMS[RI]))</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">      if (SlotIndex::isEarlierInstr(Uses[I + 1], RMS[RI]))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">      // Skip a regmask on the same instruction as the last use. It doesn't</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">      // Skip a regmask on the same instruction as the last use. It doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">      // overlap the live range.</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">      // overlap the live range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">      if (SlotIndex::isSameInstr(Uses[I + 1], RMS[RI]) && I + 1 == NumGaps)</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">      if (SlotIndex::isSameInstr(Uses[I + 1], RMS[RI]) && I + 1 == NumGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << ' ' << RMS[RI] << ':' << Uses[I] << '-'</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << ' ' << RMS[RI] << ':' << Uses[I] << '-'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">                        << Uses[I + 1]);</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">                        << Uses[I + 1]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">      RegMaskGaps.push_back(I);</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">      RegMaskGaps.push_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">      // Advance ri to the next gap. A regmask on one of the uses counts in</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">      // Advance ri to the next gap. A regmask on one of the uses counts in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">      // both gaps.</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">      // both gaps.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">      while (RI != RE && SlotIndex::isEarlierInstr(RMS[RI], Uses[I + 1]))</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">      while (RI != RE && SlotIndex::isEarlierInstr(RMS[RI], Uses[I + 1]))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">        ++RI;</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">        ++RI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << '\n');</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline"></td>
    <td class="lineNumber">1524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">  // Since we allow local split results to be split again, there is a risk of</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">  // Since we allow local split results to be split again, there is a risk of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">  // creating infinite loops. It is tempting to require that the new live</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">  // creating infinite loops. It is tempting to require that the new live</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">  // ranges have less instructions than the original. That would guarantee</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">  // ranges have less instructions than the original. That would guarantee</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">  // convergence, but it is too strict. A live range with 3 instructions can be</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">  // convergence, but it is too strict. A live range with 3 instructions can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">  // split 2+3 (including the COPY), and we want to allow that.</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">  // split 2+3 (including the COPY), and we want to allow that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">  // Instead we use these rules:</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">  // Instead we use these rules:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">  // 1. Allow any split for ranges with getStage() < RS_Split2. (Except for the</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">  // 1. Allow any split for ranges with getStage() < RS_Split2. (Except for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">  //    noop split, of course).</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">  //    noop split, of course).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">  // 2. Require progress be made for ranges with getStage() == RS_Split2. All</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">  // 2. Require progress be made for ranges with getStage() == RS_Split2. All</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">  //    the new ranges must have fewer instructions than before the split.</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">  //    the new ranges must have fewer instructions than before the split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">  // 3. New ranges with the same number of instructions are marked RS_Split2,</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">  // 3. New ranges with the same number of instructions are marked RS_Split2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  //    smaller ranges are marked RS_New.</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  //    smaller ranges are marked RS_New.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">  // These rules allow a 3 -> 2+3 split once, which we need. They also prevent</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">  // These rules allow a 3 -> 2+3 split once, which we need. They also prevent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">  // excessive splitting and infinite loops.</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">  // excessive splitting and infinite loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  bool ProgressRequired = ExtraInfo->getStage(VirtReg) >= RS_Split2;</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  bool ProgressRequired = ExtraInfo->getStage(VirtReg) >= RS_Split2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">  // Best split candidate.</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">  // Best split candidate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  unsigned BestBefore = NumGaps;</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  unsigned BestBefore = NumGaps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">  unsigned BestAfter = 0;</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">  unsigned BestAfter = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">  float BestDiff = 0;</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">  float BestDiff = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline"></td>
    <td class="lineNumber">1549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  const float blockFreq =</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  const float blockFreq =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">    SpillPlacer->getBlockFrequency(BI.MBB->getNumber()).getFrequency() *</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">    SpillPlacer->getBlockFrequency(BI.MBB->getNumber()).getFrequency() *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">    (1.0f / MBFI->getEntryFreq());</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">    (1.0f / MBFI->getEntryFreq());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  SmallVector<float, 8> GapWeight;</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  SmallVector<float, 8> GapWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline"></td>
    <td class="lineNumber">1554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">  for (MCPhysReg PhysReg : Order) {</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">  for (MCPhysReg PhysReg : Order) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">    assert(PhysReg);</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">    assert(PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">    // Keep track of the largest spill weight that would need to be evicted in</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">    // Keep track of the largest spill weight that would need to be evicted in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">    // order to make use of PhysReg between UseSlots[I] and UseSlots[I + 1].</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">    // order to make use of PhysReg between UseSlots[I] and UseSlots[I + 1].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">    calcGapWeights(PhysReg, GapWeight);</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">    calcGapWeights(PhysReg, GapWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline"></td>
    <td class="lineNumber">1560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">    // Remove any gaps with regmask clobbers.</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">    // Remove any gaps with regmask clobbers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">    if (Matrix->checkRegMaskInterference(VirtReg, PhysReg))</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">    if (Matrix->checkRegMaskInterference(VirtReg, PhysReg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">      for (unsigned I = 0, E = RegMaskGaps.size(); I != E; ++I)</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">      for (unsigned I = 0, E = RegMaskGaps.size(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">        GapWeight[RegMaskGaps[I]] = huge_valf;</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">        GapWeight[RegMaskGaps[I]] = huge_valf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline"></td>
    <td class="lineNumber">1565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">    // Try to find the best sequence of gaps to close.</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">    // Try to find the best sequence of gaps to close.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">    // The new spill weight must be larger than any gap interference.</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">    // The new spill weight must be larger than any gap interference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">    // We will split before Uses[SplitBefore] and after Uses[SplitAfter].</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">    // We will split before Uses[SplitBefore] and after Uses[SplitAfter].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">    unsigned SplitBefore = 0, SplitAfter = 1;</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">    unsigned SplitBefore = 0, SplitAfter = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">    // MaxGap should always be max(GapWeight[SplitBefore..SplitAfter-1]).</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">    // MaxGap should always be max(GapWeight[SplitBefore..SplitAfter-1]).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">    // It is the spill weight that needs to be evicted.</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">    // It is the spill weight that needs to be evicted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">    float MaxGap = GapWeight[0];</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">    float MaxGap = GapWeight[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline"></td>
    <td class="lineNumber">1575</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">    while (true) {</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">    while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">      // Live before/after split?</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">      // Live before/after split?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">      const bool LiveBefore = SplitBefore != 0 || BI.LiveIn;</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">      const bool LiveBefore = SplitBefore != 0 || BI.LiveIn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">      const bool LiveAfter = SplitAfter != NumGaps || BI.LiveOut;</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">      const bool LiveAfter = SplitAfter != NumGaps || BI.LiveOut;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline"></td>
    <td class="lineNumber">1580</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << ' ' << Uses[SplitBefore]</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << ' ' << Uses[SplitBefore]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">                        << '-' << Uses[SplitAfter] << " I=" << MaxGap);</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">                        << '-' << Uses[SplitAfter] << " I=" << MaxGap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline"></td>
    <td class="lineNumber">1583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">      // Stop before the interval gets so big we wouldn't be making progress.</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">      // Stop before the interval gets so big we wouldn't be making progress.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">      if (!LiveBefore && !LiveAfter) {</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">      if (!LiveBefore && !LiveAfter) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << " all\n");</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << " all\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">      // Should the interval be extended or shrunk?</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">      // Should the interval be extended or shrunk?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">      bool Shrink = true;</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">      bool Shrink = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline"></td>
    <td class="lineNumber">1591</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">      // How many gaps would the new range have?</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">      // How many gaps would the new range have?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">      unsigned NewGaps = LiveBefore + SplitAfter - SplitBefore + LiveAfter;</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">      unsigned NewGaps = LiveBefore + SplitAfter - SplitBefore + LiveAfter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline"></td>
    <td class="lineNumber">1594</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">      // Legally, without causing looping?</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">      // Legally, without causing looping?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">      bool Legal = !ProgressRequired || NewGaps < NumGaps;</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">      bool Legal = !ProgressRequired || NewGaps < NumGaps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">      if (Legal && MaxGap < huge_valf) {</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">      if (Legal && MaxGap < huge_valf) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">        // Estimate the new spill weight. Each instruction reads or writes the</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">        // Estimate the new spill weight. Each instruction reads or writes the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">        // register. Conservatively assume there are no read-modify-write</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">        // register. Conservatively assume there are no read-modify-write</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">        // instructions.</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">        // instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">        //</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">        //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">        // Try to guess the size of the new interval.</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">        // Try to guess the size of the new interval.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">        const float EstWeight = normalizeSpillWeight(</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">        const float EstWeight = normalizeSpillWeight(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">            blockFreq * (NewGaps + 1),</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">            blockFreq * (NewGaps + 1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">            Uses[SplitBefore].distance(Uses[SplitAfter]) +</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">            Uses[SplitBefore].distance(Uses[SplitAfter]) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">                (LiveBefore + LiveAfter) * SlotIndex::InstrDist,</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">                (LiveBefore + LiveAfter) * SlotIndex::InstrDist,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">            1);</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">            1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">        // Would this split be possible to allocate?</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">        // Would this split be possible to allocate?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">        // Never allocate all gaps, we wouldn't be making progress.</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">        // Never allocate all gaps, we wouldn't be making progress.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << " w=" << EstWeight);</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << " w=" << EstWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">        if (EstWeight * Hysteresis >= MaxGap) {</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">        if (EstWeight * Hysteresis >= MaxGap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">          Shrink = false;</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">          Shrink = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">          float Diff = EstWeight - MaxGap;</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">          float Diff = EstWeight - MaxGap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">          if (Diff > BestDiff) {</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">          if (Diff > BestDiff) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">            LLVM_DEBUG(dbgs() << " (best)");</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">            LLVM_DEBUG(dbgs() << " (best)");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">            BestDiff = Hysteresis * Diff;</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">            BestDiff = Hysteresis * Diff;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">            BestBefore = SplitBefore;</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">            BestBefore = SplitBefore;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">            BestAfter = SplitAfter;</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">            BestAfter = SplitAfter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline"></td>
    <td class="lineNumber">1623</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">      // Try to shrink.</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">      // Try to shrink.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">      if (Shrink) {</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">      if (Shrink) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">        if (++SplitBefore < SplitAfter) {</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">        if (++SplitBefore < SplitAfter) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << " shrink\n");</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << " shrink\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">          // Recompute the max when necessary.</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">          // Recompute the max when necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">          if (GapWeight[SplitBefore - 1] >= MaxGap) {</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">          if (GapWeight[SplitBefore - 1] >= MaxGap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">            MaxGap = GapWeight[SplitBefore];</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">            MaxGap = GapWeight[SplitBefore];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">            for (unsigned I = SplitBefore + 1; I != SplitAfter; ++I)</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">            for (unsigned I = SplitBefore + 1; I != SplitAfter; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">              MaxGap = std::max(MaxGap, GapWeight[I]);</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">              MaxGap = std::max(MaxGap, GapWeight[I]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">        MaxGap = 0;</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">        MaxGap = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline"></td>
    <td class="lineNumber">1638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">      // Try to extend the interval.</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">      // Try to extend the interval.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">      if (SplitAfter >= NumGaps) {</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">      if (SplitAfter >= NumGaps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << " end\n");</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << " end\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << " extend\n");</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << " extend\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">      MaxGap = std::max(MaxGap, GapWeight[SplitAfter++]);</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">      MaxGap = std::max(MaxGap, GapWeight[SplitAfter++]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">  // Didn't find any candidates?</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">  // Didn't find any candidates?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">  if (BestBefore == NumGaps)</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">  if (BestBefore == NumGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline"></td>
    <td class="lineNumber">1653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Best local split range: " << Uses[BestBefore] << '-'</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Best local split range: " << Uses[BestBefore] << '-'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">                    << Uses[BestAfter] << ", " << BestDiff << ", "</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">                    << Uses[BestAfter] << ", " << BestDiff << ", "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">                    << (BestAfter - BestBefore + 1) << " instrs\n");</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">                    << (BestAfter - BestBefore + 1) << " instrs\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">  SE->reset(LREdit);</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">  SE->reset(LREdit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline"></td>
    <td class="lineNumber">1660</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">  SE->openIntv();</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">  SE->openIntv();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">  SlotIndex SegStart = SE->enterIntvBefore(Uses[BestBefore]);</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">  SlotIndex SegStart = SE->enterIntvBefore(Uses[BestBefore]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  SlotIndex SegStop  = SE->leaveIntvAfter(Uses[BestAfter]);</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  SlotIndex SegStop  = SE->leaveIntvAfter(Uses[BestAfter]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">  SE->useIntv(SegStart, SegStop);</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">  SE->useIntv(SegStart, SegStop);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">  SmallVector<unsigned, 8> IntvMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">  SE->finish(&IntvMap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">  // If the new range has the same number of instructions as before, mark it as</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">  // If the new range has the same number of instructions as before, mark it as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">  // RS_Split2 so the next split will be forced to make progress. Otherwise,</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">  // RS_Split2 so the next split will be forced to make progress. Otherwise,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">  // leave the new intervals as RS_New so they can compete.</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">  // leave the new intervals as RS_New so they can compete.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">  bool LiveBefore = BestBefore != 0 || BI.LiveIn;</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">  bool LiveBefore = BestBefore != 0 || BI.LiveIn;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">  bool LiveAfter = BestAfter != NumGaps || BI.LiveOut;</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">  bool LiveAfter = BestAfter != NumGaps || BI.LiveOut;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  unsigned NewGaps = LiveBefore + BestAfter - BestBefore + LiveAfter;</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  unsigned NewGaps = LiveBefore + BestAfter - BestBefore + LiveAfter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">  if (NewGaps >= NumGaps) {</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">  if (NewGaps >= NumGaps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Tagging non-progress ranges:");</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Tagging non-progress ranges:");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">    assert(!ProgressRequired && "Didn't make progress when it was required.");</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">    assert(!ProgressRequired && "Didn't make progress when it was required.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">    for (unsigned I = 0, E = IntvMap.size(); I != E; ++I)</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">    for (unsigned I = 0, E = IntvMap.size(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">      if (IntvMap[I] == 1) {</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">      if (IntvMap[I] == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">        ExtraInfo->setStage(LIS->getInterval(LREdit.get(I)), RS_Split2);</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">        ExtraInfo->setStage(LIS->getInterval(LREdit.get(I)), RS_Split2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << ' ' << printReg(LREdit.get(I)));</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << ' ' << printReg(LREdit.get(I)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << '\n');</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">  ++NumLocalSplits;</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">  ++NumLocalSplits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline"></td>
    <td class="lineNumber">1685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline"></td>
    <td class="lineNumber">1688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">//                          Live Range Splitting</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">//                          Live Range Splitting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline"></td>
    <td class="lineNumber">1692</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">/// trySplit - Try to split VirtReg or one of its interferences, making it</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">/// trySplit - Try to split VirtReg or one of its interferences, making it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">/// assignable.</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">/// assignable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">/// @return Physreg when VirtReg may be assigned and/or new NewVRegs.</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">/// @return Physreg when VirtReg may be assigned and/or new NewVRegs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">unsigned RAGreedy::trySplit(const LiveInterval &VirtReg, AllocationOrder &Order,</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">unsigned RAGreedy::trySplit(const LiveInterval &VirtReg, AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">                            SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">                            SmallVectorImpl<Register> &NewVRegs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">                            const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">                            const SmallVirtRegSet &FixedRegisters) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">  // Ranges must be Split2 or less.</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">  // Ranges must be Split2 or less.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">  if (ExtraInfo->getStage(VirtReg) >= RS_Spill)</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">  if (ExtraInfo->getStage(VirtReg) >= RS_Spill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline"></td>
    <td class="lineNumber">1702</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">  // Local intervals are handled separately.</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">  // Local intervals are handled separately.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">  if (LIS->intervalIsInOneMBB(VirtReg)) {</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">  if (LIS->intervalIsInOneMBB(VirtReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">    NamedRegionTimer T("local_split", "Local Splitting", TimerGroupName,</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">    NamedRegionTimer T("local_split", "Local Splitting", TimerGroupName,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">                       TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">                       TimerGroupDescription, TimePassesIsEnabled);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">    SA->analyze(&VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">    Register PhysReg = tryLocalSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">    Register PhysReg = tryLocalSplit(VirtReg, Order, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">    if (PhysReg || !NewVRegs.empty())</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">    if (PhysReg || !NewVRegs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">      return PhysReg;</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">      return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">    return tryInstructionSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">    return tryInstructionSplit(VirtReg, Order, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline"></td>
    <td class="lineNumber">1713</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  NamedRegionTimer T("global_split", "Global Splitting", TimerGroupName,</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  NamedRegionTimer T("global_split", "Global Splitting", TimerGroupName,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">                     TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">                     TimerGroupDescription, TimePassesIsEnabled);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">  SA->analyze(&VirtReg);</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">  SA->analyze(&VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline"></td>
    <td class="lineNumber">1718</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">  // First try to split around a region spanning multiple blocks. RS_Split2</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">  // First try to split around a region spanning multiple blocks. RS_Split2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  // ranges already made dubious progress with region splitting, so they go</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  // ranges already made dubious progress with region splitting, so they go</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">  // straight to single block splitting.</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">  // straight to single block splitting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  if (ExtraInfo->getStage(VirtReg) < RS_Split2) {</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  if (ExtraInfo->getStage(VirtReg) < RS_Split2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">    MCRegister PhysReg = tryRegionSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">    MCRegister PhysReg = tryRegionSplit(VirtReg, Order, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">    if (PhysReg || !NewVRegs.empty())</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">    if (PhysReg || !NewVRegs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">      return PhysReg;</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">      return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  // Then isolate blocks.</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  // Then isolate blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  return tryBlockSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  return tryBlockSplit(VirtReg, Order, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline"></td>
    <td class="lineNumber">1731</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">//                          Last Chance Recoloring</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">//                          Last Chance Recoloring</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline"></td>
    <td class="lineNumber">1735</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">/// Return true if \p reg has any tied def operand.</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">/// Return true if \p reg has any tied def operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">static bool hasTiedDef(MachineRegisterInfo *MRI, unsigned reg) {</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">static bool hasTiedDef(MachineRegisterInfo *MRI, unsigned reg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">  for (const MachineOperand &MO : MRI->def_operands(reg))</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">  for (const MachineOperand &MO : MRI->def_operands(reg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">    if (MO.isTied())</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">    if (MO.isTied())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline"></td>
    <td class="lineNumber">1741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline"></td>
    <td class="lineNumber">1744</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">/// Return true if the existing assignment of \p Intf overlaps, but is not the</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">/// Return true if the existing assignment of \p Intf overlaps, but is not the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">/// same, as \p PhysReg.</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">/// same, as \p PhysReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">static bool assignedRegPartiallyOverlaps(const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">static bool assignedRegPartiallyOverlaps(const TargetRegisterInfo &TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">                                         const VirtRegMap &VRM,</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">                                         const VirtRegMap &VRM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">                                         MCRegister PhysReg,</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">                                         MCRegister PhysReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">                                         const LiveInterval &Intf) {</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">                                         const LiveInterval &Intf) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">  MCRegister AssignedReg = VRM.getPhys(Intf.reg());</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">  MCRegister AssignedReg = VRM.getPhys(Intf.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">  if (PhysReg == AssignedReg)</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">  if (PhysReg == AssignedReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">  return TRI.regsOverlap(PhysReg, AssignedReg);</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">  return TRI.regsOverlap(PhysReg, AssignedReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline"></td>
    <td class="lineNumber">1756</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">/// mayRecolorAllInterferences - Check if the virtual registers that</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">/// mayRecolorAllInterferences - Check if the virtual registers that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">/// interfere with \p VirtReg on \p PhysReg (or one of its aliases) may be</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">/// interfere with \p VirtReg on \p PhysReg (or one of its aliases) may be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">/// recolored to free \p PhysReg.</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">/// recolored to free \p PhysReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">/// When true is returned, \p RecoloringCandidates has been augmented with all</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">/// When true is returned, \p RecoloringCandidates has been augmented with all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">/// the live intervals that need to be recolored in order to free \p PhysReg</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">/// the live intervals that need to be recolored in order to free \p PhysReg</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">/// for \p VirtReg.</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">/// for \p VirtReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">/// recolored.</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">/// recolored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">bool RAGreedy::mayRecolorAllInterferences(</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">bool RAGreedy::mayRecolorAllInterferences(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">    MCRegister PhysReg, const LiveInterval &VirtReg,</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">    MCRegister PhysReg, const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">    SmallLISet &RecoloringCandidates, const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">    SmallLISet &RecoloringCandidates, const SmallVirtRegSet &FixedRegisters) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline"></td>
    <td class="lineNumber">1769</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">    // If there is LastChanceRecoloringMaxInterference or more interferences,</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">    // If there is LastChanceRecoloringMaxInterference or more interferences,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">    // chances are one would not be recolorable.</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">    // chances are one would not be recolorable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">    if (Q.interferingVRegs(LastChanceRecoloringMaxInterference).size() >=</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">    if (Q.interferingVRegs(LastChanceRecoloringMaxInterference).size() >=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">            LastChanceRecoloringMaxInterference &&</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">            LastChanceRecoloringMaxInterference &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">        !ExhaustiveSearch) {</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">        !ExhaustiveSearch) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Early abort: too many interferences.\n");</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Early abort: too many interferences.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">      CutOffInfo |= CO_Interf;</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">      CutOffInfo |= CO_Interf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">    for (const LiveInterval *Intf : reverse(Q.interferingVRegs())) {</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">    for (const LiveInterval *Intf : reverse(Q.interferingVRegs())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">      // If Intf is done and sits on the same register class as VirtReg, it</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">      // If Intf is done and sits on the same register class as VirtReg, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">      // would not be recolorable as it is in the same state as</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">      // would not be recolorable as it is in the same state as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">      // VirtReg. However there are at least two exceptions.</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">      // VirtReg. However there are at least two exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">      // If VirtReg has tied defs and Intf doesn't, then</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">      // If VirtReg has tied defs and Intf doesn't, then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">      // there is still a point in examining if it can be recolorable.</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">      // there is still a point in examining if it can be recolorable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">      // Additionally, if the register class has overlapping tuple members, it</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">      // Additionally, if the register class has overlapping tuple members, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">      // may still be recolorable using a different tuple. This is more likely</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">      // may still be recolorable using a different tuple. This is more likely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">      // if the existing assignment aliases with the candidate.</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">      // if the existing assignment aliases with the candidate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">      if (((ExtraInfo->getStage(*Intf) == RS_Done &&</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">      if (((ExtraInfo->getStage(*Intf) == RS_Done &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">            MRI->getRegClass(Intf->reg()) == CurRC &&</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">            MRI->getRegClass(Intf->reg()) == CurRC &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">            !assignedRegPartiallyOverlaps(*TRI, *VRM, PhysReg, *Intf)) &&</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">            !assignedRegPartiallyOverlaps(*TRI, *VRM, PhysReg, *Intf)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">           !(hasTiedDef(MRI, VirtReg.reg()) &&</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">           !(hasTiedDef(MRI, VirtReg.reg()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">             !hasTiedDef(MRI, Intf->reg()))) ||</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">             !hasTiedDef(MRI, Intf->reg()))) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">          FixedRegisters.count(Intf->reg())) {</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">          FixedRegisters.count(Intf->reg())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">        LLVM_DEBUG(</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">        LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">            dbgs() << "Early abort: the interference is not recolorable.\n");</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">            dbgs() << "Early abort: the interference is not recolorable.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">      RecoloringCandidates.insert(Intf);</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">      RecoloringCandidates.insert(Intf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline"></td>
    <td class="lineNumber">1808</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">/// its interferences.</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">/// its interferences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">/// Last chance recoloring chooses a color for \p VirtReg and recolors every</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">/// Last chance recoloring chooses a color for \p VirtReg and recolors every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">/// virtual register that was using it. The recoloring process may recursively</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">/// virtual register that was using it. The recoloring process may recursively</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">/// use the last chance recoloring. Therefore, when a virtual register has been</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">/// use the last chance recoloring. Therefore, when a virtual register has been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">/// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">/// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">/// be last-chance-recolored again during this recoloring "session".</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">/// be last-chance-recolored again during this recoloring "session".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">/// E.g.,</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">/// E.g.,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">/// Let</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">/// Let</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">/// vA can use {R1, R2    }</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">/// vA can use {R1, R2    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">/// vB can use {    R2, R3}</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">/// vB can use {    R2, R3}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">/// vC can use {R1        }</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">/// vC can use {R1        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">/// Where vA, vB, and vC cannot be split anymore (they are reloads for</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">/// Where vA, vB, and vC cannot be split anymore (they are reloads for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">/// instance) and they all interfere.</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">/// instance) and they all interfere.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">/// vA is assigned R1</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">/// vA is assigned R1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">/// vB is assigned R2</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">/// vB is assigned R2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">/// vC tries to evict vA but vA is already done.</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">/// vC tries to evict vA but vA is already done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">/// Regular register allocation fails.</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">/// Regular register allocation fails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">/// Last chance recoloring kicks in:</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">/// Last chance recoloring kicks in:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">/// vC does as if vA was evicted => vC uses R1.</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">/// vC does as if vA was evicted => vC uses R1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">/// vC is marked as fixed.</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">/// vC is marked as fixed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">/// vA needs to find a color.</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">/// vA needs to find a color.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">/// None are available.</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">/// None are available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">/// vA cannot evict vC: vC is a fixed virtual register now.</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">/// vA cannot evict vC: vC is a fixed virtual register now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">/// vA does as if vB was evicted => vA uses R2.</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">/// vA does as if vB was evicted => vA uses R2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">/// vB needs to find a color.</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">/// vB needs to find a color.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">/// R3 is available.</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">/// R3 is available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">/// Recoloring => vC = R1, vA = R2, vB = R3</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">/// Recoloring => vC = R1, vA = R2, vB = R3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">/// \p Order defines the preferred allocation order for \p VirtReg.</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">/// \p Order defines the preferred allocation order for \p VirtReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">/// \p NewRegs will contain any new virtual register that have been created</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">/// \p NewRegs will contain any new virtual register that have been created</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">/// (split, spill) during the process and that must be assigned.</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">/// (split, spill) during the process and that must be assigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">/// recolored.</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">/// recolored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">/// \p RecolorStack tracks the original assignments of successfully recolored</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">/// \p RecolorStack tracks the original assignments of successfully recolored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">/// registers.</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">/// registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">/// \p Depth gives the current depth of the last chance recoloring.</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">/// \p Depth gives the current depth of the last chance recoloring.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">/// \return a physical register that can be used for VirtReg or ~0u if none</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">/// \return a physical register that can be used for VirtReg or ~0u if none</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">/// exists.</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">/// exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">unsigned RAGreedy::tryLastChanceRecoloring(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">unsigned RAGreedy::tryLastChanceRecoloring(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">                                           AllocationOrder &Order,</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">                                           AllocationOrder &Order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">                                           SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">                                           SmallVectorImpl<Register> &NewVRegs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">                                           SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">                                           SmallVirtRegSet &FixedRegisters,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">                                           RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">                                           RecoloringStack &RecolorStack,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">                                           unsigned Depth) {</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">                                           unsigned Depth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">  if (!TRI->shouldUseLastChanceRecoloringForVirtReg(*MF, VirtReg))</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  if (!TRI->shouldUseLastChanceRecoloringForVirtReg(*MF, VirtReg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">    return ~0u;</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">    return ~0u;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline"></td>
    <td class="lineNumber">1860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Try last chance recoloring for " << VirtReg << '\n');</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Try last chance recoloring for " << VirtReg << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline"></td>
    <td class="lineNumber">1862</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  const ssize_t EntryStackSize = RecolorStack.size();</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  const ssize_t EntryStackSize = RecolorStack.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline"></td>
    <td class="lineNumber">1864</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">  // Ranges must be Done.</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">  // Ranges must be Done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">  assert((ExtraInfo->getStage(VirtReg) >= RS_Done || !VirtReg.isSpillable()) &&</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">  assert((ExtraInfo->getStage(VirtReg) >= RS_Done || !VirtReg.isSpillable()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">         "Last chance recoloring should really be last chance");</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">         "Last chance recoloring should really be last chance");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">  // Set the max depth to LastChanceRecoloringMaxDepth.</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">  // Set the max depth to LastChanceRecoloringMaxDepth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">  // We may want to reconsider that if we end up with a too large search space</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">  // We may want to reconsider that if we end up with a too large search space</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">  // for target with hundreds of registers.</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">  // for target with hundreds of registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">  // Indeed, in that case we may want to cut the search space earlier.</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">  // Indeed, in that case we may want to cut the search space earlier.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">  if (Depth >= LastChanceRecoloringMaxDepth && !ExhaustiveSearch) {</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">  if (Depth >= LastChanceRecoloringMaxDepth && !ExhaustiveSearch) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Abort because max depth has been reached.\n");</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Abort because max depth has been reached.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">    CutOffInfo |= CO_Depth;</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">    CutOffInfo |= CO_Depth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">    return ~0u;</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">    return ~0u;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline"></td>
    <td class="lineNumber">1877</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  // Set of Live intervals that will need to be recolored.</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  // Set of Live intervals that will need to be recolored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">  SmallLISet RecoloringCandidates;</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">  SmallLISet RecoloringCandidates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline"></td>
    <td class="lineNumber">1880</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  // Mark VirtReg as fixed, i.e., it will not be recolored pass this point in</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  // Mark VirtReg as fixed, i.e., it will not be recolored pass this point in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">  // this recoloring "session".</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">  // this recoloring "session".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  assert(!FixedRegisters.count(VirtReg.reg()));</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  assert(!FixedRegisters.count(VirtReg.reg()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">  FixedRegisters.insert(VirtReg.reg());</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">  FixedRegisters.insert(VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">  SmallVector<Register, 4> CurrentNewVRegs;</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">  SmallVector<Register, 4> CurrentNewVRegs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline"></td>
    <td class="lineNumber">1886</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">  for (MCRegister PhysReg : Order) {</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">  for (MCRegister PhysReg : Order) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">    assert(PhysReg.isValid());</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">    assert(PhysReg.isValid());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Try to assign: " << VirtReg << " to "</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Try to assign: " << VirtReg << " to "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">                      << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">                      << printReg(PhysReg, TRI) << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">    RecoloringCandidates.clear();</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">    RecoloringCandidates.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">    CurrentNewVRegs.clear();</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">    CurrentNewVRegs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline"></td>
    <td class="lineNumber">1893</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">    // It is only possible to recolor virtual register interference.</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">    // It is only possible to recolor virtual register interference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">    if (Matrix->checkInterference(VirtReg, PhysReg) ></td>
    <td class="lineNumber">1895</td>
    <td class="codeline">    if (Matrix->checkInterference(VirtReg, PhysReg) ></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">        LiveRegMatrix::IK_VirtReg) {</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">        LiveRegMatrix::IK_VirtReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">      LLVM_DEBUG(</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">      LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">          dbgs() << "Some interferences are not with virtual registers.\n");</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">          dbgs() << "Some interferences are not with virtual registers.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline"></td>
    <td class="lineNumber">1899</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline"></td>
    <td class="lineNumber">1902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">    // Early give up on this PhysReg if it is obvious we cannot recolor all</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">    // Early give up on this PhysReg if it is obvious we cannot recolor all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">    // the interferences.</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">    // the interferences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">    if (!mayRecolorAllInterferences(PhysReg, VirtReg, RecoloringCandidates,</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">    if (!mayRecolorAllInterferences(PhysReg, VirtReg, RecoloringCandidates,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">                                    FixedRegisters)) {</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">                                    FixedRegisters)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Some interferences cannot be recolored.\n");</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Some interferences cannot be recolored.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline"></td>
    <td class="lineNumber">1910</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">    // RecoloringCandidates contains all the virtual registers that interfere</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">    // RecoloringCandidates contains all the virtual registers that interfere</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">    // with VirtReg on PhysReg (or one of its aliases). Enqueue them for</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">    // with VirtReg on PhysReg (or one of its aliases). Enqueue them for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">    // recoloring and perform the actual recoloring.</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">    // recoloring and perform the actual recoloring.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">    PQueue RecoloringQueue;</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">    PQueue RecoloringQueue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">    for (const LiveInterval *RC : RecoloringCandidates) {</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">    for (const LiveInterval *RC : RecoloringCandidates) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">      Register ItVirtReg = RC->reg();</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">      Register ItVirtReg = RC->reg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">      enqueue(RecoloringQueue, RC);</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">      enqueue(RecoloringQueue, RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">      assert(VRM->hasPhys(ItVirtReg) &&</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">      assert(VRM->hasPhys(ItVirtReg) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">             "Interferences are supposed to be with allocated variables");</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">             "Interferences are supposed to be with allocated variables");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline"></td>
    <td class="lineNumber">1920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">      // Record the current allocation.</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">      // Record the current allocation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">      RecolorStack.push_back(std::make_pair(RC, VRM->getPhys(ItVirtReg)));</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">      RecolorStack.push_back(std::make_pair(RC, VRM->getPhys(ItVirtReg)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">      // unset the related struct.</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">      // unset the related struct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">      Matrix->unassign(*RC);</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">      Matrix->unassign(*RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline"></td>
    <td class="lineNumber">1927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">    // Do as if VirtReg was assigned to PhysReg so that the underlying</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">    // Do as if VirtReg was assigned to PhysReg so that the underlying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">    // recoloring has the right information about the interferes and</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">    // recoloring has the right information about the interferes and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">    // available colors.</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">    // available colors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">    Matrix->assign(VirtReg, PhysReg);</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">    Matrix->assign(VirtReg, PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
    <td class="lineNumber">1932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">    // Save the current recoloring state.</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">    // Save the current recoloring state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">    // If we cannot recolor all the interferences, we will have to start again</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">    // If we cannot recolor all the interferences, we will have to start again</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">    // at this point for the next physical register.</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">    // at this point for the next physical register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">    SmallVirtRegSet SaveFixedRegisters(FixedRegisters);</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">    SmallVirtRegSet SaveFixedRegisters(FixedRegisters);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">    if (tryRecoloringCandidates(RecoloringQueue, CurrentNewVRegs,</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">    if (tryRecoloringCandidates(RecoloringQueue, CurrentNewVRegs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">                                FixedRegisters, RecolorStack, Depth)) {</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">                                FixedRegisters, RecolorStack, Depth)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">      // Push the queued vregs into the main queue.</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">      // Push the queued vregs into the main queue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">      for (Register NewVReg : CurrentNewVRegs)</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">      for (Register NewVReg : CurrentNewVRegs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">        NewVRegs.push_back(NewVReg);</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">        NewVRegs.push_back(NewVReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">      // Do not mess up with the global assignment process.</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">      // Do not mess up with the global assignment process.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">      // I.e., VirtReg must be unassigned.</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">      // I.e., VirtReg must be unassigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">      Matrix->unassign(VirtReg);</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">      Matrix->unassign(VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">      return PhysReg;</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">      return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Fail to assign: " << VirtReg << " to "</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Fail to assign: " << VirtReg << " to "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">                      << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">                      << printReg(PhysReg, TRI) << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline"></td>
    <td class="lineNumber">1950</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">    // The recoloring attempt failed, undo the changes.</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">    // The recoloring attempt failed, undo the changes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">    FixedRegisters = SaveFixedRegisters;</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">    FixedRegisters = SaveFixedRegisters;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">    Matrix->unassign(VirtReg);</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">    Matrix->unassign(VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline"></td>
    <td class="lineNumber">1954</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">    // For a newly created vreg which is also in RecoloringCandidates,</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">    // For a newly created vreg which is also in RecoloringCandidates,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">    // don't add it to NewVRegs because its physical register will be restored</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">    // don't add it to NewVRegs because its physical register will be restored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">    // below. Other vregs in CurrentNewVRegs are created by calling</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">    // below. Other vregs in CurrentNewVRegs are created by calling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">    // selectOrSplit and should be added into NewVRegs.</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">    // selectOrSplit and should be added into NewVRegs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">    for (Register R : CurrentNewVRegs) {</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">    for (Register R : CurrentNewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">      if (RecoloringCandidates.count(&LIS->getInterval(R)))</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">      if (RecoloringCandidates.count(&LIS->getInterval(R)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">      NewVRegs.push_back(R);</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">      NewVRegs.push_back(R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline"></td>
    <td class="lineNumber">1964</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">    // Roll back our unsuccessful recoloring. Also roll back any successful</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">    // Roll back our unsuccessful recoloring. Also roll back any successful</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">    // recolorings in any recursive recoloring attempts, since it's possible</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">    // recolorings in any recursive recoloring attempts, since it's possible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">    // they would have introduced conflicts with assignments we will be</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">    // they would have introduced conflicts with assignments we will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">    // restoring further up the stack. Perform all unassignments prior to</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">    // restoring further up the stack. Perform all unassignments prior to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">    // reassigning, since sub-recolorings may have conflicted with the registers</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">    // reassigning, since sub-recolorings may have conflicted with the registers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">    // we are going to restore to their original assignments.</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">    // we are going to restore to their original assignments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">    for (ssize_t I = RecolorStack.size() - 1; I >= EntryStackSize; --I) {</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">    for (ssize_t I = RecolorStack.size() - 1; I >= EntryStackSize; --I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">      const LiveInterval *LI;</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">      const LiveInterval *LI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">      MCRegister PhysReg;</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">      MCRegister PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline"></td>
    <td class="lineNumber">1975</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">      if (VRM->hasPhys(LI->reg()))</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">      if (VRM->hasPhys(LI->reg()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">        Matrix->unassign(*LI);</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">        Matrix->unassign(*LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline"></td>
    <td class="lineNumber">1979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">    for (size_t I = EntryStackSize; I != RecolorStack.size(); ++I) {</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">    for (size_t I = EntryStackSize; I != RecolorStack.size(); ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">      const LiveInterval *LI;</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">      const LiveInterval *LI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">      MCRegister PhysReg;</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">      MCRegister PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">      if (!LI->empty() && !MRI->reg_nodbg_empty(LI->reg()))</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">      if (!LI->empty() && !MRI->reg_nodbg_empty(LI->reg()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">        Matrix->assign(*LI, PhysReg);</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">        Matrix->assign(*LI, PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline"></td>
    <td class="lineNumber">1987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">    // Pop the stack of recoloring attempts.</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">    // Pop the stack of recoloring attempts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">    RecolorStack.resize(EntryStackSize);</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">    RecolorStack.resize(EntryStackSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">  // Last chance recoloring did not worked either, give up.</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">  // Last chance recoloring did not worked either, give up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">  return ~0u;</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">  return ~0u;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline"></td>
    <td class="lineNumber">1995</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">/// tryRecoloringCandidates - Try to assign a new color to every register</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">/// tryRecoloringCandidates - Try to assign a new color to every register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">/// in \RecoloringQueue.</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">/// in \RecoloringQueue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">/// \p NewRegs will contain any new virtual register created during the</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">/// \p NewRegs will contain any new virtual register created during the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">/// recoloring process.</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">/// recoloring process.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">/// \p FixedRegisters[in/out] contains all the registers that have been</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">/// \p FixedRegisters[in/out] contains all the registers that have been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">/// recolored.</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">/// recolored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">/// \return true if all virtual registers in RecoloringQueue were successfully</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">/// \return true if all virtual registers in RecoloringQueue were successfully</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">/// recolored, false otherwise.</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">/// recolored, false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">bool RAGreedy::tryRecoloringCandidates(PQueue &RecoloringQueue,</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">bool RAGreedy::tryRecoloringCandidates(PQueue &RecoloringQueue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">                                       SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">                                       SmallVectorImpl<Register> &NewVRegs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">                                       SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">                                       SmallVirtRegSet &FixedRegisters,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">                                       RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">                                       RecoloringStack &RecolorStack,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">                                       unsigned Depth) {</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">                                       unsigned Depth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">  while (!RecoloringQueue.empty()) {</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">  while (!RecoloringQueue.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">    const LiveInterval *LI = dequeue(RecoloringQueue);</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">    const LiveInterval *LI = dequeue(RecoloringQueue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Try to recolor: " << *LI << '\n');</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Try to recolor: " << *LI << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">    MCRegister PhysReg = selectOrSplitImpl(*LI, NewVRegs, FixedRegisters,</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">    MCRegister PhysReg = selectOrSplitImpl(*LI, NewVRegs, FixedRegisters,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">                                           RecolorStack, Depth + 1);</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">                                           RecolorStack, Depth + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">    // When splitting happens, the live-range may actually be empty.</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">    // When splitting happens, the live-range may actually be empty.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">    // In that case, this is okay to continue the recoloring even</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">    // In that case, this is okay to continue the recoloring even</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">    // if we did not find an alternative color for it. Indeed,</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">    // if we did not find an alternative color for it. Indeed,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">    // there will not be anything to color for LI in the end.</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">    // there will not be anything to color for LI in the end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">    if (PhysReg == ~0u || (!PhysReg && !LI->empty()))</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">    if (PhysReg == ~0u || (!PhysReg && !LI->empty()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">    if (!PhysReg) {</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">    if (!PhysReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">      assert(LI->empty() && "Only empty live-range do not require a register");</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">      assert(LI->empty() && "Only empty live-range do not require a register");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">                        << " succeeded. Empty LI.\n");</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">                        << " succeeded. Empty LI.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">                      << " succeeded with: " << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">                      << " succeeded with: " << printReg(PhysReg, TRI) << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline"></td>
    <td class="lineNumber">2029</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">    Matrix->assign(*LI, PhysReg);</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">    Matrix->assign(*LI, PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">    FixedRegisters.insert(LI->reg());</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">    FixedRegisters.insert(LI->reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline"></td>
    <td class="lineNumber">2035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">//                            Main Entry Point</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">//                            Main Entry Point</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline"></td>
    <td class="lineNumber">2039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">MCRegister RAGreedy::selectOrSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">MCRegister RAGreedy::selectOrSplit(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">                                   SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">                                   SmallVectorImpl<Register> &NewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">  CutOffInfo = CO_None;</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">  CutOffInfo = CO_None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">  LLVMContext &Ctx = MF->getFunction().getContext();</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">  LLVMContext &Ctx = MF->getFunction().getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">  SmallVirtRegSet FixedRegisters;</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">  SmallVirtRegSet FixedRegisters;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  RecoloringStack RecolorStack;</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  RecoloringStack RecolorStack;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">  MCRegister Reg =</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">  MCRegister Reg =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">      selectOrSplitImpl(VirtReg, NewVRegs, FixedRegisters, RecolorStack);</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">      selectOrSplitImpl(VirtReg, NewVRegs, FixedRegisters, RecolorStack);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  if (Reg == ~0U && (CutOffInfo != CO_None)) {</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  if (Reg == ~0U && (CutOffInfo != CO_None)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">    uint8_t CutOffEncountered = CutOffInfo & (CO_Depth | CO_Interf);</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">    uint8_t CutOffEncountered = CutOffInfo & (CO_Depth | CO_Interf);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">    if (CutOffEncountered == CO_Depth)</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">    if (CutOffEncountered == CO_Depth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">      Ctx.emitError("register allocation failed: maximum depth for recoloring "</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">      Ctx.emitError("register allocation failed: maximum depth for recoloring "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">                    "reached. Use -fexhaustive-register-search to skip "</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">                    "reached. Use -fexhaustive-register-search to skip "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">                    "cutoffs");</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">                    "cutoffs");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">    else if (CutOffEncountered == CO_Interf)</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">    else if (CutOffEncountered == CO_Interf)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">      Ctx.emitError("register allocation failed: maximum interference for "</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">      Ctx.emitError("register allocation failed: maximum interference for "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">                    "recoloring reached. Use -fexhaustive-register-search "</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">                    "recoloring reached. Use -fexhaustive-register-search "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">                    "to skip cutoffs");</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">                    "to skip cutoffs");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">    else if (CutOffEncountered == (CO_Depth | CO_Interf))</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">    else if (CutOffEncountered == (CO_Depth | CO_Interf))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">      Ctx.emitError("register allocation failed: maximum interference and "</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">      Ctx.emitError("register allocation failed: maximum interference and "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">                    "depth for recoloring reached. Use "</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">                    "depth for recoloring reached. Use "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">                    "-fexhaustive-register-search to skip cutoffs");</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">                    "-fexhaustive-register-search to skip cutoffs");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">  return Reg;</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">  return Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline"></td>
    <td class="lineNumber">2065</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">/// Using a CSR for the first time has a cost because it causes push|pop</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">/// Using a CSR for the first time has a cost because it causes push|pop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">/// to be added to prologue|epilogue. Splitting a cold section of the live</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">/// to be added to prologue|epilogue. Splitting a cold section of the live</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">/// range can have lower cost than using the CSR for the first time;</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">/// range can have lower cost than using the CSR for the first time;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">/// Spilling a live range in the cold path can have lower cost than using</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">/// Spilling a live range in the cold path can have lower cost than using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">/// the CSR for the first time. Returns the physical register if we decide</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">/// the CSR for the first time. Returns the physical register if we decide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">/// to use the CSR; otherwise return 0.</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">/// to use the CSR; otherwise return 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">MCRegister RAGreedy::tryAssignCSRFirstTime(</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">MCRegister RAGreedy::tryAssignCSRFirstTime(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">    const LiveInterval &VirtReg, AllocationOrder &Order, MCRegister PhysReg,</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">    const LiveInterval &VirtReg, AllocationOrder &Order, MCRegister PhysReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">    uint8_t &CostPerUseLimit, SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">    uint8_t &CostPerUseLimit, SmallVectorImpl<Register> &NewVRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">  if (ExtraInfo->getStage(VirtReg) == RS_Spill && VirtReg.isSpillable()) {</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">  if (ExtraInfo->getStage(VirtReg) == RS_Spill && VirtReg.isSpillable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">    // We choose spill over using the CSR for the first time if the spill cost</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">    // We choose spill over using the CSR for the first time if the spill cost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">    // is lower than CSRCost.</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">    // is lower than CSRCost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">    SA->analyze(&VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">    if (calcSpillCost() >= CSRCost)</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">    if (calcSpillCost() >= CSRCost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">      return PhysReg;</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">      return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline"></td>
    <td class="lineNumber">2081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">    // We are going to spill, set CostPerUseLimit to 1 to make sure that</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">    // We are going to spill, set CostPerUseLimit to 1 to make sure that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">    // we will not use a callee-saved register in tryEvict.</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">    // we will not use a callee-saved register in tryEvict.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">    CostPerUseLimit = 1;</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">    CostPerUseLimit = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">  if (ExtraInfo->getStage(VirtReg) < RS_Split) {</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">  if (ExtraInfo->getStage(VirtReg) < RS_Split) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">    // We choose pre-splitting over using the CSR for the first time if</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">    // We choose pre-splitting over using the CSR for the first time if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">    // the cost of splitting is lower than CSRCost.</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">    // the cost of splitting is lower than CSRCost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">    SA->analyze(&VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">    unsigned NumCands = 0;</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">    unsigned NumCands = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">    BlockFrequency BestCost = CSRCost; // Don't modify CSRCost.</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">    BlockFrequency BestCost = CSRCost; // Don't modify CSRCost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">    unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">    unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">                                                 NumCands, true /*IgnoreCSR*/);</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">                                                 NumCands, true /*IgnoreCSR*/);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">    if (BestCand == NoCand)</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">    if (BestCand == NoCand)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">      // Use the CSR if we can't find a region split below CSRCost.</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">      // Use the CSR if we can't find a region split below CSRCost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">      return PhysReg;</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">      return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">    // Perform the actual pre-splitting.</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">    // Perform the actual pre-splitting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">    doRegionSplit(VirtReg, BestCand, false/*HasCompact*/, NewVRegs);</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">    doRegionSplit(VirtReg, BestCand, false/*HasCompact*/, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  return PhysReg;</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline"></td>
    <td class="lineNumber">2105</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">void RAGreedy::aboutToRemoveInterval(const LiveInterval &LI) {</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">void RAGreedy::aboutToRemoveInterval(const LiveInterval &LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  // Do not keep invalid information around.</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  // Do not keep invalid information around.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">  SetOfBrokenHints.remove(&LI);</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">  SetOfBrokenHints.remove(&LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline"></td>
    <td class="lineNumber">2110</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">void RAGreedy::initializeCSRCost() {</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">void RAGreedy::initializeCSRCost() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">  // We use the larger one out of the command-line option and the value report</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">  // We use the larger one out of the command-line option and the value report</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">  // by TRI.</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  // by TRI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">  CSRCost = BlockFrequency(</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">  CSRCost = BlockFrequency(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">      std::max((unsigned)CSRFirstTimeCost, TRI->getCSRFirstUseCost()));</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">      std::max((unsigned)CSRFirstTimeCost, TRI->getCSRFirstUseCost()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">  if (!CSRCost.getFrequency())</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">  if (!CSRCost.getFrequency())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline"></td>
    <td class="lineNumber">2118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">  // Raw cost is relative to Entry == 2^14; scale it appropriately.</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">  // Raw cost is relative to Entry == 2^14; scale it appropriately.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">  uint64_t ActualEntry = MBFI->getEntryFreq();</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">  uint64_t ActualEntry = MBFI->getEntryFreq();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">  if (!ActualEntry) {</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">  if (!ActualEntry) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">    CSRCost = 0;</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">    CSRCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  uint64_t FixedEntry = 1 << 14;</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  uint64_t FixedEntry = 1 << 14;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">  if (ActualEntry < FixedEntry)</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">  if (ActualEntry < FixedEntry)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">    CSRCost *= BranchProbability(ActualEntry, FixedEntry);</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">    CSRCost *= BranchProbability(ActualEntry, FixedEntry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">  else if (ActualEntry <= UINT32_MAX)</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">  else if (ActualEntry <= UINT32_MAX)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">    // Invert the fraction and divide.</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">    // Invert the fraction and divide.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">    CSRCost /= BranchProbability(FixedEntry, ActualEntry);</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">    CSRCost /= BranchProbability(FixedEntry, ActualEntry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">    // Can't use BranchProbability in general, since it takes 32-bit numbers.</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">    // Can't use BranchProbability in general, since it takes 32-bit numbers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">    CSRCost = CSRCost.getFrequency() * (ActualEntry / FixedEntry);</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">    CSRCost = CSRCost.getFrequency() * (ActualEntry / FixedEntry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline"></td>
    <td class="lineNumber">2135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">/// Collect the hint info for \p Reg.</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">/// Collect the hint info for \p Reg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">/// The results are stored into \p Out.</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">/// The results are stored into \p Out.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">/// \p Out is not cleared before being populated.</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">/// \p Out is not cleared before being populated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">void RAGreedy::collectHintInfo(Register Reg, HintsInfo &Out) {</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">void RAGreedy::collectHintInfo(Register Reg, HintsInfo &Out) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">  for (const MachineInstr &Instr : MRI->reg_nodbg_instructions(Reg)) {</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">  for (const MachineInstr &Instr : MRI->reg_nodbg_instructions(Reg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">    if (!Instr.isFullCopy())</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">    if (!Instr.isFullCopy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">    // Look for the other end of the copy.</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">    // Look for the other end of the copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">    Register OtherReg = Instr.getOperand(0).getReg();</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">    Register OtherReg = Instr.getOperand(0).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">    if (OtherReg == Reg) {</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">    if (OtherReg == Reg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">      OtherReg = Instr.getOperand(1).getReg();</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">      OtherReg = Instr.getOperand(1).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">      if (OtherReg == Reg)</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">      if (OtherReg == Reg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">    // Get the current assignment.</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">    // Get the current assignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">    MCRegister OtherPhysReg =</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">    MCRegister OtherPhysReg =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">        OtherReg.isPhysical() ? OtherReg.asMCReg() : VRM->getPhys(OtherReg);</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">        OtherReg.isPhysical() ? OtherReg.asMCReg() : VRM->getPhys(OtherReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">    // Push the collected information.</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">    // Push the collected information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">    Out.push_back(HintInfo(MBFI->getBlockFreq(Instr.getParent()), OtherReg,</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">    Out.push_back(HintInfo(MBFI->getBlockFreq(Instr.getParent()), OtherReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">                           OtherPhysReg));</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">                           OtherPhysReg));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline"></td>
    <td class="lineNumber">2158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">/// Using the given \p List, compute the cost of the broken hints if</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">/// Using the given \p List, compute the cost of the broken hints if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">/// \p PhysReg was used.</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">/// \p PhysReg was used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">/// \return The cost of \p List for \p PhysReg.</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">/// \return The cost of \p List for \p PhysReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">BlockFrequency RAGreedy::getBrokenHintFreq(const HintsInfo &List,</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">BlockFrequency RAGreedy::getBrokenHintFreq(const HintsInfo &List,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">                                           MCRegister PhysReg) {</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">                                           MCRegister PhysReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">  BlockFrequency Cost = 0;</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">  BlockFrequency Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  for (const HintInfo &Info : List) {</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  for (const HintInfo &Info : List) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">    if (Info.PhysReg != PhysReg)</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">    if (Info.PhysReg != PhysReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">      Cost += Info.Freq;</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">      Cost += Info.Freq;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  return Cost;</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline"></td>
    <td class="lineNumber">2171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">/// Using the register assigned to \p VirtReg, try to recolor</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">/// Using the register assigned to \p VirtReg, try to recolor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">/// all the live ranges that are copy-related with \p VirtReg.</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">/// all the live ranges that are copy-related with \p VirtReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">/// The recoloring is then propagated to all the live-ranges that have</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">/// The recoloring is then propagated to all the live-ranges that have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">/// been recolored and so on, until no more copies can be coalesced or</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">/// been recolored and so on, until no more copies can be coalesced or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">/// it is not profitable.</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">/// it is not profitable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">/// For a given live range, profitability is determined by the sum of the</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">/// For a given live range, profitability is determined by the sum of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">/// frequencies of the non-identity copies it would introduce with the old</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">/// frequencies of the non-identity copies it would introduce with the old</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">/// and new register.</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">/// and new register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">void RAGreedy::tryHintRecoloring(const LiveInterval &VirtReg) {</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">void RAGreedy::tryHintRecoloring(const LiveInterval &VirtReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">  // We have a broken hint, check if it is possible to fix it by</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">  // We have a broken hint, check if it is possible to fix it by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">  // reusing PhysReg for the copy-related live-ranges. Indeed, we evicted</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">  // reusing PhysReg for the copy-related live-ranges. Indeed, we evicted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">  // some register and PhysReg may be available for the other live-ranges.</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">  // some register and PhysReg may be available for the other live-ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">  SmallSet<Register, 4> Visited;</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">  SmallSet<Register, 4> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">  SmallVector<unsigned, 2> RecoloringCandidates;</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">  SmallVector<unsigned, 2> RecoloringCandidates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">  HintsInfo Info;</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">  HintsInfo Info;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">  Register Reg = VirtReg.reg();</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">  Register Reg = VirtReg.reg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">  MCRegister PhysReg = VRM->getPhys(Reg);</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">  MCRegister PhysReg = VRM->getPhys(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">  // Start the recoloring algorithm from the input live-interval, then</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">  // Start the recoloring algorithm from the input live-interval, then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">  // it will propagate to the ones that are copy-related with it.</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">  // it will propagate to the ones that are copy-related with it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">  Visited.insert(Reg);</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">  Visited.insert(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">  RecoloringCandidates.push_back(Reg);</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">  RecoloringCandidates.push_back(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline"></td>
    <td class="lineNumber">2193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Trying to reconcile hints for: " << printReg(Reg, TRI)</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Trying to reconcile hints for: " << printReg(Reg, TRI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">                    << '(' << printReg(PhysReg, TRI) << ")\n");</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">                    << '(' << printReg(PhysReg, TRI) << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline"></td>
    <td class="lineNumber">2196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">  do {</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">  do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">    Reg = RecoloringCandidates.pop_back_val();</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">    Reg = RecoloringCandidates.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline"></td>
    <td class="lineNumber">2199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">    // We cannot recolor physical register.</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">    // We cannot recolor physical register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">    if (Reg.isPhysical())</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">    if (Reg.isPhysical())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline"></td>
    <td class="lineNumber">2203</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">    // This may be a skipped class</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">    // This may be a skipped class</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">    if (!VRM->hasPhys(Reg)) {</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">    if (!VRM->hasPhys(Reg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">      assert(!ShouldAllocateClass(*TRI, *MRI->getRegClass(Reg)) &&</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">      assert(!ShouldAllocateClass(*TRI, *MRI->getRegClass(Reg)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">             "We have an unallocated variable which should have been handled");</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">             "We have an unallocated variable which should have been handled");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline"></td>
    <td class="lineNumber">2210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">    // Get the live interval mapped with this virtual register to be able</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">    // Get the live interval mapped with this virtual register to be able</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">    // to check for the interference with the new color.</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">    // to check for the interference with the new color.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">    LiveInterval &LI = LIS->getInterval(Reg);</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">    LiveInterval &LI = LIS->getInterval(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">    MCRegister CurrPhys = VRM->getPhys(Reg);</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">    MCRegister CurrPhys = VRM->getPhys(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">    // Check that the new color matches the register class constraints and</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">    // Check that the new color matches the register class constraints and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">    // that it is free for this live range.</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">    // that it is free for this live range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">    if (CurrPhys != PhysReg && (!MRI->getRegClass(Reg)->contains(PhysReg) ||</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">    if (CurrPhys != PhysReg && (!MRI->getRegClass(Reg)->contains(PhysReg) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">                                Matrix->checkInterference(LI, PhysReg)))</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">                                Matrix->checkInterference(LI, PhysReg)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline"></td>
    <td class="lineNumber">2220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << printReg(Reg, TRI) << '(' << printReg(CurrPhys, TRI)</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << printReg(Reg, TRI) << '(' << printReg(CurrPhys, TRI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">                      << ") is recolorable.\n");</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">                      << ") is recolorable.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline"></td>
    <td class="lineNumber">2223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">    // Gather the hint info.</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">    // Gather the hint info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">    Info.clear();</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">    Info.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">    collectHintInfo(Reg, Info);</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">    collectHintInfo(Reg, Info);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">    // Check if recoloring the live-range will increase the cost of the</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">    // Check if recoloring the live-range will increase the cost of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">    // non-identity copies.</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">    // non-identity copies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">    if (CurrPhys != PhysReg) {</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">    if (CurrPhys != PhysReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Checking profitability:\n");</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Checking profitability:\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">      BlockFrequency OldCopiesCost = getBrokenHintFreq(Info, CurrPhys);</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">      BlockFrequency OldCopiesCost = getBrokenHintFreq(Info, CurrPhys);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">      BlockFrequency NewCopiesCost = getBrokenHintFreq(Info, PhysReg);</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">      BlockFrequency NewCopiesCost = getBrokenHintFreq(Info, PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Old Cost: " << OldCopiesCost.getFrequency()</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "Old Cost: " << OldCopiesCost.getFrequency()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">                        << "\nNew Cost: " << NewCopiesCost.getFrequency()</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">                        << "\nNew Cost: " << NewCopiesCost.getFrequency()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">                        << '\n');</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">                        << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">      if (OldCopiesCost < NewCopiesCost) {</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">      if (OldCopiesCost < NewCopiesCost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "=> Not profitable.\n");</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "=> Not profitable.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">      // At this point, the cost is either cheaper or equal. If it is</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">      // At this point, the cost is either cheaper or equal. If it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">      // equal, we consider this is profitable because it may expose</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">      // equal, we consider this is profitable because it may expose</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">      // more recoloring opportunities.</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">      // more recoloring opportunities.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "=> Profitable.\n");</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "=> Profitable.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">      // Recolor the live-range.</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">      // Recolor the live-range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">      Matrix->unassign(LI);</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">      Matrix->unassign(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">      Matrix->assign(LI, PhysReg);</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">      Matrix->assign(LI, PhysReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">    // Push all copy-related live-ranges to keep reconciling the broken</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">    // Push all copy-related live-ranges to keep reconciling the broken</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">    // hints.</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">    // hints.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">    for (const HintInfo &HI : Info) {</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">    for (const HintInfo &HI : Info) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">      if (Visited.insert(HI.Reg).second)</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">      if (Visited.insert(HI.Reg).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">        RecoloringCandidates.push_back(HI.Reg);</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">        RecoloringCandidates.push_back(HI.Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  } while (!RecoloringCandidates.empty());</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  } while (!RecoloringCandidates.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline"></td>
    <td class="lineNumber">2256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">/// Try to recolor broken hints.</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">/// Try to recolor broken hints.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">/// Broken hints may be repaired by recoloring when an evicted variable</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">/// Broken hints may be repaired by recoloring when an evicted variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">/// freed up a register for a larger live-range.</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">/// freed up a register for a larger live-range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">/// Consider the following example:</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">/// Consider the following example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">/// BB1:</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">/// BB1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">///   a =</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">///   a =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">///   b =</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">///   b =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">/// BB2:</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">/// BB2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">///   ...</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">///   ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">///   = b</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">///   = b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">///   = a</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">///   = a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">/// Let us assume b gets split:</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">/// Let us assume b gets split:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">/// BB1:</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">/// BB1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">///   a =</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">///   a =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">///   b =</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">///   b =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">/// BB2:</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">/// BB2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">///   c = b</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">///   c = b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">///   ...</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">///   ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">///   d = c</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">///   d = c</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">///   = d</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">///   = d</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">///   = a</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">///   = a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">/// Because of how the allocation work, b, c, and d may be assigned different</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">/// Because of how the allocation work, b, c, and d may be assigned different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">/// colors. Now, if a gets evicted later:</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">/// colors. Now, if a gets evicted later:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">/// BB1:</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">/// BB1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">///   a =</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">///   a =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">///   st a, SpillSlot</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">///   st a, SpillSlot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">///   b =</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">///   b =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">/// BB2:</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">/// BB2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">///   c = b</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">///   c = b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">///   ...</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">///   ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">///   d = c</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">///   d = c</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">///   = d</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">///   = d</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">///   e = ld SpillSlot</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">///   e = ld SpillSlot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">///   = e</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">///   = e</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">/// This is likely that we can assign the same register for b, c, and d,</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">/// This is likely that we can assign the same register for b, c, and d,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">/// getting rid of 2 copies.</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">/// getting rid of 2 copies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">void RAGreedy::tryHintsRecoloring() {</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">void RAGreedy::tryHintsRecoloring() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">  for (const LiveInterval *LI : SetOfBrokenHints) {</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">  for (const LiveInterval *LI : SetOfBrokenHints) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">    assert(LI->reg().isVirtual() &&</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">    assert(LI->reg().isVirtual() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">           "Recoloring is possible only for virtual registers");</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">           "Recoloring is possible only for virtual registers");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">    // Some dead defs may be around (e.g., because of debug uses).</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">    // Some dead defs may be around (e.g., because of debug uses).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">    // Ignore those.</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">    // Ignore those.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">    if (!VRM->hasPhys(LI->reg()))</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">    if (!VRM->hasPhys(LI->reg()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">    tryHintRecoloring(*LI);</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">    tryHintRecoloring(*LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">MCRegister RAGreedy::selectOrSplitImpl(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">MCRegister RAGreedy::selectOrSplitImpl(const LiveInterval &VirtReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">                                       SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">                                       SmallVectorImpl<Register> &NewVRegs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">                                       SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">                                       SmallVirtRegSet &FixedRegisters,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">                                       RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">                                       RecoloringStack &RecolorStack,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">                                       unsigned Depth) {</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">                                       unsigned Depth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">  uint8_t CostPerUseLimit = uint8_t(~0u);</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">  uint8_t CostPerUseLimit = uint8_t(~0u);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">  // First try assigning a free register.</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">  // First try assigning a free register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">  auto Order =</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">  auto Order =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">      AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix);</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">      AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">  if (MCRegister PhysReg =</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">  if (MCRegister PhysReg =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">          tryAssign(VirtReg, Order, NewVRegs, FixedRegisters)) {</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">          tryAssign(VirtReg, Order, NewVRegs, FixedRegisters)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">    // When NewVRegs is not empty, we may have made decisions such as evicting</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">    // When NewVRegs is not empty, we may have made decisions such as evicting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">    // a virtual register, go with the earlier decisions and use the physical</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">    // a virtual register, go with the earlier decisions and use the physical</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">    // register.</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">    // register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">    if (CSRCost.getFrequency() &&</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">    if (CSRCost.getFrequency() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">        EvictAdvisor->isUnusedCalleeSavedReg(PhysReg) && NewVRegs.empty()) {</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">        EvictAdvisor->isUnusedCalleeSavedReg(PhysReg) && NewVRegs.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">      MCRegister CSRReg = tryAssignCSRFirstTime(VirtReg, Order, PhysReg,</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">      MCRegister CSRReg = tryAssignCSRFirstTime(VirtReg, Order, PhysReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">                                                CostPerUseLimit, NewVRegs);</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">                                                CostPerUseLimit, NewVRegs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">      if (CSRReg || !NewVRegs.empty())</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">      if (CSRReg || !NewVRegs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">        // Return now if we decide to use a CSR or create new vregs due to</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">        // Return now if we decide to use a CSR or create new vregs due to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">        // pre-splitting.</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">        // pre-splitting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">        return CSRReg;</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">        return CSRReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">      return PhysReg;</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">      return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline"></td>
    <td class="lineNumber">2330</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">  LiveRangeStage Stage = ExtraInfo->getStage(VirtReg);</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">  LiveRangeStage Stage = ExtraInfo->getStage(VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << StageName[Stage] << " Cascade "</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << StageName[Stage] << " Cascade "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">                    << ExtraInfo->getCascade(VirtReg.reg()) << '\n');</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">                    << ExtraInfo->getCascade(VirtReg.reg()) << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline"></td>
    <td class="lineNumber">2334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">  // Try to evict a less worthy live range, but only for ranges from the primary</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">  // Try to evict a less worthy live range, but only for ranges from the primary</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">  // queue. The RS_Split ranges already failed to do this, and they should not</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">  // queue. The RS_Split ranges already failed to do this, and they should not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">  // get a second chance until they have been split.</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">  // get a second chance until they have been split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  if (Stage != RS_Split)</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  if (Stage != RS_Split)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">    if (Register PhysReg =</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">    if (Register PhysReg =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">            tryEvict(VirtReg, Order, NewVRegs, CostPerUseLimit,</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">            tryEvict(VirtReg, Order, NewVRegs, CostPerUseLimit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">                     FixedRegisters)) {</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">                     FixedRegisters)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">      Register Hint = MRI->getSimpleHint(VirtReg.reg());</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">      Register Hint = MRI->getSimpleHint(VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">      // If VirtReg has a hint and that hint is broken record this</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">      // If VirtReg has a hint and that hint is broken record this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">      // virtual register as a recoloring candidate for broken hint.</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">      // virtual register as a recoloring candidate for broken hint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">      // Indeed, since we evicted a variable in its neighborhood it is</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">      // Indeed, since we evicted a variable in its neighborhood it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">      // likely we can at least partially recolor some of the</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">      // likely we can at least partially recolor some of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">      // copy-related live-ranges.</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">      // copy-related live-ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">      if (Hint && Hint != PhysReg)</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">      if (Hint && Hint != PhysReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">        SetOfBrokenHints.insert(&VirtReg);</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">        SetOfBrokenHints.insert(&VirtReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">      return PhysReg;</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">      return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">  assert((NewVRegs.empty() || Depth) && "Cannot append to existing NewVRegs");</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">  assert((NewVRegs.empty() || Depth) && "Cannot append to existing NewVRegs");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline"></td>
    <td class="lineNumber">2354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">  // The first time we see a live range, don't try to split or spill.</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">  // The first time we see a live range, don't try to split or spill.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">  // Wait until the second time, when all smaller ranges have been allocated.</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">  // Wait until the second time, when all smaller ranges have been allocated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">  // This gives a better picture of the interference to split around.</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">  // This gives a better picture of the interference to split around.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">  if (Stage < RS_Split) {</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">  if (Stage < RS_Split) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">    ExtraInfo->setStage(VirtReg, RS_Split);</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">    ExtraInfo->setStage(VirtReg, RS_Split);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "wait for second round\n");</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "wait for second round\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">    NewVRegs.push_back(VirtReg.reg());</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">    NewVRegs.push_back(VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline"></td>
    <td class="lineNumber">2364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">  if (Stage < RS_Spill) {</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">  if (Stage < RS_Spill) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">    // Try splitting VirtReg or interferences.</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">    // Try splitting VirtReg or interferences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">    unsigned NewVRegSizeBefore = NewVRegs.size();</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">    unsigned NewVRegSizeBefore = NewVRegs.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">    Register PhysReg = trySplit(VirtReg, Order, NewVRegs, FixedRegisters);</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">    Register PhysReg = trySplit(VirtReg, Order, NewVRegs, FixedRegisters);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">    if (PhysReg || (NewVRegs.size() - NewVRegSizeBefore))</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">    if (PhysReg || (NewVRegs.size() - NewVRegSizeBefore))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">      return PhysReg;</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">      return PhysReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline"></td>
    <td class="lineNumber">2372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">  // If we couldn't allocate a register from spilling, there is probably some</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">  // If we couldn't allocate a register from spilling, there is probably some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  // invalid inline assembly. The base class will report it.</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  // invalid inline assembly. The base class will report it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">  if (Stage >= RS_Done || !VirtReg.isSpillable()) {</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">  if (Stage >= RS_Done || !VirtReg.isSpillable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">    return tryLastChanceRecoloring(VirtReg, Order, NewVRegs, FixedRegisters,</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">    return tryLastChanceRecoloring(VirtReg, Order, NewVRegs, FixedRegisters,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">                                   RecolorStack, Depth);</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">                                   RecolorStack, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline"></td>
    <td class="lineNumber">2379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">  // Finally spill VirtReg itself.</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">  // Finally spill VirtReg itself.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">  if ((EnableDeferredSpilling ||</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">  if ((EnableDeferredSpilling ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">       TRI->shouldUseDeferredSpillingForVirtReg(*MF, VirtReg)) &&</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">       TRI->shouldUseDeferredSpillingForVirtReg(*MF, VirtReg)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">      ExtraInfo->getStage(VirtReg) < RS_Memory) {</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">      ExtraInfo->getStage(VirtReg) < RS_Memory) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">    // TODO: This is experimental and in particular, we do not model</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">    // TODO: This is experimental and in particular, we do not model</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">    // the live range splitting done by spilling correctly.</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">    // the live range splitting done by spilling correctly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">    // We would need a deep integration with the spiller to do the</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">    // We would need a deep integration with the spiller to do the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">    // right thing here. Anyway, that is still good for early testing.</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">    // right thing here. Anyway, that is still good for early testing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">    ExtraInfo->setStage(VirtReg, RS_Memory);</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">    ExtraInfo->setStage(VirtReg, RS_Memory);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Do as if this register is in memory\n");</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Do as if this register is in memory\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">    NewVRegs.push_back(VirtReg.reg());</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">    NewVRegs.push_back(VirtReg.reg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">    NamedRegionTimer T("spill", "Spiller", TimerGroupName,</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">    NamedRegionTimer T("spill", "Spiller", TimerGroupName,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">                       TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">                       TimerGroupDescription, TimePassesIsEnabled);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">    LiveRangeEdit LRE(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">    LiveRangeEdit LRE(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">    spiller().spill(LRE);</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">    spiller().spill(LRE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">    ExtraInfo->setStage(NewVRegs.begin(), NewVRegs.end(), RS_Done);</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">    ExtraInfo->setStage(NewVRegs.begin(), NewVRegs.end(), RS_Done);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">    // Tell LiveDebugVariables about the new ranges. Ranges not being covered by</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">    // Tell LiveDebugVariables about the new ranges. Ranges not being covered by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">    // the new regs are kept in LDV (still mapping to the old register), until</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">    // the new regs are kept in LDV (still mapping to the old register), until</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">    // we rewrite spilled locations in LDV at a later stage.</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">    // we rewrite spilled locations in LDV at a later stage.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">    DebugVars->splitRegister(VirtReg.reg(), LRE.regs(), *LIS);</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">    DebugVars->splitRegister(VirtReg.reg(), LRE.regs(), *LIS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline"></td>
    <td class="lineNumber">2402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">    if (VerifyEnabled)</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">    if (VerifyEnabled)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">      MF->verify(this, "After spilling");</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">      MF->verify(this, "After spilling");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline"></td>
    <td class="lineNumber">2406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  // The live virtual register requesting allocation was spilled, so tell</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  // The live virtual register requesting allocation was spilled, so tell</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">  // the caller not to allocate anything during this round.</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">  // the caller not to allocate anything during this round.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">  return 0;</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">  return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline"></td>
    <td class="lineNumber">2411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">void RAGreedy::RAGreedyStats::report(MachineOptimizationRemarkMissed &R) {</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">void RAGreedy::RAGreedyStats::report(MachineOptimizationRemarkMissed &R) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">  using namespace ore;</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">  using namespace ore;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">  if (Spills) {</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">  if (Spills) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">    R << NV("NumSpills", Spills) << " spills ";</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">    R << NV("NumSpills", Spills) << " spills ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">    R << NV("TotalSpillsCost", SpillsCost) << " total spills cost ";</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">    R << NV("TotalSpillsCost", SpillsCost) << " total spills cost ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">  if (FoldedSpills) {</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">  if (FoldedSpills) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">    R << NV("NumFoldedSpills", FoldedSpills) << " folded spills ";</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">    R << NV("NumFoldedSpills", FoldedSpills) << " folded spills ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">    R << NV("TotalFoldedSpillsCost", FoldedSpillsCost)</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">    R << NV("TotalFoldedSpillsCost", FoldedSpillsCost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">      << " total folded spills cost ";</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">      << " total folded spills cost ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">  if (Reloads) {</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">  if (Reloads) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">    R << NV("NumReloads", Reloads) << " reloads ";</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">    R << NV("NumReloads", Reloads) << " reloads ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">    R << NV("TotalReloadsCost", ReloadsCost) << " total reloads cost ";</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">    R << NV("TotalReloadsCost", ReloadsCost) << " total reloads cost ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">  if (FoldedReloads) {</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">  if (FoldedReloads) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">    R << NV("NumFoldedReloads", FoldedReloads) << " folded reloads ";</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">    R << NV("NumFoldedReloads", FoldedReloads) << " folded reloads ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">    R << NV("TotalFoldedReloadsCost", FoldedReloadsCost)</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">    R << NV("TotalFoldedReloadsCost", FoldedReloadsCost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">      << " total folded reloads cost ";</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">      << " total folded reloads cost ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">  if (ZeroCostFoldedReloads)</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">  if (ZeroCostFoldedReloads)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">    R << NV("NumZeroCostFoldedReloads", ZeroCostFoldedReloads)</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">    R << NV("NumZeroCostFoldedReloads", ZeroCostFoldedReloads)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">      << " zero cost folded reloads ";</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">      << " zero cost folded reloads ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">  if (Copies) {</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">  if (Copies) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">    R << NV("NumVRCopies", Copies) << " virtual registers copies ";</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">    R << NV("NumVRCopies", Copies) << " virtual registers copies ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">    R << NV("TotalCopiesCost", CopiesCost) << " total copies cost ";</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">    R << NV("TotalCopiesCost", CopiesCost) << " total copies cost ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline"></td>
    <td class="lineNumber">2440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">RAGreedy::RAGreedyStats RAGreedy::computeStats(MachineBasicBlock &MBB) {</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">RAGreedy::RAGreedyStats RAGreedy::computeStats(MachineBasicBlock &MBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">  RAGreedyStats Stats;</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">  RAGreedyStats Stats;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">  const MachineFrameInfo &MFI = MF->getFrameInfo();</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">  const MachineFrameInfo &MFI = MF->getFrameInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">  int FI;</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">  int FI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline"></td>
    <td class="lineNumber">2445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">  auto isSpillSlotAccess = [&MFI](const MachineMemOperand *A) {</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">  auto isSpillSlotAccess = [&MFI](const MachineMemOperand *A) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">    return MFI.isSpillSlotObjectIndex(cast<FixedStackPseudoSourceValue>(</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">    return MFI.isSpillSlotObjectIndex(cast<FixedStackPseudoSourceValue>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">        A->getPseudoValue())->getFrameIndex());</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">        A->getPseudoValue())->getFrameIndex());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">  auto isPatchpointInstr = [](const MachineInstr &MI) {</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">  auto isPatchpointInstr = [](const MachineInstr &MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">    return MI.getOpcode() == TargetOpcode::PATCHPOINT ||</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">    return MI.getOpcode() == TargetOpcode::PATCHPOINT ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">           MI.getOpcode() == TargetOpcode::STACKMAP ||</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">           MI.getOpcode() == TargetOpcode::STACKMAP ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">           MI.getOpcode() == TargetOpcode::STATEPOINT;</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">           MI.getOpcode() == TargetOpcode::STATEPOINT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">  for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">  for (MachineInstr &MI : MBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">    if (MI.isCopy()) {</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">    if (MI.isCopy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">      const MachineOperand &Dest = MI.getOperand(0);</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">      const MachineOperand &Dest = MI.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">      const MachineOperand &Src = MI.getOperand(1);</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">      const MachineOperand &Src = MI.getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">      Register SrcReg = Src.getReg();</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">      Register SrcReg = Src.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">      Register DestReg = Dest.getReg();</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">      Register DestReg = Dest.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">      // Only count `COPY`s with a virtual register as source or destination.</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">      // Only count `COPY`s with a virtual register as source or destination.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">      if (SrcReg.isVirtual() || DestReg.isVirtual()) {</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">      if (SrcReg.isVirtual() || DestReg.isVirtual()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">        if (SrcReg.isVirtual()) {</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">        if (SrcReg.isVirtual()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">          SrcReg = VRM->getPhys(SrcReg);</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">          SrcReg = VRM->getPhys(SrcReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">          if (SrcReg && Src.getSubReg())</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">          if (SrcReg && Src.getSubReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">            SrcReg = TRI->getSubReg(SrcReg, Src.getSubReg());</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">            SrcReg = TRI->getSubReg(SrcReg, Src.getSubReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">        if (DestReg.isVirtual()) {</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">        if (DestReg.isVirtual()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">          DestReg = VRM->getPhys(DestReg);</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">          DestReg = VRM->getPhys(DestReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">          if (DestReg && Dest.getSubReg())</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">          if (DestReg && Dest.getSubReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">            DestReg = TRI->getSubReg(DestReg, Dest.getSubReg());</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">            DestReg = TRI->getSubReg(DestReg, Dest.getSubReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2472</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">        if (SrcReg != DestReg)</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">        if (SrcReg != DestReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">          ++Stats.Copies;</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">          ++Stats.Copies;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline"></td>
    <td class="lineNumber">2478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">    SmallVector<const MachineMemOperand *, 2> Accesses;</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">    SmallVector<const MachineMemOperand *, 2> Accesses;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">    if (TII->isLoadFromStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">    if (TII->isLoadFromStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">      ++Stats.Reloads;</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">      ++Stats.Reloads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">    if (TII->isStoreToStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">    if (TII->isStoreToStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">      ++Stats.Spills;</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">      ++Stats.Spills;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">    if (TII->hasLoadFromStackSlot(MI, Accesses) &&</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">    if (TII->hasLoadFromStackSlot(MI, Accesses) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">      if (!isPatchpointInstr(MI)) {</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">      if (!isPatchpointInstr(MI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">        Stats.FoldedReloads += Accesses.size();</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">        Stats.FoldedReloads += Accesses.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">      // For statepoint there may be folded and zero cost folded stack reloads.</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">      // For statepoint there may be folded and zero cost folded stack reloads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">      std::pair<unsigned, unsigned> NonZeroCostRange =</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">      std::pair<unsigned, unsigned> NonZeroCostRange =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">          TII->getPatchpointUnfoldableRange(MI);</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">          TII->getPatchpointUnfoldableRange(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">      SmallSet<unsigned, 16> FoldedReloads;</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">      SmallSet<unsigned, 16> FoldedReloads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">      SmallSet<unsigned, 16> ZeroCostFoldedReloads;</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">      SmallSet<unsigned, 16> ZeroCostFoldedReloads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">      for (unsigned Idx = 0, E = MI.getNumOperands(); Idx < E; ++Idx) {</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">      for (unsigned Idx = 0, E = MI.getNumOperands(); Idx < E; ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">        MachineOperand &MO = MI.getOperand(Idx);</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">        MachineOperand &MO = MI.getOperand(Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">        if (!MO.isFI() || !MFI.isSpillSlotObjectIndex(MO.getIndex()))</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">        if (!MO.isFI() || !MFI.isSpillSlotObjectIndex(MO.getIndex()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">        if (Idx >= NonZeroCostRange.first && Idx < NonZeroCostRange.second)</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">        if (Idx >= NonZeroCostRange.first && Idx < NonZeroCostRange.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">          FoldedReloads.insert(MO.getIndex());</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">          FoldedReloads.insert(MO.getIndex());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">        else</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">        else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">          ZeroCostFoldedReloads.insert(MO.getIndex());</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">          ZeroCostFoldedReloads.insert(MO.getIndex());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">      // If stack slot is used in folded reload it is not zero cost then.</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">      // If stack slot is used in folded reload it is not zero cost then.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">      for (unsigned Slot : FoldedReloads)</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">      for (unsigned Slot : FoldedReloads)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">        ZeroCostFoldedReloads.erase(Slot);</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">        ZeroCostFoldedReloads.erase(Slot);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">      Stats.FoldedReloads += FoldedReloads.size();</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">      Stats.FoldedReloads += FoldedReloads.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline">      Stats.ZeroCostFoldedReloads += ZeroCostFoldedReloads.size();</td>
    <td class="lineNumber">2512</td>
    <td class="codeline">      Stats.ZeroCostFoldedReloads += ZeroCostFoldedReloads.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">    Accesses.clear();</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">    Accesses.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">    if (TII->hasStoreToStackSlot(MI, Accesses) &&</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">    if (TII->hasStoreToStackSlot(MI, Accesses) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">      Stats.FoldedSpills += Accesses.size();</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">      Stats.FoldedSpills += Accesses.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">  // Set cost of collected statistic by multiplication to relative frequency of</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">  // Set cost of collected statistic by multiplication to relative frequency of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">  // this basic block.</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">  // this basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">  float RelFreq = MBFI->getBlockFreqRelativeToEntryBlock(&MBB);</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">  float RelFreq = MBFI->getBlockFreqRelativeToEntryBlock(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">  Stats.ReloadsCost = RelFreq * Stats.Reloads;</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">  Stats.ReloadsCost = RelFreq * Stats.Reloads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">  Stats.FoldedReloadsCost = RelFreq * Stats.FoldedReloads;</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">  Stats.FoldedReloadsCost = RelFreq * Stats.FoldedReloads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">  Stats.SpillsCost = RelFreq * Stats.Spills;</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">  Stats.SpillsCost = RelFreq * Stats.Spills;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">  Stats.FoldedSpillsCost = RelFreq * Stats.FoldedSpills;</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">  Stats.FoldedSpillsCost = RelFreq * Stats.FoldedSpills;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">  Stats.CopiesCost = RelFreq * Stats.Copies;</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">  Stats.CopiesCost = RelFreq * Stats.Copies;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">  return Stats;</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">  return Stats;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline"></td>
    <td class="lineNumber">2531</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">RAGreedy::RAGreedyStats RAGreedy::reportStats(MachineLoop *L) {</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">RAGreedy::RAGreedyStats RAGreedy::reportStats(MachineLoop *L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">  RAGreedyStats Stats;</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">  RAGreedyStats Stats;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline"></td>
    <td class="lineNumber">2534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">  // Sum up the spill and reloads in subloops.</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">  // Sum up the spill and reloads in subloops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">  for (MachineLoop *SubLoop : *L)</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">  for (MachineLoop *SubLoop : *L)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">    Stats.add(reportStats(SubLoop));</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">    Stats.add(reportStats(SubLoop));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline"></td>
    <td class="lineNumber">2538</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">  for (MachineBasicBlock *MBB : L->getBlocks())</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">  for (MachineBasicBlock *MBB : L->getBlocks())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">    // Handle blocks that were not included in subloops.</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">    // Handle blocks that were not included in subloops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">    if (Loops->getLoopFor(MBB) == L)</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">    if (Loops->getLoopFor(MBB) == L)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">      Stats.add(computeStats(*MBB));</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">      Stats.add(computeStats(*MBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline"></td>
    <td class="lineNumber">2543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">  if (!Stats.isEmpty()) {</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">  if (!Stats.isEmpty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">    using namespace ore;</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">    using namespace ore;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline"></td>
    <td class="lineNumber">2546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">    ORE->emit([&]() {</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">    ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "LoopSpillReloadCopies",</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "LoopSpillReloadCopies",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline">                                        L->getStartLoc(), L->getHeader());</td>
    <td class="lineNumber">2549</td>
    <td class="codeline">                                        L->getStartLoc(), L->getHeader());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">      Stats.report(R);</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">      Stats.report(R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">      R << "generated in loop";</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">      R << "generated in loop";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">      return R;</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">      return R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2554</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">  return Stats;</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">  return Stats;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline"></td>
    <td class="lineNumber">2557</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">void RAGreedy::reportStats() {</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">void RAGreedy::reportStats() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">  if (!ORE->allowExtraAnalysis(DEBUG_TYPE))</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">  if (!ORE->allowExtraAnalysis(DEBUG_TYPE))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">  RAGreedyStats Stats;</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">  RAGreedyStats Stats;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">  for (MachineLoop *L : *Loops)</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">  for (MachineLoop *L : *Loops)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">    Stats.add(reportStats(L));</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">    Stats.add(reportStats(L));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">  // Process non-loop blocks.</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">  // Process non-loop blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : *MF)</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : *MF)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline">    if (!Loops->getLoopFor(&MBB))</td>
    <td class="lineNumber">2566</td>
    <td class="codeline">    if (!Loops->getLoopFor(&MBB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">      Stats.add(computeStats(MBB));</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">      Stats.add(computeStats(MBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">  if (!Stats.isEmpty()) {</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">  if (!Stats.isEmpty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">    using namespace ore;</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">    using namespace ore;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline"></td>
    <td class="lineNumber">2570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">    ORE->emit([&]() {</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">    ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">      DebugLoc Loc;</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">      DebugLoc Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">      if (auto *SP = MF->getFunction().getSubprogram())</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">      if (auto *SP = MF->getFunction().getSubprogram())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">        Loc = DILocation::get(SP->getContext(), SP->getLine(), 1, SP);</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">        Loc = DILocation::get(SP->getContext(), SP->getLine(), 1, SP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "SpillReloadCopies", Loc,</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "SpillReloadCopies", Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">                                        &MF->front());</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">                                        &MF->front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">      Stats.report(R);</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">      Stats.report(R);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">      R << "generated in function";</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">      R << "generated in function";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">      return R;</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">      return R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">    });</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">    });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline"></td>
    <td class="lineNumber">2583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">bool RAGreedy::hasVirtRegAlloc() {</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">bool RAGreedy::hasVirtRegAlloc() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline">  for (unsigned I = 0, E = MRI->getNumVirtRegs(); I != E; ++I) {</td>
    <td class="lineNumber">2585</td>
    <td class="codeline">  for (unsigned I = 0, E = MRI->getNumVirtRegs(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">    Register Reg = Register::index2VirtReg(I);</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">    Register Reg = Register::index2VirtReg(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">    if (MRI->reg_nodbg_empty(Reg))</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">    if (MRI->reg_nodbg_empty(Reg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">    const TargetRegisterClass *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">    const TargetRegisterClass *RC = MRI->getRegClass(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">    if (!RC)</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">    if (!RC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">    if (ShouldAllocateClass(*TRI, *RC))</td>
    <td class="lineNumber">2592</td>
    <td class="codeline">    if (ShouldAllocateClass(*TRI, *RC))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline"></td>
    <td class="lineNumber">2595</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2597</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline"></td>
    <td class="lineNumber">2598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">bool RAGreedy::runOnMachineFunction(MachineFunction &mf) {</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">bool RAGreedy::runOnMachineFunction(MachineFunction &mf) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "********** GREEDY REGISTER ALLOCATION **********\n"</td>
    <td class="lineNumber">2600</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "********** GREEDY REGISTER ALLOCATION **********\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">                    << "********** Function: " << mf.getName() << '\n');</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">                    << "********** Function: " << mf.getName() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline"></td>
    <td class="lineNumber">2602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">  MF = &mf;</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">  MF = &mf;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline">  TII = MF->getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">2604</td>
    <td class="codeline">  TII = MF->getSubtarget().getInstrInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline"></td>
    <td class="lineNumber">2605</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">  if (VerifyEnabled)</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">  if (VerifyEnabled)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline">    MF->verify(this, "Before greedy register allocator");</td>
    <td class="lineNumber">2607</td>
    <td class="codeline">    MF->verify(this, "Before greedy register allocator");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline"></td>
    <td class="lineNumber">2608</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">  RegAllocBase::init(getAnalysis<VirtRegMap>(),</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">  RegAllocBase::init(getAnalysis<VirtRegMap>(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">                     getAnalysis<LiveIntervals>(),</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">                     getAnalysis<LiveIntervals>(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">                     getAnalysis<LiveRegMatrix>());</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">                     getAnalysis<LiveRegMatrix>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline"></td>
    <td class="lineNumber">2612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  // Early return if there is no virtual register to be allocated to a</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  // Early return if there is no virtual register to be allocated to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">  // physical register.</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">  // physical register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">  if (!hasVirtRegAlloc())</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">  if (!hasVirtRegAlloc())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2616</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline"></td>
    <td class="lineNumber">2617</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline">  Indexes = &getAnalysis<SlotIndexes>();</td>
    <td class="lineNumber">2618</td>
    <td class="codeline">  Indexes = &getAnalysis<SlotIndexes>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline">  MBFI = &getAnalysis<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">2619</td>
    <td class="codeline">  MBFI = &getAnalysis<MachineBlockFrequencyInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">  DomTree = &getAnalysis<MachineDominatorTree>();</td>
    <td class="lineNumber">2620</td>
    <td class="codeline">  DomTree = &getAnalysis<MachineDominatorTree>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">  Loops = &getAnalysis<MachineLoopInfo>();</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">  Loops = &getAnalysis<MachineLoopInfo>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">  Bundles = &getAnalysis<EdgeBundles>();</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">  Bundles = &getAnalysis<EdgeBundles>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline">  SpillPlacer = &getAnalysis<SpillPlacement>();</td>
    <td class="lineNumber">2624</td>
    <td class="codeline">  SpillPlacer = &getAnalysis<SpillPlacement>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">  DebugVars = &getAnalysis<LiveDebugVariables>();</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">  DebugVars = &getAnalysis<LiveDebugVariables>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline"></td>
    <td class="lineNumber">2626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">  initializeCSRCost();</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">  initializeCSRCost();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline"></td>
    <td class="lineNumber">2628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">  RegCosts = TRI->getRegisterCosts(*MF);</td>
    <td class="lineNumber">2629</td>
    <td class="codeline">  RegCosts = TRI->getRegisterCosts(*MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">  RegClassPriorityTrumpsGlobalness =</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">  RegClassPriorityTrumpsGlobalness =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">      GreedyRegClassPriorityTrumpsGlobalness.getNumOccurrences()</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">      GreedyRegClassPriorityTrumpsGlobalness.getNumOccurrences()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">          ? GreedyRegClassPriorityTrumpsGlobalness</td>
    <td class="lineNumber">2632</td>
    <td class="codeline">          ? GreedyRegClassPriorityTrumpsGlobalness</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">          : TRI->regClassPriorityTrumpsGlobalness(*MF);</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">          : TRI->regClassPriorityTrumpsGlobalness(*MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline"></td>
    <td class="lineNumber">2634</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">  ReverseLocalAssignment = GreedyReverseLocalAssignment.getNumOccurrences()</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">  ReverseLocalAssignment = GreedyReverseLocalAssignment.getNumOccurrences()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">                               ? GreedyReverseLocalAssignment</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">                               ? GreedyReverseLocalAssignment</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">                               : TRI->reverseLocalAssignment();</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">                               : TRI->reverseLocalAssignment();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline"></td>
    <td class="lineNumber">2638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">  ExtraInfo.emplace();</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">  ExtraInfo.emplace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline">  EvictAdvisor =</td>
    <td class="lineNumber">2640</td>
    <td class="codeline">  EvictAdvisor =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">      getAnalysis<RegAllocEvictionAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">      getAnalysis<RegAllocEvictionAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">  PriorityAdvisor =</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">  PriorityAdvisor =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">      getAnalysis<RegAllocPriorityAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">      getAnalysis<RegAllocPriorityAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline"></td>
    <td class="lineNumber">2644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">  VRAI = std::make_unique<VirtRegAuxInfo>(*MF, *LIS, *VRM, *Loops, *MBFI);</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">  VRAI = std::make_unique<VirtRegAuxInfo>(*MF, *LIS, *VRM, *Loops, *MBFI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">  SpillerInstance.reset(createInlineSpiller(*this, *MF, *VRM, *VRAI));</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">  SpillerInstance.reset(createInlineSpiller(*this, *MF, *VRM, *VRAI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline"></td>
    <td class="lineNumber">2647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">  VRAI->calculateSpillWeightsAndHints();</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">  VRAI->calculateSpillWeightsAndHints();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline"></td>
    <td class="lineNumber">2649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">  LLVM_DEBUG(LIS->dump());</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">  LLVM_DEBUG(LIS->dump());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline"></td>
    <td class="lineNumber">2651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline">  SA.reset(new SplitAnalysis(*VRM, *LIS, *Loops));</td>
    <td class="lineNumber">2652</td>
    <td class="codeline">  SA.reset(new SplitAnalysis(*VRM, *LIS, *Loops));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">  SE.reset(new SplitEditor(*SA, *LIS, *VRM, *DomTree, *MBFI, *VRAI));</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">  SE.reset(new SplitEditor(*SA, *LIS, *VRM, *DomTree, *MBFI, *VRAI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline"></td>
    <td class="lineNumber">2654</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">  IntfCache.init(MF, Matrix->getLiveUnions(), Indexes, LIS, TRI);</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">  IntfCache.init(MF, Matrix->getLiveUnions(), Indexes, LIS, TRI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">  GlobalCand.resize(32);  // This will grow as needed.</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">  GlobalCand.resize(32);  // This will grow as needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline">  SetOfBrokenHints.clear();</td>
    <td class="lineNumber">2657</td>
    <td class="codeline">  SetOfBrokenHints.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline"></td>
    <td class="lineNumber">2658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline">  allocatePhysRegs();</td>
    <td class="lineNumber">2659</td>
    <td class="codeline">  allocatePhysRegs();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline">  tryHintsRecoloring();</td>
    <td class="lineNumber">2660</td>
    <td class="codeline">  tryHintsRecoloring();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline"></td>
    <td class="lineNumber">2661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">  if (VerifyEnabled)</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">  if (VerifyEnabled)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline">    MF->verify(this, "Before post optimization");</td>
    <td class="lineNumber">2663</td>
    <td class="codeline">    MF->verify(this, "Before post optimization");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline">  postOptimization();</td>
    <td class="lineNumber">2664</td>
    <td class="codeline">  postOptimization();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">  reportStats();</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">  reportStats();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline"></td>
    <td class="lineNumber">2666</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">  releaseMemory();</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">  releaseMemory();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2668</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline"></td>
    <td class="lineNumber">2670</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- RegAllocGreedy.cpp - greedy register allocator ---------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- RegAllocGreedy.cpp - greedy register allocator ---------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file defines the RAGreedy function pass for register allocation in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file defines the RAGreedy function pass for register allocation in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// optimized builds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// optimized builds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "RegAllocGreedy.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "RegAllocGreedy.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "AllocationOrder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "AllocationOrder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "InterferenceCache.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "InterferenceCache.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "LiveDebugVariables.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "LiveDebugVariables.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "RegAllocBase.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "RegAllocBase.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "RegAllocEvictionAdvisor.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "RegAllocEvictionAdvisor.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "RegAllocPriorityAdvisor.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "RegAllocPriorityAdvisor.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "SpillPlacement.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "SpillPlacement.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "SplitKit.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "SplitKit.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/IndexedMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/IndexedMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Analysis/AliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/CodeGen/CalcSpillWeights.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/CodeGen/CalcSpillWeights.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/CodeGen/EdgeBundles.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/CodeGen/EdgeBundles.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveInterval.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveInterval.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveIntervalUnion.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveIntervalUnion.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveIntervals.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveIntervals.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveRangeEdit.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveRangeEdit.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveRegMatrix.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveRegMatrix.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveStacks.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/CodeGen/LiveStacks.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBlockFrequencyInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBlockFrequencyInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineDominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineDominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFrameInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFrameInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineLoopInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/CodeGen/RegAllocRegistry.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/CodeGen/RegAllocRegistry.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/CodeGen/SlotIndexes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/CodeGen/SlotIndexes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/CodeGen/Spiller.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/CodeGen/Spiller.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/CodeGen/VirtRegMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/CodeGen/VirtRegMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/IR/DebugInfoMetadata.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/IR/DebugInfoMetadata.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">#include "llvm/MC/MCRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">#include "llvm/MC/MCRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">#include "llvm/Support/BlockFrequency.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">#include "llvm/Support/BlockFrequency.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">#include "llvm/Support/Timer.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">#include "llvm/Support/Timer.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">#define DEBUG_TYPE "regalloc"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">#define DEBUG_TYPE "regalloc"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">STATISTIC(NumGlobalSplits, "Number of split global live ranges");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">STATISTIC(NumGlobalSplits, "Number of split global live ranges");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">STATISTIC(NumLocalSplits,  "Number of split local live ranges");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">STATISTIC(NumLocalSplits,  "Number of split local live ranges");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">STATISTIC(NumEvicted,      "Number of interferences evicted");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">STATISTIC(NumEvicted,      "Number of interferences evicted");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">static cl::opt<SplitEditor::ComplementSpillMode> SplitSpillMode(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">static cl::opt<SplitEditor::ComplementSpillMode> SplitSpillMode(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">    "split-spill-mode", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">    "split-spill-mode", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">    cl::desc("Spill mode for splitting live ranges"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">    cl::desc("Spill mode for splitting live ranges"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">    cl::values(clEnumValN(SplitEditor::SM_Partition, "default", "Default"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">    cl::values(clEnumValN(SplitEditor::SM_Partition, "default", "Default"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">               clEnumValN(SplitEditor::SM_Size, "size", "Optimize for size"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">               clEnumValN(SplitEditor::SM_Size, "size", "Optimize for size"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">               clEnumValN(SplitEditor::SM_Speed, "speed", "Optimize for speed")),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">               clEnumValN(SplitEditor::SM_Speed, "speed", "Optimize for speed")),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">    cl::init(SplitEditor::SM_Speed));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">    cl::init(SplitEditor::SM_Speed));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">LastChanceRecoloringMaxDepth("lcr-max-depth", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">LastChanceRecoloringMaxDepth("lcr-max-depth", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">                             cl::desc("Last chance recoloring max depth"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">                             cl::desc("Last chance recoloring max depth"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">                             cl::init(5));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">                             cl::init(5));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">static cl::opt<unsigned> LastChanceRecoloringMaxInterference(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">static cl::opt<unsigned> LastChanceRecoloringMaxInterference(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">    "lcr-max-interf", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">    "lcr-max-interf", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">    cl::desc("Last chance recoloring maximum number of considered"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">    cl::desc("Last chance recoloring maximum number of considered"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">             " interference at a time"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">             " interference at a time"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">    cl::init(8));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">    cl::init(8));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">static cl::opt<bool> ExhaustiveSearch(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">static cl::opt<bool> ExhaustiveSearch(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">    "exhaustive-register-search", cl::NotHidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">    "exhaustive-register-search", cl::NotHidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">    cl::desc("Exhaustive Search for registers bypassing the depth "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">    cl::desc("Exhaustive Search for registers bypassing the depth "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">             "and interference cutoffs of last chance recoloring"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">             "and interference cutoffs of last chance recoloring"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">static cl::opt<bool> EnableDeferredSpilling(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">static cl::opt<bool> EnableDeferredSpilling(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">    "enable-deferred-spilling", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">    "enable-deferred-spilling", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">    cl::desc("Instead of spilling a variable right away, defer the actual "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">    cl::desc("Instead of spilling a variable right away, defer the actual "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">             "code insertion to the end of the allocation. That way the "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">             "code insertion to the end of the allocation. That way the "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">             "allocator might still find a suitable coloring for this "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">             "allocator might still find a suitable coloring for this "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">             "variable because of other evicted variables."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">             "variable because of other evicted variables."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">    cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">    cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">// FIXME: Find a good default for this flag and remove the flag.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">// FIXME: Find a good default for this flag and remove the flag.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">CSRFirstTimeCost("regalloc-csr-first-time-cost",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">CSRFirstTimeCost("regalloc-csr-first-time-cost",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">              cl::desc("Cost for first time use of callee-saved register."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">              cl::desc("Cost for first time use of callee-saved register."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">              cl::init(0), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">              cl::init(0), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">static cl::opt<unsigned long> GrowRegionComplexityBudget(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">static cl::opt<unsigned long> GrowRegionComplexityBudget(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">    "grow-region-complexity-budget",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">    "grow-region-complexity-budget",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">    cl::desc("growRegion() does not scale with the number of BB edges, so "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">    cl::desc("growRegion() does not scale with the number of BB edges, so "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">             "limit its budget and bail out once we reach the limit."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">             "limit its budget and bail out once we reach the limit."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">    cl::init(10000), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">    cl::init(10000), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">static cl::opt<bool> GreedyRegClassPriorityTrumpsGlobalness(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">static cl::opt<bool> GreedyRegClassPriorityTrumpsGlobalness(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">    "greedy-regclass-priority-trumps-globalness",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">    "greedy-regclass-priority-trumps-globalness",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    cl::desc("Change the greedy register allocator's live range priority "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    cl::desc("Change the greedy register allocator's live range priority "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">             "calculation to make the AllocationPriority of the register class "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">             "calculation to make the AllocationPriority of the register class "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">             "more important then whether the range is global"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">             "more important then whether the range is global"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">static cl::opt<bool> GreedyReverseLocalAssignment(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">static cl::opt<bool> GreedyReverseLocalAssignment(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">    "greedy-reverse-local-assignment",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">    "greedy-reverse-local-assignment",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">    cl::desc("Reverse allocation order of local live ranges, such that "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">    cl::desc("Reverse allocation order of local live ranges, such that "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">             "shorter local live ranges will tend to be allocated first"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">             "shorter local live ranges will tend to be allocated first"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">static RegisterRegAlloc greedyRegAlloc("greedy", "greedy register allocator",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">static RegisterRegAlloc greedyRegAlloc("greedy", "greedy register allocator",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">                                       createGreedyRegisterAllocator);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">                                       createGreedyRegisterAllocator);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">char RAGreedy::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">char RAGreedy::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">char &llvm::RAGreedyID = RAGreedy::ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">char &llvm::RAGreedyID = RAGreedy::ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(RAGreedy, "greedy",</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">150</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(RAGreedy, "greedy",</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">                "Greedy Register Allocator", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">                "Greedy Register Allocator", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveDebugVariables)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">152</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveDebugVariables)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(SlotIndexes)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">153</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(SlotIndexes)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">154</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveIntervals)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(RegisterCoalescer)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">155</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(RegisterCoalescer)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineScheduler)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">156</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineScheduler)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveStacks)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">157</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveStacks)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">158</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineDominatorTree)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">159</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(VirtRegMap)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">160</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(VirtRegMap)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveRegMatrix)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">161</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LiveRegMatrix)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(EdgeBundles)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">162</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(EdgeBundles)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(SpillPlacement)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">163</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(SpillPlacement)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineOptimizationRemarkEmitterPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">164</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(MachineOptimizationRemarkEmitterPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(RegAllocEvictionAdvisorAnalysis)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">165</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(RegAllocEvictionAdvisorAnalysis)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(RegAllocPriorityAdvisorAnalysis)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">166</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(RegAllocPriorityAdvisorAnalysis)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(RAGreedy, "greedy",</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">167</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(RAGreedy, "greedy",</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">                "Greedy Register Allocator", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">                "Greedy Register Allocator", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">const char *const RAGreedy::StageName[] = {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">const char *const RAGreedy::StageName[] = {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">    "RS_New",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">    "RS_New",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    "RS_Assign",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    "RS_Assign",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">    "RS_Split",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">    "RS_Split",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">    "RS_Split2",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">    "RS_Split2",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">    "RS_Spill",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">    "RS_Spill",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">    "RS_Memory",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">    "RS_Memory",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">    "RS_Done"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">    "RS_Done"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">// Hysteresis to use when comparing floats.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">// Hysteresis to use when comparing floats.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">// This helps stabilize decisions based on float comparisons.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">// This helps stabilize decisions based on float comparisons.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">const float Hysteresis = (2007 / 2048.0f); // 0.97998046875</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">const float Hysteresis = (2007 / 2048.0f); // 0.97998046875</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine coveredLine">FunctionPass* llvm::createGreedyRegisterAllocator() {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">186</td>
    <td class="codeLine coveredLine">FunctionPass* llvm::createGreedyRegisterAllocator() {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine coveredLine">  return new RAGreedy();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">187</td>
    <td class="codeLine coveredLine">  return new RAGreedy();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">FunctionPass *llvm::createGreedyRegisterAllocator(RegClassFilterFunc Ftor) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">FunctionPass *llvm::createGreedyRegisterAllocator(RegClassFilterFunc Ftor) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  return new RAGreedy(Ftor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  return new RAGreedy(Ftor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine coveredLine">RAGreedy::RAGreedy(RegClassFilterFunc F):</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">194</td>
    <td class="codeLine coveredLine">RAGreedy::RAGreedy(RegClassFilterFunc F):</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  MachineFunctionPass(ID),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  MachineFunctionPass(ID),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine coveredLine">  RegAllocBase(F) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">196</td>
    <td class="codeLine coveredLine">  RegAllocBase(F) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">197</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine coveredLine">void RAGreedy::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">199</td>
    <td class="codeLine coveredLine">void RAGreedy::getAnalysisUsage(AnalysisUsage &AU) const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine coveredLine">  AU.setPreservesCFG();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">200</td>
    <td class="codeLine coveredLine">  AU.setPreservesCFG();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine coveredLine">  AU.addRequired<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">201</td>
    <td class="codeLine coveredLine">  AU.addRequired<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine coveredLine">  AU.addPreserved<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">202</td>
    <td class="codeLine coveredLine">  AU.addPreserved<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine coveredLine">  AU.addRequired<LiveIntervals>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">203</td>
    <td class="codeLine coveredLine">  AU.addRequired<LiveIntervals>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine coveredLine">  AU.addPreserved<LiveIntervals>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">204</td>
    <td class="codeLine coveredLine">  AU.addPreserved<LiveIntervals>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine coveredLine">  AU.addRequired<SlotIndexes>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">205</td>
    <td class="codeLine coveredLine">  AU.addRequired<SlotIndexes>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">  AU.addPreserved<SlotIndexes>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">  AU.addPreserved<SlotIndexes>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">  AU.addRequired<LiveDebugVariables>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">  AU.addRequired<LiveDebugVariables>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine coveredLine">  AU.addPreserved<LiveDebugVariables>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">208</td>
    <td class="codeLine coveredLine">  AU.addPreserved<LiveDebugVariables>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine coveredLine">  AU.addRequired<LiveStacks>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">209</td>
    <td class="codeLine coveredLine">  AU.addRequired<LiveStacks>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine coveredLine">  AU.addPreserved<LiveStacks>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">210</td>
    <td class="codeLine coveredLine">  AU.addPreserved<LiveStacks>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine coveredLine">  AU.addRequired<MachineDominatorTree>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">211</td>
    <td class="codeLine coveredLine">  AU.addRequired<MachineDominatorTree>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine coveredLine">  AU.addPreserved<MachineDominatorTree>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">212</td>
    <td class="codeLine coveredLine">  AU.addPreserved<MachineDominatorTree>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine coveredLine">  AU.addRequired<MachineLoopInfo>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">213</td>
    <td class="codeLine coveredLine">  AU.addRequired<MachineLoopInfo>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine coveredLine">  AU.addPreserved<MachineLoopInfo>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">214</td>
    <td class="codeLine coveredLine">  AU.addPreserved<MachineLoopInfo>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine coveredLine">  AU.addRequired<VirtRegMap>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">215</td>
    <td class="codeLine coveredLine">  AU.addRequired<VirtRegMap>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine coveredLine">  AU.addPreserved<VirtRegMap>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">216</td>
    <td class="codeLine coveredLine">  AU.addPreserved<VirtRegMap>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine coveredLine">  AU.addRequired<LiveRegMatrix>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">217</td>
    <td class="codeLine coveredLine">  AU.addRequired<LiveRegMatrix>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine coveredLine">  AU.addPreserved<LiveRegMatrix>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">218</td>
    <td class="codeLine coveredLine">  AU.addPreserved<LiveRegMatrix>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine coveredLine">  AU.addRequired<EdgeBundles>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">219</td>
    <td class="codeLine coveredLine">  AU.addRequired<EdgeBundles>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine coveredLine">  AU.addRequired<SpillPlacement>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">220</td>
    <td class="codeLine coveredLine">  AU.addRequired<SpillPlacement>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine coveredLine">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">221</td>
    <td class="codeLine coveredLine">  AU.addRequired<MachineOptimizationRemarkEmitterPass>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine coveredLine">  AU.addRequired<RegAllocEvictionAdvisorAnalysis>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">222</td>
    <td class="codeLine coveredLine">  AU.addRequired<RegAllocEvictionAdvisorAnalysis>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine coveredLine">  AU.addRequired<RegAllocPriorityAdvisorAnalysis>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">223</td>
    <td class="codeLine coveredLine">  AU.addRequired<RegAllocPriorityAdvisorAnalysis>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine coveredLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">224</td>
    <td class="codeLine coveredLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">225</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">//                     LiveRangeEdit delegate methods</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">//                     LiveRangeEdit delegate methods</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">bool RAGreedy::LRE_CanEraseVirtReg(Register VirtReg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">bool RAGreedy::LRE_CanEraseVirtReg(Register VirtReg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  if (VRM->hasPhys(VirtReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  if (VRM->hasPhys(VirtReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">    Matrix->unassign(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">    Matrix->unassign(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">    aboutToRemoveInterval(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">    aboutToRemoveInterval(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  // Unassigned virtreg is probably in the priority queue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  // Unassigned virtreg is probably in the priority queue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  // RegAllocBase will erase it after dequeueing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  // RegAllocBase will erase it after dequeueing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  // Nonetheless, clear the live-range so that the debug</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  // Nonetheless, clear the live-range so that the debug</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  // dump will show the right state for that VirtReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  // dump will show the right state for that VirtReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  LI.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  LI.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">void RAGreedy::LRE_WillShrinkVirtReg(Register VirtReg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">void RAGreedy::LRE_WillShrinkVirtReg(Register VirtReg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  if (!VRM->hasPhys(VirtReg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  if (!VRM->hasPhys(VirtReg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  // Register is assigned, put it back on the queue for reassignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  // Register is assigned, put it back on the queue for reassignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  LiveInterval &LI = LIS->getInterval(VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  Matrix->unassign(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  Matrix->unassign(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  RegAllocBase::enqueue(&LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  RegAllocBase::enqueue(&LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">void RAGreedy::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">void RAGreedy::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  ExtraInfo->LRE_DidCloneVirtReg(New, Old);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  ExtraInfo->LRE_DidCloneVirtReg(New, Old);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">void RAGreedy::ExtraRegInfo::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">void RAGreedy::ExtraRegInfo::LRE_DidCloneVirtReg(Register New, Register Old) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">  // Cloning a register we haven't even heard about yet?  Just ignore it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">  // Cloning a register we haven't even heard about yet?  Just ignore it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  if (!Info.inBounds(Old))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  if (!Info.inBounds(Old))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  // LRE may clone a virtual register because dead code elimination causes it to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  // LRE may clone a virtual register because dead code elimination causes it to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  // be split into connected components. The new components are much smaller</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  // be split into connected components. The new components are much smaller</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  // than the original, so they should get a new chance at being assigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  // than the original, so they should get a new chance at being assigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  // same stage as the parent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  // same stage as the parent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  Info[Old].Stage = RS_Assign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  Info[Old].Stage = RS_Assign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  Info.grow(New.id());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  Info.grow(New.id());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  Info[New] = Info[Old];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  Info[New] = Info[Old];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine coveredLine">void RAGreedy::releaseMemory() {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">274</td>
    <td class="codeLine coveredLine">void RAGreedy::releaseMemory() {</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine coveredLine">  SpillerInstance.reset();</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">275</td>
    <td class="codeLine coveredLine">  SpillerInstance.reset();</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine coveredLine">  GlobalCand.clear();</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">276</td>
    <td class="codeLine coveredLine">  GlobalCand.clear();</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">277</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine coveredLine">void RAGreedy::enqueueImpl(const LiveInterval *LI) { enqueue(Queue, LI); }</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">279</td>
    <td class="codeLine coveredLine">void RAGreedy::enqueueImpl(const LiveInterval *LI) { enqueue(Queue, LI); }</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine coveredLine">void RAGreedy::enqueue(PQueue &CurQueue, const LiveInterval *LI) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">281</td>
    <td class="codeLine coveredLine">void RAGreedy::enqueue(PQueue &CurQueue, const LiveInterval *LI) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">  // Prioritize live ranges by size, assigning larger ranges first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">  // Prioritize live ranges by size, assigning larger ranges first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  // The queue holds (size, reg) pairs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  // The queue holds (size, reg) pairs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">  const Register Reg = LI->reg();</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">  const Register Reg = LI->reg();</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine coveredLine">  assert(Reg.isVirtual() && "Can only enqueue virtual registers");</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">285</td>
    <td class="codeLine coveredLine">  assert(Reg.isVirtual() && "Can only enqueue virtual registers");</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine coveredLine">  auto Stage = ExtraInfo->getOrInitStage(Reg);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">287</td>
    <td class="codeLine coveredLine">  auto Stage = ExtraInfo->getOrInitStage(Reg);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine coveredLine">  if (Stage == RS_New) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">288</td>
    <td class="codeLine coveredLine">  if (Stage == RS_New) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine coveredLine">    Stage = RS_Assign;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">289</td>
    <td class="codeLine coveredLine">    Stage = RS_Assign;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine coveredLine">    ExtraInfo->setStage(Reg, Stage);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">290</td>
    <td class="codeLine coveredLine">    ExtraInfo->setStage(Reg, Stage);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine coveredLine">  unsigned Ret = PriorityAdvisor->getPriority(*LI);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">293</td>
    <td class="codeLine coveredLine">  unsigned Ret = PriorityAdvisor->getPriority(*LI);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  // The virtual register number is a tie breaker for same-sized ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  // The virtual register number is a tie breaker for same-sized ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  // Give lower vreg numbers higher priority to assign them first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  // Give lower vreg numbers higher priority to assign them first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine coveredLine">  CurQueue.push(std::make_pair(Ret, ~Reg));</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">297</td>
    <td class="codeLine coveredLine">  CurQueue.push(std::make_pair(Ret, ~Reg));</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">298</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine coveredLine">unsigned DefaultPriorityAdvisor::getPriority(const LiveInterval &LI) const {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">300</td>
    <td class="codeLine coveredLine">unsigned DefaultPriorityAdvisor::getPriority(const LiveInterval &LI) const {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine coveredLine">  const unsigned Size = LI.getSize();</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">301</td>
    <td class="codeLine coveredLine">  const unsigned Size = LI.getSize();</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine coveredLine">  const Register Reg = LI.reg();</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">302</td>
    <td class="codeLine coveredLine">  const Register Reg = LI.reg();</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  unsigned Prio;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  unsigned Prio;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine coveredLine">  LiveRangeStage Stage = RA.getExtraInfo().getStage(LI);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">304</td>
    <td class="codeLine coveredLine">  LiveRangeStage Stage = RA.getExtraInfo().getStage(LI);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine coveredLine">  if (Stage == RS_Split) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">306</td>
    <td class="codeLine coveredLine">  if (Stage == RS_Split) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">    // Unsplit ranges that couldn't be allocated immediately are deferred until</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">    // Unsplit ranges that couldn't be allocated immediately are deferred until</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    // everything else has been allocated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    // everything else has been allocated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">    Prio = Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">    Prio = Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine coveredLine">  } else if (Stage == RS_Memory) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">310</td>
    <td class="codeLine coveredLine">  } else if (Stage == RS_Memory) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    // Memory operand should be considered last.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    // Memory operand should be considered last.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    // Change the priority such that Memory operand are assigned in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    // Change the priority such that Memory operand are assigned in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">    // the reverse order that they came in.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">    // the reverse order that they came in.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">    // TODO: Make this a member variable and probably do something about hints.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">    // TODO: Make this a member variable and probably do something about hints.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">    static unsigned MemOp = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">    static unsigned MemOp = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">    Prio = MemOp++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">    Prio = MemOp++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">    // Giant live ranges fall back to the global assignment heuristic, which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">    // Giant live ranges fall back to the global assignment heuristic, which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">    // prevents excessive spilling in pathological cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">    // prevents excessive spilling in pathological cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine coveredLine">    const TargetRegisterClass &RC = *MRI->getRegClass(Reg);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">320</td>
    <td class="codeLine coveredLine">    const TargetRegisterClass &RC = *MRI->getRegClass(Reg);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine coveredLine">    bool ForceGlobal = RC.GlobalPriority ||</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">321</td>
    <td class="codeLine coveredLine">    bool ForceGlobal = RC.GlobalPriority ||</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine coveredLine">                       (!ReverseLocalAssignment &&</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">322</td>
    <td class="codeLine coveredLine">                       (!ReverseLocalAssignment &&</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine coveredLine">                        (Size / SlotIndex::InstrDist) ></td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">323</td>
    <td class="codeLine coveredLine">                        (Size / SlotIndex::InstrDist) ></td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine coveredLine">                            (2 * RegClassInfo.getNumAllocatableRegs(&RC)));</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">324</td>
    <td class="codeLine coveredLine">                            (2 * RegClassInfo.getNumAllocatableRegs(&RC)));</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine coveredLine">    unsigned GlobalBit = 0;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">325</td>
    <td class="codeLine coveredLine">    unsigned GlobalBit = 0;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine coveredLine">    if (Stage == RS_Assign && !ForceGlobal && !LI.empty() &&</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">327</td>
    <td class="codeLine coveredLine">    if (Stage == RS_Assign && !ForceGlobal && !LI.empty() &&</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine coveredLine">        LIS->intervalIsInOneMBB(LI)) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">328</td>
    <td class="codeLine coveredLine">        LIS->intervalIsInOneMBB(LI)) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">      // Allocate original local ranges in linear instruction order. Since they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">      // Allocate original local ranges in linear instruction order. Since they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">      // are singly defined, this produces optimal coloring in the absence of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">      // are singly defined, this produces optimal coloring in the absence of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">      // global interference and other constraints.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">      // global interference and other constraints.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine coveredLine">      if (!ReverseLocalAssignment)</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">332</td>
    <td class="codeLine coveredLine">      if (!ReverseLocalAssignment)</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine coveredLine">        Prio = LI.beginIndex().getApproxInstrDistance(Indexes->getLastIndex());</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">333</td>
    <td class="codeLine coveredLine">        Prio = LI.beginIndex().getApproxInstrDistance(Indexes->getLastIndex());</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">        // Allocating bottom up may allow many short LRGs to be assigned first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">        // Allocating bottom up may allow many short LRGs to be assigned first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">        // to one of the cheap registers. This could be much faster for very</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">        // to one of the cheap registers. This could be much faster for very</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">        // large blocks on targets with many physical registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">        // large blocks on targets with many physical registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">        Prio = Indexes->getZeroIndex().getApproxInstrDistance(LI.endIndex());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">        Prio = Indexes->getZeroIndex().getApproxInstrDistance(LI.endIndex());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">      // Allocate global and split ranges in long->short order. Long ranges that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">      // Allocate global and split ranges in long->short order. Long ranges that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">      // don't fit should be spilled (or split) ASAP so they don't create</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">      // don't fit should be spilled (or split) ASAP so they don't create</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">      // interference.  Mark a bit to prioritize global above local ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">      // interference.  Mark a bit to prioritize global above local ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">      Prio = Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">      Prio = Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">      GlobalBit = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">      GlobalBit = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">    // Priority bit layout:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">    // Priority bit layout:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">    // 31 RS_Assign priority</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">    // 31 RS_Assign priority</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">    // 30 Preference priority</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">    // 30 Preference priority</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    // if (RegClassPriorityTrumpsGlobalness)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    // if (RegClassPriorityTrumpsGlobalness)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">    //   29-25 AllocPriority</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">    //   29-25 AllocPriority</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">    //   24 GlobalBit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">    //   24 GlobalBit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">    // else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">    // else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">    //   29 Global bit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">    //   29 Global bit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">    //   28-24 AllocPriority</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">    //   28-24 AllocPriority</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">    // 0-23 Size/Instr distance</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">    // 0-23 Size/Instr distance</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">    // Clamp the size to fit with the priority masking scheme</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">    // Clamp the size to fit with the priority masking scheme</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine coveredLine">    Prio = std::min(Prio, (unsigned)maxUIntN(24));</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">360</td>
    <td class="codeLine coveredLine">    Prio = std::min(Prio, (unsigned)maxUIntN(24));</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine coveredLine">    assert(isUInt<5>(RC.AllocationPriority) && "allocation priority overflow");</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">361</td>
    <td class="codeLine coveredLine">    assert(isUInt<5>(RC.AllocationPriority) && "allocation priority overflow");</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine coveredLine">    if (RegClassPriorityTrumpsGlobalness)</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">363</td>
    <td class="codeLine coveredLine">    if (RegClassPriorityTrumpsGlobalness)</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">      Prio |= RC.AllocationPriority << 25 | GlobalBit << 24;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">      Prio |= RC.AllocationPriority << 25 | GlobalBit << 24;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine coveredLine">      Prio |= GlobalBit << 29 | RC.AllocationPriority << 24;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">366</td>
    <td class="codeLine coveredLine">      Prio |= GlobalBit << 29 | RC.AllocationPriority << 24;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">    // Mark a higher bit to prioritize global and local above RS_Split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">    // Mark a higher bit to prioritize global and local above RS_Split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine coveredLine">    Prio |= (1u << 31);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">369</td>
    <td class="codeLine coveredLine">    Prio |= (1u << 31);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">    // Boost ranges that have a physical register hint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">    // Boost ranges that have a physical register hint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine coveredLine">    if (VRM->hasKnownPreference(Reg))</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">372</td>
    <td class="codeLine coveredLine">    if (VRM->hasKnownPreference(Reg))</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine coveredLine">      Prio |= (1u << 30);</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">373</td>
    <td class="codeLine coveredLine">      Prio |= (1u << 30);</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine coveredLine">  return Prio;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">376</td>
    <td class="codeLine coveredLine">  return Prio;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine coveredLine">const LiveInterval *RAGreedy::dequeue() { return dequeue(Queue); }</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">379</td>
    <td class="codeLine coveredLine">const LiveInterval *RAGreedy::dequeue() { return dequeue(Queue); }</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine coveredLine">const LiveInterval *RAGreedy::dequeue(PQueue &CurQueue) {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">381</td>
    <td class="codeLine coveredLine">const LiveInterval *RAGreedy::dequeue(PQueue &CurQueue) {</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine coveredLine">  if (CurQueue.empty())</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">382</td>
    <td class="codeLine coveredLine">  if (CurQueue.empty())</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine coveredLine">    return nullptr;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">383</td>
    <td class="codeLine coveredLine">    return nullptr;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine coveredLine">  LiveInterval *LI = &LIS->getInterval(~CurQueue.top().second);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">384</td>
    <td class="codeLine coveredLine">  LiveInterval *LI = &LIS->getInterval(~CurQueue.top().second);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine coveredLine">  CurQueue.pop();</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">385</td>
    <td class="codeLine coveredLine">  CurQueue.pop();</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine coveredLine">  return LI;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">386</td>
    <td class="codeLine coveredLine">  return LI;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">//                            Direct Assignment</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">//                            Direct Assignment</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">/// tryAssign - Try to assign VirtReg to an available register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">/// tryAssign - Try to assign VirtReg to an available register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine coveredLine">MCRegister RAGreedy::tryAssign(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">394</td>
    <td class="codeLine coveredLine">MCRegister RAGreedy::tryAssign(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">                               AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">                               AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">                               SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">                               SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">                               const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">                               const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine coveredLine">  MCRegister PhysReg;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">398</td>
    <td class="codeLine coveredLine">  MCRegister PhysReg;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine coveredLine">  for (auto I = Order.begin(), E = Order.end(); I != E && !PhysReg; ++I) {</td>
    <td class="lineNumber">14</td>
    <td class="lineNumber">399</td>
    <td class="codeLine coveredLine">  for (auto I = Order.begin(), E = Order.end(); I != E && !PhysReg; ++I) {</td>
    <td class="lineNumber">14</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine coveredLine">    assert(*I);</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">400</td>
    <td class="codeLine coveredLine">    assert(*I);</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine coveredLine">    if (!Matrix->checkInterference(VirtReg, *I)) {</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">401</td>
    <td class="codeLine coveredLine">    if (!Matrix->checkInterference(VirtReg, *I)) {</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine coveredLine">      if (I.isHint())</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">402</td>
    <td class="codeLine coveredLine">      if (I.isHint())</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine coveredLine">        return *I;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">403</td>
    <td class="codeLine coveredLine">        return *I;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine coveredLine">        PhysReg = *I;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">405</td>
    <td class="codeLine coveredLine">        PhysReg = *I;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine coveredLine">  if (!PhysReg.isValid())</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">408</td>
    <td class="codeLine coveredLine">  if (!PhysReg.isValid())</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">    return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">    return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  // PhysReg is available, but there may be a better choice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  // PhysReg is available, but there may be a better choice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  // If we missed a simple hint, try to cheaply evict interference from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  // If we missed a simple hint, try to cheaply evict interference from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  // preferred register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  // preferred register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine coveredLine">  if (Register Hint = MRI->getSimpleHint(VirtReg.reg()))</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">415</td>
    <td class="codeLine coveredLine">  if (Register Hint = MRI->getSimpleHint(VirtReg.reg()))</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">    if (Order.isHint(Hint)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">    if (Order.isHint(Hint)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">      MCRegister PhysHint = Hint.asMCReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">      MCRegister PhysHint = Hint.asMCReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "missed hint " << printReg(PhysHint, TRI) << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "missed hint " << printReg(PhysHint, TRI) << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">      if (EvictAdvisor->canEvictHintInterference(VirtReg, PhysHint,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">      if (EvictAdvisor->canEvictHintInterference(VirtReg, PhysHint,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">                                                 FixedRegisters)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">                                                 FixedRegisters)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">        evictInterference(VirtReg, PhysHint, NewVRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">        evictInterference(VirtReg, PhysHint, NewVRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">        return PhysHint;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">        return PhysHint;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">      // Record the missed hint, we may be able to recover</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">      // Record the missed hint, we may be able to recover</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">      // at the end if the surrounding allocation changed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">      // at the end if the surrounding allocation changed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">      SetOfBrokenHints.insert(&VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">      SetOfBrokenHints.insert(&VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  // Try to evict interference from a cheaper alternative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  // Try to evict interference from a cheaper alternative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine coveredLine">  uint8_t Cost = RegCosts[PhysReg];</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">431</td>
    <td class="codeLine coveredLine">  uint8_t Cost = RegCosts[PhysReg];</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  // Most registers have 0 additional cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  // Most registers have 0 additional cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine coveredLine">  if (!Cost)</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">434</td>
    <td class="codeLine coveredLine">  if (!Cost)</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine coveredLine">    return PhysReg;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">435</td>
    <td class="codeLine coveredLine">    return PhysReg;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << " is available at cost "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << " is available at cost "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">                    << (unsigned)Cost << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">                    << (unsigned)Cost << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  MCRegister CheapReg = tryEvict(VirtReg, Order, NewVRegs, Cost, FixedRegisters);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  MCRegister CheapReg = tryEvict(VirtReg, Order, NewVRegs, Cost, FixedRegisters);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  return CheapReg ? CheapReg : PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  return CheapReg ? CheapReg : PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">//                         Interference eviction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">//                         Interference eviction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">bool RegAllocEvictionAdvisor::canReassign(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">bool RegAllocEvictionAdvisor::canReassign(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">                                          MCRegister FromReg) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">                                          MCRegister FromReg) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  auto HasRegUnitInterference = [&](MCRegUnit Unit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  auto HasRegUnitInterference = [&](MCRegUnit Unit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">    // Instantiate a "subquery", not to be confused with the Queries array.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">    // Instantiate a "subquery", not to be confused with the Queries array.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">    LiveIntervalUnion::Query SubQ(VirtReg, Matrix->getLiveUnions()[Unit]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">    LiveIntervalUnion::Query SubQ(VirtReg, Matrix->getLiveUnions()[Unit]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">    return SubQ.checkInterference();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">    return SubQ.checkInterference();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  for (MCRegister Reg :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  for (MCRegister Reg :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">       AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">       AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">    if (Reg == FromReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">    if (Reg == FromReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">    // If no units have interference, reassignment is possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">    // If no units have interference, reassignment is possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">    if (none_of(TRI->regunits(Reg), HasRegUnitInterference)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">    if (none_of(TRI->regunits(Reg), HasRegUnitInterference)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "can reassign: " << VirtReg << " from "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "can reassign: " << VirtReg << " from "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">                        << printReg(FromReg, TRI) << " to "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">                        << printReg(FromReg, TRI) << " to "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">                        << printReg(Reg, TRI) << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">                        << printReg(Reg, TRI) << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">/// evictInterference - Evict any interferring registers that prevent VirtReg</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">/// evictInterference - Evict any interferring registers that prevent VirtReg</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">/// from being assigned to Physreg. This assumes that canEvictInterference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">/// from being assigned to Physreg. This assumes that canEvictInterference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">/// returned true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">/// returned true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">void RAGreedy::evictInterference(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">void RAGreedy::evictInterference(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">                                 MCRegister PhysReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">                                 MCRegister PhysReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  // Make sure that VirtReg has a cascade number, and assign that cascade</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  // Make sure that VirtReg has a cascade number, and assign that cascade</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  // number to every evicted register. These live ranges than then only be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  // number to every evicted register. These live ranges than then only be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  // evicted by a newer cascade, preventing infinite loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  // evicted by a newer cascade, preventing infinite loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  unsigned Cascade = ExtraInfo->getOrAssignNewCascade(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  unsigned Cascade = ExtraInfo->getOrAssignNewCascade(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "evicting " << printReg(PhysReg, TRI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "evicting " << printReg(PhysReg, TRI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">                    << " interference: Cascade " << Cascade << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">                    << " interference: Cascade " << Cascade << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  // Collect all interfering virtregs first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  // Collect all interfering virtregs first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  SmallVector<const LiveInterval *, 8> Intfs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  SmallVector<const LiveInterval *, 8> Intfs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">    // We usually have the interfering VRegs cached so collectInterferingVRegs()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">    // We usually have the interfering VRegs cached so collectInterferingVRegs()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">    // should be fast, we may need to recalculate if when different physregs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">    // should be fast, we may need to recalculate if when different physregs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">    // overlap the same register unit so we had different SubRanges queried</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">    // overlap the same register unit so we had different SubRanges queried</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">    // against it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">    // against it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">    ArrayRef<const LiveInterval *> IVR = Q.interferingVRegs();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">    ArrayRef<const LiveInterval *> IVR = Q.interferingVRegs();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">    Intfs.append(IVR.begin(), IVR.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">    Intfs.append(IVR.begin(), IVR.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  // Evict them second. This will invalidate the queries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  // Evict them second. This will invalidate the queries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  for (const LiveInterval *Intf : Intfs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  for (const LiveInterval *Intf : Intfs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">    // The same VirtReg may be present in multiple RegUnits. Skip duplicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">    // The same VirtReg may be present in multiple RegUnits. Skip duplicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    if (!VRM->hasPhys(Intf->reg()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    if (!VRM->hasPhys(Intf->reg()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">    Matrix->unassign(*Intf);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">    Matrix->unassign(*Intf);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">    assert((ExtraInfo->getCascade(Intf->reg()) < Cascade ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">    assert((ExtraInfo->getCascade(Intf->reg()) < Cascade ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">            VirtReg.isSpillable() < Intf->isSpillable()) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">            VirtReg.isSpillable() < Intf->isSpillable()) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">           "Cannot decrease cascade number, illegal eviction");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">           "Cannot decrease cascade number, illegal eviction");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">    ExtraInfo->setCascade(Intf->reg(), Cascade);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">    ExtraInfo->setCascade(Intf->reg(), Cascade);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    ++NumEvicted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    ++NumEvicted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">    NewVRegs.push_back(Intf->reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">    NewVRegs.push_back(Intf->reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">/// Returns true if the given \p PhysReg is a callee saved register and has not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">/// Returns true if the given \p PhysReg is a callee saved register and has not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">/// been used for allocation yet.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">/// been used for allocation yet.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">bool RegAllocEvictionAdvisor::isUnusedCalleeSavedReg(MCRegister PhysReg) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">bool RegAllocEvictionAdvisor::isUnusedCalleeSavedReg(MCRegister PhysReg) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  MCRegister CSR = RegClassInfo.getLastCalleeSavedAlias(PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  MCRegister CSR = RegClassInfo.getLastCalleeSavedAlias(PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  if (!CSR)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  if (!CSR)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  return !Matrix->isPhysRegUsed(PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  return !Matrix->isPhysRegUsed(PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">std::optional<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">std::optional<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">RegAllocEvictionAdvisor::getOrderLimit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">RegAllocEvictionAdvisor::getOrderLimit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">                                       const AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">                                       const AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">                                       unsigned CostPerUseLimit) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">                                       unsigned CostPerUseLimit) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  unsigned OrderLimit = Order.getOrder().size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  unsigned OrderLimit = Order.getOrder().size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  if (CostPerUseLimit < uint8_t(~0u)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  if (CostPerUseLimit < uint8_t(~0u)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">    // Check of any registers in RC are below CostPerUseLimit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">    // Check of any registers in RC are below CostPerUseLimit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    const TargetRegisterClass *RC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    const TargetRegisterClass *RC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">    uint8_t MinCost = RegClassInfo.getMinCost(RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">    uint8_t MinCost = RegClassInfo.getMinCost(RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    if (MinCost >= CostPerUseLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    if (MinCost >= CostPerUseLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << TRI->getRegClassName(RC) << " minimum cost = "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << TRI->getRegClassName(RC) << " minimum cost = "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">                        << MinCost << ", no cheaper registers to be found.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">                        << MinCost << ", no cheaper registers to be found.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">      return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">    // It is normal for register classes to have a long tail of registers with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">    // It is normal for register classes to have a long tail of registers with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    // the same cost. We don't need to look at them if they're too expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    // the same cost. We don't need to look at them if they're too expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">    if (RegCosts[Order.getOrder().back()] >= CostPerUseLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">    if (RegCosts[Order.getOrder().back()] >= CostPerUseLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">      OrderLimit = RegClassInfo.getLastCostChange(RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">      OrderLimit = RegClassInfo.getLastCostChange(RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Only trying the first " << OrderLimit</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Only trying the first " << OrderLimit</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">                        << " regs.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">                        << " regs.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  return OrderLimit;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  return OrderLimit;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">bool RegAllocEvictionAdvisor::canAllocatePhysReg(unsigned CostPerUseLimit,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">bool RegAllocEvictionAdvisor::canAllocatePhysReg(unsigned CostPerUseLimit,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">                                                 MCRegister PhysReg) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">                                                 MCRegister PhysReg) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  if (RegCosts[PhysReg] >= CostPerUseLimit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  if (RegCosts[PhysReg] >= CostPerUseLimit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">  // The first use of a callee-saved register in a function has cost 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">  // The first use of a callee-saved register in a function has cost 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  // Don't start using a CSR when the CostPerUseLimit is low.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  // Don't start using a CSR when the CostPerUseLimit is low.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  if (CostPerUseLimit == 1 && isUnusedCalleeSavedReg(PhysReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  if (CostPerUseLimit == 1 && isUnusedCalleeSavedReg(PhysReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">    LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">    LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">        dbgs() << printReg(PhysReg, TRI) << " would clobber CSR "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">        dbgs() << printReg(PhysReg, TRI) << " would clobber CSR "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">               << printReg(RegClassInfo.getLastCalleeSavedAlias(PhysReg), TRI)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">               << printReg(RegClassInfo.getLastCalleeSavedAlias(PhysReg), TRI)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">               << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">               << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">/// tryEvict - Try to evict all interferences for a physreg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">/// tryEvict - Try to evict all interferences for a physreg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">/// @param  VirtReg Currently unassigned virtual register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">/// @param  VirtReg Currently unassigned virtual register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">/// @param  Order   Physregs to try.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">/// @param  Order   Physregs to try.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">/// @return         Physreg to assign VirtReg, or 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">/// @return         Physreg to assign VirtReg, or 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">MCRegister RAGreedy::tryEvict(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">MCRegister RAGreedy::tryEvict(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">                              AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">                              AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">                              SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">                              SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">                              uint8_t CostPerUseLimit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">                              uint8_t CostPerUseLimit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">                              const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">                              const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  NamedRegionTimer T("evict", "Evict", TimerGroupName, TimerGroupDescription,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  NamedRegionTimer T("evict", "Evict", TimerGroupName, TimerGroupDescription,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">                     TimePassesIsEnabled);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">                     TimePassesIsEnabled);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  MCRegister BestPhys = EvictAdvisor->tryFindEvictionCandidate(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  MCRegister BestPhys = EvictAdvisor->tryFindEvictionCandidate(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">      VirtReg, Order, CostPerUseLimit, FixedRegisters);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">      VirtReg, Order, CostPerUseLimit, FixedRegisters);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">  if (BestPhys.isValid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">  if (BestPhys.isValid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">    evictInterference(VirtReg, BestPhys, NewVRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">    evictInterference(VirtReg, BestPhys, NewVRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  return BestPhys;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  return BestPhys;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">//                              Region Splitting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">//                              Region Splitting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">/// addSplitConstraints - Fill out the SplitConstraints vector based on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">/// addSplitConstraints - Fill out the SplitConstraints vector based on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">/// interference pattern in Physreg and its aliases. Add the constraints to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">/// interference pattern in Physreg and its aliases. Add the constraints to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">/// SpillPlacement and return the static cost of this split in Cost, assuming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">/// SpillPlacement and return the static cost of this split in Cost, assuming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">/// that all preferences in SplitConstraints are met.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">/// that all preferences in SplitConstraints are met.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">/// Return false if there are no bundles with positive bias.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">/// Return false if there are no bundles with positive bias.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">bool RAGreedy::addSplitConstraints(InterferenceCache::Cursor Intf,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">bool RAGreedy::addSplitConstraints(InterferenceCache::Cursor Intf,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">                                   BlockFrequency &Cost) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">                                   BlockFrequency &Cost) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">  // Reset interference dependent info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">  // Reset interference dependent info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  SplitConstraints.resize(UseBlocks.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  SplitConstraints.resize(UseBlocks.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  BlockFrequency StaticCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  BlockFrequency StaticCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">    BC.Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">    BC.Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    Intf.moveToBlock(BC.Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    Intf.moveToBlock(BC.Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    BC.Entry = BI.LiveIn ? SpillPlacement::PrefReg : SpillPlacement::DontCare;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    BC.Entry = BI.LiveIn ? SpillPlacement::PrefReg : SpillPlacement::DontCare;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    BC.Exit = (BI.LiveOut &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    BC.Exit = (BI.LiveOut &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">               !LIS->getInstructionFromIndex(BI.LastInstr)->isImplicitDef())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">               !LIS->getInstructionFromIndex(BI.LastInstr)->isImplicitDef())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">                  ? SpillPlacement::PrefReg</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">                  ? SpillPlacement::PrefReg</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">                  : SpillPlacement::DontCare;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">                  : SpillPlacement::DontCare;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    BC.ChangesValue = BI.FirstDef.isValid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    BC.ChangesValue = BI.FirstDef.isValid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">    if (!Intf.hasInterference())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">    if (!Intf.hasInterference())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">    // Number of spill code instructions to insert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">    // Number of spill code instructions to insert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">    unsigned Ins = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">    unsigned Ins = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">    // Interference for the live-in value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">    // Interference for the live-in value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">    if (BI.LiveIn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">    if (BI.LiveIn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">      if (Intf.first() <= Indexes->getMBBStartIdx(BC.Number)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">      if (Intf.first() <= Indexes->getMBBStartIdx(BC.Number)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">        BC.Entry = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">        BC.Entry = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">      } else if (Intf.first() < BI.FirstInstr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">      } else if (Intf.first() < BI.FirstInstr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">        BC.Entry = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">        BC.Entry = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">      } else if (Intf.first() < BI.LastInstr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">      } else if (Intf.first() < BI.LastInstr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">      // Abort if the spill cannot be inserted at the MBB' start</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">      // Abort if the spill cannot be inserted at the MBB' start</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">      if (((BC.Entry == SpillPlacement::MustSpill) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">      if (((BC.Entry == SpillPlacement::MustSpill) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">           (BC.Entry == SpillPlacement::PrefSpill)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">           (BC.Entry == SpillPlacement::PrefSpill)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">          SlotIndex::isEarlierInstr(BI.FirstInstr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">          SlotIndex::isEarlierInstr(BI.FirstInstr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">                                    SA->getFirstSplitPoint(BC.Number)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">                                    SA->getFirstSplitPoint(BC.Number)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">    // Interference for the live-out value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">    // Interference for the live-out value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    if (BI.LiveOut) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    if (BI.LiveOut) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">      if (Intf.last() >= SA->getLastSplitPoint(BC.Number)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">      if (Intf.last() >= SA->getLastSplitPoint(BC.Number)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">        BC.Exit = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">        BC.Exit = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">      } else if (Intf.last() > BI.LastInstr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">      } else if (Intf.last() > BI.LastInstr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">        BC.Exit = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">        BC.Exit = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">      } else if (Intf.last() > BI.FirstInstr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">      } else if (Intf.last() > BI.FirstInstr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">        ++Ins;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    // Accumulate the total frequency of inserted spill code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    // Accumulate the total frequency of inserted spill code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">    while (Ins--)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">    while (Ins--)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">      StaticCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">      StaticCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  Cost = StaticCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  Cost = StaticCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  // Add constraints for use-blocks. Note that these are the only constraints</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  // Add constraints for use-blocks. Note that these are the only constraints</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  // that may add a positive bias, it is downhill from here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  // that may add a positive bias, it is downhill from here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  SpillPlacer->addConstraints(SplitConstraints);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  SpillPlacer->addConstraints(SplitConstraints);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  return SpillPlacer->scanActiveBundles();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  return SpillPlacer->scanActiveBundles();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">/// addThroughConstraints - Add constraints and links to SpillPlacer from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">/// addThroughConstraints - Add constraints and links to SpillPlacer from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">/// live-through blocks in Blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">/// live-through blocks in Blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">bool RAGreedy::addThroughConstraints(InterferenceCache::Cursor Intf,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">bool RAGreedy::addThroughConstraints(InterferenceCache::Cursor Intf,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">                                     ArrayRef<unsigned> Blocks) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">                                     ArrayRef<unsigned> Blocks) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  const unsigned GroupSize = 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  const unsigned GroupSize = 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  SpillPlacement::BlockConstraint BCS[GroupSize];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  SpillPlacement::BlockConstraint BCS[GroupSize];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  unsigned TBS[GroupSize];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  unsigned TBS[GroupSize];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">  unsigned B = 0, T = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">  unsigned B = 0, T = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  for (unsigned Number : Blocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  for (unsigned Number : Blocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">    Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">    Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">    if (!Intf.hasInterference()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">    if (!Intf.hasInterference()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">      assert(T < GroupSize && "Array overflow");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">      assert(T < GroupSize && "Array overflow");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">      TBS[T] = Number;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">      TBS[T] = Number;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">      if (++T == GroupSize) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">      if (++T == GroupSize) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">        SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">        SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">        T = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">        T = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">    assert(B < GroupSize && "Array overflow");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">    assert(B < GroupSize && "Array overflow");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    BCS[B].Number = Number;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    BCS[B].Number = Number;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">    // Abort if the spill cannot be inserted at the MBB' start</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">    // Abort if the spill cannot be inserted at the MBB' start</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">    MachineBasicBlock *MBB = MF->getBlockNumbered(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">    MachineBasicBlock *MBB = MF->getBlockNumbered(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">    auto FirstNonDebugInstr = MBB->getFirstNonDebugInstr();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">    auto FirstNonDebugInstr = MBB->getFirstNonDebugInstr();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">    if (FirstNonDebugInstr != MBB->end() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">    if (FirstNonDebugInstr != MBB->end() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">        SlotIndex::isEarlierInstr(LIS->getInstructionIndex(*FirstNonDebugInstr),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">        SlotIndex::isEarlierInstr(LIS->getInstructionIndex(*FirstNonDebugInstr),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">                                  SA->getFirstSplitPoint(Number)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">                                  SA->getFirstSplitPoint(Number)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">    // Interference for the live-in value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">    // Interference for the live-in value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    if (Intf.first() <= Indexes->getMBBStartIdx(Number))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    if (Intf.first() <= Indexes->getMBBStartIdx(Number))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">      BCS[B].Entry = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">      BCS[B].Entry = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">      BCS[B].Entry = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">      BCS[B].Entry = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">    // Interference for the live-out value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">    // Interference for the live-out value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    if (Intf.last() >= SA->getLastSplitPoint(Number))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    if (Intf.last() >= SA->getLastSplitPoint(Number))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">      BCS[B].Exit = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">      BCS[B].Exit = SpillPlacement::MustSpill;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">      BCS[B].Exit = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">      BCS[B].Exit = SpillPlacement::PrefSpill;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">    if (++B == GroupSize) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">    if (++B == GroupSize) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">      SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">      SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">      B = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">      B = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  SpillPlacer->addConstraints(ArrayRef(BCS, B));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">  SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">  SpillPlacer->addLinks(ArrayRef(TBS, T));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">bool RAGreedy::growRegion(GlobalSplitCandidate &Cand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">bool RAGreedy::growRegion(GlobalSplitCandidate &Cand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  // Keep track of through blocks that have not been added to SpillPlacer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  // Keep track of through blocks that have not been added to SpillPlacer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  BitVector Todo = SA->getThroughBlocks();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  BitVector Todo = SA->getThroughBlocks();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  SmallVectorImpl<unsigned> &ActiveBlocks = Cand.ActiveBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  SmallVectorImpl<unsigned> &ActiveBlocks = Cand.ActiveBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  unsigned AddedTo = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  unsigned AddedTo = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  unsigned Visited = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  unsigned Visited = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">  unsigned long Budget = GrowRegionComplexityBudget;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">  unsigned long Budget = GrowRegionComplexityBudget;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">    ArrayRef<unsigned> NewBundles = SpillPlacer->getRecentPositive();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">    ArrayRef<unsigned> NewBundles = SpillPlacer->getRecentPositive();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">    // Find new through blocks in the periphery of PrefRegBundles.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">    // Find new through blocks in the periphery of PrefRegBundles.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">    for (unsigned Bundle : NewBundles) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">    for (unsigned Bundle : NewBundles) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">      // Look at all blocks connected to Bundle in the full graph.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">      // Look at all blocks connected to Bundle in the full graph.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">      ArrayRef<unsigned> Blocks = Bundles->getBlocks(Bundle);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">      ArrayRef<unsigned> Blocks = Bundles->getBlocks(Bundle);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">      // Limit compilation time by bailing out after we use all our budget.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">      // Limit compilation time by bailing out after we use all our budget.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">      if (Blocks.size() >= Budget)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">      if (Blocks.size() >= Budget)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">      Budget -= Blocks.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">      Budget -= Blocks.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">      for (unsigned Block : Blocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">      for (unsigned Block : Blocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">        if (!Todo.test(Block))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">        if (!Todo.test(Block))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">        Todo.reset(Block);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">        Todo.reset(Block);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">        // This is a new through block. Add it to SpillPlacer later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">        // This is a new through block. Add it to SpillPlacer later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">        ActiveBlocks.push_back(Block);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">        ActiveBlocks.push_back(Block);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">        ++Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">        ++Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    // Any new blocks to add?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    // Any new blocks to add?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    if (ActiveBlocks.size() == AddedTo)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    if (ActiveBlocks.size() == AddedTo)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    // Compute through constraints from the interference, or assume that all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    // Compute through constraints from the interference, or assume that all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">    // through blocks prefer spilling when forming compact regions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">    // through blocks prefer spilling when forming compact regions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">    auto NewBlocks = ArrayRef(ActiveBlocks).slice(AddedTo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">    auto NewBlocks = ArrayRef(ActiveBlocks).slice(AddedTo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">    if (Cand.PhysReg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">    if (Cand.PhysReg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">      if (!addThroughConstraints(Cand.Intf, NewBlocks))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">      if (!addThroughConstraints(Cand.Intf, NewBlocks))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">      // Provide a strong negative bias on through blocks to prevent unwanted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">      // Provide a strong negative bias on through blocks to prevent unwanted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">      // liveness on loop backedges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">      // liveness on loop backedges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">      SpillPlacer->addPrefSpill(NewBlocks, /* Strong= */ true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">      SpillPlacer->addPrefSpill(NewBlocks, /* Strong= */ true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">    AddedTo = ActiveBlocks.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">    AddedTo = ActiveBlocks.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    // Perhaps iterating can enable more bundles?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    // Perhaps iterating can enable more bundles?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">    SpillPlacer->iterate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">    SpillPlacer->iterate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << ", v=" << Visited);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << ", v=" << Visited);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">/// calcCompactRegion - Compute the set of edge bundles that should be live</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">/// calcCompactRegion - Compute the set of edge bundles that should be live</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">/// when splitting the current live range into compact regions.  Compact</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">/// when splitting the current live range into compact regions.  Compact</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">/// regions can be computed without looking at interference.  They are the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">/// regions can be computed without looking at interference.  They are the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">/// regions formed by removing all the live-through blocks from the live range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">/// regions formed by removing all the live-through blocks from the live range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">/// Returns false if the current live range is already compact, or if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">/// Returns false if the current live range is already compact, or if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">/// compact regions would form single block regions anyway.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">/// compact regions would form single block regions anyway.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">bool RAGreedy::calcCompactRegion(GlobalSplitCandidate &Cand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">bool RAGreedy::calcCompactRegion(GlobalSplitCandidate &Cand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">  // Without any through blocks, the live range is already compact.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">  // Without any through blocks, the live range is already compact.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  if (!SA->getNumThroughBlocks())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  if (!SA->getNumThroughBlocks())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">  // Compact regions don't correspond to any physreg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">  // Compact regions don't correspond to any physreg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  Cand.reset(IntfCache, MCRegister::NoRegister);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  Cand.reset(IntfCache, MCRegister::NoRegister);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Compact region bundles");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Compact region bundles");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  // Use the spill placer to determine the live bundles. GrowRegion pretends</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  // Use the spill placer to determine the live bundles. GrowRegion pretends</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  // that all the through blocks have interference when PhysReg is unset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  // that all the through blocks have interference when PhysReg is unset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  SpillPlacer->prepare(Cand.LiveBundles);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  SpillPlacer->prepare(Cand.LiveBundles);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  // The static split cost will be zero since Cand.Intf reports no interference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  // The static split cost will be zero since Cand.Intf reports no interference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">  BlockFrequency Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">  BlockFrequency Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">  if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">  if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">  if (!growRegion(Cand)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">  if (!growRegion(Cand)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  SpillPlacer->finish();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  SpillPlacer->finish();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  if (!Cand.LiveBundles.any()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  if (!Cand.LiveBundles.any()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << ", none.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">    for (int I : Cand.LiveBundles.set_bits())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">    for (int I : Cand.LiveBundles.set_bits())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">      dbgs() << " EB#" << I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">      dbgs() << " EB#" << I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">    dbgs() << ".\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">    dbgs() << ".\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">/// calcSpillCost - Compute how expensive it would be to split the live range in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">/// calcSpillCost - Compute how expensive it would be to split the live range in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">/// SA around all use blocks instead of forming bundle regions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">/// SA around all use blocks instead of forming bundle regions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">BlockFrequency RAGreedy::calcSpillCost() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">BlockFrequency RAGreedy::calcSpillCost() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  BlockFrequency Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  BlockFrequency Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">    unsigned Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">    unsigned Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    // We normally only need one spill instruction - a load or a store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    // We normally only need one spill instruction - a load or a store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">    Cost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">    Cost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">    // Unless the value is redefined in the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">    // Unless the value is redefined in the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">    if (BI.LiveIn && BI.LiveOut && BI.FirstDef)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">    if (BI.LiveIn && BI.LiveOut && BI.FirstDef)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">      Cost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">      Cost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">/// calcGlobalSplitCost - Return the global split cost of following the split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">/// calcGlobalSplitCost - Return the global split cost of following the split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">/// pattern in LiveBundles. This cost should be added to the local cost of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">/// pattern in LiveBundles. This cost should be added to the local cost of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">/// interference pattern in SplitConstraints.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">/// interference pattern in SplitConstraints.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">BlockFrequency RAGreedy::calcGlobalSplitCost(GlobalSplitCandidate &Cand,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">BlockFrequency RAGreedy::calcGlobalSplitCost(GlobalSplitCandidate &Cand,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">                                             const AllocationOrder &Order) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">                                             const AllocationOrder &Order) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  BlockFrequency GlobalCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  BlockFrequency GlobalCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  const BitVector &LiveBundles = Cand.LiveBundles;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  const BitVector &LiveBundles = Cand.LiveBundles;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  for (unsigned I = 0; I != UseBlocks.size(); ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">    const SplitAnalysis::BlockInfo &BI = UseBlocks[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">    SpillPlacement::BlockConstraint &BC = SplitConstraints[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">    bool RegIn  = LiveBundles[Bundles->getBundle(BC.Number, false)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">    bool RegIn  = LiveBundles[Bundles->getBundle(BC.Number, false)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">    bool RegOut = LiveBundles[Bundles->getBundle(BC.Number, true)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">    bool RegOut = LiveBundles[Bundles->getBundle(BC.Number, true)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">    unsigned Ins = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">    unsigned Ins = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">    Cand.Intf.moveToBlock(BC.Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">    Cand.Intf.moveToBlock(BC.Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">    if (BI.LiveIn)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">    if (BI.LiveIn)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">      Ins += RegIn != (BC.Entry == SpillPlacement::PrefReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">      Ins += RegIn != (BC.Entry == SpillPlacement::PrefReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">    if (BI.LiveOut)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">    if (BI.LiveOut)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">      Ins += RegOut != (BC.Exit == SpillPlacement::PrefReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">      Ins += RegOut != (BC.Exit == SpillPlacement::PrefReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">    while (Ins--)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">    while (Ins--)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">      GlobalCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">      GlobalCost += SpillPlacer->getBlockFrequency(BC.Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  for (unsigned Number : Cand.ActiveBlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  for (unsigned Number : Cand.ActiveBlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    bool RegIn  = LiveBundles[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    bool RegIn  = LiveBundles[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    bool RegOut = LiveBundles[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    bool RegOut = LiveBundles[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    if (!RegIn && !RegOut)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    if (!RegIn && !RegOut)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">    if (RegIn && RegOut) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">    if (RegIn && RegOut) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">      // We need double spill code if this block has interference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">      // We need double spill code if this block has interference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">      Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">      Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">      if (Cand.Intf.hasInterference()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">      if (Cand.Intf.hasInterference()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">        GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">    // live-in / stack-out or stack-in live-out.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">    // live-in / stack-out or stack-in live-out.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">    GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">    GlobalCost += SpillPlacer->getBlockFrequency(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">  return GlobalCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">  return GlobalCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">/// splitAroundRegion - Split the current live range around the regions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">/// splitAroundRegion - Split the current live range around the regions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">/// determined by BundleCand and GlobalCand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">/// determined by BundleCand and GlobalCand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">/// Before calling this function, GlobalCand and BundleCand must be initialized</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">/// Before calling this function, GlobalCand and BundleCand must be initialized</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">/// so each bundle is assigned to a valid candidate, or NoCand for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">/// so each bundle is assigned to a valid candidate, or NoCand for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">/// stack-bound bundles.  The shared SA/SE SplitAnalysis and SplitEditor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">/// stack-bound bundles.  The shared SA/SE SplitAnalysis and SplitEditor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">/// objects must be initialized for the current live range, and intervals</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">/// objects must be initialized for the current live range, and intervals</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">/// created for the used candidates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">/// created for the used candidates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">/// @param LREdit    The LiveRangeEdit object handling the current split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">/// @param LREdit    The LiveRangeEdit object handling the current split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">/// @param UsedCands List of used GlobalCand entries. Every BundleCand value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">/// @param UsedCands List of used GlobalCand entries. Every BundleCand value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">///                  must appear in this list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">///                  must appear in this list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">void RAGreedy::splitAroundRegion(LiveRangeEdit &LREdit,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">void RAGreedy::splitAroundRegion(LiveRangeEdit &LREdit,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">                                 ArrayRef<unsigned> UsedCands) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">                                 ArrayRef<unsigned> UsedCands) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">  // These are the intervals created for new global ranges. We may create more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">  // These are the intervals created for new global ranges. We may create more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">  // intervals for local ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">  // intervals for local ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">  const unsigned NumGlobalIntvs = LREdit.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">  const unsigned NumGlobalIntvs = LREdit.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "splitAroundRegion with " << NumGlobalIntvs</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "splitAroundRegion with " << NumGlobalIntvs</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">                    << " globals.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">                    << " globals.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">  assert(NumGlobalIntvs && "No global intervals configured");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">  assert(NumGlobalIntvs && "No global intervals configured");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  // Isolate even single instructions when dealing with a proper sub-class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  // Isolate even single instructions when dealing with a proper sub-class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">  // That guarantees register class inflation for the stack interval because it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">  // That guarantees register class inflation for the stack interval because it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  // is all copies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  // is all copies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  Register Reg = SA->getParent().reg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  Register Reg = SA->getParent().reg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">  // First handle all the blocks with uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">  // First handle all the blocks with uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">    unsigned Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">    unsigned Number = BI.MBB->getNumber();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">    unsigned IntvIn = 0, IntvOut = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">    unsigned IntvIn = 0, IntvOut = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">    SlotIndex IntfIn, IntfOut;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">    SlotIndex IntfIn, IntfOut;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">    if (BI.LiveIn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">    if (BI.LiveIn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">      if (CandIn != NoCand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">      if (CandIn != NoCand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">        IntvIn = Cand.IntvIdx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">        IntvIn = Cand.IntvIdx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">        IntfIn = Cand.Intf.first();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">        IntfIn = Cand.Intf.first();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">    if (BI.LiveOut) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">    if (BI.LiveOut) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">      if (CandOut != NoCand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">      if (CandOut != NoCand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">        IntvOut = Cand.IntvIdx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">        IntvOut = Cand.IntvIdx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">        IntfOut = Cand.Intf.last();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">        IntfOut = Cand.Intf.last();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">    // Create separate intervals for isolated blocks with multiple uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">    // Create separate intervals for isolated blocks with multiple uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">    if (!IntvIn && !IntvOut) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">    if (!IntvIn && !IntvOut) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << printMBBReference(*BI.MBB) << " isolated.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << printMBBReference(*BI.MBB) << " isolated.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">      if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">      if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">        SE->splitSingleBlock(BI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">        SE->splitSingleBlock(BI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">    if (IntvIn && IntvOut)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">    if (IntvIn && IntvOut)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">    else if (IntvIn)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">    else if (IntvIn)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">      SE->splitRegInBlock(BI, IntvIn, IntfIn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">      SE->splitRegInBlock(BI, IntvIn, IntfIn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">      SE->splitRegOutBlock(BI, IntvOut, IntfOut);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">      SE->splitRegOutBlock(BI, IntvOut, IntfOut);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">  // Handle live-through blocks. The relevant live-through blocks are stored in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">  // Handle live-through blocks. The relevant live-through blocks are stored in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">  // the ActiveBlocks list with each candidate. We need to filter out</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">  // the ActiveBlocks list with each candidate. We need to filter out</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">  // duplicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">  // duplicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">  BitVector Todo = SA->getThroughBlocks();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">  BitVector Todo = SA->getThroughBlocks();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">  for (unsigned UsedCand : UsedCands) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">  for (unsigned UsedCand : UsedCands) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">    ArrayRef<unsigned> Blocks = GlobalCand[UsedCand].ActiveBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">    ArrayRef<unsigned> Blocks = GlobalCand[UsedCand].ActiveBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">    for (unsigned Number : Blocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">    for (unsigned Number : Blocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">      if (!Todo.test(Number))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">      if (!Todo.test(Number))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">      Todo.reset(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">      Todo.reset(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">      unsigned IntvIn = 0, IntvOut = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">      unsigned IntvIn = 0, IntvOut = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">      SlotIndex IntfIn, IntfOut;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">      SlotIndex IntfIn, IntfOut;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">      unsigned CandIn = BundleCand[Bundles->getBundle(Number, false)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">      if (CandIn != NoCand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">      if (CandIn != NoCand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">        GlobalSplitCandidate &Cand = GlobalCand[CandIn];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">        IntvIn = Cand.IntvIdx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">        IntvIn = Cand.IntvIdx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">        IntfIn = Cand.Intf.first();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">        IntfIn = Cand.Intf.first();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">      unsigned CandOut = BundleCand[Bundles->getBundle(Number, true)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">      if (CandOut != NoCand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">      if (CandOut != NoCand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">        GlobalSplitCandidate &Cand = GlobalCand[CandOut];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">        IntvOut = Cand.IntvIdx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">        IntvOut = Cand.IntvIdx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">        Cand.Intf.moveToBlock(Number);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">        IntfOut = Cand.Intf.last();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">        IntfOut = Cand.Intf.last();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">      if (!IntvIn && !IntvOut)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">      if (!IntvIn && !IntvOut)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">      SE->splitLiveThroughBlock(Number, IntvIn, IntfIn, IntvOut, IntfOut);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">  ++NumGlobalSplits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">  ++NumGlobalSplits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">  unsigned OrigBlocks = SA->getNumLiveBlocks();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">  unsigned OrigBlocks = SA->getNumLiveBlocks();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  // Sort out the new intervals created by splitting. We get four kinds:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  // Sort out the new intervals created by splitting. We get four kinds:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  // - Remainder intervals should not be split again.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  // - Remainder intervals should not be split again.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  // - Candidate intervals can be assigned to Cand.PhysReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  // - Candidate intervals can be assigned to Cand.PhysReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  // - Block-local splits are candidates for local splitting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  // - Block-local splits are candidates for local splitting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">  // - DCE leftovers should go back on the queue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">  // - DCE leftovers should go back on the queue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">    const LiveInterval &Reg = LIS->getInterval(LREdit.get(I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">    const LiveInterval &Reg = LIS->getInterval(LREdit.get(I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">    // Ignore old intervals from DCE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">    // Ignore old intervals from DCE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">    if (ExtraInfo->getOrInitStage(Reg.reg()) != RS_New)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">    if (ExtraInfo->getOrInitStage(Reg.reg()) != RS_New)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">    // Remainder interval. Don't try splitting again, spill if it doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">    // Remainder interval. Don't try splitting again, spill if it doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">    // allocate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">    // allocate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">    if (IntvMap[I] == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">    if (IntvMap[I] == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">      ExtraInfo->setStage(Reg, RS_Spill);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">      ExtraInfo->setStage(Reg, RS_Spill);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">    // Global intervals. Allow repeated splitting as long as the number of live</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">    // Global intervals. Allow repeated splitting as long as the number of live</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    // blocks is strictly decreasing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    // blocks is strictly decreasing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">    if (IntvMap[I] < NumGlobalIntvs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">    if (IntvMap[I] < NumGlobalIntvs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">      if (SA->countLiveBlocks(&Reg) >= OrigBlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">      if (SA->countLiveBlocks(&Reg) >= OrigBlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Main interval covers the same " << OrigBlocks</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Main interval covers the same " << OrigBlocks</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">                          << " blocks as original.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">                          << " blocks as original.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">        // Don't allow repeated splitting as a safe guard against looping.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">        // Don't allow repeated splitting as a safe guard against looping.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">        ExtraInfo->setStage(Reg, RS_Split2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">        ExtraInfo->setStage(Reg, RS_Split2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">    // Other intervals are treated as new. This includes local intervals created</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">    // Other intervals are treated as new. This includes local intervals created</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">    // for blocks with multiple uses, and anything created by DCE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">    // for blocks with multiple uses, and anything created by DCE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">  if (VerifyEnabled)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">  if (VerifyEnabled)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">    MF->verify(this, "After splitting live range around region");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">    MF->verify(this, "After splitting live range around region");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">MCRegister RAGreedy::tryRegionSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">MCRegister RAGreedy::tryRegionSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">                                    AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">                                    AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">                                    SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">                                    SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">  if (!TRI->shouldRegionSplitForVirtReg(*MF, VirtReg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">  if (!TRI->shouldRegionSplitForVirtReg(*MF, VirtReg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">    return MCRegister::NoRegister;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">    return MCRegister::NoRegister;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  unsigned NumCands = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  unsigned NumCands = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  BlockFrequency SpillCost = calcSpillCost();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  BlockFrequency SpillCost = calcSpillCost();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  BlockFrequency BestCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  BlockFrequency BestCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  // Check if we can split this live range around a compact region.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  // Check if we can split this live range around a compact region.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  bool HasCompact = calcCompactRegion(GlobalCand.front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  bool HasCompact = calcCompactRegion(GlobalCand.front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  if (HasCompact) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  if (HasCompact) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">    // Yes, keep GlobalCand[0] as the compact region candidate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">    // Yes, keep GlobalCand[0] as the compact region candidate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">    NumCands = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">    NumCands = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">    BestCost = BlockFrequency::getMaxFrequency();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">    BestCost = BlockFrequency::getMaxFrequency();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">    // No benefit from the compact region, our fallback will be per-block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">    // No benefit from the compact region, our fallback will be per-block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">    // splitting. Make sure we find a solution that is cheaper than spilling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">    // splitting. Make sure we find a solution that is cheaper than spilling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">    BestCost = SpillCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">    BestCost = SpillCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Cost of isolating all blocks = ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Cost of isolating all blocks = ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">               MBFI->printBlockFreq(dbgs(), BestCost) << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">               MBFI->printBlockFreq(dbgs(), BestCost) << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">                                               NumCands, false /*IgnoreCSR*/);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">                                               NumCands, false /*IgnoreCSR*/);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // No solutions found, fall back to single block splitting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // No solutions found, fall back to single block splitting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  if (!HasCompact && BestCand == NoCand)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  if (!HasCompact && BestCand == NoCand)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">    return MCRegister::NoRegister;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">    return MCRegister::NoRegister;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  return doRegionSplit(VirtReg, BestCand, HasCompact, NewVRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  return doRegionSplit(VirtReg, BestCand, HasCompact, NewVRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">unsigned RAGreedy::calculateRegionSplitCost(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">unsigned RAGreedy::calculateRegionSplitCost(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">                                            AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">                                            AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">                                            BlockFrequency &BestCost,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">                                            BlockFrequency &BestCost,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">                                            unsigned &NumCands,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">                                            unsigned &NumCands,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">                                            bool IgnoreCSR) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">                                            bool IgnoreCSR) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  unsigned BestCand = NoCand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  unsigned BestCand = NoCand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">  for (MCPhysReg PhysReg : Order) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">  for (MCPhysReg PhysReg : Order) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    assert(PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    assert(PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">    if (IgnoreCSR && EvictAdvisor->isUnusedCalleeSavedReg(PhysReg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">    if (IgnoreCSR && EvictAdvisor->isUnusedCalleeSavedReg(PhysReg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">    // Discard bad candidates before we run out of interference cache cursors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">    // Discard bad candidates before we run out of interference cache cursors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">    // This will only affect register classes with a lot of registers (>32).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">    // This will only affect register classes with a lot of registers (>32).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">    if (NumCands == IntfCache.getMaxCursors()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">    if (NumCands == IntfCache.getMaxCursors()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">      unsigned WorstCount = ~0u;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">      unsigned WorstCount = ~0u;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">      unsigned Worst = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">      unsigned Worst = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">      for (unsigned CandIndex = 0; CandIndex != NumCands; ++CandIndex) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">      for (unsigned CandIndex = 0; CandIndex != NumCands; ++CandIndex) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">        if (CandIndex == BestCand || !GlobalCand[CandIndex].PhysReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">        if (CandIndex == BestCand || !GlobalCand[CandIndex].PhysReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">        unsigned Count = GlobalCand[CandIndex].LiveBundles.count();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">        unsigned Count = GlobalCand[CandIndex].LiveBundles.count();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">        if (Count < WorstCount) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">        if (Count < WorstCount) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">          Worst = CandIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">          Worst = CandIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">          WorstCount = Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">          WorstCount = Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">      --NumCands;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">      --NumCands;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">      GlobalCand[Worst] = GlobalCand[NumCands];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">      GlobalCand[Worst] = GlobalCand[NumCands];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">      if (BestCand == NumCands)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">      if (BestCand == NumCands)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">        BestCand = Worst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">        BestCand = Worst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">    if (GlobalCand.size() <= NumCands)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">    if (GlobalCand.size() <= NumCands)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">      GlobalCand.resize(NumCands+1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">      GlobalCand.resize(NumCands+1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">    GlobalSplitCandidate &Cand = GlobalCand[NumCands];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">    GlobalSplitCandidate &Cand = GlobalCand[NumCands];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    Cand.reset(IntfCache, PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    Cand.reset(IntfCache, PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">    SpillPlacer->prepare(Cand.LiveBundles);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">    SpillPlacer->prepare(Cand.LiveBundles);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">    BlockFrequency Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">    BlockFrequency Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">    if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">    if (!addSplitConstraints(Cand.Intf, Cost)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tno positive bundles\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tno positive bundles\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tstatic = ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << "\tstatic = ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">               MBFI->printBlockFreq(dbgs(), Cost));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">               MBFI->printBlockFreq(dbgs(), Cost));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">    if (Cost >= BestCost) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">    if (Cost >= BestCost) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">        if (BestCand == NoCand)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">        if (BestCand == NoCand)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">          dbgs() << " worse than no bundles\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">          dbgs() << " worse than no bundles\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">          dbgs() << " worse than "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">          dbgs() << " worse than "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">                 << printReg(GlobalCand[BestCand].PhysReg, TRI) << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">                 << printReg(GlobalCand[BestCand].PhysReg, TRI) << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">    if (!growRegion(Cand)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">    if (!growRegion(Cand)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << ", cannot spill all interferences.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">    SpillPlacer->finish();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">    SpillPlacer->finish();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">    // No live bundles, defer to splitSingleBlocks().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">    // No live bundles, defer to splitSingleBlocks().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">    if (!Cand.LiveBundles.any()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">    if (!Cand.LiveBundles.any()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << " no bundles.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << " no bundles.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">    Cost += calcGlobalSplitCost(Cand, Order);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">    Cost += calcGlobalSplitCost(Cand, Order);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">      dbgs() << ", total = ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">      dbgs() << ", total = ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">      MBFI->printBlockFreq(dbgs(), Cost) << " with bundles";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">      MBFI->printBlockFreq(dbgs(), Cost) << " with bundles";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">      for (int I : Cand.LiveBundles.set_bits())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">      for (int I : Cand.LiveBundles.set_bits())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">        dbgs() << " EB#" << I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">        dbgs() << " EB#" << I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">      dbgs() << ".\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">      dbgs() << ".\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">    if (Cost < BestCost) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">    if (Cost < BestCost) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">      BestCand = NumCands;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">      BestCand = NumCands;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">      BestCost = Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">      BestCost = Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    ++NumCands;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    ++NumCands;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  return BestCand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  return BestCand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">unsigned RAGreedy::doRegionSplit(const LiveInterval &VirtReg, unsigned BestCand,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">unsigned RAGreedy::doRegionSplit(const LiveInterval &VirtReg, unsigned BestCand,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">                                 bool HasCompact,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">                                 bool HasCompact,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  SmallVector<unsigned, 8> UsedCands;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  SmallVector<unsigned, 8> UsedCands;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  // Prepare split editor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  // Prepare split editor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  SE->reset(LREdit, SplitSpillMode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  SE->reset(LREdit, SplitSpillMode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  // Assign all edge bundles to the preferred candidate, or NoCand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  // Assign all edge bundles to the preferred candidate, or NoCand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">  BundleCand.assign(Bundles->getNumBundles(), NoCand);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">  BundleCand.assign(Bundles->getNumBundles(), NoCand);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  // Assign bundles for the best candidate region.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  // Assign bundles for the best candidate region.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">  if (BestCand != NoCand) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">  if (BestCand != NoCand) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">    GlobalSplitCandidate &Cand = GlobalCand[BestCand];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">    GlobalSplitCandidate &Cand = GlobalCand[BestCand];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">    if (unsigned B = Cand.getBundles(BundleCand, BestCand)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">    if (unsigned B = Cand.getBundles(BundleCand, BestCand)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">      UsedCands.push_back(BestCand);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">      UsedCands.push_back(BestCand);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">      Cand.IntvIdx = SE->openIntv();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">      Cand.IntvIdx = SE->openIntv();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Split for " << printReg(Cand.PhysReg, TRI) << " in "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Split for " << printReg(Cand.PhysReg, TRI) << " in "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">                        << B << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">                        << B << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">      (void)B;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">      (void)B;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  // Assign bundles for the compact region.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  // Assign bundles for the compact region.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">  if (HasCompact) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">  if (HasCompact) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">    GlobalSplitCandidate &Cand = GlobalCand.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">    GlobalSplitCandidate &Cand = GlobalCand.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">    assert(!Cand.PhysReg && "Compact region has no physreg");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">    assert(!Cand.PhysReg && "Compact region has no physreg");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">    if (unsigned B = Cand.getBundles(BundleCand, 0)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">    if (unsigned B = Cand.getBundles(BundleCand, 0)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">      UsedCands.push_back(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">      UsedCands.push_back(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">      Cand.IntvIdx = SE->openIntv();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">      Cand.IntvIdx = SE->openIntv();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Split for compact region in " << B</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Split for compact region in " << B</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">                        << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">                        << " bundles, intv " << Cand.IntvIdx << ".\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">      (void)B;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">      (void)B;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  splitAroundRegion(LREdit, UsedCands);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  splitAroundRegion(LREdit, UsedCands);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">//                            Per-Block Splitting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">//                            Per-Block Splitting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">/// tryBlockSplit - Split a global live range around every block with uses. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">/// tryBlockSplit - Split a global live range around every block with uses. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">/// creates a lot of local live ranges, that will be split by tryLocalSplit if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">/// creates a lot of local live ranges, that will be split by tryLocalSplit if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">/// they don't allocate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">/// they don't allocate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">unsigned RAGreedy::tryBlockSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">unsigned RAGreedy::tryBlockSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">                                 AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">                                 AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  assert(&SA->getParent() == &VirtReg && "Live range wasn't analyzed");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  assert(&SA->getParent() == &VirtReg && "Live range wasn't analyzed");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">  Register Reg = VirtReg.reg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">  Register Reg = VirtReg.reg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">  bool SingleInstrs = RegClassInfo.isProperSubClass(MRI->getRegClass(Reg));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">  SE->reset(LREdit, SplitSpillMode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">  SE->reset(LREdit, SplitSpillMode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  ArrayRef<SplitAnalysis::BlockInfo> UseBlocks = SA->getUseBlocks();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  for (const SplitAnalysis::BlockInfo &BI : UseBlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">    if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">    if (SA->shouldSplitSingleBlock(BI, SingleInstrs))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">      SE->splitSingleBlock(BI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">      SE->splitSingleBlock(BI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  // No blocks were split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  // No blocks were split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">  if (LREdit.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">  if (LREdit.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  // We did split for some blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  // We did split for some blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  // Tell LiveDebugVariables about the new ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  // Tell LiveDebugVariables about the new ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">  DebugVars->splitRegister(Reg, LREdit.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  // Sort out the new intervals created by splitting. The remainder interval</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  // Sort out the new intervals created by splitting. The remainder interval</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  // goes straight to spilling, the new local ranges get to stay RS_New.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  // goes straight to spilling, the new local ranges get to stay RS_New.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">  for (unsigned I = 0, E = LREdit.size(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">    const LiveInterval &LI = LIS->getInterval(LREdit.get(I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">    const LiveInterval &LI = LIS->getInterval(LREdit.get(I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">    if (ExtraInfo->getOrInitStage(LI.reg()) == RS_New && IntvMap[I] == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">    if (ExtraInfo->getOrInitStage(LI.reg()) == RS_New && IntvMap[I] == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">      ExtraInfo->setStage(LI, RS_Spill);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">      ExtraInfo->setStage(LI, RS_Spill);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  if (VerifyEnabled)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  if (VerifyEnabled)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">    MF->verify(this, "After splitting live range around basic blocks");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">    MF->verify(this, "After splitting live range around basic blocks");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">//                         Per-Instruction Splitting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">//                         Per-Instruction Splitting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">/// Get the number of allocatable registers that match the constraints of \p Reg</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">/// Get the number of allocatable registers that match the constraints of \p Reg</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">/// on \p MI and that are also in \p SuperRC.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">/// on \p MI and that are also in \p SuperRC.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">static unsigned getNumAllocatableRegsForConstraints(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">static unsigned getNumAllocatableRegsForConstraints(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">    const MachineInstr *MI, Register Reg, const TargetRegisterClass *SuperRC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">    const MachineInstr *MI, Register Reg, const TargetRegisterClass *SuperRC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">    const TargetInstrInfo *TII, const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">    const TargetInstrInfo *TII, const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">    const RegisterClassInfo &RCI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">    const RegisterClassInfo &RCI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">  assert(SuperRC && "Invalid register class");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">  assert(SuperRC && "Invalid register class");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  const TargetRegisterClass *ConstrainedRC =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  const TargetRegisterClass *ConstrainedRC =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">      MI->getRegClassConstraintEffectForVReg(Reg, SuperRC, TII, TRI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">      MI->getRegClassConstraintEffectForVReg(Reg, SuperRC, TII, TRI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">                                             /* ExploreBundle */ true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">                                             /* ExploreBundle */ true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  if (!ConstrainedRC)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  if (!ConstrainedRC)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  return RCI.getNumAllocatableRegs(ConstrainedRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  return RCI.getNumAllocatableRegs(ConstrainedRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">static LaneBitmask getInstReadLaneMask(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">static LaneBitmask getInstReadLaneMask(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">                                       const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">                                       const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">                                       const MachineInstr &MI, Register Reg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">                                       const MachineInstr &MI, Register Reg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  LaneBitmask Mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  LaneBitmask Mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  for (const MachineOperand &MO : MI.operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  for (const MachineOperand &MO : MI.operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">    if (!MO.isReg() || MO.getReg() != Reg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">    if (!MO.isReg() || MO.getReg() != Reg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">    unsigned SubReg = MO.getSubReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">    unsigned SubReg = MO.getSubReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">    if (SubReg == 0 && MO.isUse()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">    if (SubReg == 0 && MO.isUse()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">      Mask |= MRI.getMaxLaneMaskForVReg(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">      Mask |= MRI.getMaxLaneMaskForVReg(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">    LaneBitmask SubRegMask = TRI.getSubRegIndexLaneMask(SubReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">    LaneBitmask SubRegMask = TRI.getSubRegIndexLaneMask(SubReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">    if (MO.isDef()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">    if (MO.isDef()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">      if (!MO.isUndef())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">      if (!MO.isUndef())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">        Mask |= ~SubRegMask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">        Mask |= ~SubRegMask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">      Mask |= SubRegMask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">      Mask |= SubRegMask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  return Mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  return Mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">/// Return true if \p MI at \P Use reads a subset of the lanes live in \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">/// Return true if \p MI at \P Use reads a subset of the lanes live in \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">/// VirtReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">/// VirtReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">static bool readsLaneSubset(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">static bool readsLaneSubset(const MachineRegisterInfo &MRI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">                            const MachineInstr *MI, const LiveInterval &VirtReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">                            const MachineInstr *MI, const LiveInterval &VirtReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">                            const TargetRegisterInfo *TRI, SlotIndex Use) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">                            const TargetRegisterInfo *TRI, SlotIndex Use) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  // Early check the common case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  // Early check the common case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  if (MI->isCopy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  if (MI->isCopy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">      MI->getOperand(0).getSubReg() == MI->getOperand(1).getSubReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">      MI->getOperand(0).getSubReg() == MI->getOperand(1).getSubReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">  // FIXME: We're only considering uses, but should be consider defs too?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">  // FIXME: We're only considering uses, but should be consider defs too?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">  LaneBitmask ReadMask = getInstReadLaneMask(MRI, *TRI, *MI, VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">  LaneBitmask ReadMask = getInstReadLaneMask(MRI, *TRI, *MI, VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">  LaneBitmask LiveAtMask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">  LaneBitmask LiveAtMask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">  for (const LiveInterval::SubRange &S : VirtReg.subranges()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">  for (const LiveInterval::SubRange &S : VirtReg.subranges()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">    if (S.liveAt(Use))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">    if (S.liveAt(Use))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">      LiveAtMask |= S.LaneMask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">      LiveAtMask |= S.LaneMask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">  // If the live lanes aren't different from the lanes used by the instruction,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">  // If the live lanes aren't different from the lanes used by the instruction,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">  // this doesn't help.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">  // this doesn't help.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">  return (ReadMask & ~(LiveAtMask & TRI->getCoveringLanes())).any();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">  return (ReadMask & ~(LiveAtMask & TRI->getCoveringLanes())).any();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">/// tryInstructionSplit - Split a live range around individual instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">/// tryInstructionSplit - Split a live range around individual instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">/// This is normally not worthwhile since the spiller is doing essentially the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">/// This is normally not worthwhile since the spiller is doing essentially the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">/// same thing. However, when the live range is in a constrained register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">/// same thing. However, when the live range is in a constrained register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">/// class, it may help to insert copies such that parts of the live range can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">/// class, it may help to insert copies such that parts of the live range can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">/// be moved to a larger register class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">/// be moved to a larger register class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">/// This is similar to spilling to a larger register class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">/// This is similar to spilling to a larger register class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">unsigned RAGreedy::tryInstructionSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">unsigned RAGreedy::tryInstructionSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">                                       AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">                                       AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">                                       SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">                                       SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  // There is no point to this if there are no larger sub-classes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  // There is no point to this if there are no larger sub-classes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  bool SplitSubClass = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  bool SplitSubClass = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  if (!RegClassInfo.isProperSubClass(CurRC)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  if (!RegClassInfo.isProperSubClass(CurRC)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">    if (!VirtReg.hasSubRanges())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">    if (!VirtReg.hasSubRanges())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">    SplitSubClass = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">    SplitSubClass = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">  // Always enable split spill mode, since we're effectively spilling to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">  // Always enable split spill mode, since we're effectively spilling to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">  // register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">  // register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">  SE->reset(LREdit, SplitEditor::SM_Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">  SE->reset(LREdit, SplitEditor::SM_Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">  if (Uses.size() <= 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">  if (Uses.size() <= 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Split around " << Uses.size()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Split around " << Uses.size()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">                    << " individual instrs.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">                    << " individual instrs.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  const TargetRegisterClass *SuperRC =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  const TargetRegisterClass *SuperRC =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">      TRI->getLargestLegalSuperClass(CurRC, *MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">      TRI->getLargestLegalSuperClass(CurRC, *MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">  unsigned SuperRCNumAllocatableRegs =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">  unsigned SuperRCNumAllocatableRegs =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">      RegClassInfo.getNumAllocatableRegs(SuperRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">      RegClassInfo.getNumAllocatableRegs(SuperRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  // Split around every non-copy instruction if this split will relax</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  // Split around every non-copy instruction if this split will relax</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  // the constraints on the virtual register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  // the constraints on the virtual register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">  // Otherwise, splitting just inserts uncoalescable copies that do not help</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">  // Otherwise, splitting just inserts uncoalescable copies that do not help</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">  // the allocation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">  // the allocation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">  for (const SlotIndex Use : Uses) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">  for (const SlotIndex Use : Uses) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">    if (const MachineInstr *MI = Indexes->getInstructionFromIndex(Use)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">    if (const MachineInstr *MI = Indexes->getInstructionFromIndex(Use)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">      if (MI->isFullCopy() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">      if (MI->isFullCopy() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">          (SplitSubClass &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">          (SplitSubClass &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">           SuperRCNumAllocatableRegs ==</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">           SuperRCNumAllocatableRegs ==</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">               getNumAllocatableRegsForConstraints(MI, VirtReg.reg(), SuperRC,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">               getNumAllocatableRegsForConstraints(MI, VirtReg.reg(), SuperRC,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">                                                   TII, TRI, RegClassInfo)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">                                                   TII, TRI, RegClassInfo)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">          // TODO: Handle split for subranges with subclass constraints?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">          // TODO: Handle split for subranges with subclass constraints?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">          (!SplitSubClass && VirtReg.hasSubRanges() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">          (!SplitSubClass && VirtReg.hasSubRanges() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">           !readsLaneSubset(*MRI, MI, VirtReg, TRI, Use))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">           !readsLaneSubset(*MRI, MI, VirtReg, TRI, Use))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "    skip:\t" << Use << '\t' << *MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "    skip:\t" << Use << '\t' << *MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">    SE->openIntv();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">    SE->openIntv();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">    SlotIndex SegStart = SE->enterIntvBefore(Use);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">    SlotIndex SegStart = SE->enterIntvBefore(Use);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">    SlotIndex SegStop = SE->leaveIntvAfter(Use);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">    SlotIndex SegStop = SE->leaveIntvAfter(Use);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">    SE->useIntv(SegStart, SegStop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">    SE->useIntv(SegStart, SegStop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">  if (LREdit.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">  if (LREdit.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "All uses were copies.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "All uses were copies.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">  // Assign all new registers to RS_Spill. This was the last chance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">  // Assign all new registers to RS_Spill. This was the last chance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  ExtraInfo->setStage(LREdit.begin(), LREdit.end(), RS_Spill);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  ExtraInfo->setStage(LREdit.begin(), LREdit.end(), RS_Spill);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">//                             Local Splitting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">//                             Local Splitting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">/// calcGapWeights - Compute the maximum spill weight that needs to be evicted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">/// calcGapWeights - Compute the maximum spill weight that needs to be evicted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">/// in order to use PhysReg between two entries in SA->UseSlots.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">/// in order to use PhysReg between two entries in SA->UseSlots.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">/// GapWeight[I] represents the gap between UseSlots[I] and UseSlots[I + 1].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">/// GapWeight[I] represents the gap between UseSlots[I] and UseSlots[I + 1].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">void RAGreedy::calcGapWeights(MCRegister PhysReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">void RAGreedy::calcGapWeights(MCRegister PhysReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">                              SmallVectorImpl<float> &GapWeight) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">                              SmallVectorImpl<float> &GapWeight) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  const unsigned NumGaps = Uses.size()-1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  const unsigned NumGaps = Uses.size()-1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">  // Start and end points for the interference check.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">  // Start and end points for the interference check.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">  SlotIndex StartIdx =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">  SlotIndex StartIdx =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">    BI.LiveIn ? BI.FirstInstr.getBaseIndex() : BI.FirstInstr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">    BI.LiveIn ? BI.FirstInstr.getBaseIndex() : BI.FirstInstr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  SlotIndex StopIdx =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  SlotIndex StopIdx =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">    BI.LiveOut ? BI.LastInstr.getBoundaryIndex() : BI.LastInstr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">    BI.LiveOut ? BI.LastInstr.getBoundaryIndex() : BI.LastInstr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  GapWeight.assign(NumGaps, 0.0f);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  GapWeight.assign(NumGaps, 0.0f);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  // Add interference from each overlapping register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  // Add interference from each overlapping register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">    if (!Matrix->query(const_cast<LiveInterval &>(SA->getParent()), Unit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">    if (!Matrix->query(const_cast<LiveInterval &>(SA->getParent()), Unit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">             .checkInterference())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">             .checkInterference())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">    // We know that VirtReg is a continuous interval from FirstInstr to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">    // We know that VirtReg is a continuous interval from FirstInstr to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">    // LastInstr, so we don't need InterferenceQuery.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">    // LastInstr, so we don't need InterferenceQuery.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">    // Interference that overlaps an instruction is counted in both gaps</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">    // Interference that overlaps an instruction is counted in both gaps</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">    // surrounding the instruction. The exception is interference before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">    // surrounding the instruction. The exception is interference before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">    // StartIdx and after StopIdx.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">    // StartIdx and after StopIdx.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">    LiveIntervalUnion::SegmentIter IntI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">    LiveIntervalUnion::SegmentIter IntI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">        Matrix->getLiveUnions()[Unit].find(StartIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">        Matrix->getLiveUnions()[Unit].find(StartIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">    for (unsigned Gap = 0; IntI.valid() && IntI.start() < StopIdx; ++IntI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">    for (unsigned Gap = 0; IntI.valid() && IntI.start() < StopIdx; ++IntI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">      // Skip the gaps before IntI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">      // Skip the gaps before IntI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">      while (Uses[Gap+1].getBoundaryIndex() < IntI.start())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">      while (Uses[Gap+1].getBoundaryIndex() < IntI.start())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">        if (++Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">        if (++Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">      if (Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">      if (Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">      // Update the gaps covered by IntI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">      // Update the gaps covered by IntI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">      const float weight = IntI.value()->weight();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">      const float weight = IntI.value()->weight();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">      for (; Gap != NumGaps; ++Gap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">      for (; Gap != NumGaps; ++Gap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">        GapWeight[Gap] = std::max(GapWeight[Gap], weight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">        GapWeight[Gap] = std::max(GapWeight[Gap], weight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">        if (Uses[Gap+1].getBaseIndex() >= IntI.stop())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">        if (Uses[Gap+1].getBaseIndex() >= IntI.stop())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">      if (Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">      if (Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">  // Add fixed interference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">  // Add fixed interference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">    const LiveRange &LR = LIS->getRegUnit(Unit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">    const LiveRange &LR = LIS->getRegUnit(Unit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">    LiveRange::const_iterator I = LR.find(StartIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">    LiveRange::const_iterator I = LR.find(StartIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">    LiveRange::const_iterator E = LR.end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">    LiveRange::const_iterator E = LR.end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">    // Same loop as above. Mark any overlapped gaps as HUGE_VALF.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">    // Same loop as above. Mark any overlapped gaps as HUGE_VALF.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">    for (unsigned Gap = 0; I != E && I->start < StopIdx; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">    for (unsigned Gap = 0; I != E && I->start < StopIdx; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">      while (Uses[Gap+1].getBoundaryIndex() < I->start)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">      while (Uses[Gap+1].getBoundaryIndex() < I->start)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">        if (++Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">        if (++Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">      if (Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">      if (Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">      for (; Gap != NumGaps; ++Gap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">      for (; Gap != NumGaps; ++Gap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">        GapWeight[Gap] = huge_valf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">        GapWeight[Gap] = huge_valf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">        if (Uses[Gap+1].getBaseIndex() >= I->end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">        if (Uses[Gap+1].getBaseIndex() >= I->end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">      if (Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">      if (Gap == NumGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">/// tryLocalSplit - Try to split VirtReg into smaller intervals inside its only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">/// tryLocalSplit - Try to split VirtReg into smaller intervals inside its only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">/// basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">/// basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">unsigned RAGreedy::tryLocalSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">unsigned RAGreedy::tryLocalSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">                                 AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">                                 AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">                                 SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  // TODO: the function currently only handles a single UseBlock; it should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  // TODO: the function currently only handles a single UseBlock; it should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  // possible to generalize.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  // possible to generalize.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">  if (SA->getUseBlocks().size() != 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">  if (SA->getUseBlocks().size() != 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">  const SplitAnalysis::BlockInfo &BI = SA->getUseBlocks().front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">  // Note that it is possible to have an interval that is live-in or live-out</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">  // Note that it is possible to have an interval that is live-in or live-out</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  // while only covering a single block - A phi-def can use undef values from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  // while only covering a single block - A phi-def can use undef values from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">  // predecessors, and the block could be a single-block loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">  // predecessors, and the block could be a single-block loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">  // We don't bother doing anything clever about such a case, we simply assume</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">  // We don't bother doing anything clever about such a case, we simply assume</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">  // that the interval is continuous from FirstInstr to LastInstr. We should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">  // that the interval is continuous from FirstInstr to LastInstr. We should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  // make sure that we don't do anything illegal to such an interval, though.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  // make sure that we don't do anything illegal to such an interval, though.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">  ArrayRef<SlotIndex> Uses = SA->getUseSlots();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  if (Uses.size() <= 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  if (Uses.size() <= 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">  const unsigned NumGaps = Uses.size()-1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">  const unsigned NumGaps = Uses.size()-1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">  LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">    dbgs() << "tryLocalSplit: ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">    dbgs() << "tryLocalSplit: ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">    for (const auto &Use : Uses)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">    for (const auto &Use : Uses)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">      dbgs() << ' ' << Use;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">      dbgs() << ' ' << Use;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">    dbgs() << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">    dbgs() << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  // If VirtReg is live across any register mask operands, compute a list of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  // If VirtReg is live across any register mask operands, compute a list of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">  // gaps with register masks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">  // gaps with register masks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  SmallVector<unsigned, 8> RegMaskGaps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  SmallVector<unsigned, 8> RegMaskGaps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  if (Matrix->checkRegMaskInterference(VirtReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  if (Matrix->checkRegMaskInterference(VirtReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">    // Get regmask slots for the whole block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">    // Get regmask slots for the whole block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">    ArrayRef<SlotIndex> RMS = LIS->getRegMaskSlotsInBlock(BI.MBB->getNumber());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">    ArrayRef<SlotIndex> RMS = LIS->getRegMaskSlotsInBlock(BI.MBB->getNumber());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << RMS.size() << " regmasks in block:");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << RMS.size() << " regmasks in block:");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">    // Constrain to VirtReg's live range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">    // Constrain to VirtReg's live range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">    unsigned RI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">    unsigned RI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">        llvm::lower_bound(RMS, Uses.front().getRegSlot()) - RMS.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">        llvm::lower_bound(RMS, Uses.front().getRegSlot()) - RMS.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">    unsigned RE = RMS.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">    unsigned RE = RMS.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">    for (unsigned I = 0; I != NumGaps && RI != RE; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">    for (unsigned I = 0; I != NumGaps && RI != RE; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">      // Look for Uses[I] <= RMS <= Uses[I + 1].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">      // Look for Uses[I] <= RMS <= Uses[I + 1].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">      assert(!SlotIndex::isEarlierInstr(RMS[RI], Uses[I]));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">      assert(!SlotIndex::isEarlierInstr(RMS[RI], Uses[I]));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">      if (SlotIndex::isEarlierInstr(Uses[I + 1], RMS[RI]))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">      if (SlotIndex::isEarlierInstr(Uses[I + 1], RMS[RI]))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">      // Skip a regmask on the same instruction as the last use. It doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">      // Skip a regmask on the same instruction as the last use. It doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">      // overlap the live range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">      // overlap the live range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">      if (SlotIndex::isSameInstr(Uses[I + 1], RMS[RI]) && I + 1 == NumGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">      if (SlotIndex::isSameInstr(Uses[I + 1], RMS[RI]) && I + 1 == NumGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << ' ' << RMS[RI] << ':' << Uses[I] << '-'</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << ' ' << RMS[RI] << ':' << Uses[I] << '-'</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">                        << Uses[I + 1]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">                        << Uses[I + 1]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">      RegMaskGaps.push_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">      RegMaskGaps.push_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">      // Advance ri to the next gap. A regmask on one of the uses counts in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">      // Advance ri to the next gap. A regmask on one of the uses counts in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">      // both gaps.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">      // both gaps.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">      while (RI != RE && SlotIndex::isEarlierInstr(RMS[RI], Uses[I + 1]))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">      while (RI != RE && SlotIndex::isEarlierInstr(RMS[RI], Uses[I + 1]))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">        ++RI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">        ++RI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">  // Since we allow local split results to be split again, there is a risk of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">  // Since we allow local split results to be split again, there is a risk of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">  // creating infinite loops. It is tempting to require that the new live</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">  // creating infinite loops. It is tempting to require that the new live</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">  // ranges have less instructions than the original. That would guarantee</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">  // ranges have less instructions than the original. That would guarantee</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">  // convergence, but it is too strict. A live range with 3 instructions can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">  // convergence, but it is too strict. A live range with 3 instructions can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">  // split 2+3 (including the COPY), and we want to allow that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">  // split 2+3 (including the COPY), and we want to allow that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">  // Instead we use these rules:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">  // Instead we use these rules:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">  // 1. Allow any split for ranges with getStage() < RS_Split2. (Except for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">  // 1. Allow any split for ranges with getStage() < RS_Split2. (Except for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">  //    noop split, of course).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">  //    noop split, of course).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">  // 2. Require progress be made for ranges with getStage() == RS_Split2. All</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">  // 2. Require progress be made for ranges with getStage() == RS_Split2. All</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">  //    the new ranges must have fewer instructions than before the split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">  //    the new ranges must have fewer instructions than before the split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">  // 3. New ranges with the same number of instructions are marked RS_Split2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">  // 3. New ranges with the same number of instructions are marked RS_Split2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  //    smaller ranges are marked RS_New.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  //    smaller ranges are marked RS_New.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">  // These rules allow a 3 -> 2+3 split once, which we need. They also prevent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">  // These rules allow a 3 -> 2+3 split once, which we need. They also prevent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">  // excessive splitting and infinite loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">  // excessive splitting and infinite loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  bool ProgressRequired = ExtraInfo->getStage(VirtReg) >= RS_Split2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  bool ProgressRequired = ExtraInfo->getStage(VirtReg) >= RS_Split2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">  // Best split candidate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">  // Best split candidate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  unsigned BestBefore = NumGaps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  unsigned BestBefore = NumGaps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">  unsigned BestAfter = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">  unsigned BestAfter = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">  float BestDiff = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">  float BestDiff = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  const float blockFreq =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  const float blockFreq =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">    SpillPlacer->getBlockFrequency(BI.MBB->getNumber()).getFrequency() *</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">    SpillPlacer->getBlockFrequency(BI.MBB->getNumber()).getFrequency() *</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">    (1.0f / MBFI->getEntryFreq());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">    (1.0f / MBFI->getEntryFreq());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  SmallVector<float, 8> GapWeight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  SmallVector<float, 8> GapWeight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">  for (MCPhysReg PhysReg : Order) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">  for (MCPhysReg PhysReg : Order) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">    assert(PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">    assert(PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">    // Keep track of the largest spill weight that would need to be evicted in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">    // Keep track of the largest spill weight that would need to be evicted in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">    // order to make use of PhysReg between UseSlots[I] and UseSlots[I + 1].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">    // order to make use of PhysReg between UseSlots[I] and UseSlots[I + 1].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">    calcGapWeights(PhysReg, GapWeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">    calcGapWeights(PhysReg, GapWeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">    // Remove any gaps with regmask clobbers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">    // Remove any gaps with regmask clobbers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">    if (Matrix->checkRegMaskInterference(VirtReg, PhysReg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">    if (Matrix->checkRegMaskInterference(VirtReg, PhysReg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">      for (unsigned I = 0, E = RegMaskGaps.size(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">      for (unsigned I = 0, E = RegMaskGaps.size(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">        GapWeight[RegMaskGaps[I]] = huge_valf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">        GapWeight[RegMaskGaps[I]] = huge_valf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">    // Try to find the best sequence of gaps to close.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">    // Try to find the best sequence of gaps to close.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">    // The new spill weight must be larger than any gap interference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">    // The new spill weight must be larger than any gap interference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">    // We will split before Uses[SplitBefore] and after Uses[SplitAfter].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">    // We will split before Uses[SplitBefore] and after Uses[SplitAfter].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">    unsigned SplitBefore = 0, SplitAfter = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">    unsigned SplitBefore = 0, SplitAfter = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">    // MaxGap should always be max(GapWeight[SplitBefore..SplitAfter-1]).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">    // MaxGap should always be max(GapWeight[SplitBefore..SplitAfter-1]).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">    // It is the spill weight that needs to be evicted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">    // It is the spill weight that needs to be evicted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">    float MaxGap = GapWeight[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">    float MaxGap = GapWeight[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">      // Live before/after split?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">      // Live before/after split?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">      const bool LiveBefore = SplitBefore != 0 || BI.LiveIn;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">      const bool LiveBefore = SplitBefore != 0 || BI.LiveIn;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">      const bool LiveAfter = SplitAfter != NumGaps || BI.LiveOut;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">      const bool LiveAfter = SplitAfter != NumGaps || BI.LiveOut;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << ' ' << Uses[SplitBefore]</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << printReg(PhysReg, TRI) << ' ' << Uses[SplitBefore]</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">                        << '-' << Uses[SplitAfter] << " I=" << MaxGap);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">                        << '-' << Uses[SplitAfter] << " I=" << MaxGap);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">      // Stop before the interval gets so big we wouldn't be making progress.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">      // Stop before the interval gets so big we wouldn't be making progress.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">      if (!LiveBefore && !LiveAfter) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">      if (!LiveBefore && !LiveAfter) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << " all\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << " all\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">      // Should the interval be extended or shrunk?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">      // Should the interval be extended or shrunk?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">      bool Shrink = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">      bool Shrink = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">      // How many gaps would the new range have?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">      // How many gaps would the new range have?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">      unsigned NewGaps = LiveBefore + SplitAfter - SplitBefore + LiveAfter;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">      unsigned NewGaps = LiveBefore + SplitAfter - SplitBefore + LiveAfter;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">      // Legally, without causing looping?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">      // Legally, without causing looping?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">      bool Legal = !ProgressRequired || NewGaps < NumGaps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">      bool Legal = !ProgressRequired || NewGaps < NumGaps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">      if (Legal && MaxGap < huge_valf) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">      if (Legal && MaxGap < huge_valf) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">        // Estimate the new spill weight. Each instruction reads or writes the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">        // Estimate the new spill weight. Each instruction reads or writes the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">        // register. Conservatively assume there are no read-modify-write</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">        // register. Conservatively assume there are no read-modify-write</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">        // instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">        // instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">        // Try to guess the size of the new interval.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">        // Try to guess the size of the new interval.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">        const float EstWeight = normalizeSpillWeight(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">        const float EstWeight = normalizeSpillWeight(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">            blockFreq * (NewGaps + 1),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">            blockFreq * (NewGaps + 1),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">            Uses[SplitBefore].distance(Uses[SplitAfter]) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">            Uses[SplitBefore].distance(Uses[SplitAfter]) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">                (LiveBefore + LiveAfter) * SlotIndex::InstrDist,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">                (LiveBefore + LiveAfter) * SlotIndex::InstrDist,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">            1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">            1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">        // Would this split be possible to allocate?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">        // Would this split be possible to allocate?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">        // Never allocate all gaps, we wouldn't be making progress.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">        // Never allocate all gaps, we wouldn't be making progress.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << " w=" << EstWeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << " w=" << EstWeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">        if (EstWeight * Hysteresis >= MaxGap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">        if (EstWeight * Hysteresis >= MaxGap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">          Shrink = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">          Shrink = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">          float Diff = EstWeight - MaxGap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">          float Diff = EstWeight - MaxGap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">          if (Diff > BestDiff) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">          if (Diff > BestDiff) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">            LLVM_DEBUG(dbgs() << " (best)");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">            LLVM_DEBUG(dbgs() << " (best)");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">            BestDiff = Hysteresis * Diff;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">            BestDiff = Hysteresis * Diff;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">            BestBefore = SplitBefore;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">            BestBefore = SplitBefore;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">            BestAfter = SplitAfter;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">            BestAfter = SplitAfter;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">      // Try to shrink.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">      // Try to shrink.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">      if (Shrink) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">      if (Shrink) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">        if (++SplitBefore < SplitAfter) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">        if (++SplitBefore < SplitAfter) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << " shrink\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << " shrink\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">          // Recompute the max when necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">          // Recompute the max when necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">          if (GapWeight[SplitBefore - 1] >= MaxGap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">          if (GapWeight[SplitBefore - 1] >= MaxGap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">            MaxGap = GapWeight[SplitBefore];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">            MaxGap = GapWeight[SplitBefore];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">            for (unsigned I = SplitBefore + 1; I != SplitAfter; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">            for (unsigned I = SplitBefore + 1; I != SplitAfter; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">              MaxGap = std::max(MaxGap, GapWeight[I]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">              MaxGap = std::max(MaxGap, GapWeight[I]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">        MaxGap = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">        MaxGap = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">      // Try to extend the interval.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">      // Try to extend the interval.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">      if (SplitAfter >= NumGaps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">      if (SplitAfter >= NumGaps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << " end\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << " end\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << " extend\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << " extend\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">      MaxGap = std::max(MaxGap, GapWeight[SplitAfter++]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">      MaxGap = std::max(MaxGap, GapWeight[SplitAfter++]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">  // Didn't find any candidates?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">  // Didn't find any candidates?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">  if (BestBefore == NumGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">  if (BestBefore == NumGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Best local split range: " << Uses[BestBefore] << '-'</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Best local split range: " << Uses[BestBefore] << '-'</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">                    << Uses[BestAfter] << ", " << BestDiff << ", "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">                    << Uses[BestAfter] << ", " << BestDiff << ", "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">                    << (BestAfter - BestBefore + 1) << " instrs\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">                    << (BestAfter - BestBefore + 1) << " instrs\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">  LiveRangeEdit LREdit(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">  SE->reset(LREdit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">  SE->reset(LREdit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">  SE->openIntv();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">  SE->openIntv();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">  SlotIndex SegStart = SE->enterIntvBefore(Uses[BestBefore]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">  SlotIndex SegStart = SE->enterIntvBefore(Uses[BestBefore]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  SlotIndex SegStop  = SE->leaveIntvAfter(Uses[BestAfter]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  SlotIndex SegStop  = SE->leaveIntvAfter(Uses[BestAfter]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">  SE->useIntv(SegStart, SegStop);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">  SE->useIntv(SegStart, SegStop);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">  SmallVector<unsigned, 8> IntvMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">  SE->finish(&IntvMap);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">  DebugVars->splitRegister(VirtReg.reg(), LREdit.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">  // If the new range has the same number of instructions as before, mark it as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">  // If the new range has the same number of instructions as before, mark it as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">  // RS_Split2 so the next split will be forced to make progress. Otherwise,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">  // RS_Split2 so the next split will be forced to make progress. Otherwise,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">  // leave the new intervals as RS_New so they can compete.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">  // leave the new intervals as RS_New so they can compete.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">  bool LiveBefore = BestBefore != 0 || BI.LiveIn;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">  bool LiveBefore = BestBefore != 0 || BI.LiveIn;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">  bool LiveAfter = BestAfter != NumGaps || BI.LiveOut;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">  bool LiveAfter = BestAfter != NumGaps || BI.LiveOut;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  unsigned NewGaps = LiveBefore + BestAfter - BestBefore + LiveAfter;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  unsigned NewGaps = LiveBefore + BestAfter - BestBefore + LiveAfter;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">  if (NewGaps >= NumGaps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">  if (NewGaps >= NumGaps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Tagging non-progress ranges:");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Tagging non-progress ranges:");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">    assert(!ProgressRequired && "Didn't make progress when it was required.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">    assert(!ProgressRequired && "Didn't make progress when it was required.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">    for (unsigned I = 0, E = IntvMap.size(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">    for (unsigned I = 0, E = IntvMap.size(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">      if (IntvMap[I] == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">      if (IntvMap[I] == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">        ExtraInfo->setStage(LIS->getInterval(LREdit.get(I)), RS_Split2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">        ExtraInfo->setStage(LIS->getInterval(LREdit.get(I)), RS_Split2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << ' ' << printReg(LREdit.get(I)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << ' ' << printReg(LREdit.get(I)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">  ++NumLocalSplits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">  ++NumLocalSplits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">//                          Live Range Splitting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">//                          Live Range Splitting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">/// trySplit - Try to split VirtReg or one of its interferences, making it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">/// trySplit - Try to split VirtReg or one of its interferences, making it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">/// assignable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">/// assignable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">/// @return Physreg when VirtReg may be assigned and/or new NewVRegs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">/// @return Physreg when VirtReg may be assigned and/or new NewVRegs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">unsigned RAGreedy::trySplit(const LiveInterval &VirtReg, AllocationOrder &Order,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">unsigned RAGreedy::trySplit(const LiveInterval &VirtReg, AllocationOrder &Order,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">                            SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">                            SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">                            const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">                            const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">  // Ranges must be Split2 or less.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">  // Ranges must be Split2 or less.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">  if (ExtraInfo->getStage(VirtReg) >= RS_Spill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">  if (ExtraInfo->getStage(VirtReg) >= RS_Spill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">  // Local intervals are handled separately.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">  // Local intervals are handled separately.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">  if (LIS->intervalIsInOneMBB(VirtReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">  if (LIS->intervalIsInOneMBB(VirtReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">    NamedRegionTimer T("local_split", "Local Splitting", TimerGroupName,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">    NamedRegionTimer T("local_split", "Local Splitting", TimerGroupName,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">                       TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">                       TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">    Register PhysReg = tryLocalSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">    Register PhysReg = tryLocalSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">    if (PhysReg || !NewVRegs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">    if (PhysReg || !NewVRegs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">    return tryInstructionSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">    return tryInstructionSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  NamedRegionTimer T("global_split", "Global Splitting", TimerGroupName,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  NamedRegionTimer T("global_split", "Global Splitting", TimerGroupName,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">                     TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">                     TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">  SA->analyze(&VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">  SA->analyze(&VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">  // First try to split around a region spanning multiple blocks. RS_Split2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">  // First try to split around a region spanning multiple blocks. RS_Split2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  // ranges already made dubious progress with region splitting, so they go</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  // ranges already made dubious progress with region splitting, so they go</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">  // straight to single block splitting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">  // straight to single block splitting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  if (ExtraInfo->getStage(VirtReg) < RS_Split2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  if (ExtraInfo->getStage(VirtReg) < RS_Split2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">    MCRegister PhysReg = tryRegionSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">    MCRegister PhysReg = tryRegionSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">    if (PhysReg || !NewVRegs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">    if (PhysReg || !NewVRegs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  // Then isolate blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  // Then isolate blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  return tryBlockSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  return tryBlockSplit(VirtReg, Order, NewVRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">//                          Last Chance Recoloring</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">//                          Last Chance Recoloring</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">/// Return true if \p reg has any tied def operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">/// Return true if \p reg has any tied def operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">static bool hasTiedDef(MachineRegisterInfo *MRI, unsigned reg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">static bool hasTiedDef(MachineRegisterInfo *MRI, unsigned reg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">  for (const MachineOperand &MO : MRI->def_operands(reg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">  for (const MachineOperand &MO : MRI->def_operands(reg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">    if (MO.isTied())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">    if (MO.isTied())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">/// Return true if the existing assignment of \p Intf overlaps, but is not the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">/// Return true if the existing assignment of \p Intf overlaps, but is not the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">/// same, as \p PhysReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">/// same, as \p PhysReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">static bool assignedRegPartiallyOverlaps(const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">static bool assignedRegPartiallyOverlaps(const TargetRegisterInfo &TRI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">                                         const VirtRegMap &VRM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">                                         const VirtRegMap &VRM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">                                         MCRegister PhysReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">                                         MCRegister PhysReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">                                         const LiveInterval &Intf) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">                                         const LiveInterval &Intf) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">  MCRegister AssignedReg = VRM.getPhys(Intf.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">  MCRegister AssignedReg = VRM.getPhys(Intf.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">  if (PhysReg == AssignedReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">  if (PhysReg == AssignedReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">  return TRI.regsOverlap(PhysReg, AssignedReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">  return TRI.regsOverlap(PhysReg, AssignedReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">/// mayRecolorAllInterferences - Check if the virtual registers that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">/// mayRecolorAllInterferences - Check if the virtual registers that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">/// interfere with \p VirtReg on \p PhysReg (or one of its aliases) may be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">/// interfere with \p VirtReg on \p PhysReg (or one of its aliases) may be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">/// recolored to free \p PhysReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">/// recolored to free \p PhysReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">/// When true is returned, \p RecoloringCandidates has been augmented with all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">/// When true is returned, \p RecoloringCandidates has been augmented with all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">/// the live intervals that need to be recolored in order to free \p PhysReg</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">/// the live intervals that need to be recolored in order to free \p PhysReg</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">/// for \p VirtReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">/// for \p VirtReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">/// recolored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">/// recolored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">bool RAGreedy::mayRecolorAllInterferences(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">bool RAGreedy::mayRecolorAllInterferences(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">    MCRegister PhysReg, const LiveInterval &VirtReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">    MCRegister PhysReg, const LiveInterval &VirtReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">    SmallLISet &RecoloringCandidates, const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">    SmallLISet &RecoloringCandidates, const SmallVirtRegSet &FixedRegisters) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">  const TargetRegisterClass *CurRC = MRI->getRegClass(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  for (MCRegUnit Unit : TRI->regunits(PhysReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">    LiveIntervalUnion::Query &Q = Matrix->query(VirtReg, Unit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">    // If there is LastChanceRecoloringMaxInterference or more interferences,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">    // If there is LastChanceRecoloringMaxInterference or more interferences,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">    // chances are one would not be recolorable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">    // chances are one would not be recolorable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">    if (Q.interferingVRegs(LastChanceRecoloringMaxInterference).size() >=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">    if (Q.interferingVRegs(LastChanceRecoloringMaxInterference).size() >=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">            LastChanceRecoloringMaxInterference &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">            LastChanceRecoloringMaxInterference &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">        !ExhaustiveSearch) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">        !ExhaustiveSearch) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Early abort: too many interferences.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Early abort: too many interferences.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">      CutOffInfo |= CO_Interf;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">      CutOffInfo |= CO_Interf;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">    for (const LiveInterval *Intf : reverse(Q.interferingVRegs())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">    for (const LiveInterval *Intf : reverse(Q.interferingVRegs())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">      // If Intf is done and sits on the same register class as VirtReg, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">      // If Intf is done and sits on the same register class as VirtReg, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">      // would not be recolorable as it is in the same state as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">      // would not be recolorable as it is in the same state as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">      // VirtReg. However there are at least two exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">      // VirtReg. However there are at least two exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">      // If VirtReg has tied defs and Intf doesn't, then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">      // If VirtReg has tied defs and Intf doesn't, then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">      // there is still a point in examining if it can be recolorable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">      // there is still a point in examining if it can be recolorable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">      // Additionally, if the register class has overlapping tuple members, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">      // Additionally, if the register class has overlapping tuple members, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">      // may still be recolorable using a different tuple. This is more likely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">      // may still be recolorable using a different tuple. This is more likely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">      // if the existing assignment aliases with the candidate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">      // if the existing assignment aliases with the candidate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">      if (((ExtraInfo->getStage(*Intf) == RS_Done &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">      if (((ExtraInfo->getStage(*Intf) == RS_Done &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">            MRI->getRegClass(Intf->reg()) == CurRC &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">            MRI->getRegClass(Intf->reg()) == CurRC &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">            !assignedRegPartiallyOverlaps(*TRI, *VRM, PhysReg, *Intf)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">            !assignedRegPartiallyOverlaps(*TRI, *VRM, PhysReg, *Intf)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">           !(hasTiedDef(MRI, VirtReg.reg()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">           !(hasTiedDef(MRI, VirtReg.reg()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">             !hasTiedDef(MRI, Intf->reg()))) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">             !hasTiedDef(MRI, Intf->reg()))) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">          FixedRegisters.count(Intf->reg())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">          FixedRegisters.count(Intf->reg())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">            dbgs() << "Early abort: the interference is not recolorable.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">            dbgs() << "Early abort: the interference is not recolorable.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">      RecoloringCandidates.insert(Intf);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">      RecoloringCandidates.insert(Intf);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">/// its interferences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">/// its interferences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">/// Last chance recoloring chooses a color for \p VirtReg and recolors every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">/// Last chance recoloring chooses a color for \p VirtReg and recolors every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">/// virtual register that was using it. The recoloring process may recursively</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">/// virtual register that was using it. The recoloring process may recursively</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">/// use the last chance recoloring. Therefore, when a virtual register has been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">/// use the last chance recoloring. Therefore, when a virtual register has been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">/// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">/// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">/// be last-chance-recolored again during this recoloring "session".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">/// be last-chance-recolored again during this recoloring "session".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">/// E.g.,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">/// E.g.,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">/// Let</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">/// Let</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">/// vA can use {R1, R2    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">/// vA can use {R1, R2    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">/// vB can use {    R2, R3}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">/// vB can use {    R2, R3}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">/// vC can use {R1        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">/// vC can use {R1        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">/// Where vA, vB, and vC cannot be split anymore (they are reloads for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">/// Where vA, vB, and vC cannot be split anymore (they are reloads for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">/// instance) and they all interfere.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">/// instance) and they all interfere.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">/// vA is assigned R1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">/// vA is assigned R1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">/// vB is assigned R2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">/// vB is assigned R2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">/// vC tries to evict vA but vA is already done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">/// vC tries to evict vA but vA is already done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">/// Regular register allocation fails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">/// Regular register allocation fails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">/// Last chance recoloring kicks in:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">/// Last chance recoloring kicks in:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">/// vC does as if vA was evicted => vC uses R1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">/// vC does as if vA was evicted => vC uses R1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">/// vC is marked as fixed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">/// vC is marked as fixed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">/// vA needs to find a color.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">/// vA needs to find a color.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">/// None are available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">/// None are available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">/// vA cannot evict vC: vC is a fixed virtual register now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">/// vA cannot evict vC: vC is a fixed virtual register now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">/// vA does as if vB was evicted => vA uses R2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">/// vA does as if vB was evicted => vA uses R2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">/// vB needs to find a color.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">/// vB needs to find a color.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">/// R3 is available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">/// R3 is available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">/// Recoloring => vC = R1, vA = R2, vB = R3</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">/// Recoloring => vC = R1, vA = R2, vB = R3</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">/// \p Order defines the preferred allocation order for \p VirtReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">/// \p Order defines the preferred allocation order for \p VirtReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">/// \p NewRegs will contain any new virtual register that have been created</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">/// \p NewRegs will contain any new virtual register that have been created</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">/// (split, spill) during the process and that must be assigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">/// (split, spill) during the process and that must be assigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">/// \p FixedRegisters contains all the virtual registers that cannot be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">/// recolored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">/// recolored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">/// \p RecolorStack tracks the original assignments of successfully recolored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">/// \p RecolorStack tracks the original assignments of successfully recolored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">/// registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">/// registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">/// \p Depth gives the current depth of the last chance recoloring.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">/// \p Depth gives the current depth of the last chance recoloring.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">/// \return a physical register that can be used for VirtReg or ~0u if none</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">/// \return a physical register that can be used for VirtReg or ~0u if none</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">/// exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">/// exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">unsigned RAGreedy::tryLastChanceRecoloring(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">unsigned RAGreedy::tryLastChanceRecoloring(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">                                           AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">                                           AllocationOrder &Order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">                                           SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">                                           SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">                                           SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">                                           SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">                                           RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">                                           RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">                                           unsigned Depth) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">                                           unsigned Depth) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">  if (!TRI->shouldUseLastChanceRecoloringForVirtReg(*MF, VirtReg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  if (!TRI->shouldUseLastChanceRecoloringForVirtReg(*MF, VirtReg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">    return ~0u;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">    return ~0u;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Try last chance recoloring for " << VirtReg << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Try last chance recoloring for " << VirtReg << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  const ssize_t EntryStackSize = RecolorStack.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  const ssize_t EntryStackSize = RecolorStack.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">  // Ranges must be Done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">  // Ranges must be Done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">  assert((ExtraInfo->getStage(VirtReg) >= RS_Done || !VirtReg.isSpillable()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">  assert((ExtraInfo->getStage(VirtReg) >= RS_Done || !VirtReg.isSpillable()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">         "Last chance recoloring should really be last chance");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">         "Last chance recoloring should really be last chance");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">  // Set the max depth to LastChanceRecoloringMaxDepth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">  // Set the max depth to LastChanceRecoloringMaxDepth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">  // We may want to reconsider that if we end up with a too large search space</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">  // We may want to reconsider that if we end up with a too large search space</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">  // for target with hundreds of registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">  // for target with hundreds of registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">  // Indeed, in that case we may want to cut the search space earlier.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">  // Indeed, in that case we may want to cut the search space earlier.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">  if (Depth >= LastChanceRecoloringMaxDepth && !ExhaustiveSearch) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">  if (Depth >= LastChanceRecoloringMaxDepth && !ExhaustiveSearch) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Abort because max depth has been reached.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Abort because max depth has been reached.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">    CutOffInfo |= CO_Depth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">    CutOffInfo |= CO_Depth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">    return ~0u;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">    return ~0u;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  // Set of Live intervals that will need to be recolored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  // Set of Live intervals that will need to be recolored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">  SmallLISet RecoloringCandidates;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">  SmallLISet RecoloringCandidates;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  // Mark VirtReg as fixed, i.e., it will not be recolored pass this point in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  // Mark VirtReg as fixed, i.e., it will not be recolored pass this point in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">  // this recoloring "session".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">  // this recoloring "session".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  assert(!FixedRegisters.count(VirtReg.reg()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  assert(!FixedRegisters.count(VirtReg.reg()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">  FixedRegisters.insert(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">  FixedRegisters.insert(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">  SmallVector<Register, 4> CurrentNewVRegs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">  SmallVector<Register, 4> CurrentNewVRegs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">  for (MCRegister PhysReg : Order) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">  for (MCRegister PhysReg : Order) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">    assert(PhysReg.isValid());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">    assert(PhysReg.isValid());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Try to assign: " << VirtReg << " to "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Try to assign: " << VirtReg << " to "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">                      << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">                      << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">    RecoloringCandidates.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">    RecoloringCandidates.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">    CurrentNewVRegs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">    CurrentNewVRegs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">    // It is only possible to recolor virtual register interference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">    // It is only possible to recolor virtual register interference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">    if (Matrix->checkInterference(VirtReg, PhysReg) ></td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">    if (Matrix->checkInterference(VirtReg, PhysReg) ></td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">        LiveRegMatrix::IK_VirtReg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">        LiveRegMatrix::IK_VirtReg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">      LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">      LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">          dbgs() << "Some interferences are not with virtual registers.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">          dbgs() << "Some interferences are not with virtual registers.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">    // Early give up on this PhysReg if it is obvious we cannot recolor all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">    // Early give up on this PhysReg if it is obvious we cannot recolor all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">    // the interferences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">    // the interferences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">    if (!mayRecolorAllInterferences(PhysReg, VirtReg, RecoloringCandidates,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">    if (!mayRecolorAllInterferences(PhysReg, VirtReg, RecoloringCandidates,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">                                    FixedRegisters)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">                                    FixedRegisters)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Some interferences cannot be recolored.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Some interferences cannot be recolored.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">    // RecoloringCandidates contains all the virtual registers that interfere</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">    // RecoloringCandidates contains all the virtual registers that interfere</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">    // with VirtReg on PhysReg (or one of its aliases). Enqueue them for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">    // with VirtReg on PhysReg (or one of its aliases). Enqueue them for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">    // recoloring and perform the actual recoloring.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">    // recoloring and perform the actual recoloring.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">    PQueue RecoloringQueue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">    PQueue RecoloringQueue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">    for (const LiveInterval *RC : RecoloringCandidates) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">    for (const LiveInterval *RC : RecoloringCandidates) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">      Register ItVirtReg = RC->reg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">      Register ItVirtReg = RC->reg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">      enqueue(RecoloringQueue, RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">      enqueue(RecoloringQueue, RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">      assert(VRM->hasPhys(ItVirtReg) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">      assert(VRM->hasPhys(ItVirtReg) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">             "Interferences are supposed to be with allocated variables");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">             "Interferences are supposed to be with allocated variables");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">      // Record the current allocation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">      // Record the current allocation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">      RecolorStack.push_back(std::make_pair(RC, VRM->getPhys(ItVirtReg)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">      RecolorStack.push_back(std::make_pair(RC, VRM->getPhys(ItVirtReg)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">      // unset the related struct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">      // unset the related struct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">      Matrix->unassign(*RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">      Matrix->unassign(*RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">    // Do as if VirtReg was assigned to PhysReg so that the underlying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">    // Do as if VirtReg was assigned to PhysReg so that the underlying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">    // recoloring has the right information about the interferes and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">    // recoloring has the right information about the interferes and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">    // available colors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">    // available colors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">    Matrix->assign(VirtReg, PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">    Matrix->assign(VirtReg, PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">    // Save the current recoloring state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">    // Save the current recoloring state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">    // If we cannot recolor all the interferences, we will have to start again</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">    // If we cannot recolor all the interferences, we will have to start again</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">    // at this point for the next physical register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">    // at this point for the next physical register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">    SmallVirtRegSet SaveFixedRegisters(FixedRegisters);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">    SmallVirtRegSet SaveFixedRegisters(FixedRegisters);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">    if (tryRecoloringCandidates(RecoloringQueue, CurrentNewVRegs,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">    if (tryRecoloringCandidates(RecoloringQueue, CurrentNewVRegs,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">                                FixedRegisters, RecolorStack, Depth)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">                                FixedRegisters, RecolorStack, Depth)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">      // Push the queued vregs into the main queue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">      // Push the queued vregs into the main queue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">      for (Register NewVReg : CurrentNewVRegs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">      for (Register NewVReg : CurrentNewVRegs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">        NewVRegs.push_back(NewVReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">        NewVRegs.push_back(NewVReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">      // Do not mess up with the global assignment process.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">      // Do not mess up with the global assignment process.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">      // I.e., VirtReg must be unassigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">      // I.e., VirtReg must be unassigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">      Matrix->unassign(VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">      Matrix->unassign(VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Fail to assign: " << VirtReg << " to "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Fail to assign: " << VirtReg << " to "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">                      << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">                      << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">    // The recoloring attempt failed, undo the changes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">    // The recoloring attempt failed, undo the changes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">    FixedRegisters = SaveFixedRegisters;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">    FixedRegisters = SaveFixedRegisters;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">    Matrix->unassign(VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">    Matrix->unassign(VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">    // For a newly created vreg which is also in RecoloringCandidates,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">    // For a newly created vreg which is also in RecoloringCandidates,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">    // don't add it to NewVRegs because its physical register will be restored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">    // don't add it to NewVRegs because its physical register will be restored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">    // below. Other vregs in CurrentNewVRegs are created by calling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">    // below. Other vregs in CurrentNewVRegs are created by calling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">    // selectOrSplit and should be added into NewVRegs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">    // selectOrSplit and should be added into NewVRegs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">    for (Register R : CurrentNewVRegs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">    for (Register R : CurrentNewVRegs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">      if (RecoloringCandidates.count(&LIS->getInterval(R)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">      if (RecoloringCandidates.count(&LIS->getInterval(R)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">      NewVRegs.push_back(R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">      NewVRegs.push_back(R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">    // Roll back our unsuccessful recoloring. Also roll back any successful</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">    // Roll back our unsuccessful recoloring. Also roll back any successful</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">    // recolorings in any recursive recoloring attempts, since it's possible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">    // recolorings in any recursive recoloring attempts, since it's possible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">    // they would have introduced conflicts with assignments we will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">    // they would have introduced conflicts with assignments we will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">    // restoring further up the stack. Perform all unassignments prior to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">    // restoring further up the stack. Perform all unassignments prior to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">    // reassigning, since sub-recolorings may have conflicted with the registers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">    // reassigning, since sub-recolorings may have conflicted with the registers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">    // we are going to restore to their original assignments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">    // we are going to restore to their original assignments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">    for (ssize_t I = RecolorStack.size() - 1; I >= EntryStackSize; --I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">    for (ssize_t I = RecolorStack.size() - 1; I >= EntryStackSize; --I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">      const LiveInterval *LI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">      const LiveInterval *LI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">      MCRegister PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">      MCRegister PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">      if (VRM->hasPhys(LI->reg()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">      if (VRM->hasPhys(LI->reg()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">        Matrix->unassign(*LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">        Matrix->unassign(*LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">    for (size_t I = EntryStackSize; I != RecolorStack.size(); ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">    for (size_t I = EntryStackSize; I != RecolorStack.size(); ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">      const LiveInterval *LI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">      const LiveInterval *LI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">      MCRegister PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">      MCRegister PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">      std::tie(LI, PhysReg) = RecolorStack[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">      if (!LI->empty() && !MRI->reg_nodbg_empty(LI->reg()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">      if (!LI->empty() && !MRI->reg_nodbg_empty(LI->reg()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">        Matrix->assign(*LI, PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">        Matrix->assign(*LI, PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">    // Pop the stack of recoloring attempts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">    // Pop the stack of recoloring attempts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">    RecolorStack.resize(EntryStackSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">    RecolorStack.resize(EntryStackSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">  // Last chance recoloring did not worked either, give up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">  // Last chance recoloring did not worked either, give up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">  return ~0u;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">  return ~0u;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">/// tryRecoloringCandidates - Try to assign a new color to every register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">/// tryRecoloringCandidates - Try to assign a new color to every register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">/// in \RecoloringQueue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">/// in \RecoloringQueue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">/// \p NewRegs will contain any new virtual register created during the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">/// \p NewRegs will contain any new virtual register created during the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">/// recoloring process.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">/// recoloring process.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">/// \p FixedRegisters[in/out] contains all the registers that have been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">/// \p FixedRegisters[in/out] contains all the registers that have been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">/// recolored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">/// recolored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">/// \return true if all virtual registers in RecoloringQueue were successfully</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">/// \return true if all virtual registers in RecoloringQueue were successfully</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">/// recolored, false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">/// recolored, false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">bool RAGreedy::tryRecoloringCandidates(PQueue &RecoloringQueue,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">bool RAGreedy::tryRecoloringCandidates(PQueue &RecoloringQueue,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">                                       SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">                                       SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">                                       SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">                                       SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">                                       RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">                                       RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                       unsigned Depth) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                       unsigned Depth) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">  while (!RecoloringQueue.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">  while (!RecoloringQueue.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">    const LiveInterval *LI = dequeue(RecoloringQueue);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">    const LiveInterval *LI = dequeue(RecoloringQueue);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Try to recolor: " << *LI << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Try to recolor: " << *LI << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">    MCRegister PhysReg = selectOrSplitImpl(*LI, NewVRegs, FixedRegisters,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">    MCRegister PhysReg = selectOrSplitImpl(*LI, NewVRegs, FixedRegisters,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">                                           RecolorStack, Depth + 1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">                                           RecolorStack, Depth + 1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">    // When splitting happens, the live-range may actually be empty.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">    // When splitting happens, the live-range may actually be empty.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">    // In that case, this is okay to continue the recoloring even</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">    // In that case, this is okay to continue the recoloring even</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">    // if we did not find an alternative color for it. Indeed,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">    // if we did not find an alternative color for it. Indeed,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">    // there will not be anything to color for LI in the end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">    // there will not be anything to color for LI in the end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">    if (PhysReg == ~0u || (!PhysReg && !LI->empty()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">    if (PhysReg == ~0u || (!PhysReg && !LI->empty()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">    if (!PhysReg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">    if (!PhysReg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">      assert(LI->empty() && "Only empty live-range do not require a register");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">      assert(LI->empty() && "Only empty live-range do not require a register");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">                        << " succeeded. Empty LI.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">                        << " succeeded. Empty LI.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Recoloring of " << *LI</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">                      << " succeeded with: " << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">                      << " succeeded with: " << printReg(PhysReg, TRI) << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">    Matrix->assign(*LI, PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">    Matrix->assign(*LI, PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">    FixedRegisters.insert(LI->reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">    FixedRegisters.insert(LI->reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">//                            Main Entry Point</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">//                            Main Entry Point</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine coveredLine">MCRegister RAGreedy::selectOrSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine coveredLine">MCRegister RAGreedy::selectOrSplit(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">                                   SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">                                   SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine coveredLine">  CutOffInfo = CO_None;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine coveredLine">  CutOffInfo = CO_None;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine coveredLine">  LLVMContext &Ctx = MF->getFunction().getContext();</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine coveredLine">  LLVMContext &Ctx = MF->getFunction().getContext();</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine coveredLine">  SmallVirtRegSet FixedRegisters;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine coveredLine">  SmallVirtRegSet FixedRegisters;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine coveredLine">  RecoloringStack RecolorStack;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine coveredLine">  RecoloringStack RecolorStack;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">  MCRegister Reg =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">  MCRegister Reg =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine coveredLine">      selectOrSplitImpl(VirtReg, NewVRegs, FixedRegisters, RecolorStack);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine coveredLine">      selectOrSplitImpl(VirtReg, NewVRegs, FixedRegisters, RecolorStack);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine coveredLine">  if (Reg == ~0U && (CutOffInfo != CO_None)) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine coveredLine">  if (Reg == ~0U && (CutOffInfo != CO_None)) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">    uint8_t CutOffEncountered = CutOffInfo & (CO_Depth | CO_Interf);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">    uint8_t CutOffEncountered = CutOffInfo & (CO_Depth | CO_Interf);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">    if (CutOffEncountered == CO_Depth)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">    if (CutOffEncountered == CO_Depth)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">      Ctx.emitError("register allocation failed: maximum depth for recoloring "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">      Ctx.emitError("register allocation failed: maximum depth for recoloring "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">                    "reached. Use -fexhaustive-register-search to skip "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">                    "reached. Use -fexhaustive-register-search to skip "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">                    "cutoffs");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">                    "cutoffs");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">    else if (CutOffEncountered == CO_Interf)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">    else if (CutOffEncountered == CO_Interf)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">      Ctx.emitError("register allocation failed: maximum interference for "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">      Ctx.emitError("register allocation failed: maximum interference for "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">                    "recoloring reached. Use -fexhaustive-register-search "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">                    "recoloring reached. Use -fexhaustive-register-search "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">                    "to skip cutoffs");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">                    "to skip cutoffs");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">    else if (CutOffEncountered == (CO_Depth | CO_Interf))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">    else if (CutOffEncountered == (CO_Depth | CO_Interf))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">      Ctx.emitError("register allocation failed: maximum interference and "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">      Ctx.emitError("register allocation failed: maximum interference and "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">                    "depth for recoloring reached. Use "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">                    "depth for recoloring reached. Use "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">                    "-fexhaustive-register-search to skip cutoffs");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">                    "-fexhaustive-register-search to skip cutoffs");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine coveredLine">  return Reg;</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine coveredLine">  return Reg;</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">/// Using a CSR for the first time has a cost because it causes push|pop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">/// Using a CSR for the first time has a cost because it causes push|pop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">/// to be added to prologue|epilogue. Splitting a cold section of the live</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">/// to be added to prologue|epilogue. Splitting a cold section of the live</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">/// range can have lower cost than using the CSR for the first time;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">/// range can have lower cost than using the CSR for the first time;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">/// Spilling a live range in the cold path can have lower cost than using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">/// Spilling a live range in the cold path can have lower cost than using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">/// the CSR for the first time. Returns the physical register if we decide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">/// the CSR for the first time. Returns the physical register if we decide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">/// to use the CSR; otherwise return 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">/// to use the CSR; otherwise return 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">MCRegister RAGreedy::tryAssignCSRFirstTime(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">MCRegister RAGreedy::tryAssignCSRFirstTime(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">    const LiveInterval &VirtReg, AllocationOrder &Order, MCRegister PhysReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">    const LiveInterval &VirtReg, AllocationOrder &Order, MCRegister PhysReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">    uint8_t &CostPerUseLimit, SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">    uint8_t &CostPerUseLimit, SmallVectorImpl<Register> &NewVRegs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">  if (ExtraInfo->getStage(VirtReg) == RS_Spill && VirtReg.isSpillable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">  if (ExtraInfo->getStage(VirtReg) == RS_Spill && VirtReg.isSpillable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">    // We choose spill over using the CSR for the first time if the spill cost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">    // We choose spill over using the CSR for the first time if the spill cost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">    // is lower than CSRCost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">    // is lower than CSRCost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">    if (calcSpillCost() >= CSRCost)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">    if (calcSpillCost() >= CSRCost)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">    // We are going to spill, set CostPerUseLimit to 1 to make sure that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">    // We are going to spill, set CostPerUseLimit to 1 to make sure that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">    // we will not use a callee-saved register in tryEvict.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">    // we will not use a callee-saved register in tryEvict.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">    CostPerUseLimit = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">    CostPerUseLimit = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">  if (ExtraInfo->getStage(VirtReg) < RS_Split) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">  if (ExtraInfo->getStage(VirtReg) < RS_Split) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">    // We choose pre-splitting over using the CSR for the first time if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">    // We choose pre-splitting over using the CSR for the first time if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">    // the cost of splitting is lower than CSRCost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">    // the cost of splitting is lower than CSRCost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">    SA->analyze(&VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">    unsigned NumCands = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">    unsigned NumCands = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">    BlockFrequency BestCost = CSRCost; // Don't modify CSRCost.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">    BlockFrequency BestCost = CSRCost; // Don't modify CSRCost.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">    unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">    unsigned BestCand = calculateRegionSplitCost(VirtReg, Order, BestCost,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">                                                 NumCands, true /*IgnoreCSR*/);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">                                                 NumCands, true /*IgnoreCSR*/);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">    if (BestCand == NoCand)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">    if (BestCand == NoCand)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">      // Use the CSR if we can't find a region split below CSRCost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">      // Use the CSR if we can't find a region split below CSRCost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">    // Perform the actual pre-splitting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">    // Perform the actual pre-splitting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">    doRegionSplit(VirtReg, BestCand, false/*HasCompact*/, NewVRegs);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">    doRegionSplit(VirtReg, BestCand, false/*HasCompact*/, NewVRegs);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">void RAGreedy::aboutToRemoveInterval(const LiveInterval &LI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">void RAGreedy::aboutToRemoveInterval(const LiveInterval &LI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  // Do not keep invalid information around.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  // Do not keep invalid information around.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">  SetOfBrokenHints.remove(&LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">  SetOfBrokenHints.remove(&LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine coveredLine">void RAGreedy::initializeCSRCost() {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine coveredLine">void RAGreedy::initializeCSRCost() {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">  // We use the larger one out of the command-line option and the value report</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">  // We use the larger one out of the command-line option and the value report</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">  // by TRI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  // by TRI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine coveredLine">  CSRCost = BlockFrequency(</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine coveredLine">  CSRCost = BlockFrequency(</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine coveredLine">      std::max((unsigned)CSRFirstTimeCost, TRI->getCSRFirstUseCost()));</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine coveredLine">      std::max((unsigned)CSRFirstTimeCost, TRI->getCSRFirstUseCost()));</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine coveredLine">  if (!CSRCost.getFrequency())</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine coveredLine">  if (!CSRCost.getFrequency())</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">  // Raw cost is relative to Entry == 2^14; scale it appropriately.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">  // Raw cost is relative to Entry == 2^14; scale it appropriately.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">  uint64_t ActualEntry = MBFI->getEntryFreq();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">  uint64_t ActualEntry = MBFI->getEntryFreq();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">  if (!ActualEntry) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">  if (!ActualEntry) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">    CSRCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">    CSRCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  uint64_t FixedEntry = 1 << 14;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  uint64_t FixedEntry = 1 << 14;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">  if (ActualEntry < FixedEntry)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">  if (ActualEntry < FixedEntry)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">    CSRCost *= BranchProbability(ActualEntry, FixedEntry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">    CSRCost *= BranchProbability(ActualEntry, FixedEntry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">  else if (ActualEntry <= UINT32_MAX)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">  else if (ActualEntry <= UINT32_MAX)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">    // Invert the fraction and divide.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">    // Invert the fraction and divide.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">    CSRCost /= BranchProbability(FixedEntry, ActualEntry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">    CSRCost /= BranchProbability(FixedEntry, ActualEntry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">    // Can't use BranchProbability in general, since it takes 32-bit numbers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">    // Can't use BranchProbability in general, since it takes 32-bit numbers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">    CSRCost = CSRCost.getFrequency() * (ActualEntry / FixedEntry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">    CSRCost = CSRCost.getFrequency() * (ActualEntry / FixedEntry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">/// Collect the hint info for \p Reg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">/// Collect the hint info for \p Reg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">/// The results are stored into \p Out.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">/// The results are stored into \p Out.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">/// \p Out is not cleared before being populated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">/// \p Out is not cleared before being populated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">void RAGreedy::collectHintInfo(Register Reg, HintsInfo &Out) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">void RAGreedy::collectHintInfo(Register Reg, HintsInfo &Out) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">  for (const MachineInstr &Instr : MRI->reg_nodbg_instructions(Reg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">  for (const MachineInstr &Instr : MRI->reg_nodbg_instructions(Reg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">    if (!Instr.isFullCopy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">    if (!Instr.isFullCopy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">    // Look for the other end of the copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">    // Look for the other end of the copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">    Register OtherReg = Instr.getOperand(0).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">    Register OtherReg = Instr.getOperand(0).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">    if (OtherReg == Reg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">    if (OtherReg == Reg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">      OtherReg = Instr.getOperand(1).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">      OtherReg = Instr.getOperand(1).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">      if (OtherReg == Reg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">      if (OtherReg == Reg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">    // Get the current assignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">    // Get the current assignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">    MCRegister OtherPhysReg =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">    MCRegister OtherPhysReg =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">        OtherReg.isPhysical() ? OtherReg.asMCReg() : VRM->getPhys(OtherReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">        OtherReg.isPhysical() ? OtherReg.asMCReg() : VRM->getPhys(OtherReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">    // Push the collected information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">    // Push the collected information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">    Out.push_back(HintInfo(MBFI->getBlockFreq(Instr.getParent()), OtherReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">    Out.push_back(HintInfo(MBFI->getBlockFreq(Instr.getParent()), OtherReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">                           OtherPhysReg));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">                           OtherPhysReg));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">/// Using the given \p List, compute the cost of the broken hints if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">/// Using the given \p List, compute the cost of the broken hints if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">/// \p PhysReg was used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">/// \p PhysReg was used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">/// \return The cost of \p List for \p PhysReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">/// \return The cost of \p List for \p PhysReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">BlockFrequency RAGreedy::getBrokenHintFreq(const HintsInfo &List,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">BlockFrequency RAGreedy::getBrokenHintFreq(const HintsInfo &List,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">                                           MCRegister PhysReg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">                                           MCRegister PhysReg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">  BlockFrequency Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">  BlockFrequency Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  for (const HintInfo &Info : List) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  for (const HintInfo &Info : List) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">    if (Info.PhysReg != PhysReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">    if (Info.PhysReg != PhysReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">      Cost += Info.Freq;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">      Cost += Info.Freq;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">/// Using the register assigned to \p VirtReg, try to recolor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">/// Using the register assigned to \p VirtReg, try to recolor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">/// all the live ranges that are copy-related with \p VirtReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">/// all the live ranges that are copy-related with \p VirtReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">/// The recoloring is then propagated to all the live-ranges that have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">/// The recoloring is then propagated to all the live-ranges that have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">/// been recolored and so on, until no more copies can be coalesced or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">/// been recolored and so on, until no more copies can be coalesced or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">/// it is not profitable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">/// it is not profitable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">/// For a given live range, profitability is determined by the sum of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">/// For a given live range, profitability is determined by the sum of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">/// frequencies of the non-identity copies it would introduce with the old</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">/// frequencies of the non-identity copies it would introduce with the old</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">/// and new register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">/// and new register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">void RAGreedy::tryHintRecoloring(const LiveInterval &VirtReg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">void RAGreedy::tryHintRecoloring(const LiveInterval &VirtReg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">  // We have a broken hint, check if it is possible to fix it by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">  // We have a broken hint, check if it is possible to fix it by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">  // reusing PhysReg for the copy-related live-ranges. Indeed, we evicted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">  // reusing PhysReg for the copy-related live-ranges. Indeed, we evicted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">  // some register and PhysReg may be available for the other live-ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">  // some register and PhysReg may be available for the other live-ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">  SmallSet<Register, 4> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">  SmallSet<Register, 4> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">  SmallVector<unsigned, 2> RecoloringCandidates;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">  SmallVector<unsigned, 2> RecoloringCandidates;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">  HintsInfo Info;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">  HintsInfo Info;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">  Register Reg = VirtReg.reg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">  Register Reg = VirtReg.reg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">  MCRegister PhysReg = VRM->getPhys(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">  MCRegister PhysReg = VRM->getPhys(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">  // Start the recoloring algorithm from the input live-interval, then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">  // Start the recoloring algorithm from the input live-interval, then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">  // it will propagate to the ones that are copy-related with it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">  // it will propagate to the ones that are copy-related with it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">  Visited.insert(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">  Visited.insert(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">  RecoloringCandidates.push_back(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">  RecoloringCandidates.push_back(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Trying to reconcile hints for: " << printReg(Reg, TRI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Trying to reconcile hints for: " << printReg(Reg, TRI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">                    << '(' << printReg(PhysReg, TRI) << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">                    << '(' << printReg(PhysReg, TRI) << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">    Reg = RecoloringCandidates.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">    Reg = RecoloringCandidates.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">    // We cannot recolor physical register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">    // We cannot recolor physical register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">    if (Reg.isPhysical())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">    if (Reg.isPhysical())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">    // This may be a skipped class</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">    // This may be a skipped class</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">    if (!VRM->hasPhys(Reg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">    if (!VRM->hasPhys(Reg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">      assert(!ShouldAllocateClass(*TRI, *MRI->getRegClass(Reg)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">      assert(!ShouldAllocateClass(*TRI, *MRI->getRegClass(Reg)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">             "We have an unallocated variable which should have been handled");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">             "We have an unallocated variable which should have been handled");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">    // Get the live interval mapped with this virtual register to be able</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">    // Get the live interval mapped with this virtual register to be able</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">    // to check for the interference with the new color.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">    // to check for the interference with the new color.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">    LiveInterval &LI = LIS->getInterval(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">    LiveInterval &LI = LIS->getInterval(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">    MCRegister CurrPhys = VRM->getPhys(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">    MCRegister CurrPhys = VRM->getPhys(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">    // Check that the new color matches the register class constraints and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">    // Check that the new color matches the register class constraints and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">    // that it is free for this live range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">    // that it is free for this live range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">    if (CurrPhys != PhysReg && (!MRI->getRegClass(Reg)->contains(PhysReg) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">    if (CurrPhys != PhysReg && (!MRI->getRegClass(Reg)->contains(PhysReg) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">                                Matrix->checkInterference(LI, PhysReg)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">                                Matrix->checkInterference(LI, PhysReg)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << printReg(Reg, TRI) << '(' << printReg(CurrPhys, TRI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << printReg(Reg, TRI) << '(' << printReg(CurrPhys, TRI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">                      << ") is recolorable.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">                      << ") is recolorable.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">    // Gather the hint info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">    // Gather the hint info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">    Info.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">    Info.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">    collectHintInfo(Reg, Info);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">    collectHintInfo(Reg, Info);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">    // Check if recoloring the live-range will increase the cost of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">    // Check if recoloring the live-range will increase the cost of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">    // non-identity copies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">    // non-identity copies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">    if (CurrPhys != PhysReg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">    if (CurrPhys != PhysReg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Checking profitability:\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Checking profitability:\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">      BlockFrequency OldCopiesCost = getBrokenHintFreq(Info, CurrPhys);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">      BlockFrequency OldCopiesCost = getBrokenHintFreq(Info, CurrPhys);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">      BlockFrequency NewCopiesCost = getBrokenHintFreq(Info, PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">      BlockFrequency NewCopiesCost = getBrokenHintFreq(Info, PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Old Cost: " << OldCopiesCost.getFrequency()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "Old Cost: " << OldCopiesCost.getFrequency()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">                        << "\nNew Cost: " << NewCopiesCost.getFrequency()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">                        << "\nNew Cost: " << NewCopiesCost.getFrequency()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">                        << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">                        << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">      if (OldCopiesCost < NewCopiesCost) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">      if (OldCopiesCost < NewCopiesCost) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "=> Not profitable.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "=> Not profitable.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">      // At this point, the cost is either cheaper or equal. If it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">      // At this point, the cost is either cheaper or equal. If it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">      // equal, we consider this is profitable because it may expose</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">      // equal, we consider this is profitable because it may expose</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">      // more recoloring opportunities.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">      // more recoloring opportunities.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "=> Profitable.\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "=> Profitable.\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">      // Recolor the live-range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">      // Recolor the live-range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">      Matrix->unassign(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">      Matrix->unassign(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">      Matrix->assign(LI, PhysReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">      Matrix->assign(LI, PhysReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">    // Push all copy-related live-ranges to keep reconciling the broken</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">    // Push all copy-related live-ranges to keep reconciling the broken</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">    // hints.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">    // hints.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">    for (const HintInfo &HI : Info) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">    for (const HintInfo &HI : Info) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">      if (Visited.insert(HI.Reg).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">      if (Visited.insert(HI.Reg).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">        RecoloringCandidates.push_back(HI.Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">        RecoloringCandidates.push_back(HI.Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  } while (!RecoloringCandidates.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  } while (!RecoloringCandidates.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">/// Try to recolor broken hints.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">/// Try to recolor broken hints.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">/// Broken hints may be repaired by recoloring when an evicted variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">/// Broken hints may be repaired by recoloring when an evicted variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">/// freed up a register for a larger live-range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">/// freed up a register for a larger live-range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">/// Consider the following example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">/// Consider the following example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">/// BB1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">/// BB1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">///   a =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">///   a =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">///   b =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">///   b =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">/// BB2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">/// BB2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">///   = b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">///   = b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">///   = a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">///   = a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">/// Let us assume b gets split:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">/// Let us assume b gets split:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">/// BB1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">/// BB1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">///   a =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">///   a =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">///   b =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">///   b =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">/// BB2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">/// BB2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">///   c = b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">///   c = b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">///   d = c</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">///   d = c</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">///   = d</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">///   = d</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">///   = a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">///   = a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">/// Because of how the allocation work, b, c, and d may be assigned different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">/// Because of how the allocation work, b, c, and d may be assigned different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">/// colors. Now, if a gets evicted later:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">/// colors. Now, if a gets evicted later:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">/// BB1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">/// BB1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">///   a =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">///   a =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">///   st a, SpillSlot</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">///   st a, SpillSlot</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">///   b =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">///   b =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">/// BB2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">/// BB2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">///   c = b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">///   c = b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">///   d = c</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">///   d = c</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">///   = d</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">///   = d</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">///   e = ld SpillSlot</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">///   e = ld SpillSlot</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">///   = e</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">///   = e</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">/// This is likely that we can assign the same register for b, c, and d,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">/// This is likely that we can assign the same register for b, c, and d,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">/// getting rid of 2 copies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">/// getting rid of 2 copies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine coveredLine">void RAGreedy::tryHintsRecoloring() {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine coveredLine">void RAGreedy::tryHintsRecoloring() {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine coveredLine">  for (const LiveInterval *LI : SetOfBrokenHints) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine coveredLine">  for (const LiveInterval *LI : SetOfBrokenHints) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">    assert(LI->reg().isVirtual() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">    assert(LI->reg().isVirtual() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">           "Recoloring is possible only for virtual registers");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">           "Recoloring is possible only for virtual registers");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">    // Some dead defs may be around (e.g., because of debug uses).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">    // Some dead defs may be around (e.g., because of debug uses).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">    // Ignore those.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">    // Ignore those.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">    if (!VRM->hasPhys(LI->reg()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">    if (!VRM->hasPhys(LI->reg()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">    tryHintRecoloring(*LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">    tryHintRecoloring(*LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine coveredLine">MCRegister RAGreedy::selectOrSplitImpl(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine coveredLine">MCRegister RAGreedy::selectOrSplitImpl(const LiveInterval &VirtReg,</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">                                       SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">                                       SmallVectorImpl<Register> &NewVRegs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">                                       SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">                                       SmallVirtRegSet &FixedRegisters,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">                                       RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">                                       RecoloringStack &RecolorStack,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">                                       unsigned Depth) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">                                       unsigned Depth) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine coveredLine">  uint8_t CostPerUseLimit = uint8_t(~0u);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine coveredLine">  uint8_t CostPerUseLimit = uint8_t(~0u);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">  // First try assigning a free register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">  // First try assigning a free register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">  auto Order =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">  auto Order =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine coveredLine">      AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix);</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine coveredLine">      AllocationOrder::create(VirtReg.reg(), *VRM, RegClassInfo, Matrix);</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine coveredLine">  if (MCRegister PhysReg =</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine coveredLine">  if (MCRegister PhysReg =</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine coveredLine">          tryAssign(VirtReg, Order, NewVRegs, FixedRegisters)) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine coveredLine">          tryAssign(VirtReg, Order, NewVRegs, FixedRegisters)) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">    // When NewVRegs is not empty, we may have made decisions such as evicting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">    // When NewVRegs is not empty, we may have made decisions such as evicting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">    // a virtual register, go with the earlier decisions and use the physical</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">    // a virtual register, go with the earlier decisions and use the physical</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">    // register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">    // register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine coveredLine">    if (CSRCost.getFrequency() &&</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine coveredLine">    if (CSRCost.getFrequency() &&</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine coveredLine">        EvictAdvisor->isUnusedCalleeSavedReg(PhysReg) && NewVRegs.empty()) {</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine coveredLine">        EvictAdvisor->isUnusedCalleeSavedReg(PhysReg) && NewVRegs.empty()) {</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">      MCRegister CSRReg = tryAssignCSRFirstTime(VirtReg, Order, PhysReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">      MCRegister CSRReg = tryAssignCSRFirstTime(VirtReg, Order, PhysReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">                                                CostPerUseLimit, NewVRegs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">                                                CostPerUseLimit, NewVRegs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">      if (CSRReg || !NewVRegs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">      if (CSRReg || !NewVRegs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">        // Return now if we decide to use a CSR or create new vregs due to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">        // Return now if we decide to use a CSR or create new vregs due to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">        // pre-splitting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">        // pre-splitting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">        return CSRReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">        return CSRReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine coveredLine">      return PhysReg;</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine coveredLine">      return PhysReg;</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">  LiveRangeStage Stage = ExtraInfo->getStage(VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">  LiveRangeStage Stage = ExtraInfo->getStage(VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << StageName[Stage] << " Cascade "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << StageName[Stage] << " Cascade "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">                    << ExtraInfo->getCascade(VirtReg.reg()) << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">                    << ExtraInfo->getCascade(VirtReg.reg()) << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">  // Try to evict a less worthy live range, but only for ranges from the primary</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">  // Try to evict a less worthy live range, but only for ranges from the primary</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">  // queue. The RS_Split ranges already failed to do this, and they should not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">  // queue. The RS_Split ranges already failed to do this, and they should not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">  // get a second chance until they have been split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">  // get a second chance until they have been split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  if (Stage != RS_Split)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  if (Stage != RS_Split)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">    if (Register PhysReg =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">    if (Register PhysReg =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">            tryEvict(VirtReg, Order, NewVRegs, CostPerUseLimit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">            tryEvict(VirtReg, Order, NewVRegs, CostPerUseLimit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">                     FixedRegisters)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">                     FixedRegisters)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">      Register Hint = MRI->getSimpleHint(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">      Register Hint = MRI->getSimpleHint(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">      // If VirtReg has a hint and that hint is broken record this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">      // If VirtReg has a hint and that hint is broken record this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">      // virtual register as a recoloring candidate for broken hint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">      // virtual register as a recoloring candidate for broken hint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">      // Indeed, since we evicted a variable in its neighborhood it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">      // Indeed, since we evicted a variable in its neighborhood it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">      // likely we can at least partially recolor some of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">      // likely we can at least partially recolor some of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">      // copy-related live-ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">      // copy-related live-ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">      if (Hint && Hint != PhysReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">      if (Hint && Hint != PhysReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">        SetOfBrokenHints.insert(&VirtReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">        SetOfBrokenHints.insert(&VirtReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">  assert((NewVRegs.empty() || Depth) && "Cannot append to existing NewVRegs");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">  assert((NewVRegs.empty() || Depth) && "Cannot append to existing NewVRegs");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">  // The first time we see a live range, don't try to split or spill.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">  // The first time we see a live range, don't try to split or spill.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">  // Wait until the second time, when all smaller ranges have been allocated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">  // Wait until the second time, when all smaller ranges have been allocated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">  // This gives a better picture of the interference to split around.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">  // This gives a better picture of the interference to split around.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">  if (Stage < RS_Split) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">  if (Stage < RS_Split) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">    ExtraInfo->setStage(VirtReg, RS_Split);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">    ExtraInfo->setStage(VirtReg, RS_Split);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "wait for second round\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "wait for second round\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">    NewVRegs.push_back(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">    NewVRegs.push_back(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">  if (Stage < RS_Spill) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">  if (Stage < RS_Spill) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">    // Try splitting VirtReg or interferences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">    // Try splitting VirtReg or interferences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">    unsigned NewVRegSizeBefore = NewVRegs.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">    unsigned NewVRegSizeBefore = NewVRegs.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">    Register PhysReg = trySplit(VirtReg, Order, NewVRegs, FixedRegisters);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">    Register PhysReg = trySplit(VirtReg, Order, NewVRegs, FixedRegisters);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">    if (PhysReg || (NewVRegs.size() - NewVRegSizeBefore))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">    if (PhysReg || (NewVRegs.size() - NewVRegSizeBefore))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">      return PhysReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">  // If we couldn't allocate a register from spilling, there is probably some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">  // If we couldn't allocate a register from spilling, there is probably some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  // invalid inline assembly. The base class will report it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  // invalid inline assembly. The base class will report it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">  if (Stage >= RS_Done || !VirtReg.isSpillable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">  if (Stage >= RS_Done || !VirtReg.isSpillable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">    return tryLastChanceRecoloring(VirtReg, Order, NewVRegs, FixedRegisters,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">    return tryLastChanceRecoloring(VirtReg, Order, NewVRegs, FixedRegisters,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">                                   RecolorStack, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">                                   RecolorStack, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">  // Finally spill VirtReg itself.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">  // Finally spill VirtReg itself.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">  if ((EnableDeferredSpilling ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">  if ((EnableDeferredSpilling ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">       TRI->shouldUseDeferredSpillingForVirtReg(*MF, VirtReg)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">       TRI->shouldUseDeferredSpillingForVirtReg(*MF, VirtReg)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">      ExtraInfo->getStage(VirtReg) < RS_Memory) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">      ExtraInfo->getStage(VirtReg) < RS_Memory) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">    // TODO: This is experimental and in particular, we do not model</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">    // TODO: This is experimental and in particular, we do not model</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">    // the live range splitting done by spilling correctly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">    // the live range splitting done by spilling correctly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">    // We would need a deep integration with the spiller to do the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">    // We would need a deep integration with the spiller to do the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">    // right thing here. Anyway, that is still good for early testing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">    // right thing here. Anyway, that is still good for early testing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">    ExtraInfo->setStage(VirtReg, RS_Memory);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">    ExtraInfo->setStage(VirtReg, RS_Memory);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Do as if this register is in memory\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Do as if this register is in memory\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">    NewVRegs.push_back(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">    NewVRegs.push_back(VirtReg.reg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">    NamedRegionTimer T("spill", "Spiller", TimerGroupName,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">    NamedRegionTimer T("spill", "Spiller", TimerGroupName,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">                       TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">                       TimerGroupDescription, TimePassesIsEnabled);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">    LiveRangeEdit LRE(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">    LiveRangeEdit LRE(&VirtReg, NewVRegs, *MF, *LIS, VRM, this, &DeadRemats);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">    spiller().spill(LRE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">    spiller().spill(LRE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">    ExtraInfo->setStage(NewVRegs.begin(), NewVRegs.end(), RS_Done);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">    ExtraInfo->setStage(NewVRegs.begin(), NewVRegs.end(), RS_Done);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">    // Tell LiveDebugVariables about the new ranges. Ranges not being covered by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">    // Tell LiveDebugVariables about the new ranges. Ranges not being covered by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">    // the new regs are kept in LDV (still mapping to the old register), until</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">    // the new regs are kept in LDV (still mapping to the old register), until</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">    // we rewrite spilled locations in LDV at a later stage.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">    // we rewrite spilled locations in LDV at a later stage.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">    DebugVars->splitRegister(VirtReg.reg(), LRE.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">    DebugVars->splitRegister(VirtReg.reg(), LRE.regs(), *LIS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">    if (VerifyEnabled)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">    if (VerifyEnabled)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">      MF->verify(this, "After spilling");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">      MF->verify(this, "After spilling");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  // The live virtual register requesting allocation was spilled, so tell</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  // The live virtual register requesting allocation was spilled, so tell</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">  // the caller not to allocate anything during this round.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">  // the caller not to allocate anything during this round.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">  return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">8</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">void RAGreedy::RAGreedyStats::report(MachineOptimizationRemarkMissed &R) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">void RAGreedy::RAGreedyStats::report(MachineOptimizationRemarkMissed &R) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">  using namespace ore;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">  using namespace ore;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">  if (Spills) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">  if (Spills) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">    R << NV("NumSpills", Spills) << " spills ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">    R << NV("NumSpills", Spills) << " spills ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">    R << NV("TotalSpillsCost", SpillsCost) << " total spills cost ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">    R << NV("TotalSpillsCost", SpillsCost) << " total spills cost ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">  if (FoldedSpills) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">  if (FoldedSpills) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">    R << NV("NumFoldedSpills", FoldedSpills) << " folded spills ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">    R << NV("NumFoldedSpills", FoldedSpills) << " folded spills ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">    R << NV("TotalFoldedSpillsCost", FoldedSpillsCost)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">    R << NV("TotalFoldedSpillsCost", FoldedSpillsCost)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">      << " total folded spills cost ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">      << " total folded spills cost ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">  if (Reloads) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">  if (Reloads) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">    R << NV("NumReloads", Reloads) << " reloads ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">    R << NV("NumReloads", Reloads) << " reloads ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">    R << NV("TotalReloadsCost", ReloadsCost) << " total reloads cost ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">    R << NV("TotalReloadsCost", ReloadsCost) << " total reloads cost ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">  if (FoldedReloads) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">  if (FoldedReloads) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">    R << NV("NumFoldedReloads", FoldedReloads) << " folded reloads ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">    R << NV("NumFoldedReloads", FoldedReloads) << " folded reloads ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">    R << NV("TotalFoldedReloadsCost", FoldedReloadsCost)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">    R << NV("TotalFoldedReloadsCost", FoldedReloadsCost)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">      << " total folded reloads cost ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">      << " total folded reloads cost ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">  if (ZeroCostFoldedReloads)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">  if (ZeroCostFoldedReloads)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">    R << NV("NumZeroCostFoldedReloads", ZeroCostFoldedReloads)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">    R << NV("NumZeroCostFoldedReloads", ZeroCostFoldedReloads)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">      << " zero cost folded reloads ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">      << " zero cost folded reloads ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">  if (Copies) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">  if (Copies) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">    R << NV("NumVRCopies", Copies) << " virtual registers copies ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">    R << NV("NumVRCopies", Copies) << " virtual registers copies ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">    R << NV("TotalCopiesCost", CopiesCost) << " total copies cost ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">    R << NV("TotalCopiesCost", CopiesCost) << " total copies cost ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">RAGreedy::RAGreedyStats RAGreedy::computeStats(MachineBasicBlock &MBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">RAGreedy::RAGreedyStats RAGreedy::computeStats(MachineBasicBlock &MBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">  RAGreedyStats Stats;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">  RAGreedyStats Stats;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">  const MachineFrameInfo &MFI = MF->getFrameInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">  const MachineFrameInfo &MFI = MF->getFrameInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">  int FI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">  int FI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">  auto isSpillSlotAccess = [&MFI](const MachineMemOperand *A) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">  auto isSpillSlotAccess = [&MFI](const MachineMemOperand *A) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">    return MFI.isSpillSlotObjectIndex(cast<FixedStackPseudoSourceValue>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">    return MFI.isSpillSlotObjectIndex(cast<FixedStackPseudoSourceValue>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">        A->getPseudoValue())->getFrameIndex());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">        A->getPseudoValue())->getFrameIndex());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">  auto isPatchpointInstr = [](const MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">  auto isPatchpointInstr = [](const MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">    return MI.getOpcode() == TargetOpcode::PATCHPOINT ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">    return MI.getOpcode() == TargetOpcode::PATCHPOINT ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">           MI.getOpcode() == TargetOpcode::STACKMAP ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">           MI.getOpcode() == TargetOpcode::STACKMAP ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">           MI.getOpcode() == TargetOpcode::STATEPOINT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">           MI.getOpcode() == TargetOpcode::STATEPOINT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">  for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">  for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">    if (MI.isCopy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">    if (MI.isCopy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">      const MachineOperand &Dest = MI.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">      const MachineOperand &Dest = MI.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">      const MachineOperand &Src = MI.getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">      const MachineOperand &Src = MI.getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">      Register SrcReg = Src.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">      Register SrcReg = Src.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">      Register DestReg = Dest.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">      Register DestReg = Dest.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">      // Only count `COPY`s with a virtual register as source or destination.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">      // Only count `COPY`s with a virtual register as source or destination.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">      if (SrcReg.isVirtual() || DestReg.isVirtual()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">      if (SrcReg.isVirtual() || DestReg.isVirtual()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">        if (SrcReg.isVirtual()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">        if (SrcReg.isVirtual()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">          SrcReg = VRM->getPhys(SrcReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">          SrcReg = VRM->getPhys(SrcReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">          if (SrcReg && Src.getSubReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">          if (SrcReg && Src.getSubReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">            SrcReg = TRI->getSubReg(SrcReg, Src.getSubReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">            SrcReg = TRI->getSubReg(SrcReg, Src.getSubReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">        if (DestReg.isVirtual()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">        if (DestReg.isVirtual()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">          DestReg = VRM->getPhys(DestReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">          DestReg = VRM->getPhys(DestReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">          if (DestReg && Dest.getSubReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">          if (DestReg && Dest.getSubReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">            DestReg = TRI->getSubReg(DestReg, Dest.getSubReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">            DestReg = TRI->getSubReg(DestReg, Dest.getSubReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">        if (SrcReg != DestReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">        if (SrcReg != DestReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">          ++Stats.Copies;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">          ++Stats.Copies;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">    SmallVector<const MachineMemOperand *, 2> Accesses;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">    SmallVector<const MachineMemOperand *, 2> Accesses;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">    if (TII->isLoadFromStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">    if (TII->isLoadFromStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">      ++Stats.Reloads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">      ++Stats.Reloads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">    if (TII->isStoreToStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">    if (TII->isStoreToStackSlot(MI, FI) && MFI.isSpillSlotObjectIndex(FI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">      ++Stats.Spills;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">      ++Stats.Spills;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">    if (TII->hasLoadFromStackSlot(MI, Accesses) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">    if (TII->hasLoadFromStackSlot(MI, Accesses) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">      if (!isPatchpointInstr(MI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">      if (!isPatchpointInstr(MI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">        Stats.FoldedReloads += Accesses.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">        Stats.FoldedReloads += Accesses.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">      // For statepoint there may be folded and zero cost folded stack reloads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">      // For statepoint there may be folded and zero cost folded stack reloads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">      std::pair<unsigned, unsigned> NonZeroCostRange =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">      std::pair<unsigned, unsigned> NonZeroCostRange =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">          TII->getPatchpointUnfoldableRange(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">          TII->getPatchpointUnfoldableRange(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">      SmallSet<unsigned, 16> FoldedReloads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">      SmallSet<unsigned, 16> FoldedReloads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">      SmallSet<unsigned, 16> ZeroCostFoldedReloads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">      SmallSet<unsigned, 16> ZeroCostFoldedReloads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">      for (unsigned Idx = 0, E = MI.getNumOperands(); Idx < E; ++Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">      for (unsigned Idx = 0, E = MI.getNumOperands(); Idx < E; ++Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">        MachineOperand &MO = MI.getOperand(Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">        MachineOperand &MO = MI.getOperand(Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">        if (!MO.isFI() || !MFI.isSpillSlotObjectIndex(MO.getIndex()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">        if (!MO.isFI() || !MFI.isSpillSlotObjectIndex(MO.getIndex()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">        if (Idx >= NonZeroCostRange.first && Idx < NonZeroCostRange.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">        if (Idx >= NonZeroCostRange.first && Idx < NonZeroCostRange.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">          FoldedReloads.insert(MO.getIndex());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">          FoldedReloads.insert(MO.getIndex());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">          ZeroCostFoldedReloads.insert(MO.getIndex());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">          ZeroCostFoldedReloads.insert(MO.getIndex());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">      // If stack slot is used in folded reload it is not zero cost then.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">      // If stack slot is used in folded reload it is not zero cost then.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">      for (unsigned Slot : FoldedReloads)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">      for (unsigned Slot : FoldedReloads)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">        ZeroCostFoldedReloads.erase(Slot);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">        ZeroCostFoldedReloads.erase(Slot);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">      Stats.FoldedReloads += FoldedReloads.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">      Stats.FoldedReloads += FoldedReloads.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine">      Stats.ZeroCostFoldedReloads += ZeroCostFoldedReloads.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine">      Stats.ZeroCostFoldedReloads += ZeroCostFoldedReloads.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">    Accesses.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">    Accesses.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">    if (TII->hasStoreToStackSlot(MI, Accesses) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">    if (TII->hasStoreToStackSlot(MI, Accesses) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">        llvm::any_of(Accesses, isSpillSlotAccess)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">      Stats.FoldedSpills += Accesses.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">      Stats.FoldedSpills += Accesses.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">  // Set cost of collected statistic by multiplication to relative frequency of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">  // Set cost of collected statistic by multiplication to relative frequency of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">  // this basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">  // this basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">  float RelFreq = MBFI->getBlockFreqRelativeToEntryBlock(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">  float RelFreq = MBFI->getBlockFreqRelativeToEntryBlock(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">  Stats.ReloadsCost = RelFreq * Stats.Reloads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">  Stats.ReloadsCost = RelFreq * Stats.Reloads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">  Stats.FoldedReloadsCost = RelFreq * Stats.FoldedReloads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">  Stats.FoldedReloadsCost = RelFreq * Stats.FoldedReloads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">  Stats.SpillsCost = RelFreq * Stats.Spills;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">  Stats.SpillsCost = RelFreq * Stats.Spills;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">  Stats.FoldedSpillsCost = RelFreq * Stats.FoldedSpills;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">  Stats.FoldedSpillsCost = RelFreq * Stats.FoldedSpills;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">  Stats.CopiesCost = RelFreq * Stats.Copies;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">  Stats.CopiesCost = RelFreq * Stats.Copies;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">  return Stats;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">  return Stats;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">RAGreedy::RAGreedyStats RAGreedy::reportStats(MachineLoop *L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">RAGreedy::RAGreedyStats RAGreedy::reportStats(MachineLoop *L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">  RAGreedyStats Stats;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">  RAGreedyStats Stats;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">  // Sum up the spill and reloads in subloops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">  // Sum up the spill and reloads in subloops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">  for (MachineLoop *SubLoop : *L)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">  for (MachineLoop *SubLoop : *L)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">    Stats.add(reportStats(SubLoop));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">    Stats.add(reportStats(SubLoop));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">  for (MachineBasicBlock *MBB : L->getBlocks())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">  for (MachineBasicBlock *MBB : L->getBlocks())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">    // Handle blocks that were not included in subloops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">    // Handle blocks that were not included in subloops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">    if (Loops->getLoopFor(MBB) == L)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">    if (Loops->getLoopFor(MBB) == L)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">      Stats.add(computeStats(*MBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">      Stats.add(computeStats(*MBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">  if (!Stats.isEmpty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">  if (!Stats.isEmpty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">    using namespace ore;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">    using namespace ore;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "LoopSpillReloadCopies",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "LoopSpillReloadCopies",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine">                                        L->getStartLoc(), L->getHeader());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine">                                        L->getStartLoc(), L->getHeader());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">      Stats.report(R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">      Stats.report(R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">      R << "generated in loop";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">      R << "generated in loop";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">      return R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">      return R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine">  return Stats;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine">  return Stats;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine coveredLine">void RAGreedy::reportStats() {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine coveredLine">void RAGreedy::reportStats() {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine coveredLine">  if (!ORE->allowExtraAnalysis(DEBUG_TYPE))</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine coveredLine">  if (!ORE->allowExtraAnalysis(DEBUG_TYPE))</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine coveredLine">    return;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">  RAGreedyStats Stats;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">  RAGreedyStats Stats;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">  for (MachineLoop *L : *Loops)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">  for (MachineLoop *L : *Loops)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">    Stats.add(reportStats(L));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">    Stats.add(reportStats(L));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">  // Process non-loop blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">  // Process non-loop blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : *MF)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : *MF)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine">    if (!Loops->getLoopFor(&MBB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine">    if (!Loops->getLoopFor(&MBB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">      Stats.add(computeStats(MBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">      Stats.add(computeStats(MBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">  if (!Stats.isEmpty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">  if (!Stats.isEmpty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">    using namespace ore;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">    using namespace ore;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine">    ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">      DebugLoc Loc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">      DebugLoc Loc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">      if (auto *SP = MF->getFunction().getSubprogram())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">      if (auto *SP = MF->getFunction().getSubprogram())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">        Loc = DILocation::get(SP->getContext(), SP->getLine(), 1, SP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">        Loc = DILocation::get(SP->getContext(), SP->getLine(), 1, SP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "SpillReloadCopies", Loc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">      MachineOptimizationRemarkMissed R(DEBUG_TYPE, "SpillReloadCopies", Loc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">                                        &MF->front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">                                        &MF->front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">      Stats.report(R);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">      Stats.report(R);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">      R << "generated in function";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">      R << "generated in function";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">      return R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">      return R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">    });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine coveredLine">bool RAGreedy::hasVirtRegAlloc() {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine coveredLine">bool RAGreedy::hasVirtRegAlloc() {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine coveredLine">  for (unsigned I = 0, E = MRI->getNumVirtRegs(); I != E; ++I) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine coveredLine">  for (unsigned I = 0, E = MRI->getNumVirtRegs(); I != E; ++I) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine coveredLine">    Register Reg = Register::index2VirtReg(I);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine coveredLine">    Register Reg = Register::index2VirtReg(I);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine coveredLine">    if (MRI->reg_nodbg_empty(Reg))</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine coveredLine">    if (MRI->reg_nodbg_empty(Reg))</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine coveredLine">    const TargetRegisterClass *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine coveredLine">    const TargetRegisterClass *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine coveredLine">    if (!RC)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine coveredLine">    if (!RC)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine coveredLine">    if (ShouldAllocateClass(*TRI, *RC))</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine coveredLine">    if (ShouldAllocateClass(*TRI, *RC))</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine coveredLine">      return true;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine coveredLine">      return true;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine coveredLine">bool RAGreedy::runOnMachineFunction(MachineFunction &mf) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine coveredLine">bool RAGreedy::runOnMachineFunction(MachineFunction &mf) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(dbgs() << "********** GREEDY REGISTER ALLOCATION **********\n"</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(dbgs() << "********** GREEDY REGISTER ALLOCATION **********\n"</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">                    << "********** Function: " << mf.getName() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">                    << "********** Function: " << mf.getName() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine coveredLine">  MF = &mf;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine coveredLine">  MF = &mf;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine coveredLine">  TII = MF->getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine coveredLine">  TII = MF->getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine coveredLine">  if (VerifyEnabled)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine coveredLine">  if (VerifyEnabled)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine">    MF->verify(this, "Before greedy register allocator");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine">    MF->verify(this, "Before greedy register allocator");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine coveredLine">  RegAllocBase::init(getAnalysis<VirtRegMap>(),</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine coveredLine">  RegAllocBase::init(getAnalysis<VirtRegMap>(),</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">                     getAnalysis<LiveIntervals>(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">                     getAnalysis<LiveIntervals>(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">                     getAnalysis<LiveRegMatrix>());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">                     getAnalysis<LiveRegMatrix>());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  // Early return if there is no virtual register to be allocated to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  // Early return if there is no virtual register to be allocated to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">  // physical register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">  // physical register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine coveredLine">  if (!hasVirtRegAlloc())</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine coveredLine">  if (!hasVirtRegAlloc())</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine coveredLine">  Indexes = &getAnalysis<SlotIndexes>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine coveredLine">  Indexes = &getAnalysis<SlotIndexes>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine coveredLine">  MBFI = &getAnalysis<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine coveredLine">  MBFI = &getAnalysis<MachineBlockFrequencyInfo>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine coveredLine">  DomTree = &getAnalysis<MachineDominatorTree>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine coveredLine">  DomTree = &getAnalysis<MachineDominatorTree>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine coveredLine">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine coveredLine">  ORE = &getAnalysis<MachineOptimizationRemarkEmitterPass>().getORE();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine coveredLine">  Loops = &getAnalysis<MachineLoopInfo>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine coveredLine">  Loops = &getAnalysis<MachineLoopInfo>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine coveredLine">  Bundles = &getAnalysis<EdgeBundles>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine coveredLine">  Bundles = &getAnalysis<EdgeBundles>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine coveredLine">  SpillPlacer = &getAnalysis<SpillPlacement>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine coveredLine">  SpillPlacer = &getAnalysis<SpillPlacement>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine coveredLine">  DebugVars = &getAnalysis<LiveDebugVariables>();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine coveredLine">  DebugVars = &getAnalysis<LiveDebugVariables>();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine coveredLine">  initializeCSRCost();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine coveredLine">  initializeCSRCost();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine coveredLine">  RegCosts = TRI->getRegisterCosts(*MF);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine coveredLine">  RegCosts = TRI->getRegisterCosts(*MF);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine coveredLine">  RegClassPriorityTrumpsGlobalness =</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine coveredLine">  RegClassPriorityTrumpsGlobalness =</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine coveredLine">      GreedyRegClassPriorityTrumpsGlobalness.getNumOccurrences()</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine coveredLine">      GreedyRegClassPriorityTrumpsGlobalness.getNumOccurrences()</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine coveredLine">          ? GreedyRegClassPriorityTrumpsGlobalness</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine coveredLine">          ? GreedyRegClassPriorityTrumpsGlobalness</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine coveredLine">          : TRI->regClassPriorityTrumpsGlobalness(*MF);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine coveredLine">          : TRI->regClassPriorityTrumpsGlobalness(*MF);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine coveredLine">  ReverseLocalAssignment = GreedyReverseLocalAssignment.getNumOccurrences()</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine coveredLine">  ReverseLocalAssignment = GreedyReverseLocalAssignment.getNumOccurrences()</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine coveredLine">                               ? GreedyReverseLocalAssignment</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine coveredLine">                               ? GreedyReverseLocalAssignment</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine coveredLine">                               : TRI->reverseLocalAssignment();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine coveredLine">                               : TRI->reverseLocalAssignment();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine coveredLine">  ExtraInfo.emplace();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine coveredLine">  ExtraInfo.emplace();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine">  EvictAdvisor =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine">  EvictAdvisor =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine coveredLine">      getAnalysis<RegAllocEvictionAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine coveredLine">      getAnalysis<RegAllocEvictionAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">  PriorityAdvisor =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">  PriorityAdvisor =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine coveredLine">      getAnalysis<RegAllocPriorityAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine coveredLine">      getAnalysis<RegAllocPriorityAdvisorAnalysis>().getAdvisor(*MF, *this);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine coveredLine">  VRAI = std::make_unique<VirtRegAuxInfo>(*MF, *LIS, *VRM, *Loops, *MBFI);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine coveredLine">  VRAI = std::make_unique<VirtRegAuxInfo>(*MF, *LIS, *VRM, *Loops, *MBFI);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine coveredLine">  SpillerInstance.reset(createInlineSpiller(*this, *MF, *VRM, *VRAI));</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine coveredLine">  SpillerInstance.reset(createInlineSpiller(*this, *MF, *VRM, *VRAI));</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine coveredLine">  VRAI->calculateSpillWeightsAndHints();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine coveredLine">  VRAI->calculateSpillWeightsAndHints();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(LIS->dump());</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine coveredLine">  LLVM_DEBUG(LIS->dump());</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine coveredLine">  SA.reset(new SplitAnalysis(*VRM, *LIS, *Loops));</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine coveredLine">  SA.reset(new SplitAnalysis(*VRM, *LIS, *Loops));</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine coveredLine">  SE.reset(new SplitEditor(*SA, *LIS, *VRM, *DomTree, *MBFI, *VRAI));</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine coveredLine">  SE.reset(new SplitEditor(*SA, *LIS, *VRM, *DomTree, *MBFI, *VRAI));</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine coveredLine">  IntfCache.init(MF, Matrix->getLiveUnions(), Indexes, LIS, TRI);</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine coveredLine">  IntfCache.init(MF, Matrix->getLiveUnions(), Indexes, LIS, TRI);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine coveredLine">  GlobalCand.resize(32);  // This will grow as needed.</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine coveredLine">  GlobalCand.resize(32);  // This will grow as needed.</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine coveredLine">  SetOfBrokenHints.clear();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine coveredLine">  SetOfBrokenHints.clear();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine coveredLine">  allocatePhysRegs();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine coveredLine">  allocatePhysRegs();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine coveredLine">  tryHintsRecoloring();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine coveredLine">  tryHintsRecoloring();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine coveredLine">  if (VerifyEnabled)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine coveredLine">  if (VerifyEnabled)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine">    MF->verify(this, "Before post optimization");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine">    MF->verify(this, "Before post optimization");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine coveredLine">  postOptimization();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine coveredLine">  postOptimization();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine coveredLine">  reportStats();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine coveredLine">  reportStats();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine coveredLine">  releaseMemory();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine coveredLine">  releaseMemory();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine coveredLine">  return true;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine coveredLine">  return true;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>