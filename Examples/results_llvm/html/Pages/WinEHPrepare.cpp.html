<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WinEHPrepare.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- WinEHPrepare - Prepare exception handling for code generation ---===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This pass lowers LLVM IR exception handling into something closer to what the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// backend wants for functions using a personality function from a runtime</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// provided by MSVC. Functions with other personality functions are left alone</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// and may be prepared by other passes. In particular, all supported MSVC</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">// personality functions require cleanup code to be outlined, and the C++</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// personality requires catch handler code to be outlined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/MapVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/CodeGen/Passes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/CodeGen/WinEHFuncInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/IR/EHPersonalities.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/IR/Verifier.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/TargetParser/Triple.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/Transforms/Utils/Cloning.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/Transforms/Utils/Local.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/Transforms/Utils/SSAUpdater.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#define DEBUG_TYPE "winehprepare"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">static cl::opt<bool> DisableDemotion(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">    "disable-demotion", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">    cl::desc(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">        "Clone multicolor basic blocks but do not demote cross scopes"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">    cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">static cl::opt<bool> DisableCleanups(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">    "disable-cleanups", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">    cl::desc("Do not remove implausible terminators or other similar cleanups"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">    cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">static cl::opt<bool> DemoteCatchSwitchPHIOnlyOpt(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">    "demote-catchswitch-only", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">    cl::desc("Demote catchswitch BBs only (for wasm EH)"), cl::init(false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">class WinEHPrepare : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">  static char ID; // Pass identification, replacement for typeid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="uncoveredLine">  WinEHPrepare(bool DemoteCatchSwitchPHIOnly = false)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="uncoveredLine">      : FunctionPass(ID), DemoteCatchSwitchPHIOnly(DemoteCatchSwitchPHIOnly) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">  bool runOnFunction(Function &Fn) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">  bool doFinalization(Module &M) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="uncoveredLine">  StringRef getPassName() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="uncoveredLine">    return "Windows exception handling preparation";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">  void insertPHIStores(PHINode *OriginalPHI, AllocaInst *SpillSlot);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">  void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  insertPHIStore(BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">                 SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  AllocaInst *insertPHILoads(PHINode *PN, Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  void replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">                          DenseMap<BasicBlock *, Value *> &Loads, Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  bool prepareExplicitEH(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">  void colorFunclets(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  void demotePHIsOnFunclets(Function &F, bool DemoteCatchSwitchPHIOnly);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">  void cloneCommonBlocks(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  void removeImplausibleInstructions(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  void cleanupPreparedFunclets(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">  void verifyPreparedFunclets(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  bool DemoteCatchSwitchPHIOnly;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  // All fields are reset by runOnFunction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">  EHPersonality Personality = EHPersonality::Unknown;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  const DataLayout *DL = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  DenseMap<BasicBlock *, ColorVector> BlockColors;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  MapVector<BasicBlock *, std::vector<BasicBlock *>> FuncletBlocks;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">char WinEHPrepare::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="coveredLine">INITIALIZE_PASS(WinEHPrepare, DEBUG_TYPE, "Prepare Windows exceptions",</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">                false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="uncoveredLine">FunctionPass *llvm::createWinEHPass(bool DemoteCatchSwitchPHIOnly) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="uncoveredLine">  return new WinEHPrepare(DemoteCatchSwitchPHIOnly);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="uncoveredLine">bool WinEHPrepare::runOnFunction(Function &Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="uncoveredLine">  if (!Fn.hasPersonalityFn())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  // Classify the personality to see what kind of preparation we need.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="uncoveredLine">  Personality = classifyEHPersonality(Fn.getPersonalityFn());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  // Do nothing if this is not a scope-based personality.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="uncoveredLine">  if (!isScopedEHPersonality(Personality))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="uncoveredLine">  DL = &Fn.getParent()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="uncoveredLine">  return prepareExplicitEH(Fn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">bool WinEHPrepare::doFinalization(Module &M) { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="uncoveredLine">void WinEHPrepare::getAnalysisUsage(AnalysisUsage &AU) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">static int addUnwindMapEntry(WinEHFuncInfo &FuncInfo, int ToState,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">                             const BasicBlock *BB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="uncoveredLine">  CxxUnwindMapEntry UME;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="uncoveredLine">  UME.ToState = ToState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">  UME.Cleanup = BB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="uncoveredLine">  FuncInfo.CxxUnwindMap.push_back(UME);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="uncoveredLine">  return FuncInfo.getLastStateNumber();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="uncoveredLine">static void addTryBlockMapEntry(WinEHFuncInfo &FuncInfo, int TryLow,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">                                int TryHigh, int CatchHigh,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">                                ArrayRef<const CatchPadInst *> Handlers) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">  WinEHTryBlockMapEntry TBME;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="uncoveredLine">  TBME.TryLow = TryLow;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="uncoveredLine">  TBME.TryHigh = TryHigh;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="uncoveredLine">  TBME.CatchHigh = CatchHigh;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="uncoveredLine">  assert(TBME.TryLow <= TBME.TryHigh);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="uncoveredLine">  for (const CatchPadInst *CPI : Handlers) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">    WinEHHandlerType HT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="uncoveredLine">    Constant *TypeInfo = cast<Constant>(CPI->getArgOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="uncoveredLine">    if (TypeInfo->isNullValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="uncoveredLine">      HT.TypeDescriptor = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="uncoveredLine">      HT.TypeDescriptor = cast<GlobalVariable>(TypeInfo->stripPointerCasts());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="uncoveredLine">    HT.Adjectives = cast<ConstantInt>(CPI->getArgOperand(1))->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="uncoveredLine">    HT.Handler = CPI->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">    if (auto *AI =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">            dyn_cast<AllocaInst>(CPI->getArgOperand(2)->stripPointerCasts()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="uncoveredLine">      HT.CatchObj.Alloca = AI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="uncoveredLine">      HT.CatchObj.Alloca = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">    TBME.HandlerArray.push_back(HT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">  FuncInfo.TryBlockMap.push_back(TBME);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">static BasicBlock *getCleanupRetUnwindDest(const CleanupPadInst *CleanupPad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">  for (const User *U : CleanupPad->users())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">    if (const auto *CRI = dyn_cast<CleanupReturnInst>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">      return CRI->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">static void calculateStateNumbersForInvokes(const Function *Fn,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">                                            WinEHFuncInfo &FuncInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="uncoveredLine">  auto *F = const_cast<Function *>(Fn);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">  DenseMap<BasicBlock *, ColorVector> BlockColors = colorEHFunclets(*F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">  for (BasicBlock &BB : *F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="uncoveredLine">    auto *II = dyn_cast<InvokeInst>(BB.getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="uncoveredLine">    if (!II)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="uncoveredLine">    auto &BBColors = BlockColors[&BB];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="uncoveredLine">    assert(BBColors.size() == 1 && "multi-color BB not removed by preparation");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">    BasicBlock *FuncletEntryBB = BBColors.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">    BasicBlock *FuncletUnwindDest;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">    auto *FuncletPad =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">        dyn_cast<FuncletPadInst>(FuncletEntryBB->getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">    assert(FuncletPad || FuncletEntryBB == &Fn->getEntryBlock());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">    if (!FuncletPad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">      FuncletUnwindDest = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">    else if (auto *CatchPad = dyn_cast<CatchPadInst>(FuncletPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">      FuncletUnwindDest = CatchPad->getCatchSwitch()->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">    else if (auto *CleanupPad = dyn_cast<CleanupPadInst>(FuncletPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">      FuncletUnwindDest = getCleanupRetUnwindDest(CleanupPad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">      llvm_unreachable("unexpected funclet pad!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">    BasicBlock *InvokeUnwindDest = II->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">    int BaseState = -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">    if (FuncletUnwindDest == InvokeUnwindDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">      auto BaseStateI = FuncInfo.FuncletBaseStateMap.find(FuncletPad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="uncoveredLine">      if (BaseStateI != FuncInfo.FuncletBaseStateMap.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="uncoveredLine">        BaseState = BaseStateI->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">    if (BaseState != -1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="uncoveredLine">      FuncInfo.InvokeStateMap[II] = BaseState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">      Instruction *PadInst = InvokeUnwindDest->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">      assert(FuncInfo.EHPadStateMap.count(PadInst) && "EH Pad has no state!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">      FuncInfo.InvokeStateMap[II] = FuncInfo.EHPadStateMap[PadInst];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">// See comments below for calculateSEHStateForAsynchEH().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">// State - incoming State of normal paths</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">struct WorkItem {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">  const BasicBlock *Block;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  int State;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">  WorkItem(const BasicBlock *BB, int St) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">    Block = BB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">    State = St;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">void llvm::calculateCXXStateForAsynchEH(const BasicBlock *BB, int State,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">                                        WinEHFuncInfo &EHInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">  SmallVector<struct WorkItem *, 8> WorkList;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">  struct WorkItem *WI = new WorkItem(BB, State);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  WorkList.push_back(WI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">  while (!WorkList.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">    WI = WorkList.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">    const BasicBlock *BB = WI->Block;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">    int State = WI->State;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">    delete WI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">      continue; // skip blocks already visited by lower State</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="uncoveredLine">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="uncoveredLine">    const llvm::Instruction *TI = BB->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">    if (I->isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="uncoveredLine">      State = EHInfo.EHPadStateMap[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">    EHInfo.BlockToStateMap[BB] = State; // Record state, also flag visiting</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">    if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) && State > 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">      // Retrive the new State</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">      State = EHInfo.CxxUnwindMap[State].ToState; // Retrive next State</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="uncoveredLine">    } else if (isa<InvokeInst>(TI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">      auto *Call = cast<CallBase>(TI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">      const Function *Fn = Call->getCalledFunction();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">      if (Fn && Fn->isIntrinsic() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">          (Fn->getIntrinsicID() == Intrinsic::seh_scope_begin ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">           Fn->getIntrinsicID() == Intrinsic::seh_try_begin))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">        // Retrive the new State from seh_scope_begin</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="uncoveredLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">      else if (Fn && Fn->isIntrinsic() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">               (Fn->getIntrinsicID() == Intrinsic::seh_scope_end ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">                Fn->getIntrinsicID() == Intrinsic::seh_try_end)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">        // In case of conditional ctor, let's retrieve State from Invoke</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">        // end of current state, retrive new state from UnwindMap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">        State = EHInfo.CxxUnwindMap[State].ToState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">    // Continue push successors into worklist</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">    for (auto *SuccBB : successors(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="uncoveredLine">      WI = new WorkItem(SuccBB, State);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">      WorkList.push_back(WI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">// The central theory of this routine is based on the following:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">//   A _try scope is always a SEME (Single Entry Multiple Exits) region</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">//     as jumping into a _try is not allowed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">//   The single entry must start with a seh_try_begin() invoke with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">//     correct State number that is the initial state of the SEME.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">//   Through control-flow, state number is propagated into all blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">//   Side exits marked by seh_try_end() will unwind to parent state via</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">//     existing SEHUnwindMap[].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">//   Side exits can ONLY jump into parent scopes (lower state number).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">//   Thus, when a block succeeds various states from its predecessors,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">//     the lowest State trumphs others.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">//   If some exits flow to unreachable, propagation on those paths terminate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">//     not affecting remaining blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">void llvm::calculateSEHStateForAsynchEH(const BasicBlock *BB, int State,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">                                        WinEHFuncInfo &EHInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">  SmallVector<struct WorkItem *, 8> WorkList;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">  struct WorkItem *WI = new WorkItem(BB, State);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">  WorkList.push_back(WI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">  while (!WorkList.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">    WI = WorkList.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">    const BasicBlock *BB = WI->Block;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="uncoveredLine">    int State = WI->State;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">    delete WI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="uncoveredLine">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">      continue; // skip blocks already visited by lower State</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="uncoveredLine">    const llvm::Instruction *TI = BB->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">    if (I->isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">      State = EHInfo.EHPadStateMap[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="uncoveredLine">    EHInfo.BlockToStateMap[BB] = State; // Record state</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">    if (isa<CatchPadInst>(I) && isa<CatchReturnInst>(TI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">      const Constant *FilterOrNull = cast<Constant>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">          cast<CatchPadInst>(I)->getArgOperand(0)->stripPointerCasts());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">      const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="uncoveredLine">      if (!Filter || !Filter->getName().startswith("__IsLocalUnwind"))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="uncoveredLine">        State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">    } else if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">               State > 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">      // Retrive the new State.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">      State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">    } else if (isa<InvokeInst>(TI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">      auto *Call = cast<CallBase>(TI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="uncoveredLine">      const Function *Fn = Call->getCalledFunction();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="uncoveredLine">      if (Fn && Fn->isIntrinsic() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">          Fn->getIntrinsicID() == Intrinsic::seh_try_begin)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">        // Retrive the new State from seh_try_begin</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">      else if (Fn && Fn->isIntrinsic() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="uncoveredLine">               Fn->getIntrinsicID() == Intrinsic::seh_try_end)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">        // end of current state, retrive new state from UnwindMap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="uncoveredLine">        State = EHInfo.SEHUnwindMap[State].ToState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">    // Continue push successors into worklist</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">    for (auto *SuccBB : successors(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">      WI = new WorkItem(SuccBB, State);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="uncoveredLine">      WorkList.push_back(WI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">// Given BB which ends in an unwind edge, return the EHPad that this BB belongs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">// to. If the unwind edge came from an invoke, return null.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">static const BasicBlock *getEHPadFromPredecessor(const BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">                                                 Value *ParentPad) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">  const Instruction *TI = BB->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">  if (isa<InvokeInst>(TI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(TI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">    if (CatchSwitch->getParentPad() != ParentPad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">    return BB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">  assert(!TI->isEHPad() && "unexpected EHPad!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">  auto *CleanupPad = cast<CleanupReturnInst>(TI)->getCleanupPad();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="uncoveredLine">  if (CleanupPad->getParentPad() != ParentPad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">  return CleanupPad->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">// Starting from a EHPad, Backward walk through control-flow graph</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">// to produce two primary outputs:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">//      FuncInfo.EHPadStateMap[] and FuncInfo.CxxUnwindMap[]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">static void calculateCXXStateNumbers(WinEHFuncInfo &FuncInfo,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">                                     const Instruction *FirstNonPHI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">                                     int ParentState) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="uncoveredLine">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">  assert(BB->isEHPad() && "not a funclet!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">           "shouldn't revist catch funclets!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">    SmallVector<const CatchPadInst *, 2> Handlers;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">    for (const BasicBlock *CatchPadBB : CatchSwitch->handlers()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">      auto *CatchPad = cast<CatchPadInst>(CatchPadBB->getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">      Handlers.push_back(CatchPad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">    int TryLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">    FuncInfo.EHPadStateMap[CatchSwitch] = TryLow;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">                                               CatchSwitch->getParentPad())))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">                                 TryLow);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">    int CatchLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">    // catchpads are separate funclets in C++ EH due to the way rethrow works.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">    int TryHigh = CatchLow - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">    // MSVC FrameHandler3/4 on x64&Arm64 expect Catch Handlers in $tryMap$</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">    //  stored in pre-order (outer first, inner next), not post-order</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">    //  Add to map here.  Fix the CatchHigh after children are processed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">    const Module *Mod = BB->getParent()->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">    bool IsPreOrder = Triple(Mod->getTargetTriple()).isArch64Bit();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">    if (IsPreOrder)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchLow, Handlers);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">    unsigned TBMEIdx = FuncInfo.TryBlockMap.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">    for (const auto *CatchPad : Handlers) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">      FuncInfo.FuncletBaseStateMap[CatchPad] = CatchLow;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">      FuncInfo.EHPadStateMap[CatchPad] = CatchLow;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">      for (const User *U : CatchPad->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">        const auto *UserI = cast<Instruction>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">        if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">          BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">        if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">          BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">          // If a nested cleanup pad reports a null unwind destination and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">          // enclosing catch pad doesn't it must be post-dominated by an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">          // unreachable instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="uncoveredLine">    int CatchHigh = FuncInfo.getLastStateNumber();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">    // Now child Catches are processed, update CatchHigh</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">    if (IsPreOrder)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">      FuncInfo.TryBlockMap[TBMEIdx].CatchHigh = CatchHigh;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">    else // PostOrder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchHigh, Handlers);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "TryLow[" << BB->getName() << "]: " << TryLow << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "TryHigh[" << BB->getName() << "]: " << TryHigh</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">                      << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "CatchHigh[" << BB->getName() << "]: " << CatchHigh</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">                      << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">    // cleanupret instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">    int CleanupState = addUnwindMapEntry(FuncInfo, ParentState, BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">                      << BB->getName() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">    for (const BasicBlock *PredBlock : predecessors(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">                                               CleanupPad->getParentPad()))) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="uncoveredLine">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">                                 CleanupState);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">    for (const User *U : CleanupPad->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">      if (UserI->isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">        report_fatal_error("Cleanup funclets for the MSVC++ personality cannot "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">                           "contain exceptional actions");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">static int addSEHExcept(WinEHFuncInfo &FuncInfo, int ParentState,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">                        const Function *Filter, const BasicBlock *Handler) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">  SEHUnwindMapEntry Entry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">  Entry.ToState = ParentState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">  Entry.IsFinally = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">  Entry.Filter = Filter;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">  Entry.Handler = Handler;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="uncoveredLine">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">static int addSEHFinally(WinEHFuncInfo &FuncInfo, int ParentState,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">                         const BasicBlock *Handler) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">  SEHUnwindMapEntry Entry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">  Entry.ToState = ParentState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">  Entry.IsFinally = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  Entry.Filter = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">  Entry.Handler = Handler;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">// Starting from a EHPad, Backward walk through control-flow graph</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">// to produce two primary outputs:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">//      FuncInfo.EHPadStateMap[] and FuncInfo.SEHUnwindMap[]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">static void calculateSEHStateNumbers(WinEHFuncInfo &FuncInfo,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">                                     const Instruction *FirstNonPHI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">                                     int ParentState) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">  assert(BB->isEHPad() && "no a funclet!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">           "shouldn't revist catch funclets!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">    // Extract the filter function and the __except basic block and create a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">    // state for them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">    assert(CatchSwitch->getNumHandlers() == 1 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">           "SEH doesn't have multiple handlers per __try");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">    const auto *CatchPad =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="uncoveredLine">        cast<CatchPadInst>((*CatchSwitch->handler_begin())->getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">    const BasicBlock *CatchPadBB = CatchPad->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">    const Constant *FilterOrNull =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">        cast<Constant>(CatchPad->getArgOperand(0)->stripPointerCasts());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">    const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">    assert((Filter || FilterOrNull->isNullValue()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">           "unexpected filter value");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">    int TryState = addSEHExcept(FuncInfo, ParentState, Filter, CatchPadBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">    // Everything in the __try block uses TryState as its parent state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">    FuncInfo.EHPadStateMap[CatchSwitch] = TryState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">    FuncInfo.EHPadStateMap[CatchPad] = TryState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << TryState << " to BB "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">                      << CatchPadBB->getName() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="uncoveredLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">                                               CatchSwitch->getParentPad())))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">                                 TryState);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">    // Everything in the __except block unwinds to ParentState, just like code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">    // outside the __try.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">    for (const User *U : CatchPad->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">      if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">        BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="uncoveredLine">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">      if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">        BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">        // If a nested cleanup pad reports a null unwind destination and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">        // enclosing catch pad doesn't it must be post-dominated by an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">        // unreachable instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">    // cleanupret instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">    int CleanupState = addSEHFinally(FuncInfo, ParentState, BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">                      << BB->getName() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">      if ((PredBlock =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">               getEHPadFromPredecessor(PredBlock, CleanupPad->getParentPad())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="uncoveredLine">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">                                 CleanupState);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">    for (const User *U : CleanupPad->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="uncoveredLine">      if (UserI->isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">        report_fatal_error("Cleanup funclets for the SEH personality cannot "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">                           "contain exceptional actions");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="uncoveredLine">static bool isTopLevelPadForMSVC(const Instruction *EHPad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(EHPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">    return isa<ConstantTokenNone>(CatchSwitch->getParentPad()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="uncoveredLine">           CatchSwitch->unwindsToCaller();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">  if (auto *CleanupPad = dyn_cast<CleanupPadInst>(EHPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="uncoveredLine">    return isa<ConstantTokenNone>(CleanupPad->getParentPad()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="uncoveredLine">           getCleanupRetUnwindDest(CleanupPad) == nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="uncoveredLine">  if (isa<CatchPadInst>(EHPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">  llvm_unreachable("unexpected EHPad!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">void llvm::calculateSEHStateNumbers(const Function *Fn,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">                                    WinEHFuncInfo &FuncInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  // Don't compute state numbers twice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  if (!FuncInfo.SEHUnwindMap.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">    if (!BB.isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">    ::calculateSEHStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">  if (IsEHa) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">    calculateSEHStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">void llvm::calculateWinCXXEHStateNumbers(const Function *Fn,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">                                         WinEHFuncInfo &FuncInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">  // Return if it's already been done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">  if (!FuncInfo.EHPadStateMap.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">    if (!BB.isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">    calculateCXXStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">  if (IsEHa) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="uncoveredLine">    calculateCXXStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">static int addClrEHHandler(WinEHFuncInfo &FuncInfo, int HandlerParentState,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">                           int TryParentState, ClrHandlerType HandlerType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">                           uint32_t TypeToken, const BasicBlock *Handler) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">  ClrEHUnwindMapEntry Entry;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  Entry.HandlerParentState = HandlerParentState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">  Entry.TryParentState = TryParentState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">  Entry.Handler = Handler;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">  Entry.HandlerType = HandlerType;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">  Entry.TypeToken = TypeToken;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">  FuncInfo.ClrEHUnwindMap.push_back(Entry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">  return FuncInfo.ClrEHUnwindMap.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">void llvm::calculateClrEHStateNumbers(const Function *Fn,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">                                      WinEHFuncInfo &FuncInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">  // Return if it's already been done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">  if (!FuncInfo.EHPadStateMap.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  // This numbering assigns one state number to each catchpad and cleanuppad.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">  // It also computes two tree-like relations over states:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">  // 1) Each state has a "HandlerParentState", which is the state of the next</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">  //    outer handler enclosing this state's handler (same as nearest ancestor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">  //    per the ParentPad linkage on EH pads, but skipping over catchswitches).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  // 2) Each state has a "TryParentState", which:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  //    a) for a catchpad that's not the last handler on its catchswitch, is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">  //       the state of the next catchpad on that catchswitch</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  //    b) for all other pads, is the state of the pad whose try region is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">  //       next outer try region enclosing this state's try region.  The "try</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  //       regions are not present as such in the IR, but will be inferred</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  //       based on the placement of invokes and pads which reach each other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">  //       by exceptional exits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  // Catchswitches do not get their own states, but each gets mapped to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  // state of its first catchpad.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">  // Step one: walk down from outermost to innermost funclets, assigning each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  // catchpad and cleanuppad a state number.  Add an entry to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">  // ClrEHUnwindMap for each state, recording its HandlerParentState and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  // handler attributes.  Record the TryParentState as well for each catchpad</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">  // that's not the last on its catchswitch, but initialize all other entries'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">  // TryParentStates to a sentinel -1 value that the next pass will update.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">  // Seed a worklist with pads that have no parent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">  SmallVector<std::pair<const Instruction *, int>, 8> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">    const Value *ParentPad;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">    if (const auto *CPI = dyn_cast<CleanupPadInst>(FirstNonPHI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">      ParentPad = CPI->getParentPad();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">    else if (const auto *CSI = dyn_cast<CatchSwitchInst>(FirstNonPHI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">      ParentPad = CSI->getParentPad();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">    if (isa<ConstantTokenNone>(ParentPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">      Worklist.emplace_back(FirstNonPHI, -1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  // Use the worklist to visit all pads, from outer to inner.  Record</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  // HandlerParentState for all pads.  Record TryParentState only for catchpads</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  // that aren't the last on their catchswitch (setting all other entries'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  // TryParentStates to an initial value of -1).  This loop is also responsible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">  // for setting the EHPadStateMap entry for all catchpads, cleanuppads, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">  // catchswitches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">    const Instruction *Pad;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">    int HandlerParentState;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">    std::tie(Pad, HandlerParentState) = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">    if (const auto *Cleanup = dyn_cast<CleanupPadInst>(Pad)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">      // Create the entry for this cleanup with the appropriate handler</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">      // properties.  Finally and fault handlers are distinguished by arity.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">      ClrHandlerType HandlerType =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">          (Cleanup->arg_size() ? ClrHandlerType::Fault</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">                               : ClrHandlerType::Finally);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">      int CleanupState = addClrEHHandler(FuncInfo, HandlerParentState, -1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">                                         HandlerType, 0, Pad->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">      // Queue any child EH pads on the worklist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">      for (const User *U : Cleanup->users())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">        if (const auto *I = dyn_cast<Instruction>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">          if (I->isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">            Worklist.emplace_back(I, CleanupState);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">      // Remember this pad's state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">      FuncInfo.EHPadStateMap[Cleanup] = CleanupState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">      // Walk the handlers of this catchswitch in reverse order since all but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">      // the last need to set the following one as its TryParentState.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">      const auto *CatchSwitch = cast<CatchSwitchInst>(Pad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">      int CatchState = -1, FollowerState = -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">      SmallVector<const BasicBlock *, 4> CatchBlocks(CatchSwitch->handlers());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">      for (const BasicBlock *CatchBlock : llvm::reverse(CatchBlocks)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">        // Create the entry for this catch with the appropriate handler</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">        // properties.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">        const auto *Catch = cast<CatchPadInst>(CatchBlock->getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">        uint32_t TypeToken = static_cast<uint32_t>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">            cast<ConstantInt>(Catch->getArgOperand(0))->getZExtValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">        CatchState =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">            addClrEHHandler(FuncInfo, HandlerParentState, FollowerState,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">                            ClrHandlerType::Catch, TypeToken, CatchBlock);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">        // Queue any child EH pads on the worklist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">        for (const User *U : Catch->users())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">          if (const auto *I = dyn_cast<Instruction>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">            if (I->isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">              Worklist.emplace_back(I, CatchState);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">        // Remember this catch's state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">        FuncInfo.EHPadStateMap[Catch] = CatchState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">        FollowerState = CatchState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">      // Associate the catchswitch with the state of its first catch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">      assert(CatchSwitch->getNumHandlers());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">      FuncInfo.EHPadStateMap[CatchSwitch] = CatchState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">  // Step two: record the TryParentState of each state.  For cleanuppads that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">  // don't have cleanuprets, we may need to infer this from their child pads,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">  // so visit pads in descendant-most to ancestor-most order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">  for (ClrEHUnwindMapEntry &Entry : llvm::reverse(FuncInfo.ClrEHUnwindMap)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">    const Instruction *Pad =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">        cast<const BasicBlock *>(Entry.Handler)->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">    // For most pads, the TryParentState is the state associated with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">    // unwind dest of exceptional exits from it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">    const BasicBlock *UnwindDest;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">    if (const auto *Catch = dyn_cast<CatchPadInst>(Pad)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">      // If a catch is not the last in its catchswitch, its TryParentState is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">      // the state associated with the next catch in the switch, even though</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">      // that's not the unwind dest of exceptions escaping the catch.  Those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">      // cases were already assigned a TryParentState in the first pass, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">      // skip them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">      if (Entry.TryParentState != -1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">      // Otherwise, get the unwind dest from the catchswitch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">      UnwindDest = Catch->getCatchSwitch()->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">      const auto *Cleanup = cast<CleanupPadInst>(Pad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">      UnwindDest = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">      for (const User *U : Cleanup->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">        if (auto *CleanupRet = dyn_cast<CleanupReturnInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">          // Common and unambiguous case -- cleanupret indicates cleanup's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">          // unwind dest.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">          UnwindDest = CleanupRet->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">        // Get an unwind dest for the user</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">        const BasicBlock *UserUnwindDest = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">        if (auto *Invoke = dyn_cast<InvokeInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">          UserUnwindDest = Invoke->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">        } else if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">          UserUnwindDest = CatchSwitch->getUnwindDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="uncoveredLine">        } else if (auto *ChildCleanup = dyn_cast<CleanupPadInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">          int UserState = FuncInfo.EHPadStateMap[ChildCleanup];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">          int UserUnwindState =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">              FuncInfo.ClrEHUnwindMap[UserState].TryParentState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">          if (UserUnwindState != -1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">            UserUnwindDest = cast<const BasicBlock *>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">                FuncInfo.ClrEHUnwindMap[UserUnwindState].Handler);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">        // Not having an unwind dest for this user might indicate that it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">        // doesn't unwind, so can't be taken as proof that the cleanup itself</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">        // may unwind to caller (see e.g. SimplifyUnreachable and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">        // RemoveUnwindEdge).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">        if (!UserUnwindDest)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">        // Now we have an unwind dest for the user, but we need to see if it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">        // unwinds all the way out of the cleanup or if it stays within it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">        const Instruction *UserUnwindPad = UserUnwindDest->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">        const Value *UserUnwindParent;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">        if (auto *CSI = dyn_cast<CatchSwitchInst>(UserUnwindPad))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">          UserUnwindParent = CSI->getParentPad();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">        else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">          UserUnwindParent =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">              cast<CleanupPadInst>(UserUnwindPad)->getParentPad();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">        // The unwind stays within the cleanup iff it targets a child of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">        // cleanup.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">        if (UserUnwindParent == Cleanup)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">        // This unwind exits the cleanup, so its dest is the cleanup's dest.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">        UnwindDest = UserUnwindDest;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">    // Record the state of the unwind dest as the TryParentState.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">    int UnwindDestState;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">    // If UnwindDest is null at this point, either the pad in question can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">    // be exited by unwind to caller, or it cannot be exited by unwind.  In</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">    // either case, reporting such cases as unwinding to caller is correct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">    // This can lead to EH tables that "look strange" -- if this pad's is in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">    // a parent funclet which has other children that do unwind to an enclosing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">    // pad, the try region for this pad will be missing the "duplicate" EH</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">    // clause entries that you'd expect to see covering the whole parent.  That</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">    // should be benign, since the unwind never actually happens.  If it were</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">    // an issue, we could add a subsequent pass that pushes unwind dests down</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">    // from parents that have them to children that appear to unwind to caller.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">    if (!UnwindDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="uncoveredLine">      UnwindDestState = -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">      UnwindDestState = FuncInfo.EHPadStateMap[UnwindDest->getFirstNonPHI()];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">    Entry.TryParentState = UnwindDestState;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">  // Step three: transfer information from pads to invokes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">void WinEHPrepare::colorFunclets(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">  BlockColors = colorEHFunclets(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">  // Invert the map from BB to colors to color to BBs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">  for (BasicBlock &BB : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">    ColorVector &Colors = BlockColors[&BB];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">    for (BasicBlock *Color : Colors)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">      FuncletBlocks[Color].push_back(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">void WinEHPrepare::demotePHIsOnFunclets(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">                                        bool DemoteCatchSwitchPHIOnly) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  // Strip PHI nodes off of EH pads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">  SmallVector<PHINode *, 16> PHINodes;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">  for (BasicBlock &BB : make_early_inc_range(F)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">    if (!BB.isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">    if (DemoteCatchSwitchPHIOnly && !isa<CatchSwitchInst>(BB.getFirstNonPHI()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="uncoveredLine">    for (Instruction &I : make_early_inc_range(BB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">      auto *PN = dyn_cast<PHINode>(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">      // Stop at the first non-PHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">      if (!PN)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">      AllocaInst *SpillSlot = insertPHILoads(PN, F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">      if (SpillSlot)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">        insertPHIStores(PN, SpillSlot);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">      PHINodes.push_back(PN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">  for (auto *PN : PHINodes) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">    // There may be lingering uses on other EH PHIs being removed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">    PN->replaceAllUsesWith(PoisonValue::get(PN->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">    PN->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">void WinEHPrepare::cloneCommonBlocks(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">  // We need to clone all blocks which belong to multiple funclets.  Values are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">  // remapped throughout the funclet to propagate both the new instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">  // *and* the new basic blocks themselves.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">  for (auto &Funclets : FuncletBlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">    BasicBlock *FuncletPadBB = Funclets.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">    std::vector<BasicBlock *> &BlocksInFunclet = Funclets.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">    Value *FuncletToken;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="uncoveredLine">    if (FuncletPadBB == &F.getEntryBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="uncoveredLine">      FuncletToken = ConstantTokenNone::get(F.getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">      FuncletToken = FuncletPadBB->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">    std::vector<std::pair<BasicBlock *, BasicBlock *>> Orig2Clone;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="uncoveredLine">    ValueToValueMapTy VMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="uncoveredLine">    for (BasicBlock *BB : BlocksInFunclet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">      ColorVector &ColorsForBB = BlockColors[BB];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">      // We don't need to do anything if the block is monochromatic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="uncoveredLine">      size_t NumColorsForBB = ColorsForBB.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="uncoveredLine">      if (NumColorsForBB == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">                      dbgs() << "  Cloning block \'" << BB->getName()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">                              << "\' for funclet \'" << FuncletPadBB->getName()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">                              << "\'.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">      // Create a new basic block and copy instructions into it!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">      BasicBlock *CBB =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">          CloneBasicBlock(BB, VMap, Twine(".for.", FuncletPadBB->getName()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">      // Insert the clone immediately after the original to ensure determinism</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">      // and to keep the same relative ordering of any funclet's blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">      CBB->insertInto(&F, BB->getNextNode());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">      // Add basic block mapping.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">      VMap[BB] = CBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">      // Record delta operations that we need to perform to our color mappings.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">      Orig2Clone.emplace_back(BB, CBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">    // If nothing was cloned, we're done cloning in this funclet.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">    if (Orig2Clone.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">    // Update our color mappings to reflect that one block has lost a color and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">    // another has gained a color.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">      BlocksInFunclet.push_back(NewBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">      ColorVector &NewColors = BlockColors[NewBlock];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">      assert(NewColors.empty() && "A new block should only have one color!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">      NewColors.push_back(FuncletPadBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">                      dbgs() << "  Assigned color \'" << FuncletPadBB->getName()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">                              << "\' to block \'" << NewBlock->getName()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">                              << "\'.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="uncoveredLine">      llvm::erase_value(BlocksInFunclet, OldBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">      ColorVector &OldColors = BlockColors[OldBlock];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">      llvm::erase_value(OldColors, FuncletPadBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">                      dbgs() << "  Removed color \'" << FuncletPadBB->getName()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">                              << "\' from block \'" << OldBlock->getName()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">                              << "\'.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">    // Loop over all of the instructions in this funclet, fixing up operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">    // references as we go.  This uses VMap to do all the hard work.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">    for (BasicBlock *BB : BlocksInFunclet)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">      // Loop over all instructions, fixing each one as we find it...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">      for (Instruction &I : *BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">        RemapInstruction(&I, VMap,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">                         RF_IgnoreMissingLocals | RF_NoModuleLevelChanges);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">    // Catchrets targeting cloned blocks need to be updated separately from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">    // the loop above because they are not in the current funclet.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">    SmallVector<CatchReturnInst *, 2> FixupCatchrets;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="uncoveredLine">      FixupCatchrets.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">      for (BasicBlock *Pred : predecessors(OldBlock))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="uncoveredLine">        if (auto *CatchRet = dyn_cast<CatchReturnInst>(Pred->getTerminator()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="uncoveredLine">          if (CatchRet->getCatchSwitchParentPad() == FuncletToken)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">            FixupCatchrets.push_back(CatchRet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="uncoveredLine">      for (CatchReturnInst *CatchRet : FixupCatchrets)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">        CatchRet->setSuccessor(NewBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">    auto UpdatePHIOnClonedBlock = [&](PHINode *PN, bool IsForOldBlock) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="uncoveredLine">      unsigned NumPreds = PN->getNumIncomingValues();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">      for (unsigned PredIdx = 0, PredEnd = NumPreds; PredIdx != PredEnd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">           ++PredIdx) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">        BasicBlock *IncomingBlock = PN->getIncomingBlock(PredIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">        bool EdgeTargetsFunclet;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">        if (auto *CRI =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">                dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">          EdgeTargetsFunclet = (CRI->getCatchSwitchParentPad() == FuncletToken);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">          ColorVector &IncomingColors = BlockColors[IncomingBlock];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">          assert(!IncomingColors.empty() && "Block not colored!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">          assert((IncomingColors.size() == 1 ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">                  !llvm::is_contained(IncomingColors, FuncletPadBB)) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">                 "Cloning should leave this funclet's blocks monochromatic");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">          EdgeTargetsFunclet = (IncomingColors.front() == FuncletPadBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">        if (IsForOldBlock != EdgeTargetsFunclet)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">        PN->removeIncomingValue(IncomingBlock, /*DeletePHIIfEmpty=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">        // Revisit the next entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">        --PredIdx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="uncoveredLine">        --PredEnd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">      for (PHINode &OldPN : OldBlock->phis()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">        UpdatePHIOnClonedBlock(&OldPN, /*IsForOldBlock=*/true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">      for (PHINode &NewPN : NewBlock->phis()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">        UpdatePHIOnClonedBlock(&NewPN, /*IsForOldBlock=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">    // Check to see if SuccBB has PHI nodes. If so, we need to add entries to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">    // the PHI nodes for NewBB now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">      for (BasicBlock *SuccBB : successors(NewBlock)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">        for (PHINode &SuccPN : SuccBB->phis()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">          // Ok, we have a PHI node.  Figure out what the incoming value was for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">          // the OldBlock.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">          int OldBlockIdx = SuccPN.getBasicBlockIndex(OldBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">          if (OldBlockIdx == -1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">            break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">          Value *IV = SuccPN.getIncomingValue(OldBlockIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">          // Remap the value if necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">          if (auto *Inst = dyn_cast<Instruction>(IV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">            ValueToValueMapTy::iterator I = VMap.find(Inst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="uncoveredLine">            if (I != VMap.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="uncoveredLine">              IV = I->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">          SuccPN.addIncoming(IV, NewBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">    for (ValueToValueMapTy::value_type VT : VMap) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">      // If there were values defined in BB that are used outside the funclet,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">      // then we now have to update all uses of the value to use either the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">      // original value, the cloned value, or some PHI derived value.  This can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">      // require arbitrary PHI insertion, of which we are prepared to do, clean</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">      // these up now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">      SmallVector<Use *, 16> UsesToRename;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">      auto *OldI = dyn_cast<Instruction>(const_cast<Value *>(VT.first));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="uncoveredLine">      if (!OldI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="uncoveredLine">      auto *NewI = cast<Instruction>(VT.second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">      // Scan all uses of this instruction to see if it is used outside of its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">      // funclet, and if so, record them in UsesToRename.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">      for (Use &U : OldI->uses()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">        Instruction *UserI = cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="uncoveredLine">        BasicBlock *UserBB = UserI->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="uncoveredLine">        ColorVector &ColorsForUserBB = BlockColors[UserBB];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">        assert(!ColorsForUserBB.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">        if (ColorsForUserBB.size() > 1 ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">            *ColorsForUserBB.begin() != FuncletPadBB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">          UsesToRename.push_back(&U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">      // If there are no uses outside the block, we're done with this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">      // instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">      if (UsesToRename.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">      // We found a use of OldI outside of the funclet.  Rename all uses of OldI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">      // that are outside its funclet to be uses of the appropriate PHI node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">      // etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="uncoveredLine">      SSAUpdater SSAUpdate;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="uncoveredLine">      SSAUpdate.Initialize(OldI->getType(), OldI->getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">      SSAUpdate.AddAvailableValue(OldI->getParent(), OldI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">      SSAUpdate.AddAvailableValue(NewI->getParent(), NewI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">      while (!UsesToRename.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="uncoveredLine">        SSAUpdate.RewriteUseAfterInsertions(*UsesToRename.pop_back_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="uncoveredLine">void WinEHPrepare::removeImplausibleInstructions(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">  // Remove implausible terminators and replace them with UnreachableInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">  for (auto &Funclet : FuncletBlocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="uncoveredLine">    BasicBlock *FuncletPadBB = Funclet.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">    std::vector<BasicBlock *> &BlocksInFunclet = Funclet.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">    Instruction *FirstNonPHI = FuncletPadBB->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">    auto *FuncletPad = dyn_cast<FuncletPadInst>(FirstNonPHI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">    auto *CatchPad = dyn_cast_or_null<CatchPadInst>(FuncletPad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">    auto *CleanupPad = dyn_cast_or_null<CleanupPadInst>(FuncletPad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">    for (BasicBlock *BB : BlocksInFunclet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">      for (Instruction &I : *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="uncoveredLine">        auto *CB = dyn_cast<CallBase>(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">        if (!CB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">        Value *FuncletBundleOperand = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">        if (auto BU = CB->getOperandBundle(LLVMContext::OB_funclet))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">          FuncletBundleOperand = BU->Inputs.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">        if (FuncletBundleOperand == FuncletPad)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">        // Skip call sites which are nounwind intrinsics or inline asm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">        auto *CalledFn =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">            dyn_cast<Function>(CB->getCalledOperand()->stripPointerCasts());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="uncoveredLine">        if (CalledFn && ((CalledFn->isIntrinsic() && CB->doesNotThrow()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">                         CB->isInlineAsm()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">        // This call site was not part of this funclet, remove it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">        if (isa<InvokeInst>(CB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">          // Remove the unwind edge if it was an invoke.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">          removeUnwindEdge(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">          // Get a pointer to the new call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">          BasicBlock::iterator CallI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">              std::prev(BB->getTerminator()->getIterator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">          auto *CI = cast<CallInst>(&*CallI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">          changeToUnreachable(CI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">          changeToUnreachable(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">        // There are no more instructions in the block (except for unreachable),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">        // we are done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">      Instruction *TI = BB->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">      // CatchPadInst and CleanupPadInst can't transfer control to a ReturnInst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">      bool IsUnreachableRet = isa<ReturnInst>(TI) && FuncletPad;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="">      // The token consumed by a CatchReturnInst must match the funclet token.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">      bool IsUnreachableCatchret = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">      if (auto *CRI = dyn_cast<CatchReturnInst>(TI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">        IsUnreachableCatchret = CRI->getCatchPad() != CatchPad;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">      // The token consumed by a CleanupReturnInst must match the funclet token.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">      bool IsUnreachableCleanupret = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="uncoveredLine">      if (auto *CRI = dyn_cast<CleanupReturnInst>(TI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">        IsUnreachableCleanupret = CRI->getCleanupPad() != CleanupPad;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="uncoveredLine">      if (IsUnreachableRet || IsUnreachableCatchret ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">          IsUnreachableCleanupret) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">        changeToUnreachable(TI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">      } else if (isa<InvokeInst>(TI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">        if (Personality == EHPersonality::MSVC_CXX && CleanupPad) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">          // Invokes within a cleanuppad for the MSVC++ personality never</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">          // transfer control to their unwind edge: the personality will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">          // terminate the program.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="uncoveredLine">          removeUnwindEdge(BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">void WinEHPrepare::cleanupPreparedFunclets(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  // Clean-up some of the mess we made by removing useles PHI nodes, trivial</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">  // branches, etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">  for (BasicBlock &BB : llvm::make_early_inc_range(F)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">    SimplifyInstructionsInBlock(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">    ConstantFoldTerminator(&BB, /*DeleteDeadConditions=*/true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">    MergeBlockIntoPredecessor(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">  // We might have some unreachable blocks after cleaning up some impossible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">  // control flow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">  removeUnreachableBlocks(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="uncoveredLine">void WinEHPrepare::verifyPreparedFunclets(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">  for (BasicBlock &BB : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">    size_t NumColors = BlockColors[&BB].size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="uncoveredLine">    assert(NumColors == 1 && "Expected monochromatic BB!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">    if (NumColors == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">      report_fatal_error("Uncolored BB!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">    if (NumColors > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">      report_fatal_error("Multicolor BB!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">    assert((DisableDemotion || !(BB.isEHPad() && isa<PHINode>(BB.begin()))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">           "EH Pad still has a PHI!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">bool WinEHPrepare::prepareExplicitEH(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">  // Remove unreachable blocks.  It is not valuable to assign them a color and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">  // their existence can trick us into thinking values are alive when they are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">  // not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">  removeUnreachableBlocks(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  // Determine which blocks are reachable from which funclet entries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">  colorFunclets(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">  cloneCommonBlocks(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="uncoveredLine">  if (!DisableDemotion)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">    demotePHIsOnFunclets(F, DemoteCatchSwitchPHIOnly ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">                                DemoteCatchSwitchPHIOnlyOpt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">  if (!DisableCleanups) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">    assert(!verifyFunction(F, &dbgs()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="uncoveredLine">    removeImplausibleInstructions(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="uncoveredLine">    assert(!verifyFunction(F, &dbgs()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="uncoveredLine">    cleanupPreparedFunclets(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">  // Recolor the CFG to verify that all is well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">  LLVM_DEBUG(colorFunclets(F));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">  BlockColors.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">  FuncletBlocks.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">// TODO: Share loads when one use dominates another, or when a catchpad exit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">// dominates uses (needs dominators).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">AllocaInst *WinEHPrepare::insertPHILoads(PHINode *PN, Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="uncoveredLine">  BasicBlock *PHIBlock = PN->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">  AllocaInst *SpillSlot = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">  Instruction *EHPad = PHIBlock->getFirstNonPHI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">  if (!EHPad->isTerminator()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">    // If the EHPad isn't a terminator, then we can insert a load in this block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">    // that will dominate all uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">    SpillSlot = new AllocaInst(PN->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">                               Twine(PN->getName(), ".wineh.spillslot"),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="uncoveredLine">                               &F.getEntryBlock().front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">    Value *V = new LoadInst(PN->getType(), SpillSlot,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">                            Twine(PN->getName(), ".wineh.reload"),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="uncoveredLine">                            &*PHIBlock->getFirstInsertionPt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">    PN->replaceAllUsesWith(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">    return SpillSlot;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  // Otherwise, we have a PHI on a terminator EHPad, and we give up and insert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">  // loads of the slot before every use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="uncoveredLine">  DenseMap<BasicBlock *, Value *> Loads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">  for (Use &U : llvm::make_early_inc_range(PN->uses())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">    auto *UsingInst = cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="uncoveredLine">    if (isa<PHINode>(UsingInst) && UsingInst->getParent()->isEHPad()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">      // Use is on an EH pad phi.  Leave it alone; we'll insert loads and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">      // stores for it separately.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="uncoveredLine">    replaceUseWithLoad(PN, U, SpillSlot, Loads, F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="uncoveredLine">  return SpillSlot;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">// TODO: improve store placement.  Inserting at def is probably good, but need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">// to be careful not to introduce interfering stores (needs liveness analysis).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">// TODO: identify related phi nodes that can share spill slots, and share them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">// (also needs liveness).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="uncoveredLine">void WinEHPrepare::insertPHIStores(PHINode *OriginalPHI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">                                   AllocaInst *SpillSlot) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  // Use a worklist of (Block, Value) pairs -- the given Value needs to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">  // stored to the spill slot by the end of the given Block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="uncoveredLine">  SmallVector<std::pair<BasicBlock *, Value *>, 4> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="uncoveredLine">  Worklist.push_back({OriginalPHI->getParent(), OriginalPHI});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">    BasicBlock *EHBlock;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">    Value *InVal;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">    std::tie(EHBlock, InVal) = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">    PHINode *PN = dyn_cast<PHINode>(InVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">    if (PN && PN->getParent() == EHBlock) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">      // The value is defined by another PHI we need to remove, with no room to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">      // insert a store after the PHI, so each predecessor needs to store its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">      // incoming value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">      for (unsigned i = 0, e = PN->getNumIncomingValues(); i < e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">        Value *PredVal = PN->getIncomingValue(i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">        // Undef can safely be skipped.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="uncoveredLine">        if (isa<UndefValue>(PredVal))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">        insertPHIStore(PN->getIncomingBlock(i), PredVal, SpillSlot, Worklist);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">      // We need to store InVal, which dominates EHBlock, but can't put a store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">      // in EHBlock, so need to put stores in each predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">      for (BasicBlock *PredBlock : predecessors(EHBlock)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="uncoveredLine">        insertPHIStore(PredBlock, InVal, SpillSlot, Worklist);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="uncoveredLine">void WinEHPrepare::insertPHIStore(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">    BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">    SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">  if (PredBlock->isEHPad() && PredBlock->getFirstNonPHI()->isTerminator()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">    // Pred is unsplittable, so we need to queue it on the worklist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="uncoveredLine">    Worklist.push_back({PredBlock, PredVal});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">  // Otherwise, insert the store at the end of the basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">  new StoreInst(PredVal, SpillSlot, PredBlock->getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">void WinEHPrepare::replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">                                      DenseMap<BasicBlock *, Value *> &Loads,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">                                      Function &F) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">  // Lazilly create the spill slot.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="uncoveredLine">  if (!SpillSlot)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">    SpillSlot = new AllocaInst(V->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="uncoveredLine">                               Twine(V->getName(), ".wineh.spillslot"),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">                               &F.getEntryBlock().front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">  auto *UsingInst = cast<Instruction>(U.getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">  if (auto *UsingPHI = dyn_cast<PHINode>(UsingInst)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">    // If this is a PHI node, we can't insert a load of the value before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">    // the use.  Instead insert the load in the predecessor block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">    // corresponding to the incoming value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">    // Note that if there are multiple edges from a basic block to this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">    // PHI node that we cannot have multiple loads.  The problem is that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">    // the resulting PHI node will have multiple values (from each load)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">    // coming in from the same block, which is illegal SSA form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">    // For this reason, we keep track of and reuse loads we insert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="uncoveredLine">    BasicBlock *IncomingBlock = UsingPHI->getIncomingBlock(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">    if (auto *CatchRet =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">            dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">      // Putting a load above a catchret and use on the phi would still leave</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">      // a cross-funclet def/use.  We need to split the edge, change the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">      // catchret to target the new block, and put the load there.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">      BasicBlock *PHIBlock = UsingInst->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="uncoveredLine">      BasicBlock *NewBlock = SplitEdge(IncomingBlock, PHIBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">      // SplitEdge gives us:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">      //   IncomingBlock:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">      //     ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">      //     br label %NewBlock</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">      //   NewBlock:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">      //     catchret label %PHIBlock</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">      // But we need:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">      //   IncomingBlock:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">      //     ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">      //     catchret label %NewBlock</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="">      //   NewBlock:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">      //     br label %PHIBlock</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">      // So move the terminators to each others' blocks and swap their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">      // successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">      BranchInst *Goto = cast<BranchInst>(IncomingBlock->getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">      Goto->removeFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="uncoveredLine">      CatchRet->removeFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">      CatchRet->insertInto(IncomingBlock, IncomingBlock->end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">      Goto->insertInto(NewBlock, NewBlock->end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">      Goto->setSuccessor(0, PHIBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">      CatchRet->setSuccessor(NewBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">      // Update the color mapping for the newly split edge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">      // Grab a reference to the ColorVector to be inserted before getting the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">      // reference to the vector we are copying because inserting the new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">      // element in BlockColors might cause the map to be reallocated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">      ColorVector &ColorsForNewBlock = BlockColors[NewBlock];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">      ColorVector &ColorsForPHIBlock = BlockColors[PHIBlock];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">      ColorsForNewBlock = ColorsForPHIBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="uncoveredLine">      for (BasicBlock *FuncletPad : ColorsForPHIBlock)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">        FuncletBlocks[FuncletPad].push_back(NewBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">      // Treat the new block as incoming for load insertion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="uncoveredLine">      IncomingBlock = NewBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">    Value *&Load = Loads[IncomingBlock];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">    // Insert the load into the predecessor block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">    if (!Load)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">      Load = new LoadInst(V->getType(), SpillSlot,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">                          Twine(V->getName(), ".wineh.reload"),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">                          /*isVolatile=*/false, IncomingBlock->getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">    U.set(Load);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">    // Reload right before the old use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="uncoveredLine">    auto *Load = new LoadInst(V->getType(), SpillSlot,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="uncoveredLine">                              Twine(V->getName(), ".wineh.reload"),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="uncoveredLine">                              /*isVolatile=*/false, UsingInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="uncoveredLine">    U.set(Load);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">void WinEHFuncInfo::addIPToStateRange(const InvokeInst *II,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">                                      MCSymbol *InvokeBegin,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">                                      MCSymbol *InvokeEnd) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="uncoveredLine">  assert(InvokeStateMap.count(II) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">         "should get invoke with precomputed state");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">  LabelToStateMap[InvokeBegin] = std::make_pair(InvokeStateMap[II], InvokeEnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="uncoveredLine">void WinEHFuncInfo::addIPToStateRange(int State, MCSymbol* InvokeBegin,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">    MCSymbol* InvokeEnd) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">    LabelToStateMap[InvokeBegin] = std::make_pair(State, InvokeEnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">WinEHFuncInfo::WinEHFuncInfo() = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepareC2Eb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112WinEHPrepare11getPassNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL30initializeWinEHPreparePassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26initializeWinEHPreparePassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15createWinEHPassEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare14doFinalizationERN4llvm6ModuleE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_112WinEHPrepare16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL17addUnwindMapEntryRN4llvm13WinEHFuncInfoEiPKNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL19addTryBlockMapEntryRN4llvm13WinEHFuncInfoEiiiNS_8ArrayRefIPKNS_12CatchPadInstEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23getCleanupRetUnwindDestPKN4llvm14CleanupPadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL31calculateStateNumbersForInvokesPKN4llvm8FunctionERNS_13WinEHFuncInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN8WorkItemC2EPKN4llvm10BasicBlockEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm28calculateCXXStateForAsynchEHEPKNS_10BasicBlockEiRNS_13WinEHFuncInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm28calculateSEHStateForAsynchEHEPKNS_10BasicBlockEiRNS_13WinEHFuncInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23getEHPadFromPredecessorPKN4llvm10BasicBlockEPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL24calculateCXXStateNumbersRN4llvm13WinEHFuncInfoEPKNS_11InstructionEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12addSEHExceptRN4llvm13WinEHFuncInfoEiPKNS_8FunctionEPKNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13addSEHFinallyRN4llvm13WinEHFuncInfoEiPKNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL24calculateSEHStateNumbersRN4llvm13WinEHFuncInfoEPKNS_11InstructionEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL20isTopLevelPadForMSVCPKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24calculateSEHStateNumbersEPKNS_8FunctionERNS_13WinEHFuncInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm29calculateWinCXXEHStateNumbersEPKNS_8FunctionERNS_13WinEHFuncInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15addClrEHHandlerRN4llvm13WinEHFuncInfoEiiNS_14ClrHandlerTypeEjPKNS_10BasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm26calculateClrEHStateNumbersEPKNS_8FunctionERNS_13WinEHFuncInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare13colorFuncletsERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare20demotePHIsOnFuncletsERN4llvm8FunctionEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare17cloneCommonBlocksERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_112WinEHPrepare17cloneCommonBlocksERN4llvm8FunctionEENKUlPNS1_7PHINodeEbE_clES5_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare29removeImplausibleInstructionsERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare23cleanupPreparedFuncletsERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare22verifyPreparedFuncletsERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare17prepareExplicitEHERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare14insertPHILoadsEPN4llvm7PHINodeERNS1_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare15insertPHIStoresEPN4llvm7PHINodeEPNS1_10AllocaInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare14insertPHIStoreEPN4llvm10BasicBlockEPNS1_5ValueEPNS1_10AllocaInstERNS1_15SmallVectorImplISt4pairIS3_S5_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_112WinEHPrepare18replaceUseWithLoadEPN4llvm5ValueERNS1_3UseERPNS1_10AllocaInstERNS1_8DenseMapIPNS1_10BasicBlockES3_NS1_12DenseMapInfoISB_vEENS1_6detail12DenseMapPairISB_S3_EEEERNS1_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13WinEHFuncInfo17addIPToStateRangeEPKNS_10InvokeInstEPNS_8MCSymbolES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13WinEHFuncInfo17addIPToStateRangeEiPNS_8MCSymbolES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm13WinEHFuncInfoC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- WinEHPrepare - Prepare exception handling for code generation ---===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- WinEHPrepare - Prepare exception handling for code generation ---===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass lowers LLVM IR exception handling into something closer to what the</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass lowers LLVM IR exception handling into something closer to what the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// backend wants for functions using a personality function from a runtime</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// backend wants for functions using a personality function from a runtime</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// provided by MSVC. Functions with other personality functions are left alone</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// provided by MSVC. Functions with other personality functions are left alone</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// and may be prepared by other passes. In particular, all supported MSVC</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// and may be prepared by other passes. In particular, all supported MSVC</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">// personality functions require cleanup code to be outlined, and the C++</td>
    <td class="lineNumber">13</td>
    <td class="codeline">// personality functions require cleanup code to be outlined, and the C++</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// personality requires catch handler code to be outlined.</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// personality requires catch handler code to be outlined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">//</td>
    <td class="lineNumber">15</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">16</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline"></td>
    <td class="lineNumber">17</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/MapVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/Passes.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/Passes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/WinEHFuncInfo.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/WinEHFuncInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/IR/EHPersonalities.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/IR/EHPersonalities.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/Verifier.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/Verifier.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/TargetParser/Triple.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/TargetParser/Triple.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Cloning.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Cloning.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/Transforms/Utils/SSAUpdater.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/Transforms/Utils/SSAUpdater.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline"></td>
    <td class="lineNumber">38</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline"></td>
    <td class="lineNumber">40</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#define DEBUG_TYPE "winehprepare"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#define DEBUG_TYPE "winehprepare"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline"></td>
    <td class="lineNumber">42</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">static cl::opt<bool> DisableDemotion(</td>
    <td class="lineNumber">43</td>
    <td class="codeline">static cl::opt<bool> DisableDemotion(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">    "disable-demotion", cl::Hidden,</td>
    <td class="lineNumber">44</td>
    <td class="codeline">    "disable-demotion", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">    cl::desc(</td>
    <td class="lineNumber">45</td>
    <td class="codeline">    cl::desc(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">        "Clone multicolor basic blocks but do not demote cross scopes"),</td>
    <td class="lineNumber">46</td>
    <td class="codeline">        "Clone multicolor basic blocks but do not demote cross scopes"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">    cl::init(false));</td>
    <td class="lineNumber">47</td>
    <td class="codeline">    cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline"></td>
    <td class="lineNumber">48</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">static cl::opt<bool> DisableCleanups(</td>
    <td class="lineNumber">49</td>
    <td class="codeline">static cl::opt<bool> DisableCleanups(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">    "disable-cleanups", cl::Hidden,</td>
    <td class="lineNumber">50</td>
    <td class="codeline">    "disable-cleanups", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">    cl::desc("Do not remove implausible terminators or other similar cleanups"),</td>
    <td class="lineNumber">51</td>
    <td class="codeline">    cl::desc("Do not remove implausible terminators or other similar cleanups"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">    cl::init(false));</td>
    <td class="lineNumber">52</td>
    <td class="codeline">    cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">static cl::opt<bool> DemoteCatchSwitchPHIOnlyOpt(</td>
    <td class="lineNumber">54</td>
    <td class="codeline">static cl::opt<bool> DemoteCatchSwitchPHIOnlyOpt(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">    "demote-catchswitch-only", cl::Hidden,</td>
    <td class="lineNumber">55</td>
    <td class="codeline">    "demote-catchswitch-only", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">    cl::desc("Demote catchswitch BBs only (for wasm EH)"), cl::init(false));</td>
    <td class="lineNumber">56</td>
    <td class="codeline">    cl::desc("Demote catchswitch BBs only (for wasm EH)"), cl::init(false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">58</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">class WinEHPrepare : public FunctionPass {</td>
    <td class="lineNumber">60</td>
    <td class="codeline">class WinEHPrepare : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">61</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">  static char ID; // Pass identification, replacement for typeid.</td>
    <td class="lineNumber">62</td>
    <td class="codeline">  static char ID; // Pass identification, replacement for typeid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">  WinEHPrepare(bool DemoteCatchSwitchPHIOnly = false)</td>
    <td class="lineNumber">63</td>
    <td class="codeline">  WinEHPrepare(bool DemoteCatchSwitchPHIOnly = false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">      : FunctionPass(ID), DemoteCatchSwitchPHIOnly(DemoteCatchSwitchPHIOnly) {}</td>
    <td class="lineNumber">64</td>
    <td class="codeline">      : FunctionPass(ID), DemoteCatchSwitchPHIOnly(DemoteCatchSwitchPHIOnly) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">  bool runOnFunction(Function &Fn) override;</td>
    <td class="lineNumber">66</td>
    <td class="codeline">  bool runOnFunction(Function &Fn) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline"></td>
    <td class="lineNumber">67</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  bool doFinalization(Module &M) override;</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  bool doFinalization(Module &M) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">70</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
    <td class="lineNumber">72</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">    return "Windows exception handling preparation";</td>
    <td class="lineNumber">73</td>
    <td class="codeline">    return "Windows exception handling preparation";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">74</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
    <td class="lineNumber">75</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">76</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">  void insertPHIStores(PHINode *OriginalPHI, AllocaInst *SpillSlot);</td>
    <td class="lineNumber">77</td>
    <td class="codeline">  void insertPHIStores(PHINode *OriginalPHI, AllocaInst *SpillSlot);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">  void</td>
    <td class="lineNumber">78</td>
    <td class="codeline">  void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  insertPHIStore(BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  insertPHIStore(BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">                 SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist);</td>
    <td class="lineNumber">80</td>
    <td class="codeline">                 SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  AllocaInst *insertPHILoads(PHINode *PN, Function &F);</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  AllocaInst *insertPHILoads(PHINode *PN, Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  void replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  void replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">                          DenseMap<BasicBlock *, Value *> &Loads, Function &F);</td>
    <td class="lineNumber">83</td>
    <td class="codeline">                          DenseMap<BasicBlock *, Value *> &Loads, Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  bool prepareExplicitEH(Function &F);</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  bool prepareExplicitEH(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  void colorFunclets(Function &F);</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  void colorFunclets(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline"></td>
    <td class="lineNumber">86</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  void demotePHIsOnFunclets(Function &F, bool DemoteCatchSwitchPHIOnly);</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  void demotePHIsOnFunclets(Function &F, bool DemoteCatchSwitchPHIOnly);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">  void cloneCommonBlocks(Function &F);</td>
    <td class="lineNumber">88</td>
    <td class="codeline">  void cloneCommonBlocks(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  void removeImplausibleInstructions(Function &F);</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  void removeImplausibleInstructions(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  void cleanupPreparedFunclets(Function &F);</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  void cleanupPreparedFunclets(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">  void verifyPreparedFunclets(Function &F);</td>
    <td class="lineNumber">91</td>
    <td class="codeline">  void verifyPreparedFunclets(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  bool DemoteCatchSwitchPHIOnly;</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  bool DemoteCatchSwitchPHIOnly;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  // All fields are reset by runOnFunction.</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  // All fields are reset by runOnFunction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  EHPersonality Personality = EHPersonality::Unknown;</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  EHPersonality Personality = EHPersonality::Unknown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  const DataLayout *DL = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  DenseMap<BasicBlock *, ColorVector> BlockColors;</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  DenseMap<BasicBlock *, ColorVector> BlockColors;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  MapVector<BasicBlock *, std::vector<BasicBlock *>> FuncletBlocks;</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  MapVector<BasicBlock *, std::vector<BasicBlock *>> FuncletBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">};</td>
    <td class="lineNumber">101</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">103</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline"></td>
    <td class="lineNumber">104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">char WinEHPrepare::ID = 0;</td>
    <td class="lineNumber">105</td>
    <td class="codeline">char WinEHPrepare::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">INITIALIZE_PASS(WinEHPrepare, DEBUG_TYPE, "Prepare Windows exceptions",</td>
    <td class="lineNumber">106</td>
    <td class="codeline">INITIALIZE_PASS(WinEHPrepare, DEBUG_TYPE, "Prepare Windows exceptions",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">                false, false)</td>
    <td class="lineNumber">107</td>
    <td class="codeline">                false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline"></td>
    <td class="lineNumber">108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">FunctionPass *llvm::createWinEHPass(bool DemoteCatchSwitchPHIOnly) {</td>
    <td class="lineNumber">109</td>
    <td class="codeline">FunctionPass *llvm::createWinEHPass(bool DemoteCatchSwitchPHIOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  return new WinEHPrepare(DemoteCatchSwitchPHIOnly);</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  return new WinEHPrepare(DemoteCatchSwitchPHIOnly);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">}</td>
    <td class="lineNumber">111</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline"></td>
    <td class="lineNumber">112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">bool WinEHPrepare::runOnFunction(Function &Fn) {</td>
    <td class="lineNumber">113</td>
    <td class="codeline">bool WinEHPrepare::runOnFunction(Function &Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  if (!Fn.hasPersonalityFn())</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  if (!Fn.hasPersonalityFn())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">115</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  // Classify the personality to see what kind of preparation we need.</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  // Classify the personality to see what kind of preparation we need.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  Personality = classifyEHPersonality(Fn.getPersonalityFn());</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  Personality = classifyEHPersonality(Fn.getPersonalityFn());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  // Do nothing if this is not a scope-based personality.</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  // Do nothing if this is not a scope-based personality.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  if (!isScopedEHPersonality(Personality))</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  if (!isScopedEHPersonality(Personality))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">122</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  DL = &Fn.getParent()->getDataLayout();</td>
    <td class="lineNumber">124</td>
    <td class="codeline">  DL = &Fn.getParent()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  return prepareExplicitEH(Fn);</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  return prepareExplicitEH(Fn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">}</td>
    <td class="lineNumber">126</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">bool WinEHPrepare::doFinalization(Module &M) { return false; }</td>
    <td class="lineNumber">128</td>
    <td class="codeline">bool WinEHPrepare::doFinalization(Module &M) { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">void WinEHPrepare::getAnalysisUsage(AnalysisUsage &AU) const {}</td>
    <td class="lineNumber">130</td>
    <td class="codeline">void WinEHPrepare::getAnalysisUsage(AnalysisUsage &AU) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
    <td class="lineNumber">131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">static int addUnwindMapEntry(WinEHFuncInfo &FuncInfo, int ToState,</td>
    <td class="lineNumber">132</td>
    <td class="codeline">static int addUnwindMapEntry(WinEHFuncInfo &FuncInfo, int ToState,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">                             const BasicBlock *BB) {</td>
    <td class="lineNumber">133</td>
    <td class="codeline">                             const BasicBlock *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  CxxUnwindMapEntry UME;</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  CxxUnwindMapEntry UME;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  UME.ToState = ToState;</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  UME.ToState = ToState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  UME.Cleanup = BB;</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  UME.Cleanup = BB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">  FuncInfo.CxxUnwindMap.push_back(UME);</td>
    <td class="lineNumber">137</td>
    <td class="codeline">  FuncInfo.CxxUnwindMap.push_back(UME);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  return FuncInfo.getLastStateNumber();</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  return FuncInfo.getLastStateNumber();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">}</td>
    <td class="lineNumber">139</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline"></td>
    <td class="lineNumber">140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">static void addTryBlockMapEntry(WinEHFuncInfo &FuncInfo, int TryLow,</td>
    <td class="lineNumber">141</td>
    <td class="codeline">static void addTryBlockMapEntry(WinEHFuncInfo &FuncInfo, int TryLow,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">                                int TryHigh, int CatchHigh,</td>
    <td class="lineNumber">142</td>
    <td class="codeline">                                int TryHigh, int CatchHigh,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">                                ArrayRef<const CatchPadInst *> Handlers) {</td>
    <td class="lineNumber">143</td>
    <td class="codeline">                                ArrayRef<const CatchPadInst *> Handlers) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  WinEHTryBlockMapEntry TBME;</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  WinEHTryBlockMapEntry TBME;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  TBME.TryLow = TryLow;</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  TBME.TryLow = TryLow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  TBME.TryHigh = TryHigh;</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  TBME.TryHigh = TryHigh;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  TBME.CatchHigh = CatchHigh;</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  TBME.CatchHigh = CatchHigh;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  assert(TBME.TryLow <= TBME.TryHigh);</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  assert(TBME.TryLow <= TBME.TryHigh);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  for (const CatchPadInst *CPI : Handlers) {</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  for (const CatchPadInst *CPI : Handlers) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">    WinEHHandlerType HT;</td>
    <td class="lineNumber">150</td>
    <td class="codeline">    WinEHHandlerType HT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    Constant *TypeInfo = cast<Constant>(CPI->getArgOperand(0));</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    Constant *TypeInfo = cast<Constant>(CPI->getArgOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">    if (TypeInfo->isNullValue())</td>
    <td class="lineNumber">152</td>
    <td class="codeline">    if (TypeInfo->isNullValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">      HT.TypeDescriptor = nullptr;</td>
    <td class="lineNumber">153</td>
    <td class="codeline">      HT.TypeDescriptor = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">154</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">      HT.TypeDescriptor = cast<GlobalVariable>(TypeInfo->stripPointerCasts());</td>
    <td class="lineNumber">155</td>
    <td class="codeline">      HT.TypeDescriptor = cast<GlobalVariable>(TypeInfo->stripPointerCasts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">    HT.Adjectives = cast<ConstantInt>(CPI->getArgOperand(1))->getZExtValue();</td>
    <td class="lineNumber">156</td>
    <td class="codeline">    HT.Adjectives = cast<ConstantInt>(CPI->getArgOperand(1))->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">    HT.Handler = CPI->getParent();</td>
    <td class="lineNumber">157</td>
    <td class="codeline">    HT.Handler = CPI->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">    if (auto *AI =</td>
    <td class="lineNumber">158</td>
    <td class="codeline">    if (auto *AI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">            dyn_cast<AllocaInst>(CPI->getArgOperand(2)->stripPointerCasts()))</td>
    <td class="lineNumber">159</td>
    <td class="codeline">            dyn_cast<AllocaInst>(CPI->getArgOperand(2)->stripPointerCasts()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">      HT.CatchObj.Alloca = AI;</td>
    <td class="lineNumber">160</td>
    <td class="codeline">      HT.CatchObj.Alloca = AI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">161</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">      HT.CatchObj.Alloca = nullptr;</td>
    <td class="lineNumber">162</td>
    <td class="codeline">      HT.CatchObj.Alloca = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">    TBME.HandlerArray.push_back(HT);</td>
    <td class="lineNumber">163</td>
    <td class="codeline">    TBME.HandlerArray.push_back(HT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  FuncInfo.TryBlockMap.push_back(TBME);</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  FuncInfo.TryBlockMap.push_back(TBME);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">}</td>
    <td class="lineNumber">166</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">static BasicBlock *getCleanupRetUnwindDest(const CleanupPadInst *CleanupPad) {</td>
    <td class="lineNumber">168</td>
    <td class="codeline">static BasicBlock *getCleanupRetUnwindDest(const CleanupPadInst *CleanupPad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  for (const User *U : CleanupPad->users())</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  for (const User *U : CleanupPad->users())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">    if (const auto *CRI = dyn_cast<CleanupReturnInst>(U))</td>
    <td class="lineNumber">170</td>
    <td class="codeline">    if (const auto *CRI = dyn_cast<CleanupReturnInst>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">      return CRI->getUnwindDest();</td>
    <td class="lineNumber">171</td>
    <td class="codeline">      return CRI->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">}</td>
    <td class="lineNumber">173</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">static void calculateStateNumbersForInvokes(const Function *Fn,</td>
    <td class="lineNumber">175</td>
    <td class="codeline">static void calculateStateNumbersForInvokes(const Function *Fn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">                                            WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">176</td>
    <td class="codeline">                                            WinEHFuncInfo &FuncInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  auto *F = const_cast<Function *>(Fn);</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  auto *F = const_cast<Function *>(Fn);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  DenseMap<BasicBlock *, ColorVector> BlockColors = colorEHFunclets(*F);</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  DenseMap<BasicBlock *, ColorVector> BlockColors = colorEHFunclets(*F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  for (BasicBlock &BB : *F) {</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  for (BasicBlock &BB : *F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">    auto *II = dyn_cast<InvokeInst>(BB.getTerminator());</td>
    <td class="lineNumber">180</td>
    <td class="codeline">    auto *II = dyn_cast<InvokeInst>(BB.getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">    if (!II)</td>
    <td class="lineNumber">181</td>
    <td class="codeline">    if (!II)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">182</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline"></td>
    <td class="lineNumber">183</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">    auto &BBColors = BlockColors[&BB];</td>
    <td class="lineNumber">184</td>
    <td class="codeline">    auto &BBColors = BlockColors[&BB];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">    assert(BBColors.size() == 1 && "multi-color BB not removed by preparation");</td>
    <td class="lineNumber">185</td>
    <td class="codeline">    assert(BBColors.size() == 1 && "multi-color BB not removed by preparation");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">    BasicBlock *FuncletEntryBB = BBColors.front();</td>
    <td class="lineNumber">186</td>
    <td class="codeline">    BasicBlock *FuncletEntryBB = BBColors.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    BasicBlock *FuncletUnwindDest;</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    BasicBlock *FuncletUnwindDest;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">    auto *FuncletPad =</td>
    <td class="lineNumber">189</td>
    <td class="codeline">    auto *FuncletPad =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">        dyn_cast<FuncletPadInst>(FuncletEntryBB->getFirstNonPHI());</td>
    <td class="lineNumber">190</td>
    <td class="codeline">        dyn_cast<FuncletPadInst>(FuncletEntryBB->getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">    assert(FuncletPad || FuncletEntryBB == &Fn->getEntryBlock());</td>
    <td class="lineNumber">191</td>
    <td class="codeline">    assert(FuncletPad || FuncletEntryBB == &Fn->getEntryBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">    if (!FuncletPad)</td>
    <td class="lineNumber">192</td>
    <td class="codeline">    if (!FuncletPad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">      FuncletUnwindDest = nullptr;</td>
    <td class="lineNumber">193</td>
    <td class="codeline">      FuncletUnwindDest = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">    else if (auto *CatchPad = dyn_cast<CatchPadInst>(FuncletPad))</td>
    <td class="lineNumber">194</td>
    <td class="codeline">    else if (auto *CatchPad = dyn_cast<CatchPadInst>(FuncletPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">      FuncletUnwindDest = CatchPad->getCatchSwitch()->getUnwindDest();</td>
    <td class="lineNumber">195</td>
    <td class="codeline">      FuncletUnwindDest = CatchPad->getCatchSwitch()->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    else if (auto *CleanupPad = dyn_cast<CleanupPadInst>(FuncletPad))</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    else if (auto *CleanupPad = dyn_cast<CleanupPadInst>(FuncletPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">      FuncletUnwindDest = getCleanupRetUnwindDest(CleanupPad);</td>
    <td class="lineNumber">197</td>
    <td class="codeline">      FuncletUnwindDest = getCleanupRetUnwindDest(CleanupPad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">198</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">      llvm_unreachable("unexpected funclet pad!");</td>
    <td class="lineNumber">199</td>
    <td class="codeline">      llvm_unreachable("unexpected funclet pad!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">    BasicBlock *InvokeUnwindDest = II->getUnwindDest();</td>
    <td class="lineNumber">201</td>
    <td class="codeline">    BasicBlock *InvokeUnwindDest = II->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    int BaseState = -1;</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    int BaseState = -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">    if (FuncletUnwindDest == InvokeUnwindDest) {</td>
    <td class="lineNumber">203</td>
    <td class="codeline">    if (FuncletUnwindDest == InvokeUnwindDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">      auto BaseStateI = FuncInfo.FuncletBaseStateMap.find(FuncletPad);</td>
    <td class="lineNumber">204</td>
    <td class="codeline">      auto BaseStateI = FuncInfo.FuncletBaseStateMap.find(FuncletPad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">      if (BaseStateI != FuncInfo.FuncletBaseStateMap.end())</td>
    <td class="lineNumber">205</td>
    <td class="codeline">      if (BaseStateI != FuncInfo.FuncletBaseStateMap.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">        BaseState = BaseStateI->second;</td>
    <td class="lineNumber">206</td>
    <td class="codeline">        BaseState = BaseStateI->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">207</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline"></td>
    <td class="lineNumber">208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    if (BaseState != -1) {</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    if (BaseState != -1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">      FuncInfo.InvokeStateMap[II] = BaseState;</td>
    <td class="lineNumber">210</td>
    <td class="codeline">      FuncInfo.InvokeStateMap[II] = BaseState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">211</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">      Instruction *PadInst = InvokeUnwindDest->getFirstNonPHI();</td>
    <td class="lineNumber">212</td>
    <td class="codeline">      Instruction *PadInst = InvokeUnwindDest->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">      assert(FuncInfo.EHPadStateMap.count(PadInst) && "EH Pad has no state!");</td>
    <td class="lineNumber">213</td>
    <td class="codeline">      assert(FuncInfo.EHPadStateMap.count(PadInst) && "EH Pad has no state!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">      FuncInfo.InvokeStateMap[II] = FuncInfo.EHPadStateMap[PadInst];</td>
    <td class="lineNumber">214</td>
    <td class="codeline">      FuncInfo.InvokeStateMap[II] = FuncInfo.EHPadStateMap[PadInst];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">215</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">}</td>
    <td class="lineNumber">217</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">// See comments below for calculateSEHStateForAsynchEH().</td>
    <td class="lineNumber">219</td>
    <td class="codeline">// See comments below for calculateSEHStateForAsynchEH().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">// State - incoming State of normal paths</td>
    <td class="lineNumber">220</td>
    <td class="codeline">// State - incoming State of normal paths</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">struct WorkItem {</td>
    <td class="lineNumber">221</td>
    <td class="codeline">struct WorkItem {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  const BasicBlock *Block;</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  const BasicBlock *Block;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  int State;</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  int State;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  WorkItem(const BasicBlock *BB, int St) {</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  WorkItem(const BasicBlock *BB, int St) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    Block = BB;</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    Block = BB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">    State = St;</td>
    <td class="lineNumber">226</td>
    <td class="codeline">    State = St;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">};</td>
    <td class="lineNumber">228</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">void llvm::calculateCXXStateForAsynchEH(const BasicBlock *BB, int State,</td>
    <td class="lineNumber">229</td>
    <td class="codeline">void llvm::calculateCXXStateForAsynchEH(const BasicBlock *BB, int State,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">                                        WinEHFuncInfo &EHInfo) {</td>
    <td class="lineNumber">230</td>
    <td class="codeline">                                        WinEHFuncInfo &EHInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  SmallVector<struct WorkItem *, 8> WorkList;</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  SmallVector<struct WorkItem *, 8> WorkList;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  struct WorkItem *WI = new WorkItem(BB, State);</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  struct WorkItem *WI = new WorkItem(BB, State);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  WorkList.push_back(WI);</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  WorkList.push_back(WI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  while (!WorkList.empty()) {</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  while (!WorkList.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    WI = WorkList.pop_back_val();</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    WI = WorkList.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">    const BasicBlock *BB = WI->Block;</td>
    <td class="lineNumber">237</td>
    <td class="codeline">    const BasicBlock *BB = WI->Block;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">    int State = WI->State;</td>
    <td class="lineNumber">238</td>
    <td class="codeline">    int State = WI->State;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    delete WI;</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    delete WI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
    <td class="lineNumber">240</td>
    <td class="codeline">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">      continue; // skip blocks already visited by lower State</td>
    <td class="lineNumber">241</td>
    <td class="codeline">      continue; // skip blocks already visited by lower State</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline"></td>
    <td class="lineNumber">242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">    const llvm::Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">244</td>
    <td class="codeline">    const llvm::Instruction *TI = BB->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">    if (I->isEHPad())</td>
    <td class="lineNumber">245</td>
    <td class="codeline">    if (I->isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">      State = EHInfo.EHPadStateMap[I];</td>
    <td class="lineNumber">246</td>
    <td class="codeline">      State = EHInfo.EHPadStateMap[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    EHInfo.BlockToStateMap[BB] = State; // Record state, also flag visiting</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    EHInfo.BlockToStateMap[BB] = State; // Record state, also flag visiting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">    if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) && State > 0) {</td>
    <td class="lineNumber">249</td>
    <td class="codeline">    if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) && State > 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">      // Retrive the new State</td>
    <td class="lineNumber">250</td>
    <td class="codeline">      // Retrive the new State</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">      State = EHInfo.CxxUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">251</td>
    <td class="codeline">      State = EHInfo.CxxUnwindMap[State].ToState; // Retrive next State</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">    } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">252</td>
    <td class="codeline">    } else if (isa<InvokeInst>(TI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">      auto *Call = cast<CallBase>(TI);</td>
    <td class="lineNumber">253</td>
    <td class="codeline">      auto *Call = cast<CallBase>(TI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">      const Function *Fn = Call->getCalledFunction();</td>
    <td class="lineNumber">254</td>
    <td class="codeline">      const Function *Fn = Call->getCalledFunction();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">      if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">255</td>
    <td class="codeline">      if (Fn && Fn->isIntrinsic() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">          (Fn->getIntrinsicID() == Intrinsic::seh_scope_begin ||</td>
    <td class="lineNumber">256</td>
    <td class="codeline">          (Fn->getIntrinsicID() == Intrinsic::seh_scope_begin ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">           Fn->getIntrinsicID() == Intrinsic::seh_try_begin))</td>
    <td class="lineNumber">257</td>
    <td class="codeline">           Fn->getIntrinsicID() == Intrinsic::seh_try_begin))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">        // Retrive the new State from seh_scope_begin</td>
    <td class="lineNumber">258</td>
    <td class="codeline">        // Retrive the new State from seh_scope_begin</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">259</td>
    <td class="codeline">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">      else if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">260</td>
    <td class="codeline">      else if (Fn && Fn->isIntrinsic() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">               (Fn->getIntrinsicID() == Intrinsic::seh_scope_end ||</td>
    <td class="lineNumber">261</td>
    <td class="codeline">               (Fn->getIntrinsicID() == Intrinsic::seh_scope_end ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">                Fn->getIntrinsicID() == Intrinsic::seh_try_end)) {</td>
    <td class="lineNumber">262</td>
    <td class="codeline">                Fn->getIntrinsicID() == Intrinsic::seh_try_end)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">        // In case of conditional ctor, let's retrieve State from Invoke</td>
    <td class="lineNumber">263</td>
    <td class="codeline">        // In case of conditional ctor, let's retrieve State from Invoke</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">264</td>
    <td class="codeline">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">        // end of current state, retrive new state from UnwindMap</td>
    <td class="lineNumber">265</td>
    <td class="codeline">        // end of current state, retrive new state from UnwindMap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">        State = EHInfo.CxxUnwindMap[State].ToState;</td>
    <td class="lineNumber">266</td>
    <td class="codeline">        State = EHInfo.CxxUnwindMap[State].ToState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">267</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">    // Continue push successors into worklist</td>
    <td class="lineNumber">269</td>
    <td class="codeline">    // Continue push successors into worklist</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">    for (auto *SuccBB : successors(BB)) {</td>
    <td class="lineNumber">270</td>
    <td class="codeline">    for (auto *SuccBB : successors(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">      WI = new WorkItem(SuccBB, State);</td>
    <td class="lineNumber">271</td>
    <td class="codeline">      WI = new WorkItem(SuccBB, State);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">      WorkList.push_back(WI);</td>
    <td class="lineNumber">272</td>
    <td class="codeline">      WorkList.push_back(WI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">273</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">}</td>
    <td class="lineNumber">275</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline"></td>
    <td class="lineNumber">276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">// The central theory of this routine is based on the following:</td>
    <td class="lineNumber">277</td>
    <td class="codeline">// The central theory of this routine is based on the following:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">//   A _try scope is always a SEME (Single Entry Multiple Exits) region</td>
    <td class="lineNumber">278</td>
    <td class="codeline">//   A _try scope is always a SEME (Single Entry Multiple Exits) region</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">//     as jumping into a _try is not allowed</td>
    <td class="lineNumber">279</td>
    <td class="codeline">//     as jumping into a _try is not allowed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">//   The single entry must start with a seh_try_begin() invoke with a</td>
    <td class="lineNumber">280</td>
    <td class="codeline">//   The single entry must start with a seh_try_begin() invoke with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">//     correct State number that is the initial state of the SEME.</td>
    <td class="lineNumber">281</td>
    <td class="codeline">//     correct State number that is the initial state of the SEME.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">//   Through control-flow, state number is propagated into all blocks.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">//   Through control-flow, state number is propagated into all blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">//   Side exits marked by seh_try_end() will unwind to parent state via</td>
    <td class="lineNumber">283</td>
    <td class="codeline">//   Side exits marked by seh_try_end() will unwind to parent state via</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">//     existing SEHUnwindMap[].</td>
    <td class="lineNumber">284</td>
    <td class="codeline">//     existing SEHUnwindMap[].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">//   Side exits can ONLY jump into parent scopes (lower state number).</td>
    <td class="lineNumber">285</td>
    <td class="codeline">//   Side exits can ONLY jump into parent scopes (lower state number).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">//   Thus, when a block succeeds various states from its predecessors,</td>
    <td class="lineNumber">286</td>
    <td class="codeline">//   Thus, when a block succeeds various states from its predecessors,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">//     the lowest State trumphs others.</td>
    <td class="lineNumber">287</td>
    <td class="codeline">//     the lowest State trumphs others.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">//   If some exits flow to unreachable, propagation on those paths terminate,</td>
    <td class="lineNumber">288</td>
    <td class="codeline">//   If some exits flow to unreachable, propagation on those paths terminate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">//     not affecting remaining blocks.</td>
    <td class="lineNumber">289</td>
    <td class="codeline">//     not affecting remaining blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">void llvm::calculateSEHStateForAsynchEH(const BasicBlock *BB, int State,</td>
    <td class="lineNumber">290</td>
    <td class="codeline">void llvm::calculateSEHStateForAsynchEH(const BasicBlock *BB, int State,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">                                        WinEHFuncInfo &EHInfo) {</td>
    <td class="lineNumber">291</td>
    <td class="codeline">                                        WinEHFuncInfo &EHInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  SmallVector<struct WorkItem *, 8> WorkList;</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  SmallVector<struct WorkItem *, 8> WorkList;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  struct WorkItem *WI = new WorkItem(BB, State);</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  struct WorkItem *WI = new WorkItem(BB, State);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  WorkList.push_back(WI);</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  WorkList.push_back(WI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  while (!WorkList.empty()) {</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  while (!WorkList.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">    WI = WorkList.pop_back_val();</td>
    <td class="lineNumber">297</td>
    <td class="codeline">    WI = WorkList.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">    const BasicBlock *BB = WI->Block;</td>
    <td class="lineNumber">298</td>
    <td class="codeline">    const BasicBlock *BB = WI->Block;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">    int State = WI->State;</td>
    <td class="lineNumber">299</td>
    <td class="codeline">    int State = WI->State;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">    delete WI;</td>
    <td class="lineNumber">300</td>
    <td class="codeline">    delete WI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
    <td class="lineNumber">301</td>
    <td class="codeline">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">      continue; // skip blocks already visited by lower State</td>
    <td class="lineNumber">302</td>
    <td class="codeline">      continue; // skip blocks already visited by lower State</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline"></td>
    <td class="lineNumber">303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    const llvm::Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    const llvm::Instruction *TI = BB->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    if (I->isEHPad())</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    if (I->isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">      State = EHInfo.EHPadStateMap[I];</td>
    <td class="lineNumber">307</td>
    <td class="codeline">      State = EHInfo.EHPadStateMap[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    EHInfo.BlockToStateMap[BB] = State; // Record state</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    EHInfo.BlockToStateMap[BB] = State; // Record state</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
    <td class="lineNumber">309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    if (isa<CatchPadInst>(I) && isa<CatchReturnInst>(TI)) {</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    if (isa<CatchPadInst>(I) && isa<CatchReturnInst>(TI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">      const Constant *FilterOrNull = cast<Constant>(</td>
    <td class="lineNumber">311</td>
    <td class="codeline">      const Constant *FilterOrNull = cast<Constant>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">          cast<CatchPadInst>(I)->getArgOperand(0)->stripPointerCasts());</td>
    <td class="lineNumber">312</td>
    <td class="codeline">          cast<CatchPadInst>(I)->getArgOperand(0)->stripPointerCasts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">      const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
    <td class="lineNumber">313</td>
    <td class="codeline">      const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">      if (!Filter || !Filter->getName().startswith("__IsLocalUnwind"))</td>
    <td class="lineNumber">314</td>
    <td class="codeline">      if (!Filter || !Filter->getName().startswith("__IsLocalUnwind"))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">        State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">315</td>
    <td class="codeline">        State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">    } else if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) &&</td>
    <td class="lineNumber">316</td>
    <td class="codeline">    } else if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">               State > 0) {</td>
    <td class="lineNumber">317</td>
    <td class="codeline">               State > 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">      // Retrive the new State.</td>
    <td class="lineNumber">318</td>
    <td class="codeline">      // Retrive the new State.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">      State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">319</td>
    <td class="codeline">      State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    } else if (isa<InvokeInst>(TI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">      auto *Call = cast<CallBase>(TI);</td>
    <td class="lineNumber">321</td>
    <td class="codeline">      auto *Call = cast<CallBase>(TI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">      const Function *Fn = Call->getCalledFunction();</td>
    <td class="lineNumber">322</td>
    <td class="codeline">      const Function *Fn = Call->getCalledFunction();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">      if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">323</td>
    <td class="codeline">      if (Fn && Fn->isIntrinsic() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">          Fn->getIntrinsicID() == Intrinsic::seh_try_begin)</td>
    <td class="lineNumber">324</td>
    <td class="codeline">          Fn->getIntrinsicID() == Intrinsic::seh_try_begin)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">        // Retrive the new State from seh_try_begin</td>
    <td class="lineNumber">325</td>
    <td class="codeline">        // Retrive the new State from seh_try_begin</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">326</td>
    <td class="codeline">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">      else if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">327</td>
    <td class="codeline">      else if (Fn && Fn->isIntrinsic() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">               Fn->getIntrinsicID() == Intrinsic::seh_try_end)</td>
    <td class="lineNumber">328</td>
    <td class="codeline">               Fn->getIntrinsicID() == Intrinsic::seh_try_end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">        // end of current state, retrive new state from UnwindMap</td>
    <td class="lineNumber">329</td>
    <td class="codeline">        // end of current state, retrive new state from UnwindMap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">        State = EHInfo.SEHUnwindMap[State].ToState;</td>
    <td class="lineNumber">330</td>
    <td class="codeline">        State = EHInfo.SEHUnwindMap[State].ToState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">331</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">    // Continue push successors into worklist</td>
    <td class="lineNumber">332</td>
    <td class="codeline">    // Continue push successors into worklist</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">    for (auto *SuccBB : successors(BB)) {</td>
    <td class="lineNumber">333</td>
    <td class="codeline">    for (auto *SuccBB : successors(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">      WI = new WorkItem(SuccBB, State);</td>
    <td class="lineNumber">334</td>
    <td class="codeline">      WI = new WorkItem(SuccBB, State);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">      WorkList.push_back(WI);</td>
    <td class="lineNumber">335</td>
    <td class="codeline">      WorkList.push_back(WI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">336</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">}</td>
    <td class="lineNumber">338</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline"></td>
    <td class="lineNumber">339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">// Given BB which ends in an unwind edge, return the EHPad that this BB belongs</td>
    <td class="lineNumber">340</td>
    <td class="codeline">// Given BB which ends in an unwind edge, return the EHPad that this BB belongs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">// to. If the unwind edge came from an invoke, return null.</td>
    <td class="lineNumber">341</td>
    <td class="codeline">// to. If the unwind edge came from an invoke, return null.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">static const BasicBlock *getEHPadFromPredecessor(const BasicBlock *BB,</td>
    <td class="lineNumber">342</td>
    <td class="codeline">static const BasicBlock *getEHPadFromPredecessor(const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">                                                 Value *ParentPad) {</td>
    <td class="lineNumber">343</td>
    <td class="codeline">                                                 Value *ParentPad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  const Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  const Instruction *TI = BB->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  if (isa<InvokeInst>(TI))</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  if (isa<InvokeInst>(TI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(TI)) {</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(TI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    if (CatchSwitch->getParentPad() != ParentPad)</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    if (CatchSwitch->getParentPad() != ParentPad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">349</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">    return BB;</td>
    <td class="lineNumber">350</td>
    <td class="codeline">    return BB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  assert(!TI->isEHPad() && "unexpected EHPad!");</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  assert(!TI->isEHPad() && "unexpected EHPad!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  auto *CleanupPad = cast<CleanupReturnInst>(TI)->getCleanupPad();</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  auto *CleanupPad = cast<CleanupReturnInst>(TI)->getCleanupPad();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  if (CleanupPad->getParentPad() != ParentPad)</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  if (CleanupPad->getParentPad() != ParentPad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">355</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  return CleanupPad->getParent();</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  return CleanupPad->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">}</td>
    <td class="lineNumber">357</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline"></td>
    <td class="lineNumber">358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">// Starting from a EHPad, Backward walk through control-flow graph</td>
    <td class="lineNumber">359</td>
    <td class="codeline">// Starting from a EHPad, Backward walk through control-flow graph</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">// to produce two primary outputs:</td>
    <td class="lineNumber">360</td>
    <td class="codeline">// to produce two primary outputs:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">//      FuncInfo.EHPadStateMap[] and FuncInfo.CxxUnwindMap[]</td>
    <td class="lineNumber">361</td>
    <td class="codeline">//      FuncInfo.EHPadStateMap[] and FuncInfo.CxxUnwindMap[]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">static void calculateCXXStateNumbers(WinEHFuncInfo &FuncInfo,</td>
    <td class="lineNumber">362</td>
    <td class="codeline">static void calculateCXXStateNumbers(WinEHFuncInfo &FuncInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">                                     const Instruction *FirstNonPHI,</td>
    <td class="lineNumber">363</td>
    <td class="codeline">                                     const Instruction *FirstNonPHI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">                                     int ParentState) {</td>
    <td class="lineNumber">364</td>
    <td class="codeline">                                     int ParentState) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  assert(BB->isEHPad() && "not a funclet!");</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  assert(BB->isEHPad() && "not a funclet!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
    <td class="lineNumber">369</td>
    <td class="codeline">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">           "shouldn't revist catch funclets!");</td>
    <td class="lineNumber">370</td>
    <td class="codeline">           "shouldn't revist catch funclets!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline"></td>
    <td class="lineNumber">371</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">    SmallVector<const CatchPadInst *, 2> Handlers;</td>
    <td class="lineNumber">372</td>
    <td class="codeline">    SmallVector<const CatchPadInst *, 2> Handlers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">    for (const BasicBlock *CatchPadBB : CatchSwitch->handlers()) {</td>
    <td class="lineNumber">373</td>
    <td class="codeline">    for (const BasicBlock *CatchPadBB : CatchSwitch->handlers()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">      auto *CatchPad = cast<CatchPadInst>(CatchPadBB->getFirstNonPHI());</td>
    <td class="lineNumber">374</td>
    <td class="codeline">      auto *CatchPad = cast<CatchPadInst>(CatchPadBB->getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">      Handlers.push_back(CatchPad);</td>
    <td class="lineNumber">375</td>
    <td class="codeline">      Handlers.push_back(CatchPad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">376</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">    int TryLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
    <td class="lineNumber">377</td>
    <td class="codeline">    int TryLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CatchSwitch] = TryLow;</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CatchSwitch] = TryLow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">379</td>
    <td class="codeline">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">380</td>
    <td class="codeline">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">                                               CatchSwitch->getParentPad())))</td>
    <td class="lineNumber">381</td>
    <td class="codeline">                                               CatchSwitch->getParentPad())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">382</td>
    <td class="codeline">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">                                 TryLow);</td>
    <td class="lineNumber">383</td>
    <td class="codeline">                                 TryLow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">    int CatchLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
    <td class="lineNumber">384</td>
    <td class="codeline">    int CatchLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    // catchpads are separate funclets in C++ EH due to the way rethrow works.</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    // catchpads are separate funclets in C++ EH due to the way rethrow works.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">    int TryHigh = CatchLow - 1;</td>
    <td class="lineNumber">387</td>
    <td class="codeline">    int TryHigh = CatchLow - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">    // MSVC FrameHandler3/4 on x64&Arm64 expect Catch Handlers in $tryMap$</td>
    <td class="lineNumber">389</td>
    <td class="codeline">    // MSVC FrameHandler3/4 on x64&Arm64 expect Catch Handlers in $tryMap$</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">    //  stored in pre-order (outer first, inner next), not post-order</td>
    <td class="lineNumber">390</td>
    <td class="codeline">    //  stored in pre-order (outer first, inner next), not post-order</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">    //  Add to map here.  Fix the CatchHigh after children are processed</td>
    <td class="lineNumber">391</td>
    <td class="codeline">    //  Add to map here.  Fix the CatchHigh after children are processed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">    const Module *Mod = BB->getParent()->getParent();</td>
    <td class="lineNumber">392</td>
    <td class="codeline">    const Module *Mod = BB->getParent()->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">    bool IsPreOrder = Triple(Mod->getTargetTriple()).isArch64Bit();</td>
    <td class="lineNumber">393</td>
    <td class="codeline">    bool IsPreOrder = Triple(Mod->getTargetTriple()).isArch64Bit();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">    if (IsPreOrder)</td>
    <td class="lineNumber">394</td>
    <td class="codeline">    if (IsPreOrder)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchLow, Handlers);</td>
    <td class="lineNumber">395</td>
    <td class="codeline">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchLow, Handlers);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">    unsigned TBMEIdx = FuncInfo.TryBlockMap.size() - 1;</td>
    <td class="lineNumber">396</td>
    <td class="codeline">    unsigned TBMEIdx = FuncInfo.TryBlockMap.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline"></td>
    <td class="lineNumber">397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">    for (const auto *CatchPad : Handlers) {</td>
    <td class="lineNumber">398</td>
    <td class="codeline">    for (const auto *CatchPad : Handlers) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">      FuncInfo.FuncletBaseStateMap[CatchPad] = CatchLow;</td>
    <td class="lineNumber">399</td>
    <td class="codeline">      FuncInfo.FuncletBaseStateMap[CatchPad] = CatchLow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">      FuncInfo.EHPadStateMap[CatchPad] = CatchLow;</td>
    <td class="lineNumber">400</td>
    <td class="codeline">      FuncInfo.EHPadStateMap[CatchPad] = CatchLow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">      for (const User *U : CatchPad->users()) {</td>
    <td class="lineNumber">401</td>
    <td class="codeline">      for (const User *U : CatchPad->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">        const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">402</td>
    <td class="codeline">        const auto *UserI = cast<Instruction>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">        if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
    <td class="lineNumber">403</td>
    <td class="codeline">        if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">          BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">404</td>
    <td class="codeline">          BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">405</td>
    <td class="codeline">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
    <td class="lineNumber">406</td>
    <td class="codeline">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">407</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">        if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
    <td class="lineNumber">408</td>
    <td class="codeline">        if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">          BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
    <td class="lineNumber">409</td>
    <td class="codeline">          BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">          // If a nested cleanup pad reports a null unwind destination and the</td>
    <td class="lineNumber">410</td>
    <td class="codeline">          // If a nested cleanup pad reports a null unwind destination and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">          // enclosing catch pad doesn't it must be post-dominated by an</td>
    <td class="lineNumber">411</td>
    <td class="codeline">          // enclosing catch pad doesn't it must be post-dominated by an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">          // unreachable instruction.</td>
    <td class="lineNumber">412</td>
    <td class="codeline">          // unreachable instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">413</td>
    <td class="codeline">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
    <td class="lineNumber">414</td>
    <td class="codeline">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">415</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">416</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">417</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">    int CatchHigh = FuncInfo.getLastStateNumber();</td>
    <td class="lineNumber">418</td>
    <td class="codeline">    int CatchHigh = FuncInfo.getLastStateNumber();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">    // Now child Catches are processed, update CatchHigh</td>
    <td class="lineNumber">419</td>
    <td class="codeline">    // Now child Catches are processed, update CatchHigh</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">    if (IsPreOrder)</td>
    <td class="lineNumber">420</td>
    <td class="codeline">    if (IsPreOrder)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">      FuncInfo.TryBlockMap[TBMEIdx].CatchHigh = CatchHigh;</td>
    <td class="lineNumber">421</td>
    <td class="codeline">      FuncInfo.TryBlockMap[TBMEIdx].CatchHigh = CatchHigh;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">    else // PostOrder</td>
    <td class="lineNumber">422</td>
    <td class="codeline">    else // PostOrder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchHigh, Handlers);</td>
    <td class="lineNumber">423</td>
    <td class="codeline">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchHigh, Handlers);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline"></td>
    <td class="lineNumber">424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "TryLow[" << BB->getName() << "]: " << TryLow << '\n');</td>
    <td class="lineNumber">425</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "TryLow[" << BB->getName() << "]: " << TryLow << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "TryHigh[" << BB->getName() << "]: " << TryHigh</td>
    <td class="lineNumber">426</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "TryHigh[" << BB->getName() << "]: " << TryHigh</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">                      << '\n');</td>
    <td class="lineNumber">427</td>
    <td class="codeline">                      << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "CatchHigh[" << BB->getName() << "]: " << CatchHigh</td>
    <td class="lineNumber">428</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "CatchHigh[" << BB->getName() << "]: " << CatchHigh</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">                      << '\n');</td>
    <td class="lineNumber">429</td>
    <td class="codeline">                      << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">431</td>
    <td class="codeline">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
    <td class="lineNumber">432</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
    <td class="lineNumber">433</td>
    <td class="codeline">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">    // cleanupret instructions.</td>
    <td class="lineNumber">434</td>
    <td class="codeline">    // cleanupret instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
    <td class="lineNumber">435</td>
    <td class="codeline">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">436</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">    int CleanupState = addUnwindMapEntry(FuncInfo, ParentState, BB);</td>
    <td class="lineNumber">438</td>
    <td class="codeline">    int CleanupState = addUnwindMapEntry(FuncInfo, ParentState, BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
    <td class="lineNumber">439</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
    <td class="lineNumber">440</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">                      << BB->getName() << '\n');</td>
    <td class="lineNumber">441</td>
    <td class="codeline">                      << BB->getName() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">    for (const BasicBlock *PredBlock : predecessors(BB)) {</td>
    <td class="lineNumber">442</td>
    <td class="codeline">    for (const BasicBlock *PredBlock : predecessors(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">443</td>
    <td class="codeline">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">                                               CleanupPad->getParentPad()))) {</td>
    <td class="lineNumber">444</td>
    <td class="codeline">                                               CleanupPad->getParentPad()))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">445</td>
    <td class="codeline">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">                                 CleanupState);</td>
    <td class="lineNumber">446</td>
    <td class="codeline">                                 CleanupState);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">447</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">448</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">    for (const User *U : CleanupPad->users()) {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">    for (const User *U : CleanupPad->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">450</td>
    <td class="codeline">      const auto *UserI = cast<Instruction>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">      if (UserI->isEHPad())</td>
    <td class="lineNumber">451</td>
    <td class="codeline">      if (UserI->isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">        report_fatal_error("Cleanup funclets for the MSVC++ personality cannot "</td>
    <td class="lineNumber">452</td>
    <td class="codeline">        report_fatal_error("Cleanup funclets for the MSVC++ personality cannot "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">                           "contain exceptional actions");</td>
    <td class="lineNumber">453</td>
    <td class="codeline">                           "contain exceptional actions");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">454</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">}</td>
    <td class="lineNumber">456</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">static int addSEHExcept(WinEHFuncInfo &FuncInfo, int ParentState,</td>
    <td class="lineNumber">458</td>
    <td class="codeline">static int addSEHExcept(WinEHFuncInfo &FuncInfo, int ParentState,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">                        const Function *Filter, const BasicBlock *Handler) {</td>
    <td class="lineNumber">459</td>
    <td class="codeline">                        const Function *Filter, const BasicBlock *Handler) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  SEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  SEHUnwindMapEntry Entry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  Entry.ToState = ParentState;</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  Entry.ToState = ParentState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  Entry.IsFinally = false;</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  Entry.IsFinally = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  Entry.Filter = Filter;</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  Entry.Filter = Filter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  Entry.Handler = Handler;</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  Entry.Handler = Handler;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">}</td>
    <td class="lineNumber">467</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline"></td>
    <td class="lineNumber">468</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">static int addSEHFinally(WinEHFuncInfo &FuncInfo, int ParentState,</td>
    <td class="lineNumber">469</td>
    <td class="codeline">static int addSEHFinally(WinEHFuncInfo &FuncInfo, int ParentState,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">                         const BasicBlock *Handler) {</td>
    <td class="lineNumber">470</td>
    <td class="codeline">                         const BasicBlock *Handler) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">  SEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">471</td>
    <td class="codeline">  SEHUnwindMapEntry Entry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  Entry.ToState = ParentState;</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  Entry.ToState = ParentState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  Entry.IsFinally = true;</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  Entry.IsFinally = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  Entry.Filter = nullptr;</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  Entry.Filter = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  Entry.Handler = Handler;</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  Entry.Handler = Handler;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">}</td>
    <td class="lineNumber">478</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline"></td>
    <td class="lineNumber">479</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">// Starting from a EHPad, Backward walk through control-flow graph</td>
    <td class="lineNumber">480</td>
    <td class="codeline">// Starting from a EHPad, Backward walk through control-flow graph</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">// to produce two primary outputs:</td>
    <td class="lineNumber">481</td>
    <td class="codeline">// to produce two primary outputs:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">//      FuncInfo.EHPadStateMap[] and FuncInfo.SEHUnwindMap[]</td>
    <td class="lineNumber">482</td>
    <td class="codeline">//      FuncInfo.EHPadStateMap[] and FuncInfo.SEHUnwindMap[]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">static void calculateSEHStateNumbers(WinEHFuncInfo &FuncInfo,</td>
    <td class="lineNumber">483</td>
    <td class="codeline">static void calculateSEHStateNumbers(WinEHFuncInfo &FuncInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">                                     const Instruction *FirstNonPHI,</td>
    <td class="lineNumber">484</td>
    <td class="codeline">                                     const Instruction *FirstNonPHI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">                                     int ParentState) {</td>
    <td class="lineNumber">485</td>
    <td class="codeline">                                     int ParentState) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  assert(BB->isEHPad() && "no a funclet!");</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  assert(BB->isEHPad() && "no a funclet!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
    <td class="lineNumber">490</td>
    <td class="codeline">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">           "shouldn't revist catch funclets!");</td>
    <td class="lineNumber">491</td>
    <td class="codeline">           "shouldn't revist catch funclets!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">    // Extract the filter function and the __except basic block and create a</td>
    <td class="lineNumber">493</td>
    <td class="codeline">    // Extract the filter function and the __except basic block and create a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">    // state for them.</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    // state for them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">    assert(CatchSwitch->getNumHandlers() == 1 &&</td>
    <td class="lineNumber">495</td>
    <td class="codeline">    assert(CatchSwitch->getNumHandlers() == 1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">           "SEH doesn't have multiple handlers per __try");</td>
    <td class="lineNumber">496</td>
    <td class="codeline">           "SEH doesn't have multiple handlers per __try");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    const auto *CatchPad =</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    const auto *CatchPad =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">        cast<CatchPadInst>((*CatchSwitch->handler_begin())->getFirstNonPHI());</td>
    <td class="lineNumber">498</td>
    <td class="codeline">        cast<CatchPadInst>((*CatchSwitch->handler_begin())->getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    const BasicBlock *CatchPadBB = CatchPad->getParent();</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    const BasicBlock *CatchPadBB = CatchPad->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    const Constant *FilterOrNull =</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    const Constant *FilterOrNull =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">        cast<Constant>(CatchPad->getArgOperand(0)->stripPointerCasts());</td>
    <td class="lineNumber">501</td>
    <td class="codeline">        cast<Constant>(CatchPad->getArgOperand(0)->stripPointerCasts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">    const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
    <td class="lineNumber">502</td>
    <td class="codeline">    const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">    assert((Filter || FilterOrNull->isNullValue()) &&</td>
    <td class="lineNumber">503</td>
    <td class="codeline">    assert((Filter || FilterOrNull->isNullValue()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">           "unexpected filter value");</td>
    <td class="lineNumber">504</td>
    <td class="codeline">           "unexpected filter value");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">    int TryState = addSEHExcept(FuncInfo, ParentState, Filter, CatchPadBB);</td>
    <td class="lineNumber">505</td>
    <td class="codeline">    int TryState = addSEHExcept(FuncInfo, ParentState, Filter, CatchPadBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline"></td>
    <td class="lineNumber">506</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    // Everything in the __try block uses TryState as its parent state.</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    // Everything in the __try block uses TryState as its parent state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CatchSwitch] = TryState;</td>
    <td class="lineNumber">508</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CatchSwitch] = TryState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CatchPad] = TryState;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CatchPad] = TryState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Assigning state #" << TryState << " to BB "</td>
    <td class="lineNumber">510</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Assigning state #" << TryState << " to BB "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">                      << CatchPadBB->getName() << '\n');</td>
    <td class="lineNumber">511</td>
    <td class="codeline">                      << CatchPadBB->getName() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">512</td>
    <td class="codeline">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">513</td>
    <td class="codeline">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">                                               CatchSwitch->getParentPad())))</td>
    <td class="lineNumber">514</td>
    <td class="codeline">                                               CatchSwitch->getParentPad())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">515</td>
    <td class="codeline">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">                                 TryState);</td>
    <td class="lineNumber">516</td>
    <td class="codeline">                                 TryState);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    // Everything in the __except block unwinds to ParentState, just like code</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    // Everything in the __except block unwinds to ParentState, just like code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">    // outside the __try.</td>
    <td class="lineNumber">519</td>
    <td class="codeline">    // outside the __try.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">    for (const User *U : CatchPad->users()) {</td>
    <td class="lineNumber">520</td>
    <td class="codeline">    for (const User *U : CatchPad->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">521</td>
    <td class="codeline">      const auto *UserI = cast<Instruction>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">      if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
    <td class="lineNumber">522</td>
    <td class="codeline">      if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">        BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">523</td>
    <td class="codeline">        BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">524</td>
    <td class="codeline">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
    <td class="lineNumber">525</td>
    <td class="codeline">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">526</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">      if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
    <td class="lineNumber">527</td>
    <td class="codeline">      if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">        BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
    <td class="lineNumber">528</td>
    <td class="codeline">        BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">        // If a nested cleanup pad reports a null unwind destination and the</td>
    <td class="lineNumber">529</td>
    <td class="codeline">        // If a nested cleanup pad reports a null unwind destination and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">        // enclosing catch pad doesn't it must be post-dominated by an</td>
    <td class="lineNumber">530</td>
    <td class="codeline">        // enclosing catch pad doesn't it must be post-dominated by an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">        // unreachable instruction.</td>
    <td class="lineNumber">531</td>
    <td class="codeline">        // unreachable instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">532</td>
    <td class="codeline">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
    <td class="lineNumber">533</td>
    <td class="codeline">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">534</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">535</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">537</td>
    <td class="codeline">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline"></td>
    <td class="lineNumber">538</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">    // cleanupret instructions.</td>
    <td class="lineNumber">540</td>
    <td class="codeline">    // cleanupret instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
    <td class="lineNumber">541</td>
    <td class="codeline">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">542</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline"></td>
    <td class="lineNumber">543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">    int CleanupState = addSEHFinally(FuncInfo, ParentState, BB);</td>
    <td class="lineNumber">544</td>
    <td class="codeline">    int CleanupState = addSEHFinally(FuncInfo, ParentState, BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
    <td class="lineNumber">545</td>
    <td class="codeline">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
    <td class="lineNumber">546</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">                      << BB->getName() << '\n');</td>
    <td class="lineNumber">547</td>
    <td class="codeline">                      << BB->getName() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">548</td>
    <td class="codeline">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">      if ((PredBlock =</td>
    <td class="lineNumber">549</td>
    <td class="codeline">      if ((PredBlock =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">               getEHPadFromPredecessor(PredBlock, CleanupPad->getParentPad())))</td>
    <td class="lineNumber">550</td>
    <td class="codeline">               getEHPadFromPredecessor(PredBlock, CleanupPad->getParentPad())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">551</td>
    <td class="codeline">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">                                 CleanupState);</td>
    <td class="lineNumber">552</td>
    <td class="codeline">                                 CleanupState);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">    for (const User *U : CleanupPad->users()) {</td>
    <td class="lineNumber">553</td>
    <td class="codeline">    for (const User *U : CleanupPad->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">554</td>
    <td class="codeline">      const auto *UserI = cast<Instruction>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">      if (UserI->isEHPad())</td>
    <td class="lineNumber">555</td>
    <td class="codeline">      if (UserI->isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">        report_fatal_error("Cleanup funclets for the SEH personality cannot "</td>
    <td class="lineNumber">556</td>
    <td class="codeline">        report_fatal_error("Cleanup funclets for the SEH personality cannot "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">                           "contain exceptional actions");</td>
    <td class="lineNumber">557</td>
    <td class="codeline">                           "contain exceptional actions");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">559</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">}</td>
    <td class="lineNumber">560</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline"></td>
    <td class="lineNumber">561</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">static bool isTopLevelPadForMSVC(const Instruction *EHPad) {</td>
    <td class="lineNumber">562</td>
    <td class="codeline">static bool isTopLevelPadForMSVC(const Instruction *EHPad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(EHPad))</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(EHPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">    return isa<ConstantTokenNone>(CatchSwitch->getParentPad()) &&</td>
    <td class="lineNumber">564</td>
    <td class="codeline">    return isa<ConstantTokenNone>(CatchSwitch->getParentPad()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">           CatchSwitch->unwindsToCaller();</td>
    <td class="lineNumber">565</td>
    <td class="codeline">           CatchSwitch->unwindsToCaller();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  if (auto *CleanupPad = dyn_cast<CleanupPadInst>(EHPad))</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  if (auto *CleanupPad = dyn_cast<CleanupPadInst>(EHPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">    return isa<ConstantTokenNone>(CleanupPad->getParentPad()) &&</td>
    <td class="lineNumber">567</td>
    <td class="codeline">    return isa<ConstantTokenNone>(CleanupPad->getParentPad()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">           getCleanupRetUnwindDest(CleanupPad) == nullptr;</td>
    <td class="lineNumber">568</td>
    <td class="codeline">           getCleanupRetUnwindDest(CleanupPad) == nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  if (isa<CatchPadInst>(EHPad))</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  if (isa<CatchPadInst>(EHPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">570</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  llvm_unreachable("unexpected EHPad!");</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  llvm_unreachable("unexpected EHPad!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">}</td>
    <td class="lineNumber">572</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">void llvm::calculateSEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">574</td>
    <td class="codeline">void llvm::calculateSEHStateNumbers(const Function *Fn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">                                    WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">575</td>
    <td class="codeline">                                    WinEHFuncInfo &FuncInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  // Don't compute state numbers twice.</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  // Don't compute state numbers twice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  if (!FuncInfo.SEHUnwindMap.empty())</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  if (!FuncInfo.SEHUnwindMap.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  for (const BasicBlock &BB : *Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">    if (!BB.isEHPad())</td>
    <td class="lineNumber">581</td>
    <td class="codeline">    if (!BB.isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">582</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
    <td class="lineNumber">584</td>
    <td class="codeline">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">585</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">    ::calculateSEHStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
    <td class="lineNumber">586</td>
    <td class="codeline">    ::calculateSEHStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">587</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline"></td>
    <td class="lineNumber">588</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">  if (IsEHa) {</td>
    <td class="lineNumber">592</td>
    <td class="codeline">  if (IsEHa) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    calculateSEHStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    calculateSEHStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">}</td>
    <td class="lineNumber">596</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">void llvm::calculateWinCXXEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">598</td>
    <td class="codeline">void llvm::calculateWinCXXEHStateNumbers(const Function *Fn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">                                         WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">599</td>
    <td class="codeline">                                         WinEHFuncInfo &FuncInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  // Return if it's already been done.</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  // Return if it's already been done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  if (!FuncInfo.EHPadStateMap.empty())</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  if (!FuncInfo.EHPadStateMap.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">602</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline"></td>
    <td class="lineNumber">603</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  for (const BasicBlock &BB : *Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    if (!BB.isEHPad())</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    if (!BB.isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">606</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">609</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">    calculateCXXStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
    <td class="lineNumber">610</td>
    <td class="codeline">    calculateCXXStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline"></td>
    <td class="lineNumber">612</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">613</td>
    <td class="codeline">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  if (IsEHa) {</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  if (IsEHa) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
    <td class="lineNumber">617</td>
    <td class="codeline">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">    calculateCXXStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
    <td class="lineNumber">618</td>
    <td class="codeline">    calculateCXXStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">}</td>
    <td class="lineNumber">620</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">static int addClrEHHandler(WinEHFuncInfo &FuncInfo, int HandlerParentState,</td>
    <td class="lineNumber">622</td>
    <td class="codeline">static int addClrEHHandler(WinEHFuncInfo &FuncInfo, int HandlerParentState,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">                           int TryParentState, ClrHandlerType HandlerType,</td>
    <td class="lineNumber">623</td>
    <td class="codeline">                           int TryParentState, ClrHandlerType HandlerType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">                           uint32_t TypeToken, const BasicBlock *Handler) {</td>
    <td class="lineNumber">624</td>
    <td class="codeline">                           uint32_t TypeToken, const BasicBlock *Handler) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  ClrEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  ClrEHUnwindMapEntry Entry;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  Entry.HandlerParentState = HandlerParentState;</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  Entry.HandlerParentState = HandlerParentState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  Entry.TryParentState = TryParentState;</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  Entry.TryParentState = TryParentState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  Entry.Handler = Handler;</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  Entry.Handler = Handler;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  Entry.HandlerType = HandlerType;</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  Entry.HandlerType = HandlerType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  Entry.TypeToken = TypeToken;</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  Entry.TypeToken = TypeToken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  FuncInfo.ClrEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  FuncInfo.ClrEHUnwindMap.push_back(Entry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  return FuncInfo.ClrEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  return FuncInfo.ClrEHUnwindMap.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">}</td>
    <td class="lineNumber">633</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline"></td>
    <td class="lineNumber">634</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">void llvm::calculateClrEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">635</td>
    <td class="codeline">void llvm::calculateClrEHStateNumbers(const Function *Fn,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">                                      WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">636</td>
    <td class="codeline">                                      WinEHFuncInfo &FuncInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  // Return if it's already been done.</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  // Return if it's already been done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">  if (!FuncInfo.EHPadStateMap.empty())</td>
    <td class="lineNumber">638</td>
    <td class="codeline">  if (!FuncInfo.EHPadStateMap.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">639</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
    <td class="lineNumber">640</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  // This numbering assigns one state number to each catchpad and cleanuppad.</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  // This numbering assigns one state number to each catchpad and cleanuppad.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  // It also computes two tree-like relations over states:</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  // It also computes two tree-like relations over states:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  // 1) Each state has a "HandlerParentState", which is the state of the next</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  // 1) Each state has a "HandlerParentState", which is the state of the next</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">  //    outer handler enclosing this state's handler (same as nearest ancestor</td>
    <td class="lineNumber">644</td>
    <td class="codeline">  //    outer handler enclosing this state's handler (same as nearest ancestor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  //    per the ParentPad linkage on EH pads, but skipping over catchswitches).</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  //    per the ParentPad linkage on EH pads, but skipping over catchswitches).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  // 2) Each state has a "TryParentState", which:</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  // 2) Each state has a "TryParentState", which:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  //    a) for a catchpad that's not the last handler on its catchswitch, is</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  //    a) for a catchpad that's not the last handler on its catchswitch, is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  //       the state of the next catchpad on that catchswitch</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  //       the state of the next catchpad on that catchswitch</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  //    b) for all other pads, is the state of the pad whose try region is the</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  //    b) for all other pads, is the state of the pad whose try region is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  //       next outer try region enclosing this state's try region.  The "try</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  //       next outer try region enclosing this state's try region.  The "try</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  //       regions are not present as such in the IR, but will be inferred</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  //       regions are not present as such in the IR, but will be inferred</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  //       based on the placement of invokes and pads which reach each other</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  //       based on the placement of invokes and pads which reach each other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  //       by exceptional exits</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  //       by exceptional exits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  // Catchswitches do not get their own states, but each gets mapped to the</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  // Catchswitches do not get their own states, but each gets mapped to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  // state of its first catchpad.</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  // state of its first catchpad.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline"></td>
    <td class="lineNumber">656</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  // Step one: walk down from outermost to innermost funclets, assigning each</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  // Step one: walk down from outermost to innermost funclets, assigning each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  // catchpad and cleanuppad a state number.  Add an entry to the</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  // catchpad and cleanuppad a state number.  Add an entry to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  // ClrEHUnwindMap for each state, recording its HandlerParentState and</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  // ClrEHUnwindMap for each state, recording its HandlerParentState and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  // handler attributes.  Record the TryParentState as well for each catchpad</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  // handler attributes.  Record the TryParentState as well for each catchpad</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  // that's not the last on its catchswitch, but initialize all other entries'</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  // that's not the last on its catchswitch, but initialize all other entries'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  // TryParentStates to a sentinel -1 value that the next pass will update.</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  // TryParentStates to a sentinel -1 value that the next pass will update.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
    <td class="lineNumber">663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  // Seed a worklist with pads that have no parent.</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  // Seed a worklist with pads that have no parent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  SmallVector<std::pair<const Instruction *, int>, 8> Worklist;</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  SmallVector<std::pair<const Instruction *, int>, 8> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  for (const BasicBlock &BB : *Fn) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">667</td>
    <td class="codeline">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">    const Value *ParentPad;</td>
    <td class="lineNumber">668</td>
    <td class="codeline">    const Value *ParentPad;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">    if (const auto *CPI = dyn_cast<CleanupPadInst>(FirstNonPHI))</td>
    <td class="lineNumber">669</td>
    <td class="codeline">    if (const auto *CPI = dyn_cast<CleanupPadInst>(FirstNonPHI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">      ParentPad = CPI->getParentPad();</td>
    <td class="lineNumber">670</td>
    <td class="codeline">      ParentPad = CPI->getParentPad();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    else if (const auto *CSI = dyn_cast<CatchSwitchInst>(FirstNonPHI))</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    else if (const auto *CSI = dyn_cast<CatchSwitchInst>(FirstNonPHI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">      ParentPad = CSI->getParentPad();</td>
    <td class="lineNumber">672</td>
    <td class="codeline">      ParentPad = CSI->getParentPad();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">673</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">674</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">    if (isa<ConstantTokenNone>(ParentPad))</td>
    <td class="lineNumber">675</td>
    <td class="codeline">    if (isa<ConstantTokenNone>(ParentPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">      Worklist.emplace_back(FirstNonPHI, -1);</td>
    <td class="lineNumber">676</td>
    <td class="codeline">      Worklist.emplace_back(FirstNonPHI, -1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  // Use the worklist to visit all pads, from outer to inner.  Record</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  // Use the worklist to visit all pads, from outer to inner.  Record</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  // HandlerParentState for all pads.  Record TryParentState only for catchpads</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  // HandlerParentState for all pads.  Record TryParentState only for catchpads</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  // that aren't the last on their catchswitch (setting all other entries'</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  // that aren't the last on their catchswitch (setting all other entries'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  // TryParentStates to an initial value of -1).  This loop is also responsible</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  // TryParentStates to an initial value of -1).  This loop is also responsible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  // for setting the EHPadStateMap entry for all catchpads, cleanuppads, and</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  // for setting the EHPadStateMap entry for all catchpads, cleanuppads, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  // catchswitches.</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  // catchswitches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">    const Instruction *Pad;</td>
    <td class="lineNumber">686</td>
    <td class="codeline">    const Instruction *Pad;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    int HandlerParentState;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    int HandlerParentState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    std::tie(Pad, HandlerParentState) = Worklist.pop_back_val();</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    std::tie(Pad, HandlerParentState) = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">    if (const auto *Cleanup = dyn_cast<CleanupPadInst>(Pad)) {</td>
    <td class="lineNumber">690</td>
    <td class="codeline">    if (const auto *Cleanup = dyn_cast<CleanupPadInst>(Pad)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">      // Create the entry for this cleanup with the appropriate handler</td>
    <td class="lineNumber">691</td>
    <td class="codeline">      // Create the entry for this cleanup with the appropriate handler</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">      // properties.  Finally and fault handlers are distinguished by arity.</td>
    <td class="lineNumber">692</td>
    <td class="codeline">      // properties.  Finally and fault handlers are distinguished by arity.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">      ClrHandlerType HandlerType =</td>
    <td class="lineNumber">693</td>
    <td class="codeline">      ClrHandlerType HandlerType =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">          (Cleanup->arg_size() ? ClrHandlerType::Fault</td>
    <td class="lineNumber">694</td>
    <td class="codeline">          (Cleanup->arg_size() ? ClrHandlerType::Fault</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">                               : ClrHandlerType::Finally);</td>
    <td class="lineNumber">695</td>
    <td class="codeline">                               : ClrHandlerType::Finally);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">      int CleanupState = addClrEHHandler(FuncInfo, HandlerParentState, -1,</td>
    <td class="lineNumber">696</td>
    <td class="codeline">      int CleanupState = addClrEHHandler(FuncInfo, HandlerParentState, -1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">                                         HandlerType, 0, Pad->getParent());</td>
    <td class="lineNumber">697</td>
    <td class="codeline">                                         HandlerType, 0, Pad->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">      // Queue any child EH pads on the worklist.</td>
    <td class="lineNumber">698</td>
    <td class="codeline">      // Queue any child EH pads on the worklist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">      for (const User *U : Cleanup->users())</td>
    <td class="lineNumber">699</td>
    <td class="codeline">      for (const User *U : Cleanup->users())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">        if (const auto *I = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">700</td>
    <td class="codeline">        if (const auto *I = dyn_cast<Instruction>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">          if (I->isEHPad())</td>
    <td class="lineNumber">701</td>
    <td class="codeline">          if (I->isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">            Worklist.emplace_back(I, CleanupState);</td>
    <td class="lineNumber">702</td>
    <td class="codeline">            Worklist.emplace_back(I, CleanupState);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">      // Remember this pad's state.</td>
    <td class="lineNumber">703</td>
    <td class="codeline">      // Remember this pad's state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">      FuncInfo.EHPadStateMap[Cleanup] = CleanupState;</td>
    <td class="lineNumber">704</td>
    <td class="codeline">      FuncInfo.EHPadStateMap[Cleanup] = CleanupState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">      // Walk the handlers of this catchswitch in reverse order since all but</td>
    <td class="lineNumber">706</td>
    <td class="codeline">      // Walk the handlers of this catchswitch in reverse order since all but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">      // the last need to set the following one as its TryParentState.</td>
    <td class="lineNumber">707</td>
    <td class="codeline">      // the last need to set the following one as its TryParentState.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">      const auto *CatchSwitch = cast<CatchSwitchInst>(Pad);</td>
    <td class="lineNumber">708</td>
    <td class="codeline">      const auto *CatchSwitch = cast<CatchSwitchInst>(Pad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">      int CatchState = -1, FollowerState = -1;</td>
    <td class="lineNumber">709</td>
    <td class="codeline">      int CatchState = -1, FollowerState = -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">      SmallVector<const BasicBlock *, 4> CatchBlocks(CatchSwitch->handlers());</td>
    <td class="lineNumber">710</td>
    <td class="codeline">      SmallVector<const BasicBlock *, 4> CatchBlocks(CatchSwitch->handlers());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">      for (const BasicBlock *CatchBlock : llvm::reverse(CatchBlocks)) {</td>
    <td class="lineNumber">711</td>
    <td class="codeline">      for (const BasicBlock *CatchBlock : llvm::reverse(CatchBlocks)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">        // Create the entry for this catch with the appropriate handler</td>
    <td class="lineNumber">712</td>
    <td class="codeline">        // Create the entry for this catch with the appropriate handler</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">        // properties.</td>
    <td class="lineNumber">713</td>
    <td class="codeline">        // properties.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">        const auto *Catch = cast<CatchPadInst>(CatchBlock->getFirstNonPHI());</td>
    <td class="lineNumber">714</td>
    <td class="codeline">        const auto *Catch = cast<CatchPadInst>(CatchBlock->getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">        uint32_t TypeToken = static_cast<uint32_t>(</td>
    <td class="lineNumber">715</td>
    <td class="codeline">        uint32_t TypeToken = static_cast<uint32_t>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">            cast<ConstantInt>(Catch->getArgOperand(0))->getZExtValue());</td>
    <td class="lineNumber">716</td>
    <td class="codeline">            cast<ConstantInt>(Catch->getArgOperand(0))->getZExtValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">        CatchState =</td>
    <td class="lineNumber">717</td>
    <td class="codeline">        CatchState =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">            addClrEHHandler(FuncInfo, HandlerParentState, FollowerState,</td>
    <td class="lineNumber">718</td>
    <td class="codeline">            addClrEHHandler(FuncInfo, HandlerParentState, FollowerState,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">                            ClrHandlerType::Catch, TypeToken, CatchBlock);</td>
    <td class="lineNumber">719</td>
    <td class="codeline">                            ClrHandlerType::Catch, TypeToken, CatchBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">        // Queue any child EH pads on the worklist.</td>
    <td class="lineNumber">720</td>
    <td class="codeline">        // Queue any child EH pads on the worklist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">        for (const User *U : Catch->users())</td>
    <td class="lineNumber">721</td>
    <td class="codeline">        for (const User *U : Catch->users())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">          if (const auto *I = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">722</td>
    <td class="codeline">          if (const auto *I = dyn_cast<Instruction>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">            if (I->isEHPad())</td>
    <td class="lineNumber">723</td>
    <td class="codeline">            if (I->isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">              Worklist.emplace_back(I, CatchState);</td>
    <td class="lineNumber">724</td>
    <td class="codeline">              Worklist.emplace_back(I, CatchState);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">        // Remember this catch's state.</td>
    <td class="lineNumber">725</td>
    <td class="codeline">        // Remember this catch's state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">        FuncInfo.EHPadStateMap[Catch] = CatchState;</td>
    <td class="lineNumber">726</td>
    <td class="codeline">        FuncInfo.EHPadStateMap[Catch] = CatchState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">        FollowerState = CatchState;</td>
    <td class="lineNumber">727</td>
    <td class="codeline">        FollowerState = CatchState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">728</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">      // Associate the catchswitch with the state of its first catch.</td>
    <td class="lineNumber">729</td>
    <td class="codeline">      // Associate the catchswitch with the state of its first catch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">      assert(CatchSwitch->getNumHandlers());</td>
    <td class="lineNumber">730</td>
    <td class="codeline">      assert(CatchSwitch->getNumHandlers());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">      FuncInfo.EHPadStateMap[CatchSwitch] = CatchState;</td>
    <td class="lineNumber">731</td>
    <td class="codeline">      FuncInfo.EHPadStateMap[CatchSwitch] = CatchState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">732</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline"></td>
    <td class="lineNumber">734</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">  // Step two: record the TryParentState of each state.  For cleanuppads that</td>
    <td class="lineNumber">735</td>
    <td class="codeline">  // Step two: record the TryParentState of each state.  For cleanuppads that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  // don't have cleanuprets, we may need to infer this from their child pads,</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  // don't have cleanuprets, we may need to infer this from their child pads,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">  // so visit pads in descendant-most to ancestor-most order.</td>
    <td class="lineNumber">737</td>
    <td class="codeline">  // so visit pads in descendant-most to ancestor-most order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  for (ClrEHUnwindMapEntry &Entry : llvm::reverse(FuncInfo.ClrEHUnwindMap)) {</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  for (ClrEHUnwindMapEntry &Entry : llvm::reverse(FuncInfo.ClrEHUnwindMap)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">    const Instruction *Pad =</td>
    <td class="lineNumber">739</td>
    <td class="codeline">    const Instruction *Pad =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">        cast<const BasicBlock *>(Entry.Handler)->getFirstNonPHI();</td>
    <td class="lineNumber">740</td>
    <td class="codeline">        cast<const BasicBlock *>(Entry.Handler)->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">    // For most pads, the TryParentState is the state associated with the</td>
    <td class="lineNumber">741</td>
    <td class="codeline">    // For most pads, the TryParentState is the state associated with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    // unwind dest of exceptional exits from it.</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    // unwind dest of exceptional exits from it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">    const BasicBlock *UnwindDest;</td>
    <td class="lineNumber">743</td>
    <td class="codeline">    const BasicBlock *UnwindDest;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">    if (const auto *Catch = dyn_cast<CatchPadInst>(Pad)) {</td>
    <td class="lineNumber">744</td>
    <td class="codeline">    if (const auto *Catch = dyn_cast<CatchPadInst>(Pad)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">      // If a catch is not the last in its catchswitch, its TryParentState is</td>
    <td class="lineNumber">745</td>
    <td class="codeline">      // If a catch is not the last in its catchswitch, its TryParentState is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">      // the state associated with the next catch in the switch, even though</td>
    <td class="lineNumber">746</td>
    <td class="codeline">      // the state associated with the next catch in the switch, even though</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">      // that's not the unwind dest of exceptions escaping the catch.  Those</td>
    <td class="lineNumber">747</td>
    <td class="codeline">      // that's not the unwind dest of exceptions escaping the catch.  Those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">      // cases were already assigned a TryParentState in the first pass, so</td>
    <td class="lineNumber">748</td>
    <td class="codeline">      // cases were already assigned a TryParentState in the first pass, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">      // skip them.</td>
    <td class="lineNumber">749</td>
    <td class="codeline">      // skip them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">      if (Entry.TryParentState != -1)</td>
    <td class="lineNumber">750</td>
    <td class="codeline">      if (Entry.TryParentState != -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">751</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">      // Otherwise, get the unwind dest from the catchswitch.</td>
    <td class="lineNumber">752</td>
    <td class="codeline">      // Otherwise, get the unwind dest from the catchswitch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">      UnwindDest = Catch->getCatchSwitch()->getUnwindDest();</td>
    <td class="lineNumber">753</td>
    <td class="codeline">      UnwindDest = Catch->getCatchSwitch()->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">      const auto *Cleanup = cast<CleanupPadInst>(Pad);</td>
    <td class="lineNumber">755</td>
    <td class="codeline">      const auto *Cleanup = cast<CleanupPadInst>(Pad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">      UnwindDest = nullptr;</td>
    <td class="lineNumber">756</td>
    <td class="codeline">      UnwindDest = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">      for (const User *U : Cleanup->users()) {</td>
    <td class="lineNumber">757</td>
    <td class="codeline">      for (const User *U : Cleanup->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">        if (auto *CleanupRet = dyn_cast<CleanupReturnInst>(U)) {</td>
    <td class="lineNumber">758</td>
    <td class="codeline">        if (auto *CleanupRet = dyn_cast<CleanupReturnInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">          // Common and unambiguous case -- cleanupret indicates cleanup's</td>
    <td class="lineNumber">759</td>
    <td class="codeline">          // Common and unambiguous case -- cleanupret indicates cleanup's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">          // unwind dest.</td>
    <td class="lineNumber">760</td>
    <td class="codeline">          // unwind dest.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">          UnwindDest = CleanupRet->getUnwindDest();</td>
    <td class="lineNumber">761</td>
    <td class="codeline">          UnwindDest = CleanupRet->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">762</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">763</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline"></td>
    <td class="lineNumber">764</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">        // Get an unwind dest for the user</td>
    <td class="lineNumber">765</td>
    <td class="codeline">        // Get an unwind dest for the user</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">        const BasicBlock *UserUnwindDest = nullptr;</td>
    <td class="lineNumber">766</td>
    <td class="codeline">        const BasicBlock *UserUnwindDest = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">        if (auto *Invoke = dyn_cast<InvokeInst>(U)) {</td>
    <td class="lineNumber">767</td>
    <td class="codeline">        if (auto *Invoke = dyn_cast<InvokeInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">          UserUnwindDest = Invoke->getUnwindDest();</td>
    <td class="lineNumber">768</td>
    <td class="codeline">          UserUnwindDest = Invoke->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">        } else if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(U)) {</td>
    <td class="lineNumber">769</td>
    <td class="codeline">        } else if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">          UserUnwindDest = CatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">770</td>
    <td class="codeline">          UserUnwindDest = CatchSwitch->getUnwindDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">        } else if (auto *ChildCleanup = dyn_cast<CleanupPadInst>(U)) {</td>
    <td class="lineNumber">771</td>
    <td class="codeline">        } else if (auto *ChildCleanup = dyn_cast<CleanupPadInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">          int UserState = FuncInfo.EHPadStateMap[ChildCleanup];</td>
    <td class="lineNumber">772</td>
    <td class="codeline">          int UserState = FuncInfo.EHPadStateMap[ChildCleanup];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">          int UserUnwindState =</td>
    <td class="lineNumber">773</td>
    <td class="codeline">          int UserUnwindState =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">              FuncInfo.ClrEHUnwindMap[UserState].TryParentState;</td>
    <td class="lineNumber">774</td>
    <td class="codeline">              FuncInfo.ClrEHUnwindMap[UserState].TryParentState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">          if (UserUnwindState != -1)</td>
    <td class="lineNumber">775</td>
    <td class="codeline">          if (UserUnwindState != -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">            UserUnwindDest = cast<const BasicBlock *>(</td>
    <td class="lineNumber">776</td>
    <td class="codeline">            UserUnwindDest = cast<const BasicBlock *>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">                FuncInfo.ClrEHUnwindMap[UserUnwindState].Handler);</td>
    <td class="lineNumber">777</td>
    <td class="codeline">                FuncInfo.ClrEHUnwindMap[UserUnwindState].Handler);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">778</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline"></td>
    <td class="lineNumber">779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">        // Not having an unwind dest for this user might indicate that it</td>
    <td class="lineNumber">780</td>
    <td class="codeline">        // Not having an unwind dest for this user might indicate that it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">        // doesn't unwind, so can't be taken as proof that the cleanup itself</td>
    <td class="lineNumber">781</td>
    <td class="codeline">        // doesn't unwind, so can't be taken as proof that the cleanup itself</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">        // may unwind to caller (see e.g. SimplifyUnreachable and</td>
    <td class="lineNumber">782</td>
    <td class="codeline">        // may unwind to caller (see e.g. SimplifyUnreachable and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">        // RemoveUnwindEdge).</td>
    <td class="lineNumber">783</td>
    <td class="codeline">        // RemoveUnwindEdge).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">        if (!UserUnwindDest)</td>
    <td class="lineNumber">784</td>
    <td class="codeline">        if (!UserUnwindDest)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">785</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
    <td class="lineNumber">786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">        // Now we have an unwind dest for the user, but we need to see if it</td>
    <td class="lineNumber">787</td>
    <td class="codeline">        // Now we have an unwind dest for the user, but we need to see if it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">        // unwinds all the way out of the cleanup or if it stays within it.</td>
    <td class="lineNumber">788</td>
    <td class="codeline">        // unwinds all the way out of the cleanup or if it stays within it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">        const Instruction *UserUnwindPad = UserUnwindDest->getFirstNonPHI();</td>
    <td class="lineNumber">789</td>
    <td class="codeline">        const Instruction *UserUnwindPad = UserUnwindDest->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">        const Value *UserUnwindParent;</td>
    <td class="lineNumber">790</td>
    <td class="codeline">        const Value *UserUnwindParent;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">        if (auto *CSI = dyn_cast<CatchSwitchInst>(UserUnwindPad))</td>
    <td class="lineNumber">791</td>
    <td class="codeline">        if (auto *CSI = dyn_cast<CatchSwitchInst>(UserUnwindPad))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">          UserUnwindParent = CSI->getParentPad();</td>
    <td class="lineNumber">792</td>
    <td class="codeline">          UserUnwindParent = CSI->getParentPad();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">        else</td>
    <td class="lineNumber">793</td>
    <td class="codeline">        else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">          UserUnwindParent =</td>
    <td class="lineNumber">794</td>
    <td class="codeline">          UserUnwindParent =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">              cast<CleanupPadInst>(UserUnwindPad)->getParentPad();</td>
    <td class="lineNumber">795</td>
    <td class="codeline">              cast<CleanupPadInst>(UserUnwindPad)->getParentPad();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">        // The unwind stays within the cleanup iff it targets a child of the</td>
    <td class="lineNumber">797</td>
    <td class="codeline">        // The unwind stays within the cleanup iff it targets a child of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">        // cleanup.</td>
    <td class="lineNumber">798</td>
    <td class="codeline">        // cleanup.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">        if (UserUnwindParent == Cleanup)</td>
    <td class="lineNumber">799</td>
    <td class="codeline">        if (UserUnwindParent == Cleanup)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">800</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline"></td>
    <td class="lineNumber">801</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">        // This unwind exits the cleanup, so its dest is the cleanup's dest.</td>
    <td class="lineNumber">802</td>
    <td class="codeline">        // This unwind exits the cleanup, so its dest is the cleanup's dest.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">        UnwindDest = UserUnwindDest;</td>
    <td class="lineNumber">803</td>
    <td class="codeline">        UnwindDest = UserUnwindDest;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">804</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">805</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">    // Record the state of the unwind dest as the TryParentState.</td>
    <td class="lineNumber">808</td>
    <td class="codeline">    // Record the state of the unwind dest as the TryParentState.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">    int UnwindDestState;</td>
    <td class="lineNumber">809</td>
    <td class="codeline">    int UnwindDestState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">    // If UnwindDest is null at this point, either the pad in question can</td>
    <td class="lineNumber">811</td>
    <td class="codeline">    // If UnwindDest is null at this point, either the pad in question can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">    // be exited by unwind to caller, or it cannot be exited by unwind.  In</td>
    <td class="lineNumber">812</td>
    <td class="codeline">    // be exited by unwind to caller, or it cannot be exited by unwind.  In</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">    // either case, reporting such cases as unwinding to caller is correct.</td>
    <td class="lineNumber">813</td>
    <td class="codeline">    // either case, reporting such cases as unwinding to caller is correct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">    // This can lead to EH tables that "look strange" -- if this pad's is in</td>
    <td class="lineNumber">814</td>
    <td class="codeline">    // This can lead to EH tables that "look strange" -- if this pad's is in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">    // a parent funclet which has other children that do unwind to an enclosing</td>
    <td class="lineNumber">815</td>
    <td class="codeline">    // a parent funclet which has other children that do unwind to an enclosing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">    // pad, the try region for this pad will be missing the "duplicate" EH</td>
    <td class="lineNumber">816</td>
    <td class="codeline">    // pad, the try region for this pad will be missing the "duplicate" EH</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">    // clause entries that you'd expect to see covering the whole parent.  That</td>
    <td class="lineNumber">817</td>
    <td class="codeline">    // clause entries that you'd expect to see covering the whole parent.  That</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">    // should be benign, since the unwind never actually happens.  If it were</td>
    <td class="lineNumber">818</td>
    <td class="codeline">    // should be benign, since the unwind never actually happens.  If it were</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">    // an issue, we could add a subsequent pass that pushes unwind dests down</td>
    <td class="lineNumber">819</td>
    <td class="codeline">    // an issue, we could add a subsequent pass that pushes unwind dests down</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">    // from parents that have them to children that appear to unwind to caller.</td>
    <td class="lineNumber">820</td>
    <td class="codeline">    // from parents that have them to children that appear to unwind to caller.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">    if (!UnwindDest) {</td>
    <td class="lineNumber">821</td>
    <td class="codeline">    if (!UnwindDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">      UnwindDestState = -1;</td>
    <td class="lineNumber">822</td>
    <td class="codeline">      UnwindDestState = -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">823</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">      UnwindDestState = FuncInfo.EHPadStateMap[UnwindDest->getFirstNonPHI()];</td>
    <td class="lineNumber">824</td>
    <td class="codeline">      UnwindDestState = FuncInfo.EHPadStateMap[UnwindDest->getFirstNonPHI()];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">825</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">    Entry.TryParentState = UnwindDestState;</td>
    <td class="lineNumber">827</td>
    <td class="codeline">    Entry.TryParentState = UnwindDestState;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline"></td>
    <td class="lineNumber">829</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  // Step three: transfer information from pads to invokes.</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  // Step three: transfer information from pads to invokes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">}</td>
    <td class="lineNumber">832</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">void WinEHPrepare::colorFunclets(Function &F) {</td>
    <td class="lineNumber">834</td>
    <td class="codeline">void WinEHPrepare::colorFunclets(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  BlockColors = colorEHFunclets(F);</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  BlockColors = colorEHFunclets(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  // Invert the map from BB to colors to color to BBs.</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  // Invert the map from BB to colors to color to BBs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  for (BasicBlock &BB : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">    ColorVector &Colors = BlockColors[&BB];</td>
    <td class="lineNumber">839</td>
    <td class="codeline">    ColorVector &Colors = BlockColors[&BB];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">    for (BasicBlock *Color : Colors)</td>
    <td class="lineNumber">840</td>
    <td class="codeline">    for (BasicBlock *Color : Colors)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">      FuncletBlocks[Color].push_back(&BB);</td>
    <td class="lineNumber">841</td>
    <td class="codeline">      FuncletBlocks[Color].push_back(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">}</td>
    <td class="lineNumber">843</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">void WinEHPrepare::demotePHIsOnFunclets(Function &F,</td>
    <td class="lineNumber">845</td>
    <td class="codeline">void WinEHPrepare::demotePHIsOnFunclets(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">                                        bool DemoteCatchSwitchPHIOnly) {</td>
    <td class="lineNumber">846</td>
    <td class="codeline">                                        bool DemoteCatchSwitchPHIOnly) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  // Strip PHI nodes off of EH pads.</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  // Strip PHI nodes off of EH pads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  SmallVector<PHINode *, 16> PHINodes;</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  SmallVector<PHINode *, 16> PHINodes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  for (BasicBlock &BB : make_early_inc_range(F)) {</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  for (BasicBlock &BB : make_early_inc_range(F)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">    if (!BB.isEHPad())</td>
    <td class="lineNumber">850</td>
    <td class="codeline">    if (!BB.isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">851</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">    if (DemoteCatchSwitchPHIOnly && !isa<CatchSwitchInst>(BB.getFirstNonPHI()))</td>
    <td class="lineNumber">852</td>
    <td class="codeline">    if (DemoteCatchSwitchPHIOnly && !isa<CatchSwitchInst>(BB.getFirstNonPHI()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">853</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline"></td>
    <td class="lineNumber">854</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">    for (Instruction &I : make_early_inc_range(BB)) {</td>
    <td class="lineNumber">855</td>
    <td class="codeline">    for (Instruction &I : make_early_inc_range(BB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">      auto *PN = dyn_cast<PHINode>(&I);</td>
    <td class="lineNumber">856</td>
    <td class="codeline">      auto *PN = dyn_cast<PHINode>(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">      // Stop at the first non-PHI.</td>
    <td class="lineNumber">857</td>
    <td class="codeline">      // Stop at the first non-PHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">      if (!PN)</td>
    <td class="lineNumber">858</td>
    <td class="codeline">      if (!PN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">859</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline"></td>
    <td class="lineNumber">860</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">      AllocaInst *SpillSlot = insertPHILoads(PN, F);</td>
    <td class="lineNumber">861</td>
    <td class="codeline">      AllocaInst *SpillSlot = insertPHILoads(PN, F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">      if (SpillSlot)</td>
    <td class="lineNumber">862</td>
    <td class="codeline">      if (SpillSlot)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">        insertPHIStores(PN, SpillSlot);</td>
    <td class="lineNumber">863</td>
    <td class="codeline">        insertPHIStores(PN, SpillSlot);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline"></td>
    <td class="lineNumber">864</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">      PHINodes.push_back(PN);</td>
    <td class="lineNumber">865</td>
    <td class="codeline">      PHINodes.push_back(PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline"></td>
    <td class="lineNumber">868</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  for (auto *PN : PHINodes) {</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  for (auto *PN : PHINodes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">    // There may be lingering uses on other EH PHIs being removed</td>
    <td class="lineNumber">870</td>
    <td class="codeline">    // There may be lingering uses on other EH PHIs being removed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">    PN->replaceAllUsesWith(PoisonValue::get(PN->getType()));</td>
    <td class="lineNumber">871</td>
    <td class="codeline">    PN->replaceAllUsesWith(PoisonValue::get(PN->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">    PN->eraseFromParent();</td>
    <td class="lineNumber">872</td>
    <td class="codeline">    PN->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">}</td>
    <td class="lineNumber">874</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline"></td>
    <td class="lineNumber">875</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">void WinEHPrepare::cloneCommonBlocks(Function &F) {</td>
    <td class="lineNumber">876</td>
    <td class="codeline">void WinEHPrepare::cloneCommonBlocks(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  // We need to clone all blocks which belong to multiple funclets.  Values are</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  // We need to clone all blocks which belong to multiple funclets.  Values are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  // remapped throughout the funclet to propagate both the new instructions</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  // remapped throughout the funclet to propagate both the new instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  // *and* the new basic blocks themselves.</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  // *and* the new basic blocks themselves.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">  for (auto &Funclets : FuncletBlocks) {</td>
    <td class="lineNumber">880</td>
    <td class="codeline">  for (auto &Funclets : FuncletBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">    BasicBlock *FuncletPadBB = Funclets.first;</td>
    <td class="lineNumber">881</td>
    <td class="codeline">    BasicBlock *FuncletPadBB = Funclets.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">    std::vector<BasicBlock *> &BlocksInFunclet = Funclets.second;</td>
    <td class="lineNumber">882</td>
    <td class="codeline">    std::vector<BasicBlock *> &BlocksInFunclet = Funclets.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">    Value *FuncletToken;</td>
    <td class="lineNumber">883</td>
    <td class="codeline">    Value *FuncletToken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">    if (FuncletPadBB == &F.getEntryBlock())</td>
    <td class="lineNumber">884</td>
    <td class="codeline">    if (FuncletPadBB == &F.getEntryBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">      FuncletToken = ConstantTokenNone::get(F.getContext());</td>
    <td class="lineNumber">885</td>
    <td class="codeline">      FuncletToken = ConstantTokenNone::get(F.getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">886</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">      FuncletToken = FuncletPadBB->getFirstNonPHI();</td>
    <td class="lineNumber">887</td>
    <td class="codeline">      FuncletToken = FuncletPadBB->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline"></td>
    <td class="lineNumber">888</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">    std::vector<std::pair<BasicBlock *, BasicBlock *>> Orig2Clone;</td>
    <td class="lineNumber">889</td>
    <td class="codeline">    std::vector<std::pair<BasicBlock *, BasicBlock *>> Orig2Clone;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">    ValueToValueMapTy VMap;</td>
    <td class="lineNumber">890</td>
    <td class="codeline">    ValueToValueMapTy VMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">    for (BasicBlock *BB : BlocksInFunclet) {</td>
    <td class="lineNumber">891</td>
    <td class="codeline">    for (BasicBlock *BB : BlocksInFunclet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">      ColorVector &ColorsForBB = BlockColors[BB];</td>
    <td class="lineNumber">892</td>
    <td class="codeline">      ColorVector &ColorsForBB = BlockColors[BB];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">      // We don't need to do anything if the block is monochromatic.</td>
    <td class="lineNumber">893</td>
    <td class="codeline">      // We don't need to do anything if the block is monochromatic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">      size_t NumColorsForBB = ColorsForBB.size();</td>
    <td class="lineNumber">894</td>
    <td class="codeline">      size_t NumColorsForBB = ColorsForBB.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">      if (NumColorsForBB == 1)</td>
    <td class="lineNumber">895</td>
    <td class="codeline">      if (NumColorsForBB == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">896</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline"></td>
    <td class="lineNumber">897</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">898</td>
    <td class="codeline">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">                      dbgs() << "  Cloning block \'" << BB->getName()</td>
    <td class="lineNumber">899</td>
    <td class="codeline">                      dbgs() << "  Cloning block \'" << BB->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">                              << "\' for funclet \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">900</td>
    <td class="codeline">                              << "\' for funclet \'" << FuncletPadBB->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">                              << "\'.\n");</td>
    <td class="lineNumber">901</td>
    <td class="codeline">                              << "\'.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
    <td class="lineNumber">902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">      // Create a new basic block and copy instructions into it!</td>
    <td class="lineNumber">903</td>
    <td class="codeline">      // Create a new basic block and copy instructions into it!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">      BasicBlock *CBB =</td>
    <td class="lineNumber">904</td>
    <td class="codeline">      BasicBlock *CBB =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">          CloneBasicBlock(BB, VMap, Twine(".for.", FuncletPadBB->getName()));</td>
    <td class="lineNumber">905</td>
    <td class="codeline">          CloneBasicBlock(BB, VMap, Twine(".for.", FuncletPadBB->getName()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">      // Insert the clone immediately after the original to ensure determinism</td>
    <td class="lineNumber">906</td>
    <td class="codeline">      // Insert the clone immediately after the original to ensure determinism</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">      // and to keep the same relative ordering of any funclet's blocks.</td>
    <td class="lineNumber">907</td>
    <td class="codeline">      // and to keep the same relative ordering of any funclet's blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">      CBB->insertInto(&F, BB->getNextNode());</td>
    <td class="lineNumber">908</td>
    <td class="codeline">      CBB->insertInto(&F, BB->getNextNode());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">      // Add basic block mapping.</td>
    <td class="lineNumber">910</td>
    <td class="codeline">      // Add basic block mapping.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">      VMap[BB] = CBB;</td>
    <td class="lineNumber">911</td>
    <td class="codeline">      VMap[BB] = CBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline"></td>
    <td class="lineNumber">912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">      // Record delta operations that we need to perform to our color mappings.</td>
    <td class="lineNumber">913</td>
    <td class="codeline">      // Record delta operations that we need to perform to our color mappings.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">      Orig2Clone.emplace_back(BB, CBB);</td>
    <td class="lineNumber">914</td>
    <td class="codeline">      Orig2Clone.emplace_back(BB, CBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">915</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">    // If nothing was cloned, we're done cloning in this funclet.</td>
    <td class="lineNumber">917</td>
    <td class="codeline">    // If nothing was cloned, we're done cloning in this funclet.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">    if (Orig2Clone.empty())</td>
    <td class="lineNumber">918</td>
    <td class="codeline">    if (Orig2Clone.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">919</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">    // Update our color mappings to reflect that one block has lost a color and</td>
    <td class="lineNumber">921</td>
    <td class="codeline">    // Update our color mappings to reflect that one block has lost a color and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">    // another has gained a color.</td>
    <td class="lineNumber">922</td>
    <td class="codeline">    // another has gained a color.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">923</td>
    <td class="codeline">    for (auto &BBMapping : Orig2Clone) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">924</td>
    <td class="codeline">      BasicBlock *OldBlock = BBMapping.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">925</td>
    <td class="codeline">      BasicBlock *NewBlock = BBMapping.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline"></td>
    <td class="lineNumber">926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">      BlocksInFunclet.push_back(NewBlock);</td>
    <td class="lineNumber">927</td>
    <td class="codeline">      BlocksInFunclet.push_back(NewBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">      ColorVector &NewColors = BlockColors[NewBlock];</td>
    <td class="lineNumber">928</td>
    <td class="codeline">      ColorVector &NewColors = BlockColors[NewBlock];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">      assert(NewColors.empty() && "A new block should only have one color!");</td>
    <td class="lineNumber">929</td>
    <td class="codeline">      assert(NewColors.empty() && "A new block should only have one color!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">      NewColors.push_back(FuncletPadBB);</td>
    <td class="lineNumber">930</td>
    <td class="codeline">      NewColors.push_back(FuncletPadBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline"></td>
    <td class="lineNumber">931</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">932</td>
    <td class="codeline">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">                      dbgs() << "  Assigned color \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">933</td>
    <td class="codeline">                      dbgs() << "  Assigned color \'" << FuncletPadBB->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">                              << "\' to block \'" << NewBlock->getName()</td>
    <td class="lineNumber">934</td>
    <td class="codeline">                              << "\' to block \'" << NewBlock->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">                              << "\'.\n");</td>
    <td class="lineNumber">935</td>
    <td class="codeline">                              << "\'.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline"></td>
    <td class="lineNumber">936</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">      llvm::erase_value(BlocksInFunclet, OldBlock);</td>
    <td class="lineNumber">937</td>
    <td class="codeline">      llvm::erase_value(BlocksInFunclet, OldBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">      ColorVector &OldColors = BlockColors[OldBlock];</td>
    <td class="lineNumber">938</td>
    <td class="codeline">      ColorVector &OldColors = BlockColors[OldBlock];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">      llvm::erase_value(OldColors, FuncletPadBB);</td>
    <td class="lineNumber">939</td>
    <td class="codeline">      llvm::erase_value(OldColors, FuncletPadBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">941</td>
    <td class="codeline">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">                      dbgs() << "  Removed color \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">942</td>
    <td class="codeline">                      dbgs() << "  Removed color \'" << FuncletPadBB->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">                              << "\' from block \'" << OldBlock->getName()</td>
    <td class="lineNumber">943</td>
    <td class="codeline">                              << "\' from block \'" << OldBlock->getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">                              << "\'.\n");</td>
    <td class="lineNumber">944</td>
    <td class="codeline">                              << "\'.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">945</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline"></td>
    <td class="lineNumber">946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">    // Loop over all of the instructions in this funclet, fixing up operand</td>
    <td class="lineNumber">947</td>
    <td class="codeline">    // Loop over all of the instructions in this funclet, fixing up operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">    // references as we go.  This uses VMap to do all the hard work.</td>
    <td class="lineNumber">948</td>
    <td class="codeline">    // references as we go.  This uses VMap to do all the hard work.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">    for (BasicBlock *BB : BlocksInFunclet)</td>
    <td class="lineNumber">949</td>
    <td class="codeline">    for (BasicBlock *BB : BlocksInFunclet)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">      // Loop over all instructions, fixing each one as we find it...</td>
    <td class="lineNumber">950</td>
    <td class="codeline">      // Loop over all instructions, fixing each one as we find it...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">      for (Instruction &I : *BB)</td>
    <td class="lineNumber">951</td>
    <td class="codeline">      for (Instruction &I : *BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">        RemapInstruction(&I, VMap,</td>
    <td class="lineNumber">952</td>
    <td class="codeline">        RemapInstruction(&I, VMap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">                         RF_IgnoreMissingLocals | RF_NoModuleLevelChanges);</td>
    <td class="lineNumber">953</td>
    <td class="codeline">                         RF_IgnoreMissingLocals | RF_NoModuleLevelChanges);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline"></td>
    <td class="lineNumber">954</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">    // Catchrets targeting cloned blocks need to be updated separately from</td>
    <td class="lineNumber">955</td>
    <td class="codeline">    // Catchrets targeting cloned blocks need to be updated separately from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">    // the loop above because they are not in the current funclet.</td>
    <td class="lineNumber">956</td>
    <td class="codeline">    // the loop above because they are not in the current funclet.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">    SmallVector<CatchReturnInst *, 2> FixupCatchrets;</td>
    <td class="lineNumber">957</td>
    <td class="codeline">    SmallVector<CatchReturnInst *, 2> FixupCatchrets;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">958</td>
    <td class="codeline">    for (auto &BBMapping : Orig2Clone) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">959</td>
    <td class="codeline">      BasicBlock *OldBlock = BBMapping.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">960</td>
    <td class="codeline">      BasicBlock *NewBlock = BBMapping.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline"></td>
    <td class="lineNumber">961</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">      FixupCatchrets.clear();</td>
    <td class="lineNumber">962</td>
    <td class="codeline">      FixupCatchrets.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">      for (BasicBlock *Pred : predecessors(OldBlock))</td>
    <td class="lineNumber">963</td>
    <td class="codeline">      for (BasicBlock *Pred : predecessors(OldBlock))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">        if (auto *CatchRet = dyn_cast<CatchReturnInst>(Pred->getTerminator()))</td>
    <td class="lineNumber">964</td>
    <td class="codeline">        if (auto *CatchRet = dyn_cast<CatchReturnInst>(Pred->getTerminator()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">          if (CatchRet->getCatchSwitchParentPad() == FuncletToken)</td>
    <td class="lineNumber">965</td>
    <td class="codeline">          if (CatchRet->getCatchSwitchParentPad() == FuncletToken)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">            FixupCatchrets.push_back(CatchRet);</td>
    <td class="lineNumber">966</td>
    <td class="codeline">            FixupCatchrets.push_back(CatchRet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">      for (CatchReturnInst *CatchRet : FixupCatchrets)</td>
    <td class="lineNumber">968</td>
    <td class="codeline">      for (CatchReturnInst *CatchRet : FixupCatchrets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">        CatchRet->setSuccessor(NewBlock);</td>
    <td class="lineNumber">969</td>
    <td class="codeline">        CatchRet->setSuccessor(NewBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">970</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline"></td>
    <td class="lineNumber">971</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">    auto UpdatePHIOnClonedBlock = [&](PHINode *PN, bool IsForOldBlock) {</td>
    <td class="lineNumber">972</td>
    <td class="codeline">    auto UpdatePHIOnClonedBlock = [&](PHINode *PN, bool IsForOldBlock) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">      unsigned NumPreds = PN->getNumIncomingValues();</td>
    <td class="lineNumber">973</td>
    <td class="codeline">      unsigned NumPreds = PN->getNumIncomingValues();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">      for (unsigned PredIdx = 0, PredEnd = NumPreds; PredIdx != PredEnd;</td>
    <td class="lineNumber">974</td>
    <td class="codeline">      for (unsigned PredIdx = 0, PredEnd = NumPreds; PredIdx != PredEnd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">           ++PredIdx) {</td>
    <td class="lineNumber">975</td>
    <td class="codeline">           ++PredIdx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">        BasicBlock *IncomingBlock = PN->getIncomingBlock(PredIdx);</td>
    <td class="lineNumber">976</td>
    <td class="codeline">        BasicBlock *IncomingBlock = PN->getIncomingBlock(PredIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">        bool EdgeTargetsFunclet;</td>
    <td class="lineNumber">977</td>
    <td class="codeline">        bool EdgeTargetsFunclet;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">        if (auto *CRI =</td>
    <td class="lineNumber">978</td>
    <td class="codeline">        if (auto *CRI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">                dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
    <td class="lineNumber">979</td>
    <td class="codeline">                dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">          EdgeTargetsFunclet = (CRI->getCatchSwitchParentPad() == FuncletToken);</td>
    <td class="lineNumber">980</td>
    <td class="codeline">          EdgeTargetsFunclet = (CRI->getCatchSwitchParentPad() == FuncletToken);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">981</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">          ColorVector &IncomingColors = BlockColors[IncomingBlock];</td>
    <td class="lineNumber">982</td>
    <td class="codeline">          ColorVector &IncomingColors = BlockColors[IncomingBlock];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">          assert(!IncomingColors.empty() && "Block not colored!");</td>
    <td class="lineNumber">983</td>
    <td class="codeline">          assert(!IncomingColors.empty() && "Block not colored!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">          assert((IncomingColors.size() == 1 ||</td>
    <td class="lineNumber">984</td>
    <td class="codeline">          assert((IncomingColors.size() == 1 ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">                  !llvm::is_contained(IncomingColors, FuncletPadBB)) &&</td>
    <td class="lineNumber">985</td>
    <td class="codeline">                  !llvm::is_contained(IncomingColors, FuncletPadBB)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">                 "Cloning should leave this funclet's blocks monochromatic");</td>
    <td class="lineNumber">986</td>
    <td class="codeline">                 "Cloning should leave this funclet's blocks monochromatic");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">          EdgeTargetsFunclet = (IncomingColors.front() == FuncletPadBB);</td>
    <td class="lineNumber">987</td>
    <td class="codeline">          EdgeTargetsFunclet = (IncomingColors.front() == FuncletPadBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">988</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">        if (IsForOldBlock != EdgeTargetsFunclet)</td>
    <td class="lineNumber">989</td>
    <td class="codeline">        if (IsForOldBlock != EdgeTargetsFunclet)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">990</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">        PN->removeIncomingValue(IncomingBlock, /*DeletePHIIfEmpty=*/false);</td>
    <td class="lineNumber">991</td>
    <td class="codeline">        PN->removeIncomingValue(IncomingBlock, /*DeletePHIIfEmpty=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">        // Revisit the next entry.</td>
    <td class="lineNumber">992</td>
    <td class="codeline">        // Revisit the next entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">        --PredIdx;</td>
    <td class="lineNumber">993</td>
    <td class="codeline">        --PredIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">        --PredEnd;</td>
    <td class="lineNumber">994</td>
    <td class="codeline">        --PredEnd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">995</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">996</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline"></td>
    <td class="lineNumber">997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">998</td>
    <td class="codeline">    for (auto &BBMapping : Orig2Clone) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">999</td>
    <td class="codeline">      BasicBlock *OldBlock = BBMapping.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">      BasicBlock *NewBlock = BBMapping.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">      for (PHINode &OldPN : OldBlock->phis()) {</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">      for (PHINode &OldPN : OldBlock->phis()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">        UpdatePHIOnClonedBlock(&OldPN, /*IsForOldBlock=*/true);</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">        UpdatePHIOnClonedBlock(&OldPN, /*IsForOldBlock=*/true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">      for (PHINode &NewPN : NewBlock->phis()) {</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">      for (PHINode &NewPN : NewBlock->phis()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">        UpdatePHIOnClonedBlock(&NewPN, /*IsForOldBlock=*/false);</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">        UpdatePHIOnClonedBlock(&NewPN, /*IsForOldBlock=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline"></td>
    <td class="lineNumber">1008</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">    // Check to see if SuccBB has PHI nodes. If so, we need to add entries to</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">    // Check to see if SuccBB has PHI nodes. If so, we need to add entries to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">    // the PHI nodes for NewBB now.</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">    // the PHI nodes for NewBB now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">    for (auto &BBMapping : Orig2Clone) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">      BasicBlock *OldBlock = BBMapping.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">      BasicBlock *NewBlock = BBMapping.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">      for (BasicBlock *SuccBB : successors(NewBlock)) {</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">      for (BasicBlock *SuccBB : successors(NewBlock)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">        for (PHINode &SuccPN : SuccBB->phis()) {</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">        for (PHINode &SuccPN : SuccBB->phis()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">          // Ok, we have a PHI node.  Figure out what the incoming value was for</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">          // Ok, we have a PHI node.  Figure out what the incoming value was for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">          // the OldBlock.</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">          // the OldBlock.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">          int OldBlockIdx = SuccPN.getBasicBlockIndex(OldBlock);</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">          int OldBlockIdx = SuccPN.getBasicBlockIndex(OldBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">          if (OldBlockIdx == -1)</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">          if (OldBlockIdx == -1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">            break;</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">            break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">          Value *IV = SuccPN.getIncomingValue(OldBlockIdx);</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">          Value *IV = SuccPN.getIncomingValue(OldBlockIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">          // Remap the value if necessary.</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">          // Remap the value if necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">          if (auto *Inst = dyn_cast<Instruction>(IV)) {</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">          if (auto *Inst = dyn_cast<Instruction>(IV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">            ValueToValueMapTy::iterator I = VMap.find(Inst);</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">            ValueToValueMapTy::iterator I = VMap.find(Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">            if (I != VMap.end())</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">            if (I != VMap.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">              IV = I->second;</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">              IV = I->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline"></td>
    <td class="lineNumber">1029</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">          SuccPN.addIncoming(IV, NewBlock);</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">          SuccPN.addIncoming(IV, NewBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline"></td>
    <td class="lineNumber">1034</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">    for (ValueToValueMapTy::value_type VT : VMap) {</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">    for (ValueToValueMapTy::value_type VT : VMap) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">      // If there were values defined in BB that are used outside the funclet,</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">      // If there were values defined in BB that are used outside the funclet,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">      // then we now have to update all uses of the value to use either the</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">      // then we now have to update all uses of the value to use either the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">      // original value, the cloned value, or some PHI derived value.  This can</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">      // original value, the cloned value, or some PHI derived value.  This can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">      // require arbitrary PHI insertion, of which we are prepared to do, clean</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">      // require arbitrary PHI insertion, of which we are prepared to do, clean</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">      // these up now.</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">      // these up now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">      SmallVector<Use *, 16> UsesToRename;</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">      SmallVector<Use *, 16> UsesToRename;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline"></td>
    <td class="lineNumber">1042</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">      auto *OldI = dyn_cast<Instruction>(const_cast<Value *>(VT.first));</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">      auto *OldI = dyn_cast<Instruction>(const_cast<Value *>(VT.first));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">      if (!OldI)</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">      if (!OldI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">      auto *NewI = cast<Instruction>(VT.second);</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">      auto *NewI = cast<Instruction>(VT.second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">      // Scan all uses of this instruction to see if it is used outside of its</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">      // Scan all uses of this instruction to see if it is used outside of its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">      // funclet, and if so, record them in UsesToRename.</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">      // funclet, and if so, record them in UsesToRename.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">      for (Use &U : OldI->uses()) {</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">      for (Use &U : OldI->uses()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">        Instruction *UserI = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">        Instruction *UserI = cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">        BasicBlock *UserBB = UserI->getParent();</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">        BasicBlock *UserBB = UserI->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">        ColorVector &ColorsForUserBB = BlockColors[UserBB];</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">        ColorVector &ColorsForUserBB = BlockColors[UserBB];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">        assert(!ColorsForUserBB.empty());</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">        assert(!ColorsForUserBB.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">        if (ColorsForUserBB.size() > 1 ||</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">        if (ColorsForUserBB.size() > 1 ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">            *ColorsForUserBB.begin() != FuncletPadBB)</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">            *ColorsForUserBB.begin() != FuncletPadBB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">          UsesToRename.push_back(&U);</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">          UsesToRename.push_back(&U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">      // If there are no uses outside the block, we're done with this</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">      // If there are no uses outside the block, we're done with this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">      // instruction.</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">      // instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">      if (UsesToRename.empty())</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">      if (UsesToRename.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">      // We found a use of OldI outside of the funclet.  Rename all uses of OldI</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">      // We found a use of OldI outside of the funclet.  Rename all uses of OldI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">      // that are outside its funclet to be uses of the appropriate PHI node</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">      // that are outside its funclet to be uses of the appropriate PHI node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">      // etc.</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">      // etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">      SSAUpdater SSAUpdate;</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">      SSAUpdater SSAUpdate;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">      SSAUpdate.Initialize(OldI->getType(), OldI->getName());</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">      SSAUpdate.Initialize(OldI->getType(), OldI->getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">      SSAUpdate.AddAvailableValue(OldI->getParent(), OldI);</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">      SSAUpdate.AddAvailableValue(OldI->getParent(), OldI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">      SSAUpdate.AddAvailableValue(NewI->getParent(), NewI);</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">      SSAUpdate.AddAvailableValue(NewI->getParent(), NewI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">      while (!UsesToRename.empty())</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">      while (!UsesToRename.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">        SSAUpdate.RewriteUseAfterInsertions(*UsesToRename.pop_back_val());</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">        SSAUpdate.RewriteUseAfterInsertions(*UsesToRename.pop_back_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline"></td>
    <td class="lineNumber">1077</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">void WinEHPrepare::removeImplausibleInstructions(Function &F) {</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">void WinEHPrepare::removeImplausibleInstructions(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">  // Remove implausible terminators and replace them with UnreachableInst.</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">  // Remove implausible terminators and replace them with UnreachableInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">  for (auto &Funclet : FuncletBlocks) {</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">  for (auto &Funclet : FuncletBlocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">    BasicBlock *FuncletPadBB = Funclet.first;</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">    BasicBlock *FuncletPadBB = Funclet.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">    std::vector<BasicBlock *> &BlocksInFunclet = Funclet.second;</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">    std::vector<BasicBlock *> &BlocksInFunclet = Funclet.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">    Instruction *FirstNonPHI = FuncletPadBB->getFirstNonPHI();</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">    Instruction *FirstNonPHI = FuncletPadBB->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">    auto *FuncletPad = dyn_cast<FuncletPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">    auto *FuncletPad = dyn_cast<FuncletPadInst>(FirstNonPHI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">    auto *CatchPad = dyn_cast_or_null<CatchPadInst>(FuncletPad);</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">    auto *CatchPad = dyn_cast_or_null<CatchPadInst>(FuncletPad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">    auto *CleanupPad = dyn_cast_or_null<CleanupPadInst>(FuncletPad);</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">    auto *CleanupPad = dyn_cast_or_null<CleanupPadInst>(FuncletPad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">    for (BasicBlock *BB : BlocksInFunclet) {</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">    for (BasicBlock *BB : BlocksInFunclet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">      for (Instruction &I : *BB) {</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">      for (Instruction &I : *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">        auto *CB = dyn_cast<CallBase>(&I);</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">        auto *CB = dyn_cast<CallBase>(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">        if (!CB)</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">        if (!CB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline"></td>
    <td class="lineNumber">1093</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">        Value *FuncletBundleOperand = nullptr;</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">        Value *FuncletBundleOperand = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">        if (auto BU = CB->getOperandBundle(LLVMContext::OB_funclet))</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">        if (auto BU = CB->getOperandBundle(LLVMContext::OB_funclet))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">          FuncletBundleOperand = BU->Inputs.front();</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">          FuncletBundleOperand = BU->Inputs.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline"></td>
    <td class="lineNumber">1097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">        if (FuncletBundleOperand == FuncletPad)</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">        if (FuncletBundleOperand == FuncletPad)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline"></td>
    <td class="lineNumber">1100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">        // Skip call sites which are nounwind intrinsics or inline asm.</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">        // Skip call sites which are nounwind intrinsics or inline asm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">        auto *CalledFn =</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">        auto *CalledFn =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">            dyn_cast<Function>(CB->getCalledOperand()->stripPointerCasts());</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">            dyn_cast<Function>(CB->getCalledOperand()->stripPointerCasts());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">        if (CalledFn && ((CalledFn->isIntrinsic() && CB->doesNotThrow()) ||</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">        if (CalledFn && ((CalledFn->isIntrinsic() && CB->doesNotThrow()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">                         CB->isInlineAsm()))</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">                         CB->isInlineAsm()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline"></td>
    <td class="lineNumber">1107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">        // This call site was not part of this funclet, remove it.</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">        // This call site was not part of this funclet, remove it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">        if (isa<InvokeInst>(CB)) {</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">        if (isa<InvokeInst>(CB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">          // Remove the unwind edge if it was an invoke.</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">          // Remove the unwind edge if it was an invoke.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">          removeUnwindEdge(BB);</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">          removeUnwindEdge(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">          // Get a pointer to the new call.</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">          // Get a pointer to the new call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">          BasicBlock::iterator CallI =</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">          BasicBlock::iterator CallI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">              std::prev(BB->getTerminator()->getIterator());</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">              std::prev(BB->getTerminator()->getIterator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">          auto *CI = cast<CallInst>(&*CallI);</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">          auto *CI = cast<CallInst>(&*CallI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">          changeToUnreachable(CI);</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">          changeToUnreachable(CI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">          changeToUnreachable(&I);</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">          changeToUnreachable(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline"></td>
    <td class="lineNumber">1120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">        // There are no more instructions in the block (except for unreachable),</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">        // There are no more instructions in the block (except for unreachable),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">        // we are done.</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">        // we are done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline"></td>
    <td class="lineNumber">1125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">      Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">      Instruction *TI = BB->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">      // CatchPadInst and CleanupPadInst can't transfer control to a ReturnInst.</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">      // CatchPadInst and CleanupPadInst can't transfer control to a ReturnInst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">      bool IsUnreachableRet = isa<ReturnInst>(TI) && FuncletPad;</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">      bool IsUnreachableRet = isa<ReturnInst>(TI) && FuncletPad;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">      // The token consumed by a CatchReturnInst must match the funclet token.</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">      // The token consumed by a CatchReturnInst must match the funclet token.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">      bool IsUnreachableCatchret = false;</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">      bool IsUnreachableCatchret = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">      if (auto *CRI = dyn_cast<CatchReturnInst>(TI))</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">      if (auto *CRI = dyn_cast<CatchReturnInst>(TI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">        IsUnreachableCatchret = CRI->getCatchPad() != CatchPad;</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">        IsUnreachableCatchret = CRI->getCatchPad() != CatchPad;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">      // The token consumed by a CleanupReturnInst must match the funclet token.</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">      // The token consumed by a CleanupReturnInst must match the funclet token.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">      bool IsUnreachableCleanupret = false;</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">      bool IsUnreachableCleanupret = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">      if (auto *CRI = dyn_cast<CleanupReturnInst>(TI))</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">      if (auto *CRI = dyn_cast<CleanupReturnInst>(TI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">        IsUnreachableCleanupret = CRI->getCleanupPad() != CleanupPad;</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">        IsUnreachableCleanupret = CRI->getCleanupPad() != CleanupPad;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">      if (IsUnreachableRet || IsUnreachableCatchret ||</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">      if (IsUnreachableRet || IsUnreachableCatchret ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">          IsUnreachableCleanupret) {</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">          IsUnreachableCleanupret) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">        changeToUnreachable(TI);</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">        changeToUnreachable(TI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">      } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">      } else if (isa<InvokeInst>(TI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">        if (Personality == EHPersonality::MSVC_CXX && CleanupPad) {</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">        if (Personality == EHPersonality::MSVC_CXX && CleanupPad) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">          // Invokes within a cleanuppad for the MSVC++ personality never</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">          // Invokes within a cleanuppad for the MSVC++ personality never</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">          // transfer control to their unwind edge: the personality will</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">          // transfer control to their unwind edge: the personality will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">          // terminate the program.</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">          // terminate the program.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">          removeUnwindEdge(BB);</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">          removeUnwindEdge(BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">void WinEHPrepare::cleanupPreparedFunclets(Function &F) {</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">void WinEHPrepare::cleanupPreparedFunclets(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  // Clean-up some of the mess we made by removing useles PHI nodes, trivial</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  // Clean-up some of the mess we made by removing useles PHI nodes, trivial</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  // branches, etc.</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  // branches, etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  for (BasicBlock &BB : llvm::make_early_inc_range(F)) {</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  for (BasicBlock &BB : llvm::make_early_inc_range(F)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">    SimplifyInstructionsInBlock(&BB);</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">    SimplifyInstructionsInBlock(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">    ConstantFoldTerminator(&BB, /*DeleteDeadConditions=*/true);</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">    ConstantFoldTerminator(&BB, /*DeleteDeadConditions=*/true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">    MergeBlockIntoPredecessor(&BB);</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">    MergeBlockIntoPredecessor(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline"></td>
    <td class="lineNumber">1160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">  // We might have some unreachable blocks after cleaning up some impossible</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">  // We might have some unreachable blocks after cleaning up some impossible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">  // control flow.</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">  // control flow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  removeUnreachableBlocks(F);</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  removeUnreachableBlocks(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline"></td>
    <td class="lineNumber">1165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">void WinEHPrepare::verifyPreparedFunclets(Function &F) {</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">void WinEHPrepare::verifyPreparedFunclets(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  for (BasicBlock &BB : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">    size_t NumColors = BlockColors[&BB].size();</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">    size_t NumColors = BlockColors[&BB].size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">    assert(NumColors == 1 && "Expected monochromatic BB!");</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">    assert(NumColors == 1 && "Expected monochromatic BB!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">    if (NumColors == 0)</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">    if (NumColors == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">      report_fatal_error("Uncolored BB!");</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">      report_fatal_error("Uncolored BB!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">    if (NumColors > 1)</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">    if (NumColors > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">      report_fatal_error("Multicolor BB!");</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">      report_fatal_error("Multicolor BB!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">    assert((DisableDemotion || !(BB.isEHPad() && isa<PHINode>(BB.begin()))) &&</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">    assert((DisableDemotion || !(BB.isEHPad() && isa<PHINode>(BB.begin()))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">           "EH Pad still has a PHI!");</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">           "EH Pad still has a PHI!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline"></td>
    <td class="lineNumber">1180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">bool WinEHPrepare::prepareExplicitEH(Function &F) {</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">bool WinEHPrepare::prepareExplicitEH(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">  // Remove unreachable blocks.  It is not valuable to assign them a color and</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">  // Remove unreachable blocks.  It is not valuable to assign them a color and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">  // their existence can trick us into thinking values are alive when they are</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">  // their existence can trick us into thinking values are alive when they are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">  // not.</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">  // not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">  removeUnreachableBlocks(F);</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">  removeUnreachableBlocks(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  // Determine which blocks are reachable from which funclet entries.</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  // Determine which blocks are reachable from which funclet entries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  colorFunclets(F);</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  colorFunclets(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline"></td>
    <td class="lineNumber">1189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  cloneCommonBlocks(F);</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  cloneCommonBlocks(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  if (!DisableDemotion)</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  if (!DisableDemotion)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">    demotePHIsOnFunclets(F, DemoteCatchSwitchPHIOnly ||</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">    demotePHIsOnFunclets(F, DemoteCatchSwitchPHIOnly ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">                                DemoteCatchSwitchPHIOnlyOpt);</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">                                DemoteCatchSwitchPHIOnlyOpt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline"></td>
    <td class="lineNumber">1195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">  if (!DisableCleanups) {</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">  if (!DisableCleanups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">    assert(!verifyFunction(F, &dbgs()));</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">    assert(!verifyFunction(F, &dbgs()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">    removeImplausibleInstructions(F);</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">    removeImplausibleInstructions(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">    assert(!verifyFunction(F, &dbgs()));</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">    assert(!verifyFunction(F, &dbgs()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">    cleanupPreparedFunclets(F);</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">    cleanupPreparedFunclets(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline"></td>
    <td class="lineNumber">1203</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  // Recolor the CFG to verify that all is well.</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  // Recolor the CFG to verify that all is well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">  LLVM_DEBUG(colorFunclets(F));</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">  LLVM_DEBUG(colorFunclets(F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  BlockColors.clear();</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  BlockColors.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  FuncletBlocks.clear();</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  FuncletBlocks.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline"></td>
    <td class="lineNumber">1211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline"></td>
    <td class="lineNumber">1214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">// TODO: Share loads when one use dominates another, or when a catchpad exit</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">// TODO: Share loads when one use dominates another, or when a catchpad exit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">// dominates uses (needs dominators).</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">// dominates uses (needs dominators).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">AllocaInst *WinEHPrepare::insertPHILoads(PHINode *PN, Function &F) {</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">AllocaInst *WinEHPrepare::insertPHILoads(PHINode *PN, Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  BasicBlock *PHIBlock = PN->getParent();</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  BasicBlock *PHIBlock = PN->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">  AllocaInst *SpillSlot = nullptr;</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">  AllocaInst *SpillSlot = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  Instruction *EHPad = PHIBlock->getFirstNonPHI();</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  Instruction *EHPad = PHIBlock->getFirstNonPHI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  if (!EHPad->isTerminator()) {</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  if (!EHPad->isTerminator()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">    // If the EHPad isn't a terminator, then we can insert a load in this block</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">    // If the EHPad isn't a terminator, then we can insert a load in this block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">    // that will dominate all uses.</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">    // that will dominate all uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">    SpillSlot = new AllocaInst(PN->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">    SpillSlot = new AllocaInst(PN->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">                               Twine(PN->getName(), ".wineh.spillslot"),</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">                               Twine(PN->getName(), ".wineh.spillslot"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">                               &F.getEntryBlock().front());</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">                               &F.getEntryBlock().front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">    Value *V = new LoadInst(PN->getType(), SpillSlot,</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">    Value *V = new LoadInst(PN->getType(), SpillSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">                            Twine(PN->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">                            Twine(PN->getName(), ".wineh.reload"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">                            &*PHIBlock->getFirstInsertionPt());</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">                            &*PHIBlock->getFirstInsertionPt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">    PN->replaceAllUsesWith(V);</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">    PN->replaceAllUsesWith(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">    return SpillSlot;</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">    return SpillSlot;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  // Otherwise, we have a PHI on a terminator EHPad, and we give up and insert</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  // Otherwise, we have a PHI on a terminator EHPad, and we give up and insert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  // loads of the slot before every use.</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  // loads of the slot before every use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  DenseMap<BasicBlock *, Value *> Loads;</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  DenseMap<BasicBlock *, Value *> Loads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  for (Use &U : llvm::make_early_inc_range(PN->uses())) {</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  for (Use &U : llvm::make_early_inc_range(PN->uses())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">    auto *UsingInst = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">    auto *UsingInst = cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">    if (isa<PHINode>(UsingInst) && UsingInst->getParent()->isEHPad()) {</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">    if (isa<PHINode>(UsingInst) && UsingInst->getParent()->isEHPad()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">      // Use is on an EH pad phi.  Leave it alone; we'll insert loads and</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">      // Use is on an EH pad phi.  Leave it alone; we'll insert loads and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">      // stores for it separately.</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">      // stores for it separately.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">    replaceUseWithLoad(PN, U, SpillSlot, Loads, F);</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">    replaceUseWithLoad(PN, U, SpillSlot, Loads, F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  return SpillSlot;</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  return SpillSlot;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline"></td>
    <td class="lineNumber">1249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">// TODO: improve store placement.  Inserting at def is probably good, but need</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">// TODO: improve store placement.  Inserting at def is probably good, but need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">// to be careful not to introduce interfering stores (needs liveness analysis).</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">// to be careful not to introduce interfering stores (needs liveness analysis).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">// TODO: identify related phi nodes that can share spill slots, and share them</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">// TODO: identify related phi nodes that can share spill slots, and share them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">// (also needs liveness).</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">// (also needs liveness).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">void WinEHPrepare::insertPHIStores(PHINode *OriginalPHI,</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">void WinEHPrepare::insertPHIStores(PHINode *OriginalPHI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">                                   AllocaInst *SpillSlot) {</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">                                   AllocaInst *SpillSlot) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  // Use a worklist of (Block, Value) pairs -- the given Value needs to be</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  // Use a worklist of (Block, Value) pairs -- the given Value needs to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  // stored to the spill slot by the end of the given Block.</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  // stored to the spill slot by the end of the given Block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  SmallVector<std::pair<BasicBlock *, Value *>, 4> Worklist;</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  SmallVector<std::pair<BasicBlock *, Value *>, 4> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline"></td>
    <td class="lineNumber">1259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  Worklist.push_back({OriginalPHI->getParent(), OriginalPHI});</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  Worklist.push_back({OriginalPHI->getParent(), OriginalPHI});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline"></td>
    <td class="lineNumber">1261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">    BasicBlock *EHBlock;</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">    BasicBlock *EHBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">    Value *InVal;</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">    Value *InVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">    std::tie(EHBlock, InVal) = Worklist.pop_back_val();</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">    std::tie(EHBlock, InVal) = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">    PHINode *PN = dyn_cast<PHINode>(InVal);</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">    PHINode *PN = dyn_cast<PHINode>(InVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">    if (PN && PN->getParent() == EHBlock) {</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">    if (PN && PN->getParent() == EHBlock) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">      // The value is defined by another PHI we need to remove, with no room to</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">      // The value is defined by another PHI we need to remove, with no room to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">      // insert a store after the PHI, so each predecessor needs to store its</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">      // insert a store after the PHI, so each predecessor needs to store its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">      // incoming value.</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">      // incoming value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">      for (unsigned i = 0, e = PN->getNumIncomingValues(); i < e; ++i) {</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">      for (unsigned i = 0, e = PN->getNumIncomingValues(); i < e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">        Value *PredVal = PN->getIncomingValue(i);</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">        Value *PredVal = PN->getIncomingValue(i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline"></td>
    <td class="lineNumber">1274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">        // Undef can safely be skipped.</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">        // Undef can safely be skipped.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">        if (isa<UndefValue>(PredVal))</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">        if (isa<UndefValue>(PredVal))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline"></td>
    <td class="lineNumber">1278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">        insertPHIStore(PN->getIncomingBlock(i), PredVal, SpillSlot, Worklist);</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">        insertPHIStore(PN->getIncomingBlock(i), PredVal, SpillSlot, Worklist);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">      // We need to store InVal, which dominates EHBlock, but can't put a store</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">      // We need to store InVal, which dominates EHBlock, but can't put a store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">      // in EHBlock, so need to put stores in each predecessor.</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">      // in EHBlock, so need to put stores in each predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">      for (BasicBlock *PredBlock : predecessors(EHBlock)) {</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">      for (BasicBlock *PredBlock : predecessors(EHBlock)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">        insertPHIStore(PredBlock, InVal, SpillSlot, Worklist);</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">        insertPHIStore(PredBlock, InVal, SpillSlot, Worklist);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline"></td>
    <td class="lineNumber">1290</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">void WinEHPrepare::insertPHIStore(</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">void WinEHPrepare::insertPHIStore(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">    BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">    BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">    SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist) {</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">    SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline"></td>
    <td class="lineNumber">1294</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">  if (PredBlock->isEHPad() && PredBlock->getFirstNonPHI()->isTerminator()) {</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">  if (PredBlock->isEHPad() && PredBlock->getFirstNonPHI()->isTerminator()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">    // Pred is unsplittable, so we need to queue it on the worklist.</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">    // Pred is unsplittable, so we need to queue it on the worklist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">    Worklist.push_back({PredBlock, PredVal});</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">    Worklist.push_back({PredBlock, PredVal});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">  // Otherwise, insert the store at the end of the basic block.</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">  // Otherwise, insert the store at the end of the basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">  new StoreInst(PredVal, SpillSlot, PredBlock->getTerminator());</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">  new StoreInst(PredVal, SpillSlot, PredBlock->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline"></td>
    <td class="lineNumber">1304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">void WinEHPrepare::replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">void WinEHPrepare::replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">                                      DenseMap<BasicBlock *, Value *> &Loads,</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">                                      DenseMap<BasicBlock *, Value *> &Loads,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">                                      Function &F) {</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">                                      Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">  // Lazilly create the spill slot.</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">  // Lazilly create the spill slot.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">  if (!SpillSlot)</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">  if (!SpillSlot)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">    SpillSlot = new AllocaInst(V->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">    SpillSlot = new AllocaInst(V->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">                               Twine(V->getName(), ".wineh.spillslot"),</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">                               Twine(V->getName(), ".wineh.spillslot"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">                               &F.getEntryBlock().front());</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">                               &F.getEntryBlock().front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline"></td>
    <td class="lineNumber">1313</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">  auto *UsingInst = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">  auto *UsingInst = cast<Instruction>(U.getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  if (auto *UsingPHI = dyn_cast<PHINode>(UsingInst)) {</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  if (auto *UsingPHI = dyn_cast<PHINode>(UsingInst)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">    // If this is a PHI node, we can't insert a load of the value before</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">    // If this is a PHI node, we can't insert a load of the value before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">    // the use.  Instead insert the load in the predecessor block</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">    // the use.  Instead insert the load in the predecessor block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">    // corresponding to the incoming value.</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">    // corresponding to the incoming value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">    // Note that if there are multiple edges from a basic block to this</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">    // Note that if there are multiple edges from a basic block to this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">    // PHI node that we cannot have multiple loads.  The problem is that</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">    // PHI node that we cannot have multiple loads.  The problem is that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">    // the resulting PHI node will have multiple values (from each load)</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">    // the resulting PHI node will have multiple values (from each load)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">    // coming in from the same block, which is illegal SSA form.</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">    // coming in from the same block, which is illegal SSA form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">    // For this reason, we keep track of and reuse loads we insert.</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">    // For this reason, we keep track of and reuse loads we insert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">    BasicBlock *IncomingBlock = UsingPHI->getIncomingBlock(U);</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">    BasicBlock *IncomingBlock = UsingPHI->getIncomingBlock(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    if (auto *CatchRet =</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    if (auto *CatchRet =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">            dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">            dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">      // Putting a load above a catchret and use on the phi would still leave</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">      // Putting a load above a catchret and use on the phi would still leave</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">      // a cross-funclet def/use.  We need to split the edge, change the</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">      // a cross-funclet def/use.  We need to split the edge, change the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">      // catchret to target the new block, and put the load there.</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">      // catchret to target the new block, and put the load there.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">      BasicBlock *PHIBlock = UsingInst->getParent();</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">      BasicBlock *PHIBlock = UsingInst->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">      BasicBlock *NewBlock = SplitEdge(IncomingBlock, PHIBlock);</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">      BasicBlock *NewBlock = SplitEdge(IncomingBlock, PHIBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">      // SplitEdge gives us:</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">      // SplitEdge gives us:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">      //   IncomingBlock:</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">      //   IncomingBlock:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">      //     ...</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">      //     ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">      //     br label %NewBlock</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">      //     br label %NewBlock</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">      //   NewBlock:</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">      //   NewBlock:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">      //     catchret label %PHIBlock</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">      //     catchret label %PHIBlock</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">      // But we need:</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">      // But we need:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">      //   IncomingBlock:</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">      //   IncomingBlock:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">      //     ...</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">      //     ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">      //     catchret label %NewBlock</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">      //     catchret label %NewBlock</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">      //   NewBlock:</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">      //   NewBlock:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">      //     br label %PHIBlock</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">      //     br label %PHIBlock</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">      // So move the terminators to each others' blocks and swap their</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">      // So move the terminators to each others' blocks and swap their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">      // successors.</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">      // successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">      BranchInst *Goto = cast<BranchInst>(IncomingBlock->getTerminator());</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">      BranchInst *Goto = cast<BranchInst>(IncomingBlock->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">      Goto->removeFromParent();</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">      Goto->removeFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">      CatchRet->removeFromParent();</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">      CatchRet->removeFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">      CatchRet->insertInto(IncomingBlock, IncomingBlock->end());</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">      CatchRet->insertInto(IncomingBlock, IncomingBlock->end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">      Goto->insertInto(NewBlock, NewBlock->end());</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">      Goto->insertInto(NewBlock, NewBlock->end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">      Goto->setSuccessor(0, PHIBlock);</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">      Goto->setSuccessor(0, PHIBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">      CatchRet->setSuccessor(NewBlock);</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">      CatchRet->setSuccessor(NewBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">      // Update the color mapping for the newly split edge.</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">      // Update the color mapping for the newly split edge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">      // Grab a reference to the ColorVector to be inserted before getting the</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">      // Grab a reference to the ColorVector to be inserted before getting the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">      // reference to the vector we are copying because inserting the new</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">      // reference to the vector we are copying because inserting the new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">      // element in BlockColors might cause the map to be reallocated.</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">      // element in BlockColors might cause the map to be reallocated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">      ColorVector &ColorsForNewBlock = BlockColors[NewBlock];</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">      ColorVector &ColorsForNewBlock = BlockColors[NewBlock];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">      ColorVector &ColorsForPHIBlock = BlockColors[PHIBlock];</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">      ColorVector &ColorsForPHIBlock = BlockColors[PHIBlock];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">      ColorsForNewBlock = ColorsForPHIBlock;</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">      ColorsForNewBlock = ColorsForPHIBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">      for (BasicBlock *FuncletPad : ColorsForPHIBlock)</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">      for (BasicBlock *FuncletPad : ColorsForPHIBlock)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">        FuncletBlocks[FuncletPad].push_back(NewBlock);</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">        FuncletBlocks[FuncletPad].push_back(NewBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">      // Treat the new block as incoming for load insertion.</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">      // Treat the new block as incoming for load insertion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">      IncomingBlock = NewBlock;</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">      IncomingBlock = NewBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">    Value *&Load = Loads[IncomingBlock];</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">    Value *&Load = Loads[IncomingBlock];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">    // Insert the load into the predecessor block</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">    // Insert the load into the predecessor block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">    if (!Load)</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">    if (!Load)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">      Load = new LoadInst(V->getType(), SpillSlot,</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">      Load = new LoadInst(V->getType(), SpillSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">                          Twine(V->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">                          Twine(V->getName(), ".wineh.reload"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">                          /*isVolatile=*/false, IncomingBlock->getTerminator());</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">                          /*isVolatile=*/false, IncomingBlock->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline"></td>
    <td class="lineNumber">1372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">    U.set(Load);</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">    U.set(Load);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">    // Reload right before the old use.</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">    // Reload right before the old use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">    auto *Load = new LoadInst(V->getType(), SpillSlot,</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">    auto *Load = new LoadInst(V->getType(), SpillSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">                              Twine(V->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">                              Twine(V->getName(), ".wineh.reload"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">                              /*isVolatile=*/false, UsingInst);</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">                              /*isVolatile=*/false, UsingInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">    U.set(Load);</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">    U.set(Load);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">void WinEHFuncInfo::addIPToStateRange(const InvokeInst *II,</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">void WinEHFuncInfo::addIPToStateRange(const InvokeInst *II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">                                      MCSymbol *InvokeBegin,</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">                                      MCSymbol *InvokeBegin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">                                      MCSymbol *InvokeEnd) {</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">                                      MCSymbol *InvokeEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">  assert(InvokeStateMap.count(II) &&</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">  assert(InvokeStateMap.count(II) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">         "should get invoke with precomputed state");</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">         "should get invoke with precomputed state");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">  LabelToStateMap[InvokeBegin] = std::make_pair(InvokeStateMap[II], InvokeEnd);</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">  LabelToStateMap[InvokeBegin] = std::make_pair(InvokeStateMap[II], InvokeEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">void WinEHFuncInfo::addIPToStateRange(int State, MCSymbol* InvokeBegin,</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">void WinEHFuncInfo::addIPToStateRange(int State, MCSymbol* InvokeBegin,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">    MCSymbol* InvokeEnd) {</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">    MCSymbol* InvokeEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    LabelToStateMap[InvokeBegin] = std::make_pair(State, InvokeEnd);</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    LabelToStateMap[InvokeBegin] = std::make_pair(State, InvokeEnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">WinEHFuncInfo::WinEHFuncInfo() = default;</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">WinEHFuncInfo::WinEHFuncInfo() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- WinEHPrepare - Prepare exception handling for code generation ---===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- WinEHPrepare - Prepare exception handling for code generation ---===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass lowers LLVM IR exception handling into something closer to what the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass lowers LLVM IR exception handling into something closer to what the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// backend wants for functions using a personality function from a runtime</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// backend wants for functions using a personality function from a runtime</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// provided by MSVC. Functions with other personality functions are left alone</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// provided by MSVC. Functions with other personality functions are left alone</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// and may be prepared by other passes. In particular, all supported MSVC</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// and may be prepared by other passes. In particular, all supported MSVC</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">// personality functions require cleanup code to be outlined, and the C++</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">// personality functions require cleanup code to be outlined, and the C++</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// personality requires catch handler code to be outlined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// personality requires catch handler code to be outlined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/MapVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/Passes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/Passes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/WinEHFuncInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/WinEHFuncInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/IR/EHPersonalities.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/IR/EHPersonalities.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/Verifier.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/Verifier.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/TargetParser/Triple.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/TargetParser/Triple.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Cloning.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Cloning.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/SSAUpdater.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/SSAUpdater.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#define DEBUG_TYPE "winehprepare"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#define DEBUG_TYPE "winehprepare"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">static cl::opt<bool> DisableDemotion(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">static cl::opt<bool> DisableDemotion(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">    "disable-demotion", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">    "disable-demotion", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">    cl::desc(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">    cl::desc(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">        "Clone multicolor basic blocks but do not demote cross scopes"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">        "Clone multicolor basic blocks but do not demote cross scopes"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">    cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">    cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">static cl::opt<bool> DisableCleanups(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">static cl::opt<bool> DisableCleanups(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">    "disable-cleanups", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">    "disable-cleanups", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">    cl::desc("Do not remove implausible terminators or other similar cleanups"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">    cl::desc("Do not remove implausible terminators or other similar cleanups"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">    cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">    cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">static cl::opt<bool> DemoteCatchSwitchPHIOnlyOpt(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">static cl::opt<bool> DemoteCatchSwitchPHIOnlyOpt(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">    "demote-catchswitch-only", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">    "demote-catchswitch-only", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">    cl::desc("Demote catchswitch BBs only (for wasm EH)"), cl::init(false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">    cl::desc("Demote catchswitch BBs only (for wasm EH)"), cl::init(false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">class WinEHPrepare : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">class WinEHPrepare : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">  static char ID; // Pass identification, replacement for typeid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">  static char ID; // Pass identification, replacement for typeid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">  WinEHPrepare(bool DemoteCatchSwitchPHIOnly = false)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">  WinEHPrepare(bool DemoteCatchSwitchPHIOnly = false)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">      : FunctionPass(ID), DemoteCatchSwitchPHIOnly(DemoteCatchSwitchPHIOnly) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">      : FunctionPass(ID), DemoteCatchSwitchPHIOnly(DemoteCatchSwitchPHIOnly) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">  bool runOnFunction(Function &Fn) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">  bool runOnFunction(Function &Fn) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">  bool doFinalization(Module &M) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">  bool doFinalization(Module &M) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">    return "Windows exception handling preparation";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">    return "Windows exception handling preparation";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">  void insertPHIStores(PHINode *OriginalPHI, AllocaInst *SpillSlot);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">  void insertPHIStores(PHINode *OriginalPHI, AllocaInst *SpillSlot);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">  void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">  void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  insertPHIStore(BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  insertPHIStore(BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">                 SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">                 SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  AllocaInst *insertPHILoads(PHINode *PN, Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  AllocaInst *insertPHILoads(PHINode *PN, Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  void replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  void replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">                          DenseMap<BasicBlock *, Value *> &Loads, Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">                          DenseMap<BasicBlock *, Value *> &Loads, Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  bool prepareExplicitEH(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  bool prepareExplicitEH(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  void colorFunclets(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  void colorFunclets(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  void demotePHIsOnFunclets(Function &F, bool DemoteCatchSwitchPHIOnly);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  void demotePHIsOnFunclets(Function &F, bool DemoteCatchSwitchPHIOnly);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">  void cloneCommonBlocks(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">  void cloneCommonBlocks(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  void removeImplausibleInstructions(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  void removeImplausibleInstructions(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  void cleanupPreparedFunclets(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  void cleanupPreparedFunclets(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">  void verifyPreparedFunclets(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">  void verifyPreparedFunclets(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  bool DemoteCatchSwitchPHIOnly;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  bool DemoteCatchSwitchPHIOnly;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  // All fields are reset by runOnFunction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  // All fields are reset by runOnFunction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">  EHPersonality Personality = EHPersonality::Unknown;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">  EHPersonality Personality = EHPersonality::Unknown;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  const DataLayout *DL = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  DenseMap<BasicBlock *, ColorVector> BlockColors;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  DenseMap<BasicBlock *, ColorVector> BlockColors;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  MapVector<BasicBlock *, std::vector<BasicBlock *>> FuncletBlocks;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  MapVector<BasicBlock *, std::vector<BasicBlock *>> FuncletBlocks;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">char WinEHPrepare::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">char WinEHPrepare::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS(WinEHPrepare, DEBUG_TYPE, "Prepare Windows exceptions",</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">106</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS(WinEHPrepare, DEBUG_TYPE, "Prepare Windows exceptions",</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">                false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">                false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">FunctionPass *llvm::createWinEHPass(bool DemoteCatchSwitchPHIOnly) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">FunctionPass *llvm::createWinEHPass(bool DemoteCatchSwitchPHIOnly) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  return new WinEHPrepare(DemoteCatchSwitchPHIOnly);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  return new WinEHPrepare(DemoteCatchSwitchPHIOnly);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">bool WinEHPrepare::runOnFunction(Function &Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">bool WinEHPrepare::runOnFunction(Function &Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  if (!Fn.hasPersonalityFn())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  if (!Fn.hasPersonalityFn())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  // Classify the personality to see what kind of preparation we need.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  // Classify the personality to see what kind of preparation we need.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  Personality = classifyEHPersonality(Fn.getPersonalityFn());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  Personality = classifyEHPersonality(Fn.getPersonalityFn());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  // Do nothing if this is not a scope-based personality.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  // Do nothing if this is not a scope-based personality.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  if (!isScopedEHPersonality(Personality))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  if (!isScopedEHPersonality(Personality))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  DL = &Fn.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  DL = &Fn.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  return prepareExplicitEH(Fn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  return prepareExplicitEH(Fn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">bool WinEHPrepare::doFinalization(Module &M) { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">bool WinEHPrepare::doFinalization(Module &M) { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">void WinEHPrepare::getAnalysisUsage(AnalysisUsage &AU) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">void WinEHPrepare::getAnalysisUsage(AnalysisUsage &AU) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">static int addUnwindMapEntry(WinEHFuncInfo &FuncInfo, int ToState,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">static int addUnwindMapEntry(WinEHFuncInfo &FuncInfo, int ToState,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">                             const BasicBlock *BB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">                             const BasicBlock *BB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  CxxUnwindMapEntry UME;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  CxxUnwindMapEntry UME;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  UME.ToState = ToState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  UME.ToState = ToState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  UME.Cleanup = BB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  UME.Cleanup = BB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">  FuncInfo.CxxUnwindMap.push_back(UME);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">  FuncInfo.CxxUnwindMap.push_back(UME);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">  return FuncInfo.getLastStateNumber();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">  return FuncInfo.getLastStateNumber();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">static void addTryBlockMapEntry(WinEHFuncInfo &FuncInfo, int TryLow,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">static void addTryBlockMapEntry(WinEHFuncInfo &FuncInfo, int TryLow,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">                                int TryHigh, int CatchHigh,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">                                int TryHigh, int CatchHigh,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">                                ArrayRef<const CatchPadInst *> Handlers) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">                                ArrayRef<const CatchPadInst *> Handlers) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  WinEHTryBlockMapEntry TBME;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  WinEHTryBlockMapEntry TBME;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  TBME.TryLow = TryLow;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  TBME.TryLow = TryLow;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  TBME.TryHigh = TryHigh;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  TBME.TryHigh = TryHigh;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  TBME.CatchHigh = CatchHigh;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  TBME.CatchHigh = CatchHigh;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  assert(TBME.TryLow <= TBME.TryHigh);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  assert(TBME.TryLow <= TBME.TryHigh);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  for (const CatchPadInst *CPI : Handlers) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  for (const CatchPadInst *CPI : Handlers) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">    WinEHHandlerType HT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">    WinEHHandlerType HT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    Constant *TypeInfo = cast<Constant>(CPI->getArgOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    Constant *TypeInfo = cast<Constant>(CPI->getArgOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">    if (TypeInfo->isNullValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">    if (TypeInfo->isNullValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">      HT.TypeDescriptor = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">      HT.TypeDescriptor = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">      HT.TypeDescriptor = cast<GlobalVariable>(TypeInfo->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">      HT.TypeDescriptor = cast<GlobalVariable>(TypeInfo->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">    HT.Adjectives = cast<ConstantInt>(CPI->getArgOperand(1))->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">    HT.Adjectives = cast<ConstantInt>(CPI->getArgOperand(1))->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">    HT.Handler = CPI->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">    HT.Handler = CPI->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">    if (auto *AI =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">    if (auto *AI =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">            dyn_cast<AllocaInst>(CPI->getArgOperand(2)->stripPointerCasts()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">            dyn_cast<AllocaInst>(CPI->getArgOperand(2)->stripPointerCasts()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">      HT.CatchObj.Alloca = AI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">      HT.CatchObj.Alloca = AI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">      HT.CatchObj.Alloca = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">      HT.CatchObj.Alloca = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">    TBME.HandlerArray.push_back(HT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">    TBME.HandlerArray.push_back(HT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  FuncInfo.TryBlockMap.push_back(TBME);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  FuncInfo.TryBlockMap.push_back(TBME);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">static BasicBlock *getCleanupRetUnwindDest(const CleanupPadInst *CleanupPad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">static BasicBlock *getCleanupRetUnwindDest(const CleanupPadInst *CleanupPad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  for (const User *U : CleanupPad->users())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  for (const User *U : CleanupPad->users())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">    if (const auto *CRI = dyn_cast<CleanupReturnInst>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">    if (const auto *CRI = dyn_cast<CleanupReturnInst>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">      return CRI->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">      return CRI->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">static void calculateStateNumbersForInvokes(const Function *Fn,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">static void calculateStateNumbersForInvokes(const Function *Fn,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">                                            WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">                                            WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  auto *F = const_cast<Function *>(Fn);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  auto *F = const_cast<Function *>(Fn);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  DenseMap<BasicBlock *, ColorVector> BlockColors = colorEHFunclets(*F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  DenseMap<BasicBlock *, ColorVector> BlockColors = colorEHFunclets(*F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  for (BasicBlock &BB : *F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  for (BasicBlock &BB : *F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">    auto *II = dyn_cast<InvokeInst>(BB.getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">    auto *II = dyn_cast<InvokeInst>(BB.getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">    if (!II)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">    if (!II)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">    auto &BBColors = BlockColors[&BB];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">    auto &BBColors = BlockColors[&BB];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">    assert(BBColors.size() == 1 && "multi-color BB not removed by preparation");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">    assert(BBColors.size() == 1 && "multi-color BB not removed by preparation");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">    BasicBlock *FuncletEntryBB = BBColors.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">    BasicBlock *FuncletEntryBB = BBColors.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    BasicBlock *FuncletUnwindDest;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    BasicBlock *FuncletUnwindDest;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">    auto *FuncletPad =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">    auto *FuncletPad =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">        dyn_cast<FuncletPadInst>(FuncletEntryBB->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">        dyn_cast<FuncletPadInst>(FuncletEntryBB->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">    assert(FuncletPad || FuncletEntryBB == &Fn->getEntryBlock());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">    assert(FuncletPad || FuncletEntryBB == &Fn->getEntryBlock());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">    if (!FuncletPad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">    if (!FuncletPad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">      FuncletUnwindDest = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">      FuncletUnwindDest = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">    else if (auto *CatchPad = dyn_cast<CatchPadInst>(FuncletPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">    else if (auto *CatchPad = dyn_cast<CatchPadInst>(FuncletPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">      FuncletUnwindDest = CatchPad->getCatchSwitch()->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">      FuncletUnwindDest = CatchPad->getCatchSwitch()->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    else if (auto *CleanupPad = dyn_cast<CleanupPadInst>(FuncletPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    else if (auto *CleanupPad = dyn_cast<CleanupPadInst>(FuncletPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">      FuncletUnwindDest = getCleanupRetUnwindDest(CleanupPad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">      FuncletUnwindDest = getCleanupRetUnwindDest(CleanupPad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">      llvm_unreachable("unexpected funclet pad!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">      llvm_unreachable("unexpected funclet pad!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">    BasicBlock *InvokeUnwindDest = II->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">    BasicBlock *InvokeUnwindDest = II->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    int BaseState = -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    int BaseState = -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">    if (FuncletUnwindDest == InvokeUnwindDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">    if (FuncletUnwindDest == InvokeUnwindDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">      auto BaseStateI = FuncInfo.FuncletBaseStateMap.find(FuncletPad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">      auto BaseStateI = FuncInfo.FuncletBaseStateMap.find(FuncletPad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">      if (BaseStateI != FuncInfo.FuncletBaseStateMap.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">      if (BaseStateI != FuncInfo.FuncletBaseStateMap.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">        BaseState = BaseStateI->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">        BaseState = BaseStateI->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    if (BaseState != -1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    if (BaseState != -1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">      FuncInfo.InvokeStateMap[II] = BaseState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">      FuncInfo.InvokeStateMap[II] = BaseState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">      Instruction *PadInst = InvokeUnwindDest->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">      Instruction *PadInst = InvokeUnwindDest->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">      assert(FuncInfo.EHPadStateMap.count(PadInst) && "EH Pad has no state!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">      assert(FuncInfo.EHPadStateMap.count(PadInst) && "EH Pad has no state!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">      FuncInfo.InvokeStateMap[II] = FuncInfo.EHPadStateMap[PadInst];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">      FuncInfo.InvokeStateMap[II] = FuncInfo.EHPadStateMap[PadInst];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">// See comments below for calculateSEHStateForAsynchEH().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">// See comments below for calculateSEHStateForAsynchEH().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">// State - incoming State of normal paths</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">// State - incoming State of normal paths</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">struct WorkItem {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">struct WorkItem {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  const BasicBlock *Block;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  const BasicBlock *Block;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  int State;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  int State;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  WorkItem(const BasicBlock *BB, int St) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  WorkItem(const BasicBlock *BB, int St) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    Block = BB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    Block = BB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">    State = St;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">    State = St;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">void llvm::calculateCXXStateForAsynchEH(const BasicBlock *BB, int State,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">void llvm::calculateCXXStateForAsynchEH(const BasicBlock *BB, int State,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">                                        WinEHFuncInfo &EHInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">                                        WinEHFuncInfo &EHInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  SmallVector<struct WorkItem *, 8> WorkList;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  SmallVector<struct WorkItem *, 8> WorkList;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  struct WorkItem *WI = new WorkItem(BB, State);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  struct WorkItem *WI = new WorkItem(BB, State);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  WorkList.push_back(WI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  WorkList.push_back(WI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  while (!WorkList.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  while (!WorkList.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    WI = WorkList.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    WI = WorkList.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">    const BasicBlock *BB = WI->Block;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">    const BasicBlock *BB = WI->Block;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">    int State = WI->State;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">    int State = WI->State;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    delete WI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    delete WI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">      continue; // skip blocks already visited by lower State</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">      continue; // skip blocks already visited by lower State</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">    const llvm::Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">    const llvm::Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">    if (I->isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">    if (I->isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">      State = EHInfo.EHPadStateMap[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">      State = EHInfo.EHPadStateMap[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">    EHInfo.BlockToStateMap[BB] = State; // Record state, also flag visiting</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">    EHInfo.BlockToStateMap[BB] = State; // Record state, also flag visiting</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">    if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) && State > 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">    if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) && State > 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">      // Retrive the new State</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">      // Retrive the new State</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">      State = EHInfo.CxxUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">      State = EHInfo.CxxUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">    } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">    } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">      auto *Call = cast<CallBase>(TI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">      auto *Call = cast<CallBase>(TI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">      const Function *Fn = Call->getCalledFunction();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">      const Function *Fn = Call->getCalledFunction();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">      if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">      if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">          (Fn->getIntrinsicID() == Intrinsic::seh_scope_begin ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">          (Fn->getIntrinsicID() == Intrinsic::seh_scope_begin ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">           Fn->getIntrinsicID() == Intrinsic::seh_try_begin))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">           Fn->getIntrinsicID() == Intrinsic::seh_try_begin))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">        // Retrive the new State from seh_scope_begin</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">        // Retrive the new State from seh_scope_begin</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">      else if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">      else if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">               (Fn->getIntrinsicID() == Intrinsic::seh_scope_end ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">               (Fn->getIntrinsicID() == Intrinsic::seh_scope_end ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">                Fn->getIntrinsicID() == Intrinsic::seh_try_end)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">                Fn->getIntrinsicID() == Intrinsic::seh_try_end)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">        // In case of conditional ctor, let's retrieve State from Invoke</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">        // In case of conditional ctor, let's retrieve State from Invoke</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">        // end of current state, retrive new state from UnwindMap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">        // end of current state, retrive new state from UnwindMap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">        State = EHInfo.CxxUnwindMap[State].ToState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">        State = EHInfo.CxxUnwindMap[State].ToState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">    // Continue push successors into worklist</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">    // Continue push successors into worklist</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">    for (auto *SuccBB : successors(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">    for (auto *SuccBB : successors(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">      WI = new WorkItem(SuccBB, State);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">      WI = new WorkItem(SuccBB, State);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">      WorkList.push_back(WI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">      WorkList.push_back(WI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">// The central theory of this routine is based on the following:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">// The central theory of this routine is based on the following:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">//   A _try scope is always a SEME (Single Entry Multiple Exits) region</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">//   A _try scope is always a SEME (Single Entry Multiple Exits) region</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">//     as jumping into a _try is not allowed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">//     as jumping into a _try is not allowed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">//   The single entry must start with a seh_try_begin() invoke with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">//   The single entry must start with a seh_try_begin() invoke with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">//     correct State number that is the initial state of the SEME.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">//     correct State number that is the initial state of the SEME.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">//   Through control-flow, state number is propagated into all blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">//   Through control-flow, state number is propagated into all blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">//   Side exits marked by seh_try_end() will unwind to parent state via</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">//   Side exits marked by seh_try_end() will unwind to parent state via</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">//     existing SEHUnwindMap[].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">//     existing SEHUnwindMap[].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">//   Side exits can ONLY jump into parent scopes (lower state number).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">//   Side exits can ONLY jump into parent scopes (lower state number).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">//   Thus, when a block succeeds various states from its predecessors,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">//   Thus, when a block succeeds various states from its predecessors,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">//     the lowest State trumphs others.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">//     the lowest State trumphs others.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">//   If some exits flow to unreachable, propagation on those paths terminate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">//   If some exits flow to unreachable, propagation on those paths terminate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">//     not affecting remaining blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">//     not affecting remaining blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">void llvm::calculateSEHStateForAsynchEH(const BasicBlock *BB, int State,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">void llvm::calculateSEHStateForAsynchEH(const BasicBlock *BB, int State,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">                                        WinEHFuncInfo &EHInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">                                        WinEHFuncInfo &EHInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  SmallVector<struct WorkItem *, 8> WorkList;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  SmallVector<struct WorkItem *, 8> WorkList;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  struct WorkItem *WI = new WorkItem(BB, State);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  struct WorkItem *WI = new WorkItem(BB, State);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  WorkList.push_back(WI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  WorkList.push_back(WI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  while (!WorkList.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  while (!WorkList.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">    WI = WorkList.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">    WI = WorkList.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">    const BasicBlock *BB = WI->Block;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">    const BasicBlock *BB = WI->Block;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">    int State = WI->State;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">    int State = WI->State;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">    delete WI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">    delete WI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">    if (EHInfo.BlockToStateMap.count(BB) && EHInfo.BlockToStateMap[BB] <= State)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">      continue; // skip blocks already visited by lower State</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">      continue; // skip blocks already visited by lower State</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    const llvm::Instruction *I = BB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">    const llvm::Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">    const llvm::Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    if (I->isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    if (I->isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">      State = EHInfo.EHPadStateMap[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">      State = EHInfo.EHPadStateMap[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    EHInfo.BlockToStateMap[BB] = State; // Record state</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    EHInfo.BlockToStateMap[BB] = State; // Record state</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    if (isa<CatchPadInst>(I) && isa<CatchReturnInst>(TI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    if (isa<CatchPadInst>(I) && isa<CatchReturnInst>(TI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">      const Constant *FilterOrNull = cast<Constant>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">      const Constant *FilterOrNull = cast<Constant>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">          cast<CatchPadInst>(I)->getArgOperand(0)->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">          cast<CatchPadInst>(I)->getArgOperand(0)->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">      const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">      const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">      if (!Filter || !Filter->getName().startswith("__IsLocalUnwind"))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">      if (!Filter || !Filter->getName().startswith("__IsLocalUnwind"))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">        State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">        State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">    } else if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">    } else if ((isa<CleanupReturnInst>(TI) || isa<CatchReturnInst>(TI)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">               State > 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">               State > 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">      // Retrive the new State.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">      // Retrive the new State.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">      State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">      State = EHInfo.SEHUnwindMap[State].ToState; // Retrive next State</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">    } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">    } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">      auto *Call = cast<CallBase>(TI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">      auto *Call = cast<CallBase>(TI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">      const Function *Fn = Call->getCalledFunction();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">      const Function *Fn = Call->getCalledFunction();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">      if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">      if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">          Fn->getIntrinsicID() == Intrinsic::seh_try_begin)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">          Fn->getIntrinsicID() == Intrinsic::seh_try_begin)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">        // Retrive the new State from seh_try_begin</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">        // Retrive the new State from seh_try_begin</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">        State = EHInfo.InvokeStateMap[cast<InvokeInst>(TI)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">      else if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">      else if (Fn && Fn->isIntrinsic() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">               Fn->getIntrinsicID() == Intrinsic::seh_try_end)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">               Fn->getIntrinsicID() == Intrinsic::seh_try_end)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">        // end of current state, retrive new state from UnwindMap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">        // end of current state, retrive new state from UnwindMap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">        State = EHInfo.SEHUnwindMap[State].ToState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">        State = EHInfo.SEHUnwindMap[State].ToState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">    // Continue push successors into worklist</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">    // Continue push successors into worklist</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">    for (auto *SuccBB : successors(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">    for (auto *SuccBB : successors(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">      WI = new WorkItem(SuccBB, State);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">      WI = new WorkItem(SuccBB, State);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">      WorkList.push_back(WI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">      WorkList.push_back(WI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">// Given BB which ends in an unwind edge, return the EHPad that this BB belongs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">// Given BB which ends in an unwind edge, return the EHPad that this BB belongs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">// to. If the unwind edge came from an invoke, return null.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">// to. If the unwind edge came from an invoke, return null.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">static const BasicBlock *getEHPadFromPredecessor(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">static const BasicBlock *getEHPadFromPredecessor(const BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">                                                 Value *ParentPad) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">                                                 Value *ParentPad) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  const Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  const Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  if (isa<InvokeInst>(TI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  if (isa<InvokeInst>(TI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(TI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(TI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">    if (CatchSwitch->getParentPad() != ParentPad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">    if (CatchSwitch->getParentPad() != ParentPad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">    return BB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">    return BB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  assert(!TI->isEHPad() && "unexpected EHPad!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  assert(!TI->isEHPad() && "unexpected EHPad!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  auto *CleanupPad = cast<CleanupReturnInst>(TI)->getCleanupPad();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  auto *CleanupPad = cast<CleanupReturnInst>(TI)->getCleanupPad();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  if (CleanupPad->getParentPad() != ParentPad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  if (CleanupPad->getParentPad() != ParentPad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  return CleanupPad->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  return CleanupPad->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">// Starting from a EHPad, Backward walk through control-flow graph</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">// Starting from a EHPad, Backward walk through control-flow graph</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">// to produce two primary outputs:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">// to produce two primary outputs:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">//      FuncInfo.EHPadStateMap[] and FuncInfo.CxxUnwindMap[]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">//      FuncInfo.EHPadStateMap[] and FuncInfo.CxxUnwindMap[]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">static void calculateCXXStateNumbers(WinEHFuncInfo &FuncInfo,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">static void calculateCXXStateNumbers(WinEHFuncInfo &FuncInfo,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">                                     const Instruction *FirstNonPHI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">                                     const Instruction *FirstNonPHI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">                                     int ParentState) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">                                     int ParentState) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  assert(BB->isEHPad() && "not a funclet!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  assert(BB->isEHPad() && "not a funclet!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">           "shouldn't revist catch funclets!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">           "shouldn't revist catch funclets!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">    SmallVector<const CatchPadInst *, 2> Handlers;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">    SmallVector<const CatchPadInst *, 2> Handlers;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">    for (const BasicBlock *CatchPadBB : CatchSwitch->handlers()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">    for (const BasicBlock *CatchPadBB : CatchSwitch->handlers()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">      auto *CatchPad = cast<CatchPadInst>(CatchPadBB->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">      auto *CatchPad = cast<CatchPadInst>(CatchPadBB->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">      Handlers.push_back(CatchPad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">      Handlers.push_back(CatchPad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">    int TryLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">    int TryLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CatchSwitch] = TryLow;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CatchSwitch] = TryLow;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">                                               CatchSwitch->getParentPad())))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">                                               CatchSwitch->getParentPad())))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">                                 TryLow);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">                                 TryLow);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">    int CatchLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">    int CatchLow = addUnwindMapEntry(FuncInfo, ParentState, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    // catchpads are separate funclets in C++ EH due to the way rethrow works.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    // catchpads are separate funclets in C++ EH due to the way rethrow works.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">    int TryHigh = CatchLow - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">    int TryHigh = CatchLow - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">    // MSVC FrameHandler3/4 on x64&Arm64 expect Catch Handlers in $tryMap$</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">    // MSVC FrameHandler3/4 on x64&Arm64 expect Catch Handlers in $tryMap$</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">    //  stored in pre-order (outer first, inner next), not post-order</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">    //  stored in pre-order (outer first, inner next), not post-order</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">    //  Add to map here.  Fix the CatchHigh after children are processed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">    //  Add to map here.  Fix the CatchHigh after children are processed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">    const Module *Mod = BB->getParent()->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">    const Module *Mod = BB->getParent()->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">    bool IsPreOrder = Triple(Mod->getTargetTriple()).isArch64Bit();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">    bool IsPreOrder = Triple(Mod->getTargetTriple()).isArch64Bit();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">    if (IsPreOrder)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">    if (IsPreOrder)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchLow, Handlers);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchLow, Handlers);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">    unsigned TBMEIdx = FuncInfo.TryBlockMap.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">    unsigned TBMEIdx = FuncInfo.TryBlockMap.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">    for (const auto *CatchPad : Handlers) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">    for (const auto *CatchPad : Handlers) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">      FuncInfo.FuncletBaseStateMap[CatchPad] = CatchLow;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">      FuncInfo.FuncletBaseStateMap[CatchPad] = CatchLow;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">      FuncInfo.EHPadStateMap[CatchPad] = CatchLow;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">      FuncInfo.EHPadStateMap[CatchPad] = CatchLow;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">      for (const User *U : CatchPad->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">      for (const User *U : CatchPad->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">        const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">        const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">        if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">        if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">          BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">          BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">        if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">        if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">          BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">          BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">          // If a nested cleanup pad reports a null unwind destination and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">          // If a nested cleanup pad reports a null unwind destination and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">          // enclosing catch pad doesn't it must be post-dominated by an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">          // enclosing catch pad doesn't it must be post-dominated by an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">          // unreachable instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">          // unreachable instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">          if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">            calculateCXXStateNumbers(FuncInfo, UserI, CatchLow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">    int CatchHigh = FuncInfo.getLastStateNumber();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">    int CatchHigh = FuncInfo.getLastStateNumber();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">    // Now child Catches are processed, update CatchHigh</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">    // Now child Catches are processed, update CatchHigh</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">    if (IsPreOrder)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">    if (IsPreOrder)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">      FuncInfo.TryBlockMap[TBMEIdx].CatchHigh = CatchHigh;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">      FuncInfo.TryBlockMap[TBMEIdx].CatchHigh = CatchHigh;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">    else // PostOrder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">    else // PostOrder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchHigh, Handlers);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">      addTryBlockMapEntry(FuncInfo, TryLow, TryHigh, CatchHigh, Handlers);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "TryLow[" << BB->getName() << "]: " << TryLow << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "TryLow[" << BB->getName() << "]: " << TryLow << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "TryHigh[" << BB->getName() << "]: " << TryHigh</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "TryHigh[" << BB->getName() << "]: " << TryHigh</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">                      << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">                      << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "CatchHigh[" << BB->getName() << "]: " << CatchHigh</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "CatchHigh[" << BB->getName() << "]: " << CatchHigh</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">                      << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">                      << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">    // cleanupret instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">    // cleanupret instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">    int CleanupState = addUnwindMapEntry(FuncInfo, ParentState, BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">    int CleanupState = addUnwindMapEntry(FuncInfo, ParentState, BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">                      << BB->getName() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">                      << BB->getName() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">    for (const BasicBlock *PredBlock : predecessors(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">    for (const BasicBlock *PredBlock : predecessors(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">                                               CleanupPad->getParentPad()))) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">                                               CleanupPad->getParentPad()))) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">        calculateCXXStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">                                 CleanupState);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">                                 CleanupState);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">    for (const User *U : CleanupPad->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">    for (const User *U : CleanupPad->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">      if (UserI->isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">      if (UserI->isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">        report_fatal_error("Cleanup funclets for the MSVC++ personality cannot "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">        report_fatal_error("Cleanup funclets for the MSVC++ personality cannot "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">                           "contain exceptional actions");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">                           "contain exceptional actions");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">static int addSEHExcept(WinEHFuncInfo &FuncInfo, int ParentState,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">static int addSEHExcept(WinEHFuncInfo &FuncInfo, int ParentState,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">                        const Function *Filter, const BasicBlock *Handler) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">                        const Function *Filter, const BasicBlock *Handler) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">  SEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">  SEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  Entry.ToState = ParentState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  Entry.ToState = ParentState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  Entry.IsFinally = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  Entry.IsFinally = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  Entry.Filter = Filter;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  Entry.Filter = Filter;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  Entry.Handler = Handler;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  Entry.Handler = Handler;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">static int addSEHFinally(WinEHFuncInfo &FuncInfo, int ParentState,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">static int addSEHFinally(WinEHFuncInfo &FuncInfo, int ParentState,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">                         const BasicBlock *Handler) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">                         const BasicBlock *Handler) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">  SEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">  SEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  Entry.ToState = ParentState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  Entry.ToState = ParentState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  Entry.IsFinally = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  Entry.IsFinally = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  Entry.Filter = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  Entry.Filter = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  Entry.Handler = Handler;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  Entry.Handler = Handler;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  FuncInfo.SEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  return FuncInfo.SEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">// Starting from a EHPad, Backward walk through control-flow graph</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">// Starting from a EHPad, Backward walk through control-flow graph</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">// to produce two primary outputs:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">// to produce two primary outputs:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">//      FuncInfo.EHPadStateMap[] and FuncInfo.SEHUnwindMap[]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">//      FuncInfo.EHPadStateMap[] and FuncInfo.SEHUnwindMap[]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">static void calculateSEHStateNumbers(WinEHFuncInfo &FuncInfo,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">static void calculateSEHStateNumbers(WinEHFuncInfo &FuncInfo,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">                                     const Instruction *FirstNonPHI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">                                     const Instruction *FirstNonPHI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">                                     int ParentState) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">                                     int ParentState) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  const BasicBlock *BB = FirstNonPHI->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  assert(BB->isEHPad() && "no a funclet!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  assert(BB->isEHPad() && "no a funclet!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FirstNonPHI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">    assert(FuncInfo.EHPadStateMap.count(CatchSwitch) == 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">           "shouldn't revist catch funclets!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">           "shouldn't revist catch funclets!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">    // Extract the filter function and the __except basic block and create a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">    // Extract the filter function and the __except basic block and create a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">    // state for them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">    // state for them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">    assert(CatchSwitch->getNumHandlers() == 1 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">    assert(CatchSwitch->getNumHandlers() == 1 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">           "SEH doesn't have multiple handlers per __try");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">           "SEH doesn't have multiple handlers per __try");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">    const auto *CatchPad =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">    const auto *CatchPad =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">        cast<CatchPadInst>((*CatchSwitch->handler_begin())->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">        cast<CatchPadInst>((*CatchSwitch->handler_begin())->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    const BasicBlock *CatchPadBB = CatchPad->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    const BasicBlock *CatchPadBB = CatchPad->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    const Constant *FilterOrNull =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    const Constant *FilterOrNull =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">        cast<Constant>(CatchPad->getArgOperand(0)->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">        cast<Constant>(CatchPad->getArgOperand(0)->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">    const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">    const Function *Filter = dyn_cast<Function>(FilterOrNull);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">    assert((Filter || FilterOrNull->isNullValue()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">    assert((Filter || FilterOrNull->isNullValue()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">           "unexpected filter value");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">           "unexpected filter value");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">    int TryState = addSEHExcept(FuncInfo, ParentState, Filter, CatchPadBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">    int TryState = addSEHExcept(FuncInfo, ParentState, Filter, CatchPadBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    // Everything in the __try block uses TryState as its parent state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    // Everything in the __try block uses TryState as its parent state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CatchSwitch] = TryState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CatchSwitch] = TryState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CatchPad] = TryState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CatchPad] = TryState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << TryState << " to BB "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << TryState << " to BB "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">                      << CatchPadBB->getName() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">                      << CatchPadBB->getName() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">      if ((PredBlock = getEHPadFromPredecessor(PredBlock,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">                                               CatchSwitch->getParentPad())))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">                                               CatchSwitch->getParentPad())))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">                                 TryState);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">                                 TryState);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    // Everything in the __except block unwinds to ParentState, just like code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    // Everything in the __except block unwinds to ParentState, just like code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">    // outside the __try.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">    // outside the __try.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">    for (const User *U : CatchPad->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">    for (const User *U : CatchPad->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">      if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">      if (auto *InnerCatchSwitch = dyn_cast<CatchSwitchInst>(UserI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">        BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">        BasicBlock *UnwindDest = InnerCatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">      if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">      if (auto *InnerCleanupPad = dyn_cast<CleanupPadInst>(UserI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">        BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">        BasicBlock *UnwindDest = getCleanupRetUnwindDest(InnerCleanupPad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">        // If a nested cleanup pad reports a null unwind destination and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">        // If a nested cleanup pad reports a null unwind destination and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">        // enclosing catch pad doesn't it must be post-dominated by an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">        // enclosing catch pad doesn't it must be post-dominated by an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">        // unreachable instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">        // unreachable instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">        if (!UnwindDest || UnwindDest == CatchSwitch->getUnwindDest())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">          calculateSEHStateNumbers(FuncInfo, UserI, ParentState);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">    auto *CleanupPad = cast<CleanupPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    // It's possible for a cleanup to be visited twice: it might have multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">    // cleanupret instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">    // cleanupret instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">    if (FuncInfo.EHPadStateMap.count(CleanupPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">    int CleanupState = addSEHFinally(FuncInfo, ParentState, BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">    int CleanupState = addSEHFinally(FuncInfo, ParentState, BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">    FuncInfo.EHPadStateMap[CleanupPad] = CleanupState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Assigning state #" << CleanupState << " to BB "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">                      << BB->getName() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">                      << BB->getName() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">    for (const BasicBlock *PredBlock : predecessors(BB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">      if ((PredBlock =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">      if ((PredBlock =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">               getEHPadFromPredecessor(PredBlock, CleanupPad->getParentPad())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">               getEHPadFromPredecessor(PredBlock, CleanupPad->getParentPad())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">        calculateSEHStateNumbers(FuncInfo, PredBlock->getFirstNonPHI(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">                                 CleanupState);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">                                 CleanupState);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">    for (const User *U : CleanupPad->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">    for (const User *U : CleanupPad->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">      const auto *UserI = cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">      if (UserI->isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">      if (UserI->isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">        report_fatal_error("Cleanup funclets for the SEH personality cannot "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">        report_fatal_error("Cleanup funclets for the SEH personality cannot "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">                           "contain exceptional actions");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">                           "contain exceptional actions");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">static bool isTopLevelPadForMSVC(const Instruction *EHPad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">static bool isTopLevelPadForMSVC(const Instruction *EHPad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(EHPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(EHPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">    return isa<ConstantTokenNone>(CatchSwitch->getParentPad()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">    return isa<ConstantTokenNone>(CatchSwitch->getParentPad()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">           CatchSwitch->unwindsToCaller();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">           CatchSwitch->unwindsToCaller();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">  if (auto *CleanupPad = dyn_cast<CleanupPadInst>(EHPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">  if (auto *CleanupPad = dyn_cast<CleanupPadInst>(EHPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">    return isa<ConstantTokenNone>(CleanupPad->getParentPad()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">    return isa<ConstantTokenNone>(CleanupPad->getParentPad()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">           getCleanupRetUnwindDest(CleanupPad) == nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">           getCleanupRetUnwindDest(CleanupPad) == nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  if (isa<CatchPadInst>(EHPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  if (isa<CatchPadInst>(EHPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  llvm_unreachable("unexpected EHPad!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  llvm_unreachable("unexpected EHPad!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">void llvm::calculateSEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">void llvm::calculateSEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">                                    WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">                                    WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  // Don't compute state numbers twice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  // Don't compute state numbers twice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  if (!FuncInfo.SEHUnwindMap.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  if (!FuncInfo.SEHUnwindMap.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">    if (!BB.isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">    if (!BB.isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">    ::calculateSEHStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">    ::calculateSEHStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">  if (IsEHa) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">  if (IsEHa) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">    calculateSEHStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">    calculateSEHStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">void llvm::calculateWinCXXEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">void llvm::calculateWinCXXEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">                                         WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">                                         WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  // Return if it's already been done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  // Return if it's already been done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  if (!FuncInfo.EHPadStateMap.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  if (!FuncInfo.EHPadStateMap.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    if (!BB.isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    if (!BB.isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    if (!isTopLevelPadForMSVC(FirstNonPHI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">    calculateCXXStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">    calculateCXXStateNumbers(FuncInfo, FirstNonPHI, -1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  bool IsEHa = Fn->getParent()->getModuleFlag("eh-asynch");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  if (IsEHa) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  if (IsEHa) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">    const BasicBlock *EntryBB = &(Fn->getEntryBlock());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">    calculateCXXStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">    calculateCXXStateForAsynchEH(EntryBB, -1, FuncInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">static int addClrEHHandler(WinEHFuncInfo &FuncInfo, int HandlerParentState,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">static int addClrEHHandler(WinEHFuncInfo &FuncInfo, int HandlerParentState,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">                           int TryParentState, ClrHandlerType HandlerType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">                           int TryParentState, ClrHandlerType HandlerType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">                           uint32_t TypeToken, const BasicBlock *Handler) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">                           uint32_t TypeToken, const BasicBlock *Handler) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  ClrEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  ClrEHUnwindMapEntry Entry;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  Entry.HandlerParentState = HandlerParentState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  Entry.HandlerParentState = HandlerParentState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  Entry.TryParentState = TryParentState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  Entry.TryParentState = TryParentState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  Entry.Handler = Handler;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  Entry.Handler = Handler;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  Entry.HandlerType = HandlerType;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  Entry.HandlerType = HandlerType;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">  Entry.TypeToken = TypeToken;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">  Entry.TypeToken = TypeToken;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  FuncInfo.ClrEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  FuncInfo.ClrEHUnwindMap.push_back(Entry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  return FuncInfo.ClrEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  return FuncInfo.ClrEHUnwindMap.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">void llvm::calculateClrEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">void llvm::calculateClrEHStateNumbers(const Function *Fn,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">                                      WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">                                      WinEHFuncInfo &FuncInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  // Return if it's already been done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  // Return if it's already been done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">  if (!FuncInfo.EHPadStateMap.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">  if (!FuncInfo.EHPadStateMap.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  // This numbering assigns one state number to each catchpad and cleanuppad.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  // This numbering assigns one state number to each catchpad and cleanuppad.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  // It also computes two tree-like relations over states:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  // It also computes two tree-like relations over states:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  // 1) Each state has a "HandlerParentState", which is the state of the next</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  // 1) Each state has a "HandlerParentState", which is the state of the next</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">  //    outer handler enclosing this state's handler (same as nearest ancestor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">  //    outer handler enclosing this state's handler (same as nearest ancestor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  //    per the ParentPad linkage on EH pads, but skipping over catchswitches).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  //    per the ParentPad linkage on EH pads, but skipping over catchswitches).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  // 2) Each state has a "TryParentState", which:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  // 2) Each state has a "TryParentState", which:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  //    a) for a catchpad that's not the last handler on its catchswitch, is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  //    a) for a catchpad that's not the last handler on its catchswitch, is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  //       the state of the next catchpad on that catchswitch</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  //       the state of the next catchpad on that catchswitch</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  //    b) for all other pads, is the state of the pad whose try region is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  //    b) for all other pads, is the state of the pad whose try region is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  //       next outer try region enclosing this state's try region.  The "try</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  //       next outer try region enclosing this state's try region.  The "try</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  //       regions are not present as such in the IR, but will be inferred</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  //       regions are not present as such in the IR, but will be inferred</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  //       based on the placement of invokes and pads which reach each other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  //       based on the placement of invokes and pads which reach each other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  //       by exceptional exits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  //       by exceptional exits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  // Catchswitches do not get their own states, but each gets mapped to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  // Catchswitches do not get their own states, but each gets mapped to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  // state of its first catchpad.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  // state of its first catchpad.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  // Step one: walk down from outermost to innermost funclets, assigning each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  // Step one: walk down from outermost to innermost funclets, assigning each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  // catchpad and cleanuppad a state number.  Add an entry to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  // catchpad and cleanuppad a state number.  Add an entry to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  // ClrEHUnwindMap for each state, recording its HandlerParentState and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  // ClrEHUnwindMap for each state, recording its HandlerParentState and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  // handler attributes.  Record the TryParentState as well for each catchpad</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  // handler attributes.  Record the TryParentState as well for each catchpad</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  // that's not the last on its catchswitch, but initialize all other entries'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  // that's not the last on its catchswitch, but initialize all other entries'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  // TryParentStates to a sentinel -1 value that the next pass will update.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  // TryParentStates to a sentinel -1 value that the next pass will update.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  // Seed a worklist with pads that have no parent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  // Seed a worklist with pads that have no parent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  SmallVector<std::pair<const Instruction *, int>, 8> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  SmallVector<std::pair<const Instruction *, int>, 8> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  for (const BasicBlock &BB : *Fn) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">    const Instruction *FirstNonPHI = BB.getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">    const Value *ParentPad;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">    const Value *ParentPad;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">    if (const auto *CPI = dyn_cast<CleanupPadInst>(FirstNonPHI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">    if (const auto *CPI = dyn_cast<CleanupPadInst>(FirstNonPHI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">      ParentPad = CPI->getParentPad();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">      ParentPad = CPI->getParentPad();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    else if (const auto *CSI = dyn_cast<CatchSwitchInst>(FirstNonPHI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    else if (const auto *CSI = dyn_cast<CatchSwitchInst>(FirstNonPHI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">      ParentPad = CSI->getParentPad();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">      ParentPad = CSI->getParentPad();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">    if (isa<ConstantTokenNone>(ParentPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">    if (isa<ConstantTokenNone>(ParentPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">      Worklist.emplace_back(FirstNonPHI, -1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">      Worklist.emplace_back(FirstNonPHI, -1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  // Use the worklist to visit all pads, from outer to inner.  Record</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  // Use the worklist to visit all pads, from outer to inner.  Record</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  // HandlerParentState for all pads.  Record TryParentState only for catchpads</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  // HandlerParentState for all pads.  Record TryParentState only for catchpads</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  // that aren't the last on their catchswitch (setting all other entries'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  // that aren't the last on their catchswitch (setting all other entries'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  // TryParentStates to an initial value of -1).  This loop is also responsible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  // TryParentStates to an initial value of -1).  This loop is also responsible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  // for setting the EHPadStateMap entry for all catchpads, cleanuppads, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  // for setting the EHPadStateMap entry for all catchpads, cleanuppads, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  // catchswitches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  // catchswitches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">    const Instruction *Pad;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">    const Instruction *Pad;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    int HandlerParentState;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    int HandlerParentState;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    std::tie(Pad, HandlerParentState) = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    std::tie(Pad, HandlerParentState) = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">    if (const auto *Cleanup = dyn_cast<CleanupPadInst>(Pad)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">    if (const auto *Cleanup = dyn_cast<CleanupPadInst>(Pad)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">      // Create the entry for this cleanup with the appropriate handler</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">      // Create the entry for this cleanup with the appropriate handler</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">      // properties.  Finally and fault handlers are distinguished by arity.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">      // properties.  Finally and fault handlers are distinguished by arity.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">      ClrHandlerType HandlerType =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">      ClrHandlerType HandlerType =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">          (Cleanup->arg_size() ? ClrHandlerType::Fault</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">          (Cleanup->arg_size() ? ClrHandlerType::Fault</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">                               : ClrHandlerType::Finally);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">                               : ClrHandlerType::Finally);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">      int CleanupState = addClrEHHandler(FuncInfo, HandlerParentState, -1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">      int CleanupState = addClrEHHandler(FuncInfo, HandlerParentState, -1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">                                         HandlerType, 0, Pad->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">                                         HandlerType, 0, Pad->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">      // Queue any child EH pads on the worklist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">      // Queue any child EH pads on the worklist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">      for (const User *U : Cleanup->users())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">      for (const User *U : Cleanup->users())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">        if (const auto *I = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">        if (const auto *I = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">          if (I->isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">          if (I->isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">            Worklist.emplace_back(I, CleanupState);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">            Worklist.emplace_back(I, CleanupState);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">      // Remember this pad's state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">      // Remember this pad's state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">      FuncInfo.EHPadStateMap[Cleanup] = CleanupState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">      FuncInfo.EHPadStateMap[Cleanup] = CleanupState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">      // Walk the handlers of this catchswitch in reverse order since all but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">      // Walk the handlers of this catchswitch in reverse order since all but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">      // the last need to set the following one as its TryParentState.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">      // the last need to set the following one as its TryParentState.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">      const auto *CatchSwitch = cast<CatchSwitchInst>(Pad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">      const auto *CatchSwitch = cast<CatchSwitchInst>(Pad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">      int CatchState = -1, FollowerState = -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">      int CatchState = -1, FollowerState = -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">      SmallVector<const BasicBlock *, 4> CatchBlocks(CatchSwitch->handlers());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">      SmallVector<const BasicBlock *, 4> CatchBlocks(CatchSwitch->handlers());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">      for (const BasicBlock *CatchBlock : llvm::reverse(CatchBlocks)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">      for (const BasicBlock *CatchBlock : llvm::reverse(CatchBlocks)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">        // Create the entry for this catch with the appropriate handler</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">        // Create the entry for this catch with the appropriate handler</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">        // properties.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">        // properties.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">        const auto *Catch = cast<CatchPadInst>(CatchBlock->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">        const auto *Catch = cast<CatchPadInst>(CatchBlock->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">        uint32_t TypeToken = static_cast<uint32_t>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">        uint32_t TypeToken = static_cast<uint32_t>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">            cast<ConstantInt>(Catch->getArgOperand(0))->getZExtValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">            cast<ConstantInt>(Catch->getArgOperand(0))->getZExtValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">        CatchState =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">        CatchState =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">            addClrEHHandler(FuncInfo, HandlerParentState, FollowerState,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">            addClrEHHandler(FuncInfo, HandlerParentState, FollowerState,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">                            ClrHandlerType::Catch, TypeToken, CatchBlock);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">                            ClrHandlerType::Catch, TypeToken, CatchBlock);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">        // Queue any child EH pads on the worklist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">        // Queue any child EH pads on the worklist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">        for (const User *U : Catch->users())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">        for (const User *U : Catch->users())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">          if (const auto *I = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">          if (const auto *I = dyn_cast<Instruction>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">            if (I->isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">            if (I->isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">              Worklist.emplace_back(I, CatchState);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">              Worklist.emplace_back(I, CatchState);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">        // Remember this catch's state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">        // Remember this catch's state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">        FuncInfo.EHPadStateMap[Catch] = CatchState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">        FuncInfo.EHPadStateMap[Catch] = CatchState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">        FollowerState = CatchState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">        FollowerState = CatchState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">      // Associate the catchswitch with the state of its first catch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">      // Associate the catchswitch with the state of its first catch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">      assert(CatchSwitch->getNumHandlers());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">      assert(CatchSwitch->getNumHandlers());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">      FuncInfo.EHPadStateMap[CatchSwitch] = CatchState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">      FuncInfo.EHPadStateMap[CatchSwitch] = CatchState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">  // Step two: record the TryParentState of each state.  For cleanuppads that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">  // Step two: record the TryParentState of each state.  For cleanuppads that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  // don't have cleanuprets, we may need to infer this from their child pads,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  // don't have cleanuprets, we may need to infer this from their child pads,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">  // so visit pads in descendant-most to ancestor-most order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">  // so visit pads in descendant-most to ancestor-most order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  for (ClrEHUnwindMapEntry &Entry : llvm::reverse(FuncInfo.ClrEHUnwindMap)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  for (ClrEHUnwindMapEntry &Entry : llvm::reverse(FuncInfo.ClrEHUnwindMap)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">    const Instruction *Pad =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">    const Instruction *Pad =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">        cast<const BasicBlock *>(Entry.Handler)->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">        cast<const BasicBlock *>(Entry.Handler)->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">    // For most pads, the TryParentState is the state associated with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">    // For most pads, the TryParentState is the state associated with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    // unwind dest of exceptional exits from it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    // unwind dest of exceptional exits from it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">    const BasicBlock *UnwindDest;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">    const BasicBlock *UnwindDest;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">    if (const auto *Catch = dyn_cast<CatchPadInst>(Pad)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">    if (const auto *Catch = dyn_cast<CatchPadInst>(Pad)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">      // If a catch is not the last in its catchswitch, its TryParentState is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">      // If a catch is not the last in its catchswitch, its TryParentState is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">      // the state associated with the next catch in the switch, even though</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">      // the state associated with the next catch in the switch, even though</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">      // that's not the unwind dest of exceptions escaping the catch.  Those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">      // that's not the unwind dest of exceptions escaping the catch.  Those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">      // cases were already assigned a TryParentState in the first pass, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">      // cases were already assigned a TryParentState in the first pass, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">      // skip them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">      // skip them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">      if (Entry.TryParentState != -1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">      if (Entry.TryParentState != -1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">      // Otherwise, get the unwind dest from the catchswitch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">      // Otherwise, get the unwind dest from the catchswitch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">      UnwindDest = Catch->getCatchSwitch()->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">      UnwindDest = Catch->getCatchSwitch()->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">      const auto *Cleanup = cast<CleanupPadInst>(Pad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">      const auto *Cleanup = cast<CleanupPadInst>(Pad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">      UnwindDest = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">      UnwindDest = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">      for (const User *U : Cleanup->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">      for (const User *U : Cleanup->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">        if (auto *CleanupRet = dyn_cast<CleanupReturnInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">        if (auto *CleanupRet = dyn_cast<CleanupReturnInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">          // Common and unambiguous case -- cleanupret indicates cleanup's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">          // Common and unambiguous case -- cleanupret indicates cleanup's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">          // unwind dest.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">          // unwind dest.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">          UnwindDest = CleanupRet->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">          UnwindDest = CleanupRet->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">        // Get an unwind dest for the user</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">        // Get an unwind dest for the user</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">        const BasicBlock *UserUnwindDest = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">        const BasicBlock *UserUnwindDest = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">        if (auto *Invoke = dyn_cast<InvokeInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">        if (auto *Invoke = dyn_cast<InvokeInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">          UserUnwindDest = Invoke->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">          UserUnwindDest = Invoke->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">        } else if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">        } else if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">          UserUnwindDest = CatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">          UserUnwindDest = CatchSwitch->getUnwindDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">        } else if (auto *ChildCleanup = dyn_cast<CleanupPadInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">        } else if (auto *ChildCleanup = dyn_cast<CleanupPadInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">          int UserState = FuncInfo.EHPadStateMap[ChildCleanup];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">          int UserState = FuncInfo.EHPadStateMap[ChildCleanup];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">          int UserUnwindState =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">          int UserUnwindState =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">              FuncInfo.ClrEHUnwindMap[UserState].TryParentState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">              FuncInfo.ClrEHUnwindMap[UserState].TryParentState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">          if (UserUnwindState != -1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">          if (UserUnwindState != -1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">            UserUnwindDest = cast<const BasicBlock *>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">            UserUnwindDest = cast<const BasicBlock *>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">                FuncInfo.ClrEHUnwindMap[UserUnwindState].Handler);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">                FuncInfo.ClrEHUnwindMap[UserUnwindState].Handler);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">        // Not having an unwind dest for this user might indicate that it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">        // Not having an unwind dest for this user might indicate that it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">        // doesn't unwind, so can't be taken as proof that the cleanup itself</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">        // doesn't unwind, so can't be taken as proof that the cleanup itself</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">        // may unwind to caller (see e.g. SimplifyUnreachable and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">        // may unwind to caller (see e.g. SimplifyUnreachable and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">        // RemoveUnwindEdge).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">        // RemoveUnwindEdge).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">        if (!UserUnwindDest)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">        if (!UserUnwindDest)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">        // Now we have an unwind dest for the user, but we need to see if it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">        // Now we have an unwind dest for the user, but we need to see if it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">        // unwinds all the way out of the cleanup or if it stays within it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">        // unwinds all the way out of the cleanup or if it stays within it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">        const Instruction *UserUnwindPad = UserUnwindDest->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">        const Instruction *UserUnwindPad = UserUnwindDest->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">        const Value *UserUnwindParent;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">        const Value *UserUnwindParent;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">        if (auto *CSI = dyn_cast<CatchSwitchInst>(UserUnwindPad))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">        if (auto *CSI = dyn_cast<CatchSwitchInst>(UserUnwindPad))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">          UserUnwindParent = CSI->getParentPad();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">          UserUnwindParent = CSI->getParentPad();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">        else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">          UserUnwindParent =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">          UserUnwindParent =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">              cast<CleanupPadInst>(UserUnwindPad)->getParentPad();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">              cast<CleanupPadInst>(UserUnwindPad)->getParentPad();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">        // The unwind stays within the cleanup iff it targets a child of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">        // The unwind stays within the cleanup iff it targets a child of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">        // cleanup.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">        // cleanup.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">        if (UserUnwindParent == Cleanup)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">        if (UserUnwindParent == Cleanup)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">        // This unwind exits the cleanup, so its dest is the cleanup's dest.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">        // This unwind exits the cleanup, so its dest is the cleanup's dest.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">        UnwindDest = UserUnwindDest;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">        UnwindDest = UserUnwindDest;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">    // Record the state of the unwind dest as the TryParentState.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">    // Record the state of the unwind dest as the TryParentState.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">    int UnwindDestState;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">    int UnwindDestState;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">    // If UnwindDest is null at this point, either the pad in question can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">    // If UnwindDest is null at this point, either the pad in question can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">    // be exited by unwind to caller, or it cannot be exited by unwind.  In</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">    // be exited by unwind to caller, or it cannot be exited by unwind.  In</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">    // either case, reporting such cases as unwinding to caller is correct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">    // either case, reporting such cases as unwinding to caller is correct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">    // This can lead to EH tables that "look strange" -- if this pad's is in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">    // This can lead to EH tables that "look strange" -- if this pad's is in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">    // a parent funclet which has other children that do unwind to an enclosing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">    // a parent funclet which has other children that do unwind to an enclosing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">    // pad, the try region for this pad will be missing the "duplicate" EH</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">    // pad, the try region for this pad will be missing the "duplicate" EH</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">    // clause entries that you'd expect to see covering the whole parent.  That</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">    // clause entries that you'd expect to see covering the whole parent.  That</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">    // should be benign, since the unwind never actually happens.  If it were</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">    // should be benign, since the unwind never actually happens.  If it were</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">    // an issue, we could add a subsequent pass that pushes unwind dests down</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">    // an issue, we could add a subsequent pass that pushes unwind dests down</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">    // from parents that have them to children that appear to unwind to caller.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">    // from parents that have them to children that appear to unwind to caller.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">    if (!UnwindDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">    if (!UnwindDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">      UnwindDestState = -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">      UnwindDestState = -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">      UnwindDestState = FuncInfo.EHPadStateMap[UnwindDest->getFirstNonPHI()];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">      UnwindDestState = FuncInfo.EHPadStateMap[UnwindDest->getFirstNonPHI()];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">    Entry.TryParentState = UnwindDestState;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">    Entry.TryParentState = UnwindDestState;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  // Step three: transfer information from pads to invokes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  // Step three: transfer information from pads to invokes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  calculateStateNumbersForInvokes(Fn, FuncInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">void WinEHPrepare::colorFunclets(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">void WinEHPrepare::colorFunclets(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  BlockColors = colorEHFunclets(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  BlockColors = colorEHFunclets(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  // Invert the map from BB to colors to color to BBs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  // Invert the map from BB to colors to color to BBs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">    ColorVector &Colors = BlockColors[&BB];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">    ColorVector &Colors = BlockColors[&BB];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">    for (BasicBlock *Color : Colors)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">    for (BasicBlock *Color : Colors)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">      FuncletBlocks[Color].push_back(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">      FuncletBlocks[Color].push_back(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">void WinEHPrepare::demotePHIsOnFunclets(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">void WinEHPrepare::demotePHIsOnFunclets(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">                                        bool DemoteCatchSwitchPHIOnly) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">                                        bool DemoteCatchSwitchPHIOnly) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  // Strip PHI nodes off of EH pads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  // Strip PHI nodes off of EH pads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  SmallVector<PHINode *, 16> PHINodes;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  SmallVector<PHINode *, 16> PHINodes;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  for (BasicBlock &BB : make_early_inc_range(F)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  for (BasicBlock &BB : make_early_inc_range(F)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">    if (!BB.isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">    if (!BB.isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">    if (DemoteCatchSwitchPHIOnly && !isa<CatchSwitchInst>(BB.getFirstNonPHI()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">    if (DemoteCatchSwitchPHIOnly && !isa<CatchSwitchInst>(BB.getFirstNonPHI()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">    for (Instruction &I : make_early_inc_range(BB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">    for (Instruction &I : make_early_inc_range(BB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">      auto *PN = dyn_cast<PHINode>(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">      auto *PN = dyn_cast<PHINode>(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">      // Stop at the first non-PHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">      // Stop at the first non-PHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">      if (!PN)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">      if (!PN)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">      AllocaInst *SpillSlot = insertPHILoads(PN, F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">      AllocaInst *SpillSlot = insertPHILoads(PN, F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">      if (SpillSlot)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">      if (SpillSlot)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">        insertPHIStores(PN, SpillSlot);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">        insertPHIStores(PN, SpillSlot);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">      PHINodes.push_back(PN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">      PHINodes.push_back(PN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  for (auto *PN : PHINodes) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  for (auto *PN : PHINodes) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">    // There may be lingering uses on other EH PHIs being removed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">    // There may be lingering uses on other EH PHIs being removed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">    PN->replaceAllUsesWith(PoisonValue::get(PN->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">    PN->replaceAllUsesWith(PoisonValue::get(PN->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">    PN->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">    PN->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">void WinEHPrepare::cloneCommonBlocks(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">void WinEHPrepare::cloneCommonBlocks(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  // We need to clone all blocks which belong to multiple funclets.  Values are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  // We need to clone all blocks which belong to multiple funclets.  Values are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  // remapped throughout the funclet to propagate both the new instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  // remapped throughout the funclet to propagate both the new instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">  // *and* the new basic blocks themselves.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">  // *and* the new basic blocks themselves.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">  for (auto &Funclets : FuncletBlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">  for (auto &Funclets : FuncletBlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">    BasicBlock *FuncletPadBB = Funclets.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">    BasicBlock *FuncletPadBB = Funclets.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">    std::vector<BasicBlock *> &BlocksInFunclet = Funclets.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">    std::vector<BasicBlock *> &BlocksInFunclet = Funclets.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">    Value *FuncletToken;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">    Value *FuncletToken;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">    if (FuncletPadBB == &F.getEntryBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">    if (FuncletPadBB == &F.getEntryBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">      FuncletToken = ConstantTokenNone::get(F.getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">      FuncletToken = ConstantTokenNone::get(F.getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">      FuncletToken = FuncletPadBB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">      FuncletToken = FuncletPadBB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">    std::vector<std::pair<BasicBlock *, BasicBlock *>> Orig2Clone;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">    std::vector<std::pair<BasicBlock *, BasicBlock *>> Orig2Clone;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">    ValueToValueMapTy VMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">    ValueToValueMapTy VMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">    for (BasicBlock *BB : BlocksInFunclet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">    for (BasicBlock *BB : BlocksInFunclet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">      ColorVector &ColorsForBB = BlockColors[BB];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">      ColorVector &ColorsForBB = BlockColors[BB];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">      // We don't need to do anything if the block is monochromatic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">      // We don't need to do anything if the block is monochromatic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">      size_t NumColorsForBB = ColorsForBB.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">      size_t NumColorsForBB = ColorsForBB.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">      if (NumColorsForBB == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">      if (NumColorsForBB == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">                      dbgs() << "  Cloning block \'" << BB->getName()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">                      dbgs() << "  Cloning block \'" << BB->getName()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">                              << "\' for funclet \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">                              << "\' for funclet \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">                              << "\'.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">                              << "\'.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">      // Create a new basic block and copy instructions into it!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">      // Create a new basic block and copy instructions into it!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">      BasicBlock *CBB =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">      BasicBlock *CBB =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">          CloneBasicBlock(BB, VMap, Twine(".for.", FuncletPadBB->getName()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">          CloneBasicBlock(BB, VMap, Twine(".for.", FuncletPadBB->getName()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">      // Insert the clone immediately after the original to ensure determinism</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">      // Insert the clone immediately after the original to ensure determinism</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">      // and to keep the same relative ordering of any funclet's blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">      // and to keep the same relative ordering of any funclet's blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">      CBB->insertInto(&F, BB->getNextNode());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">      CBB->insertInto(&F, BB->getNextNode());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">      // Add basic block mapping.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">      // Add basic block mapping.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">      VMap[BB] = CBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">      VMap[BB] = CBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">      // Record delta operations that we need to perform to our color mappings.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">      // Record delta operations that we need to perform to our color mappings.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">      Orig2Clone.emplace_back(BB, CBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">      Orig2Clone.emplace_back(BB, CBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">    // If nothing was cloned, we're done cloning in this funclet.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">    // If nothing was cloned, we're done cloning in this funclet.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">    if (Orig2Clone.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">    if (Orig2Clone.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">    // Update our color mappings to reflect that one block has lost a color and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">    // Update our color mappings to reflect that one block has lost a color and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">    // another has gained a color.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">    // another has gained a color.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">      BlocksInFunclet.push_back(NewBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">      BlocksInFunclet.push_back(NewBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">      ColorVector &NewColors = BlockColors[NewBlock];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">      ColorVector &NewColors = BlockColors[NewBlock];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">      assert(NewColors.empty() && "A new block should only have one color!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">      assert(NewColors.empty() && "A new block should only have one color!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">      NewColors.push_back(FuncletPadBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">      NewColors.push_back(FuncletPadBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">                      dbgs() << "  Assigned color \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">                      dbgs() << "  Assigned color \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">                              << "\' to block \'" << NewBlock->getName()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">                              << "\' to block \'" << NewBlock->getName()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">                              << "\'.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">                              << "\'.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">      llvm::erase_value(BlocksInFunclet, OldBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">      llvm::erase_value(BlocksInFunclet, OldBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">      ColorVector &OldColors = BlockColors[OldBlock];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">      ColorVector &OldColors = BlockColors[OldBlock];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">      llvm::erase_value(OldColors, FuncletPadBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">      llvm::erase_value(OldColors, FuncletPadBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">      DEBUG_WITH_TYPE("winehprepare-coloring",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">                      dbgs() << "  Removed color \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">                      dbgs() << "  Removed color \'" << FuncletPadBB->getName()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">                              << "\' from block \'" << OldBlock->getName()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">                              << "\' from block \'" << OldBlock->getName()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">                              << "\'.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">                              << "\'.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">    // Loop over all of the instructions in this funclet, fixing up operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">    // Loop over all of the instructions in this funclet, fixing up operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">    // references as we go.  This uses VMap to do all the hard work.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">    // references as we go.  This uses VMap to do all the hard work.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">    for (BasicBlock *BB : BlocksInFunclet)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">    for (BasicBlock *BB : BlocksInFunclet)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">      // Loop over all instructions, fixing each one as we find it...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">      // Loop over all instructions, fixing each one as we find it...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">      for (Instruction &I : *BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">      for (Instruction &I : *BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">        RemapInstruction(&I, VMap,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">        RemapInstruction(&I, VMap,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">                         RF_IgnoreMissingLocals | RF_NoModuleLevelChanges);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">                         RF_IgnoreMissingLocals | RF_NoModuleLevelChanges);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">    // Catchrets targeting cloned blocks need to be updated separately from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">    // Catchrets targeting cloned blocks need to be updated separately from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">    // the loop above because they are not in the current funclet.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">    // the loop above because they are not in the current funclet.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">    SmallVector<CatchReturnInst *, 2> FixupCatchrets;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">    SmallVector<CatchReturnInst *, 2> FixupCatchrets;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">      FixupCatchrets.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">      FixupCatchrets.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">      for (BasicBlock *Pred : predecessors(OldBlock))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">      for (BasicBlock *Pred : predecessors(OldBlock))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">        if (auto *CatchRet = dyn_cast<CatchReturnInst>(Pred->getTerminator()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">        if (auto *CatchRet = dyn_cast<CatchReturnInst>(Pred->getTerminator()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">          if (CatchRet->getCatchSwitchParentPad() == FuncletToken)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">          if (CatchRet->getCatchSwitchParentPad() == FuncletToken)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">            FixupCatchrets.push_back(CatchRet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">            FixupCatchrets.push_back(CatchRet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">      for (CatchReturnInst *CatchRet : FixupCatchrets)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">      for (CatchReturnInst *CatchRet : FixupCatchrets)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">        CatchRet->setSuccessor(NewBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">        CatchRet->setSuccessor(NewBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">    auto UpdatePHIOnClonedBlock = [&](PHINode *PN, bool IsForOldBlock) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">    auto UpdatePHIOnClonedBlock = [&](PHINode *PN, bool IsForOldBlock) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">      unsigned NumPreds = PN->getNumIncomingValues();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">      unsigned NumPreds = PN->getNumIncomingValues();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">      for (unsigned PredIdx = 0, PredEnd = NumPreds; PredIdx != PredEnd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">      for (unsigned PredIdx = 0, PredEnd = NumPreds; PredIdx != PredEnd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">           ++PredIdx) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">           ++PredIdx) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">        BasicBlock *IncomingBlock = PN->getIncomingBlock(PredIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">        BasicBlock *IncomingBlock = PN->getIncomingBlock(PredIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">        bool EdgeTargetsFunclet;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">        bool EdgeTargetsFunclet;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">        if (auto *CRI =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">        if (auto *CRI =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">                dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">                dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">          EdgeTargetsFunclet = (CRI->getCatchSwitchParentPad() == FuncletToken);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">          EdgeTargetsFunclet = (CRI->getCatchSwitchParentPad() == FuncletToken);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">          ColorVector &IncomingColors = BlockColors[IncomingBlock];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">          ColorVector &IncomingColors = BlockColors[IncomingBlock];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">          assert(!IncomingColors.empty() && "Block not colored!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">          assert(!IncomingColors.empty() && "Block not colored!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">          assert((IncomingColors.size() == 1 ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">          assert((IncomingColors.size() == 1 ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">                  !llvm::is_contained(IncomingColors, FuncletPadBB)) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">                  !llvm::is_contained(IncomingColors, FuncletPadBB)) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">                 "Cloning should leave this funclet's blocks monochromatic");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">                 "Cloning should leave this funclet's blocks monochromatic");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">          EdgeTargetsFunclet = (IncomingColors.front() == FuncletPadBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">          EdgeTargetsFunclet = (IncomingColors.front() == FuncletPadBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">        if (IsForOldBlock != EdgeTargetsFunclet)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">        if (IsForOldBlock != EdgeTargetsFunclet)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">        PN->removeIncomingValue(IncomingBlock, /*DeletePHIIfEmpty=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">        PN->removeIncomingValue(IncomingBlock, /*DeletePHIIfEmpty=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">        // Revisit the next entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">        // Revisit the next entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">        --PredIdx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">        --PredIdx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">        --PredEnd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">        --PredEnd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">      for (PHINode &OldPN : OldBlock->phis()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">      for (PHINode &OldPN : OldBlock->phis()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">        UpdatePHIOnClonedBlock(&OldPN, /*IsForOldBlock=*/true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">        UpdatePHIOnClonedBlock(&OldPN, /*IsForOldBlock=*/true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">      for (PHINode &NewPN : NewBlock->phis()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">      for (PHINode &NewPN : NewBlock->phis()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">        UpdatePHIOnClonedBlock(&NewPN, /*IsForOldBlock=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">        UpdatePHIOnClonedBlock(&NewPN, /*IsForOldBlock=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">    // Check to see if SuccBB has PHI nodes. If so, we need to add entries to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">    // Check to see if SuccBB has PHI nodes. If so, we need to add entries to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">    // the PHI nodes for NewBB now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">    // the PHI nodes for NewBB now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">    for (auto &BBMapping : Orig2Clone) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">      BasicBlock *OldBlock = BBMapping.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">      BasicBlock *NewBlock = BBMapping.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">      for (BasicBlock *SuccBB : successors(NewBlock)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">      for (BasicBlock *SuccBB : successors(NewBlock)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">        for (PHINode &SuccPN : SuccBB->phis()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">        for (PHINode &SuccPN : SuccBB->phis()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">          // Ok, we have a PHI node.  Figure out what the incoming value was for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">          // Ok, we have a PHI node.  Figure out what the incoming value was for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">          // the OldBlock.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">          // the OldBlock.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">          int OldBlockIdx = SuccPN.getBasicBlockIndex(OldBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">          int OldBlockIdx = SuccPN.getBasicBlockIndex(OldBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">          if (OldBlockIdx == -1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">          if (OldBlockIdx == -1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">            break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">            break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">          Value *IV = SuccPN.getIncomingValue(OldBlockIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">          Value *IV = SuccPN.getIncomingValue(OldBlockIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">          // Remap the value if necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">          // Remap the value if necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">          if (auto *Inst = dyn_cast<Instruction>(IV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">          if (auto *Inst = dyn_cast<Instruction>(IV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">            ValueToValueMapTy::iterator I = VMap.find(Inst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">            ValueToValueMapTy::iterator I = VMap.find(Inst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">            if (I != VMap.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">            if (I != VMap.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">              IV = I->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">              IV = I->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">          SuccPN.addIncoming(IV, NewBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">          SuccPN.addIncoming(IV, NewBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">    for (ValueToValueMapTy::value_type VT : VMap) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">    for (ValueToValueMapTy::value_type VT : VMap) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">      // If there were values defined in BB that are used outside the funclet,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">      // If there were values defined in BB that are used outside the funclet,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">      // then we now have to update all uses of the value to use either the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">      // then we now have to update all uses of the value to use either the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">      // original value, the cloned value, or some PHI derived value.  This can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">      // original value, the cloned value, or some PHI derived value.  This can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">      // require arbitrary PHI insertion, of which we are prepared to do, clean</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">      // require arbitrary PHI insertion, of which we are prepared to do, clean</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">      // these up now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">      // these up now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">      SmallVector<Use *, 16> UsesToRename;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">      SmallVector<Use *, 16> UsesToRename;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">      auto *OldI = dyn_cast<Instruction>(const_cast<Value *>(VT.first));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">      auto *OldI = dyn_cast<Instruction>(const_cast<Value *>(VT.first));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">      if (!OldI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">      if (!OldI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">      auto *NewI = cast<Instruction>(VT.second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">      auto *NewI = cast<Instruction>(VT.second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">      // Scan all uses of this instruction to see if it is used outside of its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">      // Scan all uses of this instruction to see if it is used outside of its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">      // funclet, and if so, record them in UsesToRename.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">      // funclet, and if so, record them in UsesToRename.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">      for (Use &U : OldI->uses()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">      for (Use &U : OldI->uses()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">        Instruction *UserI = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">        Instruction *UserI = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">        BasicBlock *UserBB = UserI->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">        BasicBlock *UserBB = UserI->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">        ColorVector &ColorsForUserBB = BlockColors[UserBB];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">        ColorVector &ColorsForUserBB = BlockColors[UserBB];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">        assert(!ColorsForUserBB.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">        assert(!ColorsForUserBB.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">        if (ColorsForUserBB.size() > 1 ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">        if (ColorsForUserBB.size() > 1 ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">            *ColorsForUserBB.begin() != FuncletPadBB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">            *ColorsForUserBB.begin() != FuncletPadBB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">          UsesToRename.push_back(&U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">          UsesToRename.push_back(&U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">      // If there are no uses outside the block, we're done with this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">      // If there are no uses outside the block, we're done with this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">      // instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">      // instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">      if (UsesToRename.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">      if (UsesToRename.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">      // We found a use of OldI outside of the funclet.  Rename all uses of OldI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">      // We found a use of OldI outside of the funclet.  Rename all uses of OldI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">      // that are outside its funclet to be uses of the appropriate PHI node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">      // that are outside its funclet to be uses of the appropriate PHI node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">      // etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">      // etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">      SSAUpdater SSAUpdate;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">      SSAUpdater SSAUpdate;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">      SSAUpdate.Initialize(OldI->getType(), OldI->getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">      SSAUpdate.Initialize(OldI->getType(), OldI->getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">      SSAUpdate.AddAvailableValue(OldI->getParent(), OldI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">      SSAUpdate.AddAvailableValue(OldI->getParent(), OldI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">      SSAUpdate.AddAvailableValue(NewI->getParent(), NewI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">      SSAUpdate.AddAvailableValue(NewI->getParent(), NewI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">      while (!UsesToRename.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">      while (!UsesToRename.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">        SSAUpdate.RewriteUseAfterInsertions(*UsesToRename.pop_back_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">        SSAUpdate.RewriteUseAfterInsertions(*UsesToRename.pop_back_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">void WinEHPrepare::removeImplausibleInstructions(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">void WinEHPrepare::removeImplausibleInstructions(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">  // Remove implausible terminators and replace them with UnreachableInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">  // Remove implausible terminators and replace them with UnreachableInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">  for (auto &Funclet : FuncletBlocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">  for (auto &Funclet : FuncletBlocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">    BasicBlock *FuncletPadBB = Funclet.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">    BasicBlock *FuncletPadBB = Funclet.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">    std::vector<BasicBlock *> &BlocksInFunclet = Funclet.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">    std::vector<BasicBlock *> &BlocksInFunclet = Funclet.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">    Instruction *FirstNonPHI = FuncletPadBB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">    Instruction *FirstNonPHI = FuncletPadBB->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">    auto *FuncletPad = dyn_cast<FuncletPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">    auto *FuncletPad = dyn_cast<FuncletPadInst>(FirstNonPHI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">    auto *CatchPad = dyn_cast_or_null<CatchPadInst>(FuncletPad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">    auto *CatchPad = dyn_cast_or_null<CatchPadInst>(FuncletPad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">    auto *CleanupPad = dyn_cast_or_null<CleanupPadInst>(FuncletPad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">    auto *CleanupPad = dyn_cast_or_null<CleanupPadInst>(FuncletPad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">    for (BasicBlock *BB : BlocksInFunclet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">    for (BasicBlock *BB : BlocksInFunclet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">      for (Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">      for (Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">        auto *CB = dyn_cast<CallBase>(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">        auto *CB = dyn_cast<CallBase>(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">        if (!CB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">        if (!CB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">        Value *FuncletBundleOperand = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">        Value *FuncletBundleOperand = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">        if (auto BU = CB->getOperandBundle(LLVMContext::OB_funclet))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">        if (auto BU = CB->getOperandBundle(LLVMContext::OB_funclet))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">          FuncletBundleOperand = BU->Inputs.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">          FuncletBundleOperand = BU->Inputs.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">        if (FuncletBundleOperand == FuncletPad)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">        if (FuncletBundleOperand == FuncletPad)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">        // Skip call sites which are nounwind intrinsics or inline asm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">        // Skip call sites which are nounwind intrinsics or inline asm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">        auto *CalledFn =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">        auto *CalledFn =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">            dyn_cast<Function>(CB->getCalledOperand()->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">            dyn_cast<Function>(CB->getCalledOperand()->stripPointerCasts());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">        if (CalledFn && ((CalledFn->isIntrinsic() && CB->doesNotThrow()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">        if (CalledFn && ((CalledFn->isIntrinsic() && CB->doesNotThrow()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">                         CB->isInlineAsm()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">                         CB->isInlineAsm()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">        // This call site was not part of this funclet, remove it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">        // This call site was not part of this funclet, remove it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">        if (isa<InvokeInst>(CB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">        if (isa<InvokeInst>(CB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">          // Remove the unwind edge if it was an invoke.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">          // Remove the unwind edge if it was an invoke.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">          removeUnwindEdge(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">          removeUnwindEdge(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">          // Get a pointer to the new call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">          // Get a pointer to the new call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">          BasicBlock::iterator CallI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">          BasicBlock::iterator CallI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">              std::prev(BB->getTerminator()->getIterator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">              std::prev(BB->getTerminator()->getIterator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">          auto *CI = cast<CallInst>(&*CallI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">          auto *CI = cast<CallInst>(&*CallI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">          changeToUnreachable(CI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">          changeToUnreachable(CI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">          changeToUnreachable(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">          changeToUnreachable(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">        // There are no more instructions in the block (except for unreachable),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">        // There are no more instructions in the block (except for unreachable),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">        // we are done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">        // we are done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">      Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">      Instruction *TI = BB->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">      // CatchPadInst and CleanupPadInst can't transfer control to a ReturnInst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">      // CatchPadInst and CleanupPadInst can't transfer control to a ReturnInst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">      bool IsUnreachableRet = isa<ReturnInst>(TI) && FuncletPad;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">      bool IsUnreachableRet = isa<ReturnInst>(TI) && FuncletPad;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">      // The token consumed by a CatchReturnInst must match the funclet token.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">      // The token consumed by a CatchReturnInst must match the funclet token.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">      bool IsUnreachableCatchret = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">      bool IsUnreachableCatchret = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">      if (auto *CRI = dyn_cast<CatchReturnInst>(TI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">      if (auto *CRI = dyn_cast<CatchReturnInst>(TI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">        IsUnreachableCatchret = CRI->getCatchPad() != CatchPad;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">        IsUnreachableCatchret = CRI->getCatchPad() != CatchPad;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">      // The token consumed by a CleanupReturnInst must match the funclet token.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">      // The token consumed by a CleanupReturnInst must match the funclet token.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">      bool IsUnreachableCleanupret = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">      bool IsUnreachableCleanupret = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">      if (auto *CRI = dyn_cast<CleanupReturnInst>(TI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">      if (auto *CRI = dyn_cast<CleanupReturnInst>(TI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">        IsUnreachableCleanupret = CRI->getCleanupPad() != CleanupPad;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">        IsUnreachableCleanupret = CRI->getCleanupPad() != CleanupPad;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">      if (IsUnreachableRet || IsUnreachableCatchret ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">      if (IsUnreachableRet || IsUnreachableCatchret ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">          IsUnreachableCleanupret) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">          IsUnreachableCleanupret) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">        changeToUnreachable(TI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">        changeToUnreachable(TI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">      } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">      } else if (isa<InvokeInst>(TI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">        if (Personality == EHPersonality::MSVC_CXX && CleanupPad) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">        if (Personality == EHPersonality::MSVC_CXX && CleanupPad) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">          // Invokes within a cleanuppad for the MSVC++ personality never</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">          // Invokes within a cleanuppad for the MSVC++ personality never</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">          // transfer control to their unwind edge: the personality will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">          // transfer control to their unwind edge: the personality will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">          // terminate the program.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">          // terminate the program.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">          removeUnwindEdge(BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">          removeUnwindEdge(BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">void WinEHPrepare::cleanupPreparedFunclets(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">void WinEHPrepare::cleanupPreparedFunclets(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  // Clean-up some of the mess we made by removing useles PHI nodes, trivial</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  // Clean-up some of the mess we made by removing useles PHI nodes, trivial</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  // branches, etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  // branches, etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  for (BasicBlock &BB : llvm::make_early_inc_range(F)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  for (BasicBlock &BB : llvm::make_early_inc_range(F)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">    SimplifyInstructionsInBlock(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">    SimplifyInstructionsInBlock(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">    ConstantFoldTerminator(&BB, /*DeleteDeadConditions=*/true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">    ConstantFoldTerminator(&BB, /*DeleteDeadConditions=*/true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">    MergeBlockIntoPredecessor(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">    MergeBlockIntoPredecessor(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">  // We might have some unreachable blocks after cleaning up some impossible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">  // We might have some unreachable blocks after cleaning up some impossible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">  // control flow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">  // control flow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  removeUnreachableBlocks(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  removeUnreachableBlocks(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">void WinEHPrepare::verifyPreparedFunclets(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">void WinEHPrepare::verifyPreparedFunclets(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">    size_t NumColors = BlockColors[&BB].size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">    size_t NumColors = BlockColors[&BB].size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">    assert(NumColors == 1 && "Expected monochromatic BB!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">    assert(NumColors == 1 && "Expected monochromatic BB!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">    if (NumColors == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">    if (NumColors == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">      report_fatal_error("Uncolored BB!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">      report_fatal_error("Uncolored BB!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">    if (NumColors > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">    if (NumColors > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">      report_fatal_error("Multicolor BB!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">      report_fatal_error("Multicolor BB!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">    assert((DisableDemotion || !(BB.isEHPad() && isa<PHINode>(BB.begin()))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">    assert((DisableDemotion || !(BB.isEHPad() && isa<PHINode>(BB.begin()))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">           "EH Pad still has a PHI!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">           "EH Pad still has a PHI!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">bool WinEHPrepare::prepareExplicitEH(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">bool WinEHPrepare::prepareExplicitEH(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">  // Remove unreachable blocks.  It is not valuable to assign them a color and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">  // Remove unreachable blocks.  It is not valuable to assign them a color and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">  // their existence can trick us into thinking values are alive when they are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">  // their existence can trick us into thinking values are alive when they are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">  // not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">  // not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">  removeUnreachableBlocks(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">  removeUnreachableBlocks(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  // Determine which blocks are reachable from which funclet entries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  // Determine which blocks are reachable from which funclet entries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  colorFunclets(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  colorFunclets(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  cloneCommonBlocks(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  cloneCommonBlocks(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  if (!DisableDemotion)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  if (!DisableDemotion)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">    demotePHIsOnFunclets(F, DemoteCatchSwitchPHIOnly ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">    demotePHIsOnFunclets(F, DemoteCatchSwitchPHIOnly ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">                                DemoteCatchSwitchPHIOnlyOpt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">                                DemoteCatchSwitchPHIOnlyOpt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">  if (!DisableCleanups) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">  if (!DisableCleanups) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">    assert(!verifyFunction(F, &dbgs()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">    assert(!verifyFunction(F, &dbgs()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">    removeImplausibleInstructions(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">    removeImplausibleInstructions(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">    assert(!verifyFunction(F, &dbgs()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">    assert(!verifyFunction(F, &dbgs()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">    cleanupPreparedFunclets(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">    cleanupPreparedFunclets(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  // Recolor the CFG to verify that all is well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  // Recolor the CFG to verify that all is well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">  LLVM_DEBUG(colorFunclets(F));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">  LLVM_DEBUG(colorFunclets(F));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  LLVM_DEBUG(verifyPreparedFunclets(F));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  BlockColors.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  BlockColors.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  FuncletBlocks.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  FuncletBlocks.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">// TODO: Share loads when one use dominates another, or when a catchpad exit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">// TODO: Share loads when one use dominates another, or when a catchpad exit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">// dominates uses (needs dominators).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">// dominates uses (needs dominators).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">AllocaInst *WinEHPrepare::insertPHILoads(PHINode *PN, Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">AllocaInst *WinEHPrepare::insertPHILoads(PHINode *PN, Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  BasicBlock *PHIBlock = PN->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  BasicBlock *PHIBlock = PN->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">  AllocaInst *SpillSlot = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">  AllocaInst *SpillSlot = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  Instruction *EHPad = PHIBlock->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  Instruction *EHPad = PHIBlock->getFirstNonPHI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  if (!EHPad->isTerminator()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  if (!EHPad->isTerminator()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">    // If the EHPad isn't a terminator, then we can insert a load in this block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">    // If the EHPad isn't a terminator, then we can insert a load in this block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">    // that will dominate all uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">    // that will dominate all uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">    SpillSlot = new AllocaInst(PN->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">    SpillSlot = new AllocaInst(PN->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">                               Twine(PN->getName(), ".wineh.spillslot"),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">                               Twine(PN->getName(), ".wineh.spillslot"),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">                               &F.getEntryBlock().front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">                               &F.getEntryBlock().front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">    Value *V = new LoadInst(PN->getType(), SpillSlot,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">    Value *V = new LoadInst(PN->getType(), SpillSlot,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">                            Twine(PN->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">                            Twine(PN->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">                            &*PHIBlock->getFirstInsertionPt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">                            &*PHIBlock->getFirstInsertionPt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">    PN->replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">    PN->replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">    return SpillSlot;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">    return SpillSlot;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  // Otherwise, we have a PHI on a terminator EHPad, and we give up and insert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  // Otherwise, we have a PHI on a terminator EHPad, and we give up and insert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  // loads of the slot before every use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  // loads of the slot before every use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  DenseMap<BasicBlock *, Value *> Loads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  DenseMap<BasicBlock *, Value *> Loads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  for (Use &U : llvm::make_early_inc_range(PN->uses())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  for (Use &U : llvm::make_early_inc_range(PN->uses())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">    auto *UsingInst = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">    auto *UsingInst = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">    if (isa<PHINode>(UsingInst) && UsingInst->getParent()->isEHPad()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">    if (isa<PHINode>(UsingInst) && UsingInst->getParent()->isEHPad()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">      // Use is on an EH pad phi.  Leave it alone; we'll insert loads and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">      // Use is on an EH pad phi.  Leave it alone; we'll insert loads and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">      // stores for it separately.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">      // stores for it separately.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">    replaceUseWithLoad(PN, U, SpillSlot, Loads, F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">    replaceUseWithLoad(PN, U, SpillSlot, Loads, F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  return SpillSlot;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  return SpillSlot;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">// TODO: improve store placement.  Inserting at def is probably good, but need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">// TODO: improve store placement.  Inserting at def is probably good, but need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">// to be careful not to introduce interfering stores (needs liveness analysis).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">// to be careful not to introduce interfering stores (needs liveness analysis).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">// TODO: identify related phi nodes that can share spill slots, and share them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">// TODO: identify related phi nodes that can share spill slots, and share them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">// (also needs liveness).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">// (also needs liveness).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">void WinEHPrepare::insertPHIStores(PHINode *OriginalPHI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">void WinEHPrepare::insertPHIStores(PHINode *OriginalPHI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">                                   AllocaInst *SpillSlot) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">                                   AllocaInst *SpillSlot) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // Use a worklist of (Block, Value) pairs -- the given Value needs to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // Use a worklist of (Block, Value) pairs -- the given Value needs to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  // stored to the spill slot by the end of the given Block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  // stored to the spill slot by the end of the given Block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  SmallVector<std::pair<BasicBlock *, Value *>, 4> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  SmallVector<std::pair<BasicBlock *, Value *>, 4> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  Worklist.push_back({OriginalPHI->getParent(), OriginalPHI});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  Worklist.push_back({OriginalPHI->getParent(), OriginalPHI});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">    BasicBlock *EHBlock;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">    BasicBlock *EHBlock;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">    Value *InVal;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">    Value *InVal;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">    std::tie(EHBlock, InVal) = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">    std::tie(EHBlock, InVal) = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">    PHINode *PN = dyn_cast<PHINode>(InVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">    PHINode *PN = dyn_cast<PHINode>(InVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">    if (PN && PN->getParent() == EHBlock) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">    if (PN && PN->getParent() == EHBlock) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">      // The value is defined by another PHI we need to remove, with no room to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">      // The value is defined by another PHI we need to remove, with no room to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">      // insert a store after the PHI, so each predecessor needs to store its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">      // insert a store after the PHI, so each predecessor needs to store its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">      // incoming value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">      // incoming value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">      for (unsigned i = 0, e = PN->getNumIncomingValues(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">      for (unsigned i = 0, e = PN->getNumIncomingValues(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">        Value *PredVal = PN->getIncomingValue(i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">        Value *PredVal = PN->getIncomingValue(i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">        // Undef can safely be skipped.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">        // Undef can safely be skipped.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">        if (isa<UndefValue>(PredVal))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">        if (isa<UndefValue>(PredVal))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">        insertPHIStore(PN->getIncomingBlock(i), PredVal, SpillSlot, Worklist);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">        insertPHIStore(PN->getIncomingBlock(i), PredVal, SpillSlot, Worklist);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">      // We need to store InVal, which dominates EHBlock, but can't put a store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">      // We need to store InVal, which dominates EHBlock, but can't put a store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">      // in EHBlock, so need to put stores in each predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">      // in EHBlock, so need to put stores in each predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">      for (BasicBlock *PredBlock : predecessors(EHBlock)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">      for (BasicBlock *PredBlock : predecessors(EHBlock)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">        insertPHIStore(PredBlock, InVal, SpillSlot, Worklist);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">        insertPHIStore(PredBlock, InVal, SpillSlot, Worklist);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">void WinEHPrepare::insertPHIStore(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">void WinEHPrepare::insertPHIStore(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">    BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">    BasicBlock *PredBlock, Value *PredVal, AllocaInst *SpillSlot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">    SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">    SmallVectorImpl<std::pair<BasicBlock *, Value *>> &Worklist) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">  if (PredBlock->isEHPad() && PredBlock->getFirstNonPHI()->isTerminator()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">  if (PredBlock->isEHPad() && PredBlock->getFirstNonPHI()->isTerminator()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // Pred is unsplittable, so we need to queue it on the worklist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">    // Pred is unsplittable, so we need to queue it on the worklist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">    Worklist.push_back({PredBlock, PredVal});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">    Worklist.push_back({PredBlock, PredVal});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">  // Otherwise, insert the store at the end of the basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">  // Otherwise, insert the store at the end of the basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">  new StoreInst(PredVal, SpillSlot, PredBlock->getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">  new StoreInst(PredVal, SpillSlot, PredBlock->getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">void WinEHPrepare::replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">void WinEHPrepare::replaceUseWithLoad(Value *V, Use &U, AllocaInst *&SpillSlot,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">                                      DenseMap<BasicBlock *, Value *> &Loads,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">                                      DenseMap<BasicBlock *, Value *> &Loads,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">                                      Function &F) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">                                      Function &F) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">  // Lazilly create the spill slot.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">  // Lazilly create the spill slot.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">  if (!SpillSlot)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">  if (!SpillSlot)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">    SpillSlot = new AllocaInst(V->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">    SpillSlot = new AllocaInst(V->getType(), DL->getAllocaAddrSpace(), nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">                               Twine(V->getName(), ".wineh.spillslot"),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">                               Twine(V->getName(), ".wineh.spillslot"),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">                               &F.getEntryBlock().front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">                               &F.getEntryBlock().front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">  auto *UsingInst = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">  auto *UsingInst = cast<Instruction>(U.getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  if (auto *UsingPHI = dyn_cast<PHINode>(UsingInst)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  if (auto *UsingPHI = dyn_cast<PHINode>(UsingInst)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">    // If this is a PHI node, we can't insert a load of the value before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">    // If this is a PHI node, we can't insert a load of the value before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">    // the use.  Instead insert the load in the predecessor block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">    // the use.  Instead insert the load in the predecessor block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">    // corresponding to the incoming value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">    // corresponding to the incoming value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">    // Note that if there are multiple edges from a basic block to this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">    // Note that if there are multiple edges from a basic block to this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">    // PHI node that we cannot have multiple loads.  The problem is that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">    // PHI node that we cannot have multiple loads.  The problem is that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">    // the resulting PHI node will have multiple values (from each load)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">    // the resulting PHI node will have multiple values (from each load)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">    // coming in from the same block, which is illegal SSA form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">    // coming in from the same block, which is illegal SSA form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">    // For this reason, we keep track of and reuse loads we insert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">    // For this reason, we keep track of and reuse loads we insert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">    BasicBlock *IncomingBlock = UsingPHI->getIncomingBlock(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">    BasicBlock *IncomingBlock = UsingPHI->getIncomingBlock(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    if (auto *CatchRet =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    if (auto *CatchRet =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">            dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">            dyn_cast<CatchReturnInst>(IncomingBlock->getTerminator())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">      // Putting a load above a catchret and use on the phi would still leave</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">      // Putting a load above a catchret and use on the phi would still leave</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">      // a cross-funclet def/use.  We need to split the edge, change the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">      // a cross-funclet def/use.  We need to split the edge, change the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">      // catchret to target the new block, and put the load there.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">      // catchret to target the new block, and put the load there.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">      BasicBlock *PHIBlock = UsingInst->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">      BasicBlock *PHIBlock = UsingInst->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">      BasicBlock *NewBlock = SplitEdge(IncomingBlock, PHIBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">      BasicBlock *NewBlock = SplitEdge(IncomingBlock, PHIBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">      // SplitEdge gives us:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">      // SplitEdge gives us:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">      //   IncomingBlock:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">      //   IncomingBlock:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">      //     ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">      //     ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">      //     br label %NewBlock</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">      //     br label %NewBlock</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">      //   NewBlock:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">      //   NewBlock:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">      //     catchret label %PHIBlock</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">      //     catchret label %PHIBlock</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">      // But we need:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">      // But we need:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">      //   IncomingBlock:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">      //   IncomingBlock:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">      //     ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">      //     ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">      //     catchret label %NewBlock</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">      //     catchret label %NewBlock</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">      //   NewBlock:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">      //   NewBlock:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">      //     br label %PHIBlock</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">      //     br label %PHIBlock</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">      // So move the terminators to each others' blocks and swap their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">      // So move the terminators to each others' blocks and swap their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">      // successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">      // successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">      BranchInst *Goto = cast<BranchInst>(IncomingBlock->getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">      BranchInst *Goto = cast<BranchInst>(IncomingBlock->getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">      Goto->removeFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">      Goto->removeFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">      CatchRet->removeFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">      CatchRet->removeFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">      CatchRet->insertInto(IncomingBlock, IncomingBlock->end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">      CatchRet->insertInto(IncomingBlock, IncomingBlock->end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">      Goto->insertInto(NewBlock, NewBlock->end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">      Goto->insertInto(NewBlock, NewBlock->end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">      Goto->setSuccessor(0, PHIBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">      Goto->setSuccessor(0, PHIBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">      CatchRet->setSuccessor(NewBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">      CatchRet->setSuccessor(NewBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">      // Update the color mapping for the newly split edge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">      // Update the color mapping for the newly split edge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">      // Grab a reference to the ColorVector to be inserted before getting the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">      // Grab a reference to the ColorVector to be inserted before getting the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">      // reference to the vector we are copying because inserting the new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">      // reference to the vector we are copying because inserting the new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">      // element in BlockColors might cause the map to be reallocated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">      // element in BlockColors might cause the map to be reallocated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">      ColorVector &ColorsForNewBlock = BlockColors[NewBlock];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">      ColorVector &ColorsForNewBlock = BlockColors[NewBlock];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">      ColorVector &ColorsForPHIBlock = BlockColors[PHIBlock];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">      ColorVector &ColorsForPHIBlock = BlockColors[PHIBlock];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">      ColorsForNewBlock = ColorsForPHIBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">      ColorsForNewBlock = ColorsForPHIBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">      for (BasicBlock *FuncletPad : ColorsForPHIBlock)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">      for (BasicBlock *FuncletPad : ColorsForPHIBlock)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">        FuncletBlocks[FuncletPad].push_back(NewBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">        FuncletBlocks[FuncletPad].push_back(NewBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">      // Treat the new block as incoming for load insertion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">      // Treat the new block as incoming for load insertion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">      IncomingBlock = NewBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">      IncomingBlock = NewBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">    Value *&Load = Loads[IncomingBlock];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">    Value *&Load = Loads[IncomingBlock];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">    // Insert the load into the predecessor block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">    // Insert the load into the predecessor block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">    if (!Load)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">    if (!Load)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">      Load = new LoadInst(V->getType(), SpillSlot,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">      Load = new LoadInst(V->getType(), SpillSlot,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">                          Twine(V->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">                          Twine(V->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">                          /*isVolatile=*/false, IncomingBlock->getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">                          /*isVolatile=*/false, IncomingBlock->getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">    U.set(Load);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">    U.set(Load);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">    // Reload right before the old use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">    // Reload right before the old use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">    auto *Load = new LoadInst(V->getType(), SpillSlot,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">    auto *Load = new LoadInst(V->getType(), SpillSlot,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">                              Twine(V->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">                              Twine(V->getName(), ".wineh.reload"),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">                              /*isVolatile=*/false, UsingInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">                              /*isVolatile=*/false, UsingInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">    U.set(Load);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">    U.set(Load);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">void WinEHFuncInfo::addIPToStateRange(const InvokeInst *II,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">void WinEHFuncInfo::addIPToStateRange(const InvokeInst *II,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">                                      MCSymbol *InvokeBegin,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">                                      MCSymbol *InvokeBegin,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">                                      MCSymbol *InvokeEnd) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">                                      MCSymbol *InvokeEnd) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">  assert(InvokeStateMap.count(II) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">  assert(InvokeStateMap.count(II) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">         "should get invoke with precomputed state");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">         "should get invoke with precomputed state");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">  LabelToStateMap[InvokeBegin] = std::make_pair(InvokeStateMap[II], InvokeEnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">  LabelToStateMap[InvokeBegin] = std::make_pair(InvokeStateMap[II], InvokeEnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">void WinEHFuncInfo::addIPToStateRange(int State, MCSymbol* InvokeBegin,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">void WinEHFuncInfo::addIPToStateRange(int State, MCSymbol* InvokeBegin,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">    MCSymbol* InvokeEnd) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">    MCSymbol* InvokeEnd) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    LabelToStateMap[InvokeBegin] = std::make_pair(State, InvokeEnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    LabelToStateMap[InvokeBegin] = std::make_pair(State, InvokeEnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">WinEHFuncInfo::WinEHFuncInfo() = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">WinEHFuncInfo::WinEHFuncInfo() = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>